
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BuzzPost
 * 
 */
export type BuzzPost = $Result.DefaultSelection<Prisma.$BuzzPostPayload>
/**
 * Model BuzzConfig
 * 
 */
export type BuzzConfig = $Result.DefaultSelection<Prisma.$BuzzConfigPayload>
/**
 * Model ScheduledPost
 * 
 */
export type ScheduledPost = $Result.DefaultSelection<Prisma.$ScheduledPostPayload>
/**
 * Model PostAnalytics
 * 
 */
export type PostAnalytics = $Result.DefaultSelection<Prisma.$PostAnalyticsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model NewsSource
 * 
 */
export type NewsSource = $Result.DefaultSelection<Prisma.$NewsSourcePayload>
/**
 * Model NewsArticle
 * 
 */
export type NewsArticle = $Result.DefaultSelection<Prisma.$NewsArticlePayload>
/**
 * Model NewsThread
 * 
 */
export type NewsThread = $Result.DefaultSelection<Prisma.$NewsThreadPayload>
/**
 * Model NewsThreadItem
 * 
 */
export type NewsThreadItem = $Result.DefaultSelection<Prisma.$NewsThreadItemPayload>
/**
 * Model NewsAnalysis
 * 
 */
export type NewsAnalysis = $Result.DefaultSelection<Prisma.$NewsAnalysisPayload>
/**
 * Model JobQueue
 * 
 */
export type JobQueue = $Result.DefaultSelection<Prisma.$JobQueuePayload>
/**
 * Model CollectionPreset
 * 
 */
export type CollectionPreset = $Result.DefaultSelection<Prisma.$CollectionPresetPayload>
/**
 * Model WatchlistUser
 * 
 */
export type WatchlistUser = $Result.DefaultSelection<Prisma.$WatchlistUserPayload>
/**
 * Model WatchlistTweet
 * 
 */
export type WatchlistTweet = $Result.DefaultSelection<Prisma.$WatchlistTweetPayload>
/**
 * Model InteractionHistory
 * 
 */
export type InteractionHistory = $Result.DefaultSelection<Prisma.$InteractionHistoryPayload>
/**
 * Model PerplexityReport
 * 
 */
export type PerplexityReport = $Result.DefaultSelection<Prisma.$PerplexityReportPayload>
/**
 * Model CotSession
 * 
 */
export type CotSession = $Result.DefaultSelection<Prisma.$CotSessionPayload>
/**
 * Model CotPhase
 * 
 */
export type CotPhase = $Result.DefaultSelection<Prisma.$CotPhasePayload>
/**
 * Model CotDraft
 * 
 */
export type CotDraft = $Result.DefaultSelection<Prisma.$CotDraftPayload>
/**
 * Model CotDraftPerformance
 * 
 */
export type CotDraftPerformance = $Result.DefaultSelection<Prisma.$CotDraftPerformancePayload>
/**
 * Model UnifiedContentSource
 * 
 */
export type UnifiedContentSource = $Result.DefaultSelection<Prisma.$UnifiedContentSourcePayload>
/**
 * Model IntegratedSession
 * 
 */
export type IntegratedSession = $Result.DefaultSelection<Prisma.$IntegratedSessionPayload>
/**
 * Model IntegratedSessionSource
 * 
 */
export type IntegratedSessionSource = $Result.DefaultSelection<Prisma.$IntegratedSessionSourcePayload>
/**
 * Model IntegratedDraft
 * 
 */
export type IntegratedDraft = $Result.DefaultSelection<Prisma.$IntegratedDraftPayload>
/**
 * Model IntegratedDraftPerformance
 * 
 */
export type IntegratedDraftPerformance = $Result.DefaultSelection<Prisma.$IntegratedDraftPerformancePayload>
/**
 * Model ScheduledRetweet
 * 
 */
export type ScheduledRetweet = $Result.DefaultSelection<Prisma.$ScheduledRetweetPayload>
/**
 * Model UnifiedPerformance
 * 
 */
export type UnifiedPerformance = $Result.DefaultSelection<Prisma.$UnifiedPerformancePayload>
/**
 * Model NewsViralRelation
 * 
 */
export type NewsViralRelation = $Result.DefaultSelection<Prisma.$NewsViralRelationPayload>
/**
 * Model SessionActivityLog
 * 
 */
export type SessionActivityLog = $Result.DefaultSelection<Prisma.$SessionActivityLogPayload>
/**
 * Model ApiErrorLog
 * 
 */
export type ApiErrorLog = $Result.DefaultSelection<Prisma.$ApiErrorLogPayload>
/**
 * Model ViralSession
 * 
 */
export type ViralSession = $Result.DefaultSelection<Prisma.$ViralSessionPayload>
/**
 * Model ViralDraftV2
 * 
 */
export type ViralDraftV2 = $Result.DefaultSelection<Prisma.$ViralDraftV2Payload>
/**
 * Model ViralDraftPerformance
 * 
 */
export type ViralDraftPerformance = $Result.DefaultSelection<Prisma.$ViralDraftPerformancePayload>
/**
 * Model CharacterProfile
 * 
 */
export type CharacterProfile = $Result.DefaultSelection<Prisma.$CharacterProfilePayload>
/**
 * Model BuzzInfluencer
 * 
 */
export type BuzzInfluencer = $Result.DefaultSelection<Prisma.$BuzzInfluencerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  FAILED: 'FAILED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const PostType: {
  NEW: 'NEW',
  RETWEET: 'RETWEET',
  QUOTE: 'QUOTE'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const CotSessionStatus: {
  PENDING: 'PENDING',
  THINKING: 'THINKING',
  EXECUTING: 'EXECUTING',
  INTEGRATING: 'INTEGRATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PAUSED: 'PAUSED'
};

export type CotSessionStatus = (typeof CotSessionStatus)[keyof typeof CotSessionStatus]


export const CotPhaseStep: {
  THINK: 'THINK',
  EXECUTE: 'EXECUTE',
  INTEGRATE: 'INTEGRATE'
};

export type CotPhaseStep = (typeof CotPhaseStep)[keyof typeof CotPhaseStep]


export const CotPhaseStatus: {
  PENDING: 'PENDING',
  THINKING: 'THINKING',
  EXECUTING: 'EXECUTING',
  INTEGRATING: 'INTEGRATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type CotPhaseStatus = (typeof CotPhaseStatus)[keyof typeof CotPhaseStatus]


export const CotDraftStatus: {
  DRAFT: 'DRAFT',
  EDITED: 'EDITED',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  ARCHIVED: 'ARCHIVED'
};

export type CotDraftStatus = (typeof CotDraftStatus)[keyof typeof CotDraftStatus]


export const RTStatus: {
  SCHEDULED: 'SCHEDULED',
  EXECUTED: 'EXECUTED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type RTStatus = (typeof RTStatus)[keyof typeof RTStatus]

}

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type CotSessionStatus = $Enums.CotSessionStatus

export const CotSessionStatus: typeof $Enums.CotSessionStatus

export type CotPhaseStep = $Enums.CotPhaseStep

export const CotPhaseStep: typeof $Enums.CotPhaseStep

export type CotPhaseStatus = $Enums.CotPhaseStatus

export const CotPhaseStatus: typeof $Enums.CotPhaseStatus

export type CotDraftStatus = $Enums.CotDraftStatus

export const CotDraftStatus: typeof $Enums.CotDraftStatus

export type RTStatus = $Enums.RTStatus

export const RTStatus: typeof $Enums.RTStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BuzzPosts
 * const buzzPosts = await prisma.buzzPost.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BuzzPosts
   * const buzzPosts = await prisma.buzzPost.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.buzzPost`: Exposes CRUD operations for the **BuzzPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzPosts
    * const buzzPosts = await prisma.buzzPost.findMany()
    * ```
    */
  get buzzPost(): Prisma.BuzzPostDelegate<ExtArgs>;

  /**
   * `prisma.buzzConfig`: Exposes CRUD operations for the **BuzzConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzConfigs
    * const buzzConfigs = await prisma.buzzConfig.findMany()
    * ```
    */
  get buzzConfig(): Prisma.BuzzConfigDelegate<ExtArgs>;

  /**
   * `prisma.scheduledPost`: Exposes CRUD operations for the **ScheduledPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledPosts
    * const scheduledPosts = await prisma.scheduledPost.findMany()
    * ```
    */
  get scheduledPost(): Prisma.ScheduledPostDelegate<ExtArgs>;

  /**
   * `prisma.postAnalytics`: Exposes CRUD operations for the **PostAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAnalytics
    * const postAnalytics = await prisma.postAnalytics.findMany()
    * ```
    */
  get postAnalytics(): Prisma.PostAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.newsSource`: Exposes CRUD operations for the **NewsSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsSources
    * const newsSources = await prisma.newsSource.findMany()
    * ```
    */
  get newsSource(): Prisma.NewsSourceDelegate<ExtArgs>;

  /**
   * `prisma.newsArticle`: Exposes CRUD operations for the **NewsArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsArticles
    * const newsArticles = await prisma.newsArticle.findMany()
    * ```
    */
  get newsArticle(): Prisma.NewsArticleDelegate<ExtArgs>;

  /**
   * `prisma.newsThread`: Exposes CRUD operations for the **NewsThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsThreads
    * const newsThreads = await prisma.newsThread.findMany()
    * ```
    */
  get newsThread(): Prisma.NewsThreadDelegate<ExtArgs>;

  /**
   * `prisma.newsThreadItem`: Exposes CRUD operations for the **NewsThreadItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsThreadItems
    * const newsThreadItems = await prisma.newsThreadItem.findMany()
    * ```
    */
  get newsThreadItem(): Prisma.NewsThreadItemDelegate<ExtArgs>;

  /**
   * `prisma.newsAnalysis`: Exposes CRUD operations for the **NewsAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsAnalyses
    * const newsAnalyses = await prisma.newsAnalysis.findMany()
    * ```
    */
  get newsAnalysis(): Prisma.NewsAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.jobQueue`: Exposes CRUD operations for the **JobQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobQueues
    * const jobQueues = await prisma.jobQueue.findMany()
    * ```
    */
  get jobQueue(): Prisma.JobQueueDelegate<ExtArgs>;

  /**
   * `prisma.collectionPreset`: Exposes CRUD operations for the **CollectionPreset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionPresets
    * const collectionPresets = await prisma.collectionPreset.findMany()
    * ```
    */
  get collectionPreset(): Prisma.CollectionPresetDelegate<ExtArgs>;

  /**
   * `prisma.watchlistUser`: Exposes CRUD operations for the **WatchlistUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistUsers
    * const watchlistUsers = await prisma.watchlistUser.findMany()
    * ```
    */
  get watchlistUser(): Prisma.WatchlistUserDelegate<ExtArgs>;

  /**
   * `prisma.watchlistTweet`: Exposes CRUD operations for the **WatchlistTweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistTweets
    * const watchlistTweets = await prisma.watchlistTweet.findMany()
    * ```
    */
  get watchlistTweet(): Prisma.WatchlistTweetDelegate<ExtArgs>;

  /**
   * `prisma.interactionHistory`: Exposes CRUD operations for the **InteractionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InteractionHistories
    * const interactionHistories = await prisma.interactionHistory.findMany()
    * ```
    */
  get interactionHistory(): Prisma.InteractionHistoryDelegate<ExtArgs>;

  /**
   * `prisma.perplexityReport`: Exposes CRUD operations for the **PerplexityReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerplexityReports
    * const perplexityReports = await prisma.perplexityReport.findMany()
    * ```
    */
  get perplexityReport(): Prisma.PerplexityReportDelegate<ExtArgs>;

  /**
   * `prisma.cotSession`: Exposes CRUD operations for the **CotSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotSessions
    * const cotSessions = await prisma.cotSession.findMany()
    * ```
    */
  get cotSession(): Prisma.CotSessionDelegate<ExtArgs>;

  /**
   * `prisma.cotPhase`: Exposes CRUD operations for the **CotPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotPhases
    * const cotPhases = await prisma.cotPhase.findMany()
    * ```
    */
  get cotPhase(): Prisma.CotPhaseDelegate<ExtArgs>;

  /**
   * `prisma.cotDraft`: Exposes CRUD operations for the **CotDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotDrafts
    * const cotDrafts = await prisma.cotDraft.findMany()
    * ```
    */
  get cotDraft(): Prisma.CotDraftDelegate<ExtArgs>;

  /**
   * `prisma.cotDraftPerformance`: Exposes CRUD operations for the **CotDraftPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotDraftPerformances
    * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany()
    * ```
    */
  get cotDraftPerformance(): Prisma.CotDraftPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.unifiedContentSource`: Exposes CRUD operations for the **UnifiedContentSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnifiedContentSources
    * const unifiedContentSources = await prisma.unifiedContentSource.findMany()
    * ```
    */
  get unifiedContentSource(): Prisma.UnifiedContentSourceDelegate<ExtArgs>;

  /**
   * `prisma.integratedSession`: Exposes CRUD operations for the **IntegratedSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegratedSessions
    * const integratedSessions = await prisma.integratedSession.findMany()
    * ```
    */
  get integratedSession(): Prisma.IntegratedSessionDelegate<ExtArgs>;

  /**
   * `prisma.integratedSessionSource`: Exposes CRUD operations for the **IntegratedSessionSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegratedSessionSources
    * const integratedSessionSources = await prisma.integratedSessionSource.findMany()
    * ```
    */
  get integratedSessionSource(): Prisma.IntegratedSessionSourceDelegate<ExtArgs>;

  /**
   * `prisma.integratedDraft`: Exposes CRUD operations for the **IntegratedDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegratedDrafts
    * const integratedDrafts = await prisma.integratedDraft.findMany()
    * ```
    */
  get integratedDraft(): Prisma.IntegratedDraftDelegate<ExtArgs>;

  /**
   * `prisma.integratedDraftPerformance`: Exposes CRUD operations for the **IntegratedDraftPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegratedDraftPerformances
    * const integratedDraftPerformances = await prisma.integratedDraftPerformance.findMany()
    * ```
    */
  get integratedDraftPerformance(): Prisma.IntegratedDraftPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.scheduledRetweet`: Exposes CRUD operations for the **ScheduledRetweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledRetweets
    * const scheduledRetweets = await prisma.scheduledRetweet.findMany()
    * ```
    */
  get scheduledRetweet(): Prisma.ScheduledRetweetDelegate<ExtArgs>;

  /**
   * `prisma.unifiedPerformance`: Exposes CRUD operations for the **UnifiedPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnifiedPerformances
    * const unifiedPerformances = await prisma.unifiedPerformance.findMany()
    * ```
    */
  get unifiedPerformance(): Prisma.UnifiedPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.newsViralRelation`: Exposes CRUD operations for the **NewsViralRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsViralRelations
    * const newsViralRelations = await prisma.newsViralRelation.findMany()
    * ```
    */
  get newsViralRelation(): Prisma.NewsViralRelationDelegate<ExtArgs>;

  /**
   * `prisma.sessionActivityLog`: Exposes CRUD operations for the **SessionActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionActivityLogs
    * const sessionActivityLogs = await prisma.sessionActivityLog.findMany()
    * ```
    */
  get sessionActivityLog(): Prisma.SessionActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.apiErrorLog`: Exposes CRUD operations for the **ApiErrorLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiErrorLogs
    * const apiErrorLogs = await prisma.apiErrorLog.findMany()
    * ```
    */
  get apiErrorLog(): Prisma.ApiErrorLogDelegate<ExtArgs>;

  /**
   * `prisma.viralSession`: Exposes CRUD operations for the **ViralSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViralSessions
    * const viralSessions = await prisma.viralSession.findMany()
    * ```
    */
  get viralSession(): Prisma.ViralSessionDelegate<ExtArgs>;

  /**
   * `prisma.viralDraftV2`: Exposes CRUD operations for the **ViralDraftV2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViralDraftV2s
    * const viralDraftV2s = await prisma.viralDraftV2.findMany()
    * ```
    */
  get viralDraftV2(): Prisma.ViralDraftV2Delegate<ExtArgs>;

  /**
   * `prisma.viralDraftPerformance`: Exposes CRUD operations for the **ViralDraftPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViralDraftPerformances
    * const viralDraftPerformances = await prisma.viralDraftPerformance.findMany()
    * ```
    */
  get viralDraftPerformance(): Prisma.ViralDraftPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.characterProfile`: Exposes CRUD operations for the **CharacterProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterProfiles
    * const characterProfiles = await prisma.characterProfile.findMany()
    * ```
    */
  get characterProfile(): Prisma.CharacterProfileDelegate<ExtArgs>;

  /**
   * `prisma.buzzInfluencer`: Exposes CRUD operations for the **BuzzInfluencer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzInfluencers
    * const buzzInfluencers = await prisma.buzzInfluencer.findMany()
    * ```
    */
  get buzzInfluencer(): Prisma.BuzzInfluencerDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BuzzPost: 'BuzzPost',
    BuzzConfig: 'BuzzConfig',
    ScheduledPost: 'ScheduledPost',
    PostAnalytics: 'PostAnalytics',
    User: 'User',
    Session: 'Session',
    NewsSource: 'NewsSource',
    NewsArticle: 'NewsArticle',
    NewsThread: 'NewsThread',
    NewsThreadItem: 'NewsThreadItem',
    NewsAnalysis: 'NewsAnalysis',
    JobQueue: 'JobQueue',
    CollectionPreset: 'CollectionPreset',
    WatchlistUser: 'WatchlistUser',
    WatchlistTweet: 'WatchlistTweet',
    InteractionHistory: 'InteractionHistory',
    PerplexityReport: 'PerplexityReport',
    CotSession: 'CotSession',
    CotPhase: 'CotPhase',
    CotDraft: 'CotDraft',
    CotDraftPerformance: 'CotDraftPerformance',
    UnifiedContentSource: 'UnifiedContentSource',
    IntegratedSession: 'IntegratedSession',
    IntegratedSessionSource: 'IntegratedSessionSource',
    IntegratedDraft: 'IntegratedDraft',
    IntegratedDraftPerformance: 'IntegratedDraftPerformance',
    ScheduledRetweet: 'ScheduledRetweet',
    UnifiedPerformance: 'UnifiedPerformance',
    NewsViralRelation: 'NewsViralRelation',
    SessionActivityLog: 'SessionActivityLog',
    ApiErrorLog: 'ApiErrorLog',
    ViralSession: 'ViralSession',
    ViralDraftV2: 'ViralDraftV2',
    ViralDraftPerformance: 'ViralDraftPerformance',
    CharacterProfile: 'CharacterProfile',
    BuzzInfluencer: 'BuzzInfluencer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "buzzPost" | "buzzConfig" | "scheduledPost" | "postAnalytics" | "user" | "session" | "newsSource" | "newsArticle" | "newsThread" | "newsThreadItem" | "newsAnalysis" | "jobQueue" | "collectionPreset" | "watchlistUser" | "watchlistTweet" | "interactionHistory" | "perplexityReport" | "cotSession" | "cotPhase" | "cotDraft" | "cotDraftPerformance" | "unifiedContentSource" | "integratedSession" | "integratedSessionSource" | "integratedDraft" | "integratedDraftPerformance" | "scheduledRetweet" | "unifiedPerformance" | "newsViralRelation" | "sessionActivityLog" | "apiErrorLog" | "viralSession" | "viralDraftV2" | "viralDraftPerformance" | "characterProfile" | "buzzInfluencer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BuzzPost: {
        payload: Prisma.$BuzzPostPayload<ExtArgs>
        fields: Prisma.BuzzPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          findFirst: {
            args: Prisma.BuzzPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          findMany: {
            args: Prisma.BuzzPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          create: {
            args: Prisma.BuzzPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          createMany: {
            args: Prisma.BuzzPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuzzPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          delete: {
            args: Prisma.BuzzPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          update: {
            args: Prisma.BuzzPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          deleteMany: {
            args: Prisma.BuzzPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuzzPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          aggregate: {
            args: Prisma.BuzzPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzPost>
          }
          groupBy: {
            args: Prisma.BuzzPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzPostCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzPostCountAggregateOutputType> | number
          }
        }
      }
      BuzzConfig: {
        payload: Prisma.$BuzzConfigPayload<ExtArgs>
        fields: Prisma.BuzzConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          findFirst: {
            args: Prisma.BuzzConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          findMany: {
            args: Prisma.BuzzConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>[]
          }
          create: {
            args: Prisma.BuzzConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          createMany: {
            args: Prisma.BuzzConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuzzConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>[]
          }
          delete: {
            args: Prisma.BuzzConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          update: {
            args: Prisma.BuzzConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          deleteMany: {
            args: Prisma.BuzzConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuzzConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          aggregate: {
            args: Prisma.BuzzConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzConfig>
          }
          groupBy: {
            args: Prisma.BuzzConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzConfigCountAggregateOutputType> | number
          }
        }
      }
      ScheduledPost: {
        payload: Prisma.$ScheduledPostPayload<ExtArgs>
        fields: Prisma.ScheduledPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findFirst: {
            args: Prisma.ScheduledPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findMany: {
            args: Prisma.ScheduledPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          create: {
            args: Prisma.ScheduledPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          createMany: {
            args: Prisma.ScheduledPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          delete: {
            args: Prisma.ScheduledPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          update: {
            args: Prisma.ScheduledPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          aggregate: {
            args: Prisma.ScheduledPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledPost>
          }
          groupBy: {
            args: Prisma.ScheduledPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledPostCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostCountAggregateOutputType> | number
          }
        }
      }
      PostAnalytics: {
        payload: Prisma.$PostAnalyticsPayload<ExtArgs>
        fields: Prisma.PostAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PostAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PostAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PostAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PostAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.PostAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          update: {
            args: Prisma.PostAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PostAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PostAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAnalytics>
          }
          groupBy: {
            args: Prisma.PostAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      NewsSource: {
        payload: Prisma.$NewsSourcePayload<ExtArgs>
        fields: Prisma.NewsSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findFirst: {
            args: Prisma.NewsSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findMany: {
            args: Prisma.NewsSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          create: {
            args: Prisma.NewsSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          createMany: {
            args: Prisma.NewsSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          delete: {
            args: Prisma.NewsSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          update: {
            args: Prisma.NewsSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          deleteMany: {
            args: Prisma.NewsSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          aggregate: {
            args: Prisma.NewsSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsSource>
          }
          groupBy: {
            args: Prisma.NewsSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsSourceCountArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceCountAggregateOutputType> | number
          }
        }
      }
      NewsArticle: {
        payload: Prisma.$NewsArticlePayload<ExtArgs>
        fields: Prisma.NewsArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findFirst: {
            args: Prisma.NewsArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findMany: {
            args: Prisma.NewsArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          create: {
            args: Prisma.NewsArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          createMany: {
            args: Prisma.NewsArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          delete: {
            args: Prisma.NewsArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          update: {
            args: Prisma.NewsArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          deleteMany: {
            args: Prisma.NewsArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          aggregate: {
            args: Prisma.NewsArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsArticle>
          }
          groupBy: {
            args: Prisma.NewsArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsArticleCountArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleCountAggregateOutputType> | number
          }
        }
      }
      NewsThread: {
        payload: Prisma.$NewsThreadPayload<ExtArgs>
        fields: Prisma.NewsThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          findFirst: {
            args: Prisma.NewsThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          findMany: {
            args: Prisma.NewsThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          create: {
            args: Prisma.NewsThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          createMany: {
            args: Prisma.NewsThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          delete: {
            args: Prisma.NewsThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          update: {
            args: Prisma.NewsThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          deleteMany: {
            args: Prisma.NewsThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          aggregate: {
            args: Prisma.NewsThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsThread>
          }
          groupBy: {
            args: Prisma.NewsThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsThreadCountArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadCountAggregateOutputType> | number
          }
        }
      }
      NewsThreadItem: {
        payload: Prisma.$NewsThreadItemPayload<ExtArgs>
        fields: Prisma.NewsThreadItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsThreadItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsThreadItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          findFirst: {
            args: Prisma.NewsThreadItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsThreadItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          findMany: {
            args: Prisma.NewsThreadItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          create: {
            args: Prisma.NewsThreadItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          createMany: {
            args: Prisma.NewsThreadItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsThreadItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          delete: {
            args: Prisma.NewsThreadItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          update: {
            args: Prisma.NewsThreadItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          deleteMany: {
            args: Prisma.NewsThreadItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsThreadItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsThreadItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          aggregate: {
            args: Prisma.NewsThreadItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsThreadItem>
          }
          groupBy: {
            args: Prisma.NewsThreadItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsThreadItemCountArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadItemCountAggregateOutputType> | number
          }
        }
      }
      NewsAnalysis: {
        payload: Prisma.$NewsAnalysisPayload<ExtArgs>
        fields: Prisma.NewsAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          findFirst: {
            args: Prisma.NewsAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          findMany: {
            args: Prisma.NewsAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          create: {
            args: Prisma.NewsAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          createMany: {
            args: Prisma.NewsAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          delete: {
            args: Prisma.NewsAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          update: {
            args: Prisma.NewsAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.NewsAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          aggregate: {
            args: Prisma.NewsAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsAnalysis>
          }
          groupBy: {
            args: Prisma.NewsAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<NewsAnalysisCountAggregateOutputType> | number
          }
        }
      }
      JobQueue: {
        payload: Prisma.$JobQueuePayload<ExtArgs>
        fields: Prisma.JobQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findFirst: {
            args: Prisma.JobQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findMany: {
            args: Prisma.JobQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          create: {
            args: Prisma.JobQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          createMany: {
            args: Prisma.JobQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          delete: {
            args: Prisma.JobQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          update: {
            args: Prisma.JobQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          deleteMany: {
            args: Prisma.JobQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          aggregate: {
            args: Prisma.JobQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobQueue>
          }
          groupBy: {
            args: Prisma.JobQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobQueueCountArgs<ExtArgs>
            result: $Utils.Optional<JobQueueCountAggregateOutputType> | number
          }
        }
      }
      CollectionPreset: {
        payload: Prisma.$CollectionPresetPayload<ExtArgs>
        fields: Prisma.CollectionPresetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionPresetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionPresetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          findFirst: {
            args: Prisma.CollectionPresetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionPresetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          findMany: {
            args: Prisma.CollectionPresetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          create: {
            args: Prisma.CollectionPresetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          createMany: {
            args: Prisma.CollectionPresetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionPresetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          delete: {
            args: Prisma.CollectionPresetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          update: {
            args: Prisma.CollectionPresetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          deleteMany: {
            args: Prisma.CollectionPresetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionPresetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CollectionPresetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          aggregate: {
            args: Prisma.CollectionPresetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionPreset>
          }
          groupBy: {
            args: Prisma.CollectionPresetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionPresetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionPresetCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionPresetCountAggregateOutputType> | number
          }
        }
      }
      WatchlistUser: {
        payload: Prisma.$WatchlistUserPayload<ExtArgs>
        fields: Prisma.WatchlistUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          findFirst: {
            args: Prisma.WatchlistUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          findMany: {
            args: Prisma.WatchlistUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          create: {
            args: Prisma.WatchlistUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          createMany: {
            args: Prisma.WatchlistUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          delete: {
            args: Prisma.WatchlistUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          update: {
            args: Prisma.WatchlistUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchlistUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          aggregate: {
            args: Prisma.WatchlistUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistUser>
          }
          groupBy: {
            args: Prisma.WatchlistUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistUserCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistUserCountAggregateOutputType> | number
          }
        }
      }
      WatchlistTweet: {
        payload: Prisma.$WatchlistTweetPayload<ExtArgs>
        fields: Prisma.WatchlistTweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistTweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistTweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          findFirst: {
            args: Prisma.WatchlistTweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistTweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          findMany: {
            args: Prisma.WatchlistTweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          create: {
            args: Prisma.WatchlistTweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          createMany: {
            args: Prisma.WatchlistTweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistTweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          delete: {
            args: Prisma.WatchlistTweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          update: {
            args: Prisma.WatchlistTweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistTweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistTweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchlistTweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          aggregate: {
            args: Prisma.WatchlistTweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistTweet>
          }
          groupBy: {
            args: Prisma.WatchlistTweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistTweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistTweetCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistTweetCountAggregateOutputType> | number
          }
        }
      }
      InteractionHistory: {
        payload: Prisma.$InteractionHistoryPayload<ExtArgs>
        fields: Prisma.InteractionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          findFirst: {
            args: Prisma.InteractionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          findMany: {
            args: Prisma.InteractionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          create: {
            args: Prisma.InteractionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          createMany: {
            args: Prisma.InteractionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          delete: {
            args: Prisma.InteractionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          update: {
            args: Prisma.InteractionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.InteractionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InteractionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          aggregate: {
            args: Prisma.InteractionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteractionHistory>
          }
          groupBy: {
            args: Prisma.InteractionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionHistoryCountAggregateOutputType> | number
          }
        }
      }
      PerplexityReport: {
        payload: Prisma.$PerplexityReportPayload<ExtArgs>
        fields: Prisma.PerplexityReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerplexityReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerplexityReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          findFirst: {
            args: Prisma.PerplexityReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerplexityReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          findMany: {
            args: Prisma.PerplexityReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          create: {
            args: Prisma.PerplexityReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          createMany: {
            args: Prisma.PerplexityReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerplexityReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          delete: {
            args: Prisma.PerplexityReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          update: {
            args: Prisma.PerplexityReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          deleteMany: {
            args: Prisma.PerplexityReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerplexityReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerplexityReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          aggregate: {
            args: Prisma.PerplexityReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerplexityReport>
          }
          groupBy: {
            args: Prisma.PerplexityReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerplexityReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerplexityReportCountArgs<ExtArgs>
            result: $Utils.Optional<PerplexityReportCountAggregateOutputType> | number
          }
        }
      }
      CotSession: {
        payload: Prisma.$CotSessionPayload<ExtArgs>
        fields: Prisma.CotSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          findFirst: {
            args: Prisma.CotSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          findMany: {
            args: Prisma.CotSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          create: {
            args: Prisma.CotSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          createMany: {
            args: Prisma.CotSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          delete: {
            args: Prisma.CotSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          update: {
            args: Prisma.CotSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          deleteMany: {
            args: Prisma.CotSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          aggregate: {
            args: Prisma.CotSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotSession>
          }
          groupBy: {
            args: Prisma.CotSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CotSessionCountAggregateOutputType> | number
          }
        }
      }
      CotPhase: {
        payload: Prisma.$CotPhasePayload<ExtArgs>
        fields: Prisma.CotPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          findFirst: {
            args: Prisma.CotPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          findMany: {
            args: Prisma.CotPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          create: {
            args: Prisma.CotPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          createMany: {
            args: Prisma.CotPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotPhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          delete: {
            args: Prisma.CotPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          update: {
            args: Prisma.CotPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          deleteMany: {
            args: Prisma.CotPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          aggregate: {
            args: Prisma.CotPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotPhase>
          }
          groupBy: {
            args: Prisma.CotPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<CotPhaseCountAggregateOutputType> | number
          }
        }
      }
      CotDraft: {
        payload: Prisma.$CotDraftPayload<ExtArgs>
        fields: Prisma.CotDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotDraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotDraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          findFirst: {
            args: Prisma.CotDraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotDraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          findMany: {
            args: Prisma.CotDraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          create: {
            args: Prisma.CotDraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          createMany: {
            args: Prisma.CotDraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotDraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          delete: {
            args: Prisma.CotDraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          update: {
            args: Prisma.CotDraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          deleteMany: {
            args: Prisma.CotDraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotDraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotDraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          aggregate: {
            args: Prisma.CotDraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotDraft>
          }
          groupBy: {
            args: Prisma.CotDraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotDraftCountArgs<ExtArgs>
            result: $Utils.Optional<CotDraftCountAggregateOutputType> | number
          }
        }
      }
      CotDraftPerformance: {
        payload: Prisma.$CotDraftPerformancePayload<ExtArgs>
        fields: Prisma.CotDraftPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotDraftPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          findFirst: {
            args: Prisma.CotDraftPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          findMany: {
            args: Prisma.CotDraftPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          create: {
            args: Prisma.CotDraftPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          createMany: {
            args: Prisma.CotDraftPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          delete: {
            args: Prisma.CotDraftPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          update: {
            args: Prisma.CotDraftPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          deleteMany: {
            args: Prisma.CotDraftPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotDraftPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotDraftPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          aggregate: {
            args: Prisma.CotDraftPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotDraftPerformance>
          }
          groupBy: {
            args: Prisma.CotDraftPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotDraftPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotDraftPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<CotDraftPerformanceCountAggregateOutputType> | number
          }
        }
      }
      UnifiedContentSource: {
        payload: Prisma.$UnifiedContentSourcePayload<ExtArgs>
        fields: Prisma.UnifiedContentSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnifiedContentSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnifiedContentSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>
          }
          findFirst: {
            args: Prisma.UnifiedContentSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnifiedContentSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>
          }
          findMany: {
            args: Prisma.UnifiedContentSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>[]
          }
          create: {
            args: Prisma.UnifiedContentSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>
          }
          createMany: {
            args: Prisma.UnifiedContentSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnifiedContentSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>[]
          }
          delete: {
            args: Prisma.UnifiedContentSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>
          }
          update: {
            args: Prisma.UnifiedContentSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>
          }
          deleteMany: {
            args: Prisma.UnifiedContentSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnifiedContentSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnifiedContentSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedContentSourcePayload>
          }
          aggregate: {
            args: Prisma.UnifiedContentSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnifiedContentSource>
          }
          groupBy: {
            args: Prisma.UnifiedContentSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnifiedContentSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnifiedContentSourceCountArgs<ExtArgs>
            result: $Utils.Optional<UnifiedContentSourceCountAggregateOutputType> | number
          }
        }
      }
      IntegratedSession: {
        payload: Prisma.$IntegratedSessionPayload<ExtArgs>
        fields: Prisma.IntegratedSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegratedSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegratedSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>
          }
          findFirst: {
            args: Prisma.IntegratedSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegratedSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>
          }
          findMany: {
            args: Prisma.IntegratedSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>[]
          }
          create: {
            args: Prisma.IntegratedSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>
          }
          createMany: {
            args: Prisma.IntegratedSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegratedSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>[]
          }
          delete: {
            args: Prisma.IntegratedSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>
          }
          update: {
            args: Prisma.IntegratedSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>
          }
          deleteMany: {
            args: Prisma.IntegratedSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegratedSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegratedSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionPayload>
          }
          aggregate: {
            args: Prisma.IntegratedSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegratedSession>
          }
          groupBy: {
            args: Prisma.IntegratedSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegratedSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegratedSessionCountArgs<ExtArgs>
            result: $Utils.Optional<IntegratedSessionCountAggregateOutputType> | number
          }
        }
      }
      IntegratedSessionSource: {
        payload: Prisma.$IntegratedSessionSourcePayload<ExtArgs>
        fields: Prisma.IntegratedSessionSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegratedSessionSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegratedSessionSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>
          }
          findFirst: {
            args: Prisma.IntegratedSessionSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegratedSessionSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>
          }
          findMany: {
            args: Prisma.IntegratedSessionSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>[]
          }
          create: {
            args: Prisma.IntegratedSessionSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>
          }
          createMany: {
            args: Prisma.IntegratedSessionSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegratedSessionSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>[]
          }
          delete: {
            args: Prisma.IntegratedSessionSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>
          }
          update: {
            args: Prisma.IntegratedSessionSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>
          }
          deleteMany: {
            args: Prisma.IntegratedSessionSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegratedSessionSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegratedSessionSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedSessionSourcePayload>
          }
          aggregate: {
            args: Prisma.IntegratedSessionSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegratedSessionSource>
          }
          groupBy: {
            args: Prisma.IntegratedSessionSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegratedSessionSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegratedSessionSourceCountArgs<ExtArgs>
            result: $Utils.Optional<IntegratedSessionSourceCountAggregateOutputType> | number
          }
        }
      }
      IntegratedDraft: {
        payload: Prisma.$IntegratedDraftPayload<ExtArgs>
        fields: Prisma.IntegratedDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegratedDraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegratedDraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>
          }
          findFirst: {
            args: Prisma.IntegratedDraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegratedDraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>
          }
          findMany: {
            args: Prisma.IntegratedDraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>[]
          }
          create: {
            args: Prisma.IntegratedDraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>
          }
          createMany: {
            args: Prisma.IntegratedDraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegratedDraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>[]
          }
          delete: {
            args: Prisma.IntegratedDraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>
          }
          update: {
            args: Prisma.IntegratedDraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>
          }
          deleteMany: {
            args: Prisma.IntegratedDraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegratedDraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegratedDraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPayload>
          }
          aggregate: {
            args: Prisma.IntegratedDraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegratedDraft>
          }
          groupBy: {
            args: Prisma.IntegratedDraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegratedDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegratedDraftCountArgs<ExtArgs>
            result: $Utils.Optional<IntegratedDraftCountAggregateOutputType> | number
          }
        }
      }
      IntegratedDraftPerformance: {
        payload: Prisma.$IntegratedDraftPerformancePayload<ExtArgs>
        fields: Prisma.IntegratedDraftPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegratedDraftPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegratedDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>
          }
          findFirst: {
            args: Prisma.IntegratedDraftPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegratedDraftPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>
          }
          findMany: {
            args: Prisma.IntegratedDraftPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>[]
          }
          create: {
            args: Prisma.IntegratedDraftPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>
          }
          createMany: {
            args: Prisma.IntegratedDraftPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegratedDraftPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>[]
          }
          delete: {
            args: Prisma.IntegratedDraftPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>
          }
          update: {
            args: Prisma.IntegratedDraftPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>
          }
          deleteMany: {
            args: Prisma.IntegratedDraftPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegratedDraftPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegratedDraftPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegratedDraftPerformancePayload>
          }
          aggregate: {
            args: Prisma.IntegratedDraftPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegratedDraftPerformance>
          }
          groupBy: {
            args: Prisma.IntegratedDraftPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegratedDraftPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegratedDraftPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<IntegratedDraftPerformanceCountAggregateOutputType> | number
          }
        }
      }
      ScheduledRetweet: {
        payload: Prisma.$ScheduledRetweetPayload<ExtArgs>
        fields: Prisma.ScheduledRetweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledRetweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledRetweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          findFirst: {
            args: Prisma.ScheduledRetweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledRetweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          findMany: {
            args: Prisma.ScheduledRetweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>[]
          }
          create: {
            args: Prisma.ScheduledRetweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          createMany: {
            args: Prisma.ScheduledRetweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledRetweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>[]
          }
          delete: {
            args: Prisma.ScheduledRetweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          update: {
            args: Prisma.ScheduledRetweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledRetweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledRetweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledRetweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          aggregate: {
            args: Prisma.ScheduledRetweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledRetweet>
          }
          groupBy: {
            args: Prisma.ScheduledRetweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledRetweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledRetweetCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledRetweetCountAggregateOutputType> | number
          }
        }
      }
      UnifiedPerformance: {
        payload: Prisma.$UnifiedPerformancePayload<ExtArgs>
        fields: Prisma.UnifiedPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnifiedPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnifiedPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          findFirst: {
            args: Prisma.UnifiedPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnifiedPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          findMany: {
            args: Prisma.UnifiedPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>[]
          }
          create: {
            args: Prisma.UnifiedPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          createMany: {
            args: Prisma.UnifiedPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnifiedPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>[]
          }
          delete: {
            args: Prisma.UnifiedPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          update: {
            args: Prisma.UnifiedPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          deleteMany: {
            args: Prisma.UnifiedPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnifiedPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnifiedPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          aggregate: {
            args: Prisma.UnifiedPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnifiedPerformance>
          }
          groupBy: {
            args: Prisma.UnifiedPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnifiedPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnifiedPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<UnifiedPerformanceCountAggregateOutputType> | number
          }
        }
      }
      NewsViralRelation: {
        payload: Prisma.$NewsViralRelationPayload<ExtArgs>
        fields: Prisma.NewsViralRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsViralRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsViralRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          findFirst: {
            args: Prisma.NewsViralRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsViralRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          findMany: {
            args: Prisma.NewsViralRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>[]
          }
          create: {
            args: Prisma.NewsViralRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          createMany: {
            args: Prisma.NewsViralRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsViralRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>[]
          }
          delete: {
            args: Prisma.NewsViralRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          update: {
            args: Prisma.NewsViralRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          deleteMany: {
            args: Prisma.NewsViralRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsViralRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsViralRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          aggregate: {
            args: Prisma.NewsViralRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsViralRelation>
          }
          groupBy: {
            args: Prisma.NewsViralRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsViralRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsViralRelationCountArgs<ExtArgs>
            result: $Utils.Optional<NewsViralRelationCountAggregateOutputType> | number
          }
        }
      }
      SessionActivityLog: {
        payload: Prisma.$SessionActivityLogPayload<ExtArgs>
        fields: Prisma.SessionActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          findFirst: {
            args: Prisma.SessionActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          findMany: {
            args: Prisma.SessionActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>[]
          }
          create: {
            args: Prisma.SessionActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          createMany: {
            args: Prisma.SessionActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>[]
          }
          delete: {
            args: Prisma.SessionActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          update: {
            args: Prisma.SessionActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.SessionActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          aggregate: {
            args: Prisma.SessionActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionActivityLog>
          }
          groupBy: {
            args: Prisma.SessionActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<SessionActivityLogCountAggregateOutputType> | number
          }
        }
      }
      ApiErrorLog: {
        payload: Prisma.$ApiErrorLogPayload<ExtArgs>
        fields: Prisma.ApiErrorLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiErrorLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiErrorLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          findFirst: {
            args: Prisma.ApiErrorLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiErrorLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          findMany: {
            args: Prisma.ApiErrorLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>[]
          }
          create: {
            args: Prisma.ApiErrorLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          createMany: {
            args: Prisma.ApiErrorLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiErrorLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>[]
          }
          delete: {
            args: Prisma.ApiErrorLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          update: {
            args: Prisma.ApiErrorLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiErrorLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiErrorLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiErrorLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          aggregate: {
            args: Prisma.ApiErrorLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiErrorLog>
          }
          groupBy: {
            args: Prisma.ApiErrorLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiErrorLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiErrorLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiErrorLogCountAggregateOutputType> | number
          }
        }
      }
      ViralSession: {
        payload: Prisma.$ViralSessionPayload<ExtArgs>
        fields: Prisma.ViralSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViralSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViralSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          findFirst: {
            args: Prisma.ViralSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViralSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          findMany: {
            args: Prisma.ViralSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>[]
          }
          create: {
            args: Prisma.ViralSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          createMany: {
            args: Prisma.ViralSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViralSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>[]
          }
          delete: {
            args: Prisma.ViralSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          update: {
            args: Prisma.ViralSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          deleteMany: {
            args: Prisma.ViralSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViralSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViralSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          aggregate: {
            args: Prisma.ViralSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViralSession>
          }
          groupBy: {
            args: Prisma.ViralSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViralSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViralSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ViralSessionCountAggregateOutputType> | number
          }
        }
      }
      ViralDraftV2: {
        payload: Prisma.$ViralDraftV2Payload<ExtArgs>
        fields: Prisma.ViralDraftV2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViralDraftV2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViralDraftV2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          findFirst: {
            args: Prisma.ViralDraftV2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViralDraftV2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          findMany: {
            args: Prisma.ViralDraftV2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>[]
          }
          create: {
            args: Prisma.ViralDraftV2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          createMany: {
            args: Prisma.ViralDraftV2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViralDraftV2CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>[]
          }
          delete: {
            args: Prisma.ViralDraftV2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          update: {
            args: Prisma.ViralDraftV2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          deleteMany: {
            args: Prisma.ViralDraftV2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViralDraftV2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViralDraftV2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          aggregate: {
            args: Prisma.ViralDraftV2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViralDraftV2>
          }
          groupBy: {
            args: Prisma.ViralDraftV2GroupByArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftV2GroupByOutputType>[]
          }
          count: {
            args: Prisma.ViralDraftV2CountArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftV2CountAggregateOutputType> | number
          }
        }
      }
      ViralDraftPerformance: {
        payload: Prisma.$ViralDraftPerformancePayload<ExtArgs>
        fields: Prisma.ViralDraftPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViralDraftPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViralDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          findFirst: {
            args: Prisma.ViralDraftPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViralDraftPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          findMany: {
            args: Prisma.ViralDraftPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>[]
          }
          create: {
            args: Prisma.ViralDraftPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          createMany: {
            args: Prisma.ViralDraftPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViralDraftPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>[]
          }
          delete: {
            args: Prisma.ViralDraftPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          update: {
            args: Prisma.ViralDraftPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          deleteMany: {
            args: Prisma.ViralDraftPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViralDraftPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViralDraftPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          aggregate: {
            args: Prisma.ViralDraftPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViralDraftPerformance>
          }
          groupBy: {
            args: Prisma.ViralDraftPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViralDraftPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftPerformanceCountAggregateOutputType> | number
          }
        }
      }
      CharacterProfile: {
        payload: Prisma.$CharacterProfilePayload<ExtArgs>
        fields: Prisma.CharacterProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          findFirst: {
            args: Prisma.CharacterProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          findMany: {
            args: Prisma.CharacterProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>[]
          }
          create: {
            args: Prisma.CharacterProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          createMany: {
            args: Prisma.CharacterProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>[]
          }
          delete: {
            args: Prisma.CharacterProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          update: {
            args: Prisma.CharacterProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          deleteMany: {
            args: Prisma.CharacterProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          aggregate: {
            args: Prisma.CharacterProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterProfile>
          }
          groupBy: {
            args: Prisma.CharacterProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterProfileCountAggregateOutputType> | number
          }
        }
      }
      BuzzInfluencer: {
        payload: Prisma.$BuzzInfluencerPayload<ExtArgs>
        fields: Prisma.BuzzInfluencerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzInfluencerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzInfluencerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>
          }
          findFirst: {
            args: Prisma.BuzzInfluencerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzInfluencerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>
          }
          findMany: {
            args: Prisma.BuzzInfluencerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>[]
          }
          create: {
            args: Prisma.BuzzInfluencerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>
          }
          createMany: {
            args: Prisma.BuzzInfluencerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuzzInfluencerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>[]
          }
          delete: {
            args: Prisma.BuzzInfluencerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>
          }
          update: {
            args: Prisma.BuzzInfluencerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>
          }
          deleteMany: {
            args: Prisma.BuzzInfluencerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzInfluencerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuzzInfluencerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzInfluencerPayload>
          }
          aggregate: {
            args: Prisma.BuzzInfluencerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzInfluencer>
          }
          groupBy: {
            args: Prisma.BuzzInfluencerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzInfluencerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzInfluencerCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzInfluencerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BuzzPostCountOutputType
   */

  export type BuzzPostCountOutputType = {
    scheduledPosts: number
  }

  export type BuzzPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPosts?: boolean | BuzzPostCountOutputTypeCountScheduledPostsArgs
  }

  // Custom InputTypes
  /**
   * BuzzPostCountOutputType without action
   */
  export type BuzzPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPostCountOutputType
     */
    select?: BuzzPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuzzPostCountOutputType without action
   */
  export type BuzzPostCountOutputTypeCountScheduledPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    watchlistUsers: number
    characterProfiles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    watchlistUsers?: boolean | UserCountOutputTypeCountWatchlistUsersArgs
    characterProfiles?: boolean | UserCountOutputTypeCountCharacterProfilesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchlistUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCharacterProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterProfileWhereInput
  }


  /**
   * Count Type NewsSourceCountOutputType
   */

  export type NewsSourceCountOutputType = {
    articles: number
  }

  export type NewsSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | NewsSourceCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * NewsSourceCountOutputType without action
   */
  export type NewsSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSourceCountOutputType
     */
    select?: NewsSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsSourceCountOutputType without action
   */
  export type NewsSourceCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
  }


  /**
   * Count Type NewsArticleCountOutputType
   */

  export type NewsArticleCountOutputType = {
    newsThreadItems: number
    viralRelations: number
  }

  export type NewsArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsThreadItems?: boolean | NewsArticleCountOutputTypeCountNewsThreadItemsArgs
    viralRelations?: boolean | NewsArticleCountOutputTypeCountViralRelationsArgs
  }

  // Custom InputTypes
  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticleCountOutputType
     */
    select?: NewsArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeCountNewsThreadItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
  }

  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeCountViralRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsViralRelationWhereInput
  }


  /**
   * Count Type NewsThreadCountOutputType
   */

  export type NewsThreadCountOutputType = {
    items: number
  }

  export type NewsThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NewsThreadCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * NewsThreadCountOutputType without action
   */
  export type NewsThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadCountOutputType
     */
    select?: NewsThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsThreadCountOutputType without action
   */
  export type NewsThreadCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
  }


  /**
   * Count Type WatchlistUserCountOutputType
   */

  export type WatchlistUserCountOutputType = {
    tweets: number
    interactions: number
  }

  export type WatchlistUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | WatchlistUserCountOutputTypeCountTweetsArgs
    interactions?: boolean | WatchlistUserCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUserCountOutputType
     */
    select?: WatchlistUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistTweetWhereInput
  }

  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionHistoryWhereInput
  }


  /**
   * Count Type CotSessionCountOutputType
   */

  export type CotSessionCountOutputType = {
    phases: number
    drafts: number
  }

  export type CotSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | CotSessionCountOutputTypeCountPhasesArgs
    drafts?: boolean | CotSessionCountOutputTypeCountDraftsArgs
  }

  // Custom InputTypes
  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSessionCountOutputType
     */
    select?: CotSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotPhaseWhereInput
  }

  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftWhereInput
  }


  /**
   * Count Type CotDraftCountOutputType
   */

  export type CotDraftCountOutputType = {
    scheduledRTs: number
  }

  export type CotDraftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledRTs?: boolean | CotDraftCountOutputTypeCountScheduledRTsArgs
  }

  // Custom InputTypes
  /**
   * CotDraftCountOutputType without action
   */
  export type CotDraftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftCountOutputType
     */
    select?: CotDraftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CotDraftCountOutputType without action
   */
  export type CotDraftCountOutputTypeCountScheduledRTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledRetweetWhereInput
  }


  /**
   * Count Type UnifiedContentSourceCountOutputType
   */

  export type UnifiedContentSourceCountOutputType = {
    integratedSessions: number
  }

  export type UnifiedContentSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integratedSessions?: boolean | UnifiedContentSourceCountOutputTypeCountIntegratedSessionsArgs
  }

  // Custom InputTypes
  /**
   * UnifiedContentSourceCountOutputType without action
   */
  export type UnifiedContentSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSourceCountOutputType
     */
    select?: UnifiedContentSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnifiedContentSourceCountOutputType without action
   */
  export type UnifiedContentSourceCountOutputTypeCountIntegratedSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedSessionSourceWhereInput
  }


  /**
   * Count Type IntegratedSessionCountOutputType
   */

  export type IntegratedSessionCountOutputType = {
    sources: number
    drafts: number
  }

  export type IntegratedSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sources?: boolean | IntegratedSessionCountOutputTypeCountSourcesArgs
    drafts?: boolean | IntegratedSessionCountOutputTypeCountDraftsArgs
  }

  // Custom InputTypes
  /**
   * IntegratedSessionCountOutputType without action
   */
  export type IntegratedSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionCountOutputType
     */
    select?: IntegratedSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntegratedSessionCountOutputType without action
   */
  export type IntegratedSessionCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedSessionSourceWhereInput
  }

  /**
   * IntegratedSessionCountOutputType without action
   */
  export type IntegratedSessionCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedDraftWhereInput
  }


  /**
   * Count Type ViralSessionCountOutputType
   */

  export type ViralSessionCountOutputType = {
    drafts: number
    newsRelations: number
    integratedSessions: number
  }

  export type ViralSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | ViralSessionCountOutputTypeCountDraftsArgs
    newsRelations?: boolean | ViralSessionCountOutputTypeCountNewsRelationsArgs
    integratedSessions?: boolean | ViralSessionCountOutputTypeCountIntegratedSessionsArgs
  }

  // Custom InputTypes
  /**
   * ViralSessionCountOutputType without action
   */
  export type ViralSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSessionCountOutputType
     */
    select?: ViralSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViralSessionCountOutputType without action
   */
  export type ViralSessionCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralDraftV2WhereInput
  }

  /**
   * ViralSessionCountOutputType without action
   */
  export type ViralSessionCountOutputTypeCountNewsRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsViralRelationWhereInput
  }

  /**
   * ViralSessionCountOutputType without action
   */
  export type ViralSessionCountOutputTypeCountIntegratedSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedSessionWhereInput
  }


  /**
   * Count Type ViralDraftV2CountOutputType
   */

  export type ViralDraftV2CountOutputType = {
    scheduledRTs: number
  }

  export type ViralDraftV2CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledRTs?: boolean | ViralDraftV2CountOutputTypeCountScheduledRTsArgs
  }

  // Custom InputTypes
  /**
   * ViralDraftV2CountOutputType without action
   */
  export type ViralDraftV2CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2CountOutputType
     */
    select?: ViralDraftV2CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViralDraftV2CountOutputType without action
   */
  export type ViralDraftV2CountOutputTypeCountScheduledRTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledRetweetWhereInput
  }


  /**
   * Count Type CharacterProfileCountOutputType
   */

  export type CharacterProfileCountOutputType = {
    sessions: number
  }

  export type CharacterProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | CharacterProfileCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * CharacterProfileCountOutputType without action
   */
  export type CharacterProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfileCountOutputType
     */
    select?: CharacterProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterProfileCountOutputType without action
   */
  export type CharacterProfileCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralSessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BuzzPost
   */

  export type AggregateBuzzPost = {
    _count: BuzzPostCountAggregateOutputType | null
    _avg: BuzzPostAvgAggregateOutputType | null
    _sum: BuzzPostSumAggregateOutputType | null
    _min: BuzzPostMinAggregateOutputType | null
    _max: BuzzPostMaxAggregateOutputType | null
  }

  export type BuzzPostAvgAggregateOutputType = {
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    authorFollowers: number | null
    authorFollowing: number | null
  }

  export type BuzzPostSumAggregateOutputType = {
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    authorFollowers: number | null
    authorFollowing: number | null
  }

  export type BuzzPostMinAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    authorUsername: string | null
    authorId: string | null
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    postedAt: Date | null
    collectedAt: Date | null
    url: string | null
    theme: string | null
    language: string | null
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
  }

  export type BuzzPostMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    authorUsername: string | null
    authorId: string | null
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    postedAt: Date | null
    collectedAt: Date | null
    url: string | null
    theme: string | null
    language: string | null
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
  }

  export type BuzzPostCountAggregateOutputType = {
    id: number
    postId: number
    content: number
    authorUsername: number
    authorId: number
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: number
    collectedAt: number
    url: number
    theme: number
    language: number
    mediaUrls: number
    hashtags: number
    chromaId: number
    authorFollowers: number
    authorFollowing: number
    authorVerified: number
    _all: number
  }


  export type BuzzPostAvgAggregateInputType = {
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    authorFollowers?: true
    authorFollowing?: true
  }

  export type BuzzPostSumAggregateInputType = {
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    authorFollowers?: true
    authorFollowing?: true
  }

  export type BuzzPostMinAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
  }

  export type BuzzPostMaxAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
  }

  export type BuzzPostCountAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    mediaUrls?: true
    hashtags?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
    _all?: true
  }

  export type BuzzPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzPost to aggregate.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzPosts
    **/
    _count?: true | BuzzPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzPostMaxAggregateInputType
  }

  export type GetBuzzPostAggregateType<T extends BuzzPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzPost[P]>
      : GetScalarType<T[P], AggregateBuzzPost[P]>
  }




  export type BuzzPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzPostWhereInput
    orderBy?: BuzzPostOrderByWithAggregationInput | BuzzPostOrderByWithAggregationInput[]
    by: BuzzPostScalarFieldEnum[] | BuzzPostScalarFieldEnum
    having?: BuzzPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzPostCountAggregateInputType | true
    _avg?: BuzzPostAvgAggregateInputType
    _sum?: BuzzPostSumAggregateInputType
    _min?: BuzzPostMinAggregateInputType
    _max?: BuzzPostMaxAggregateInputType
  }

  export type BuzzPostGroupByOutputType = {
    id: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date
    collectedAt: Date
    url: string
    theme: string
    language: string
    mediaUrls: JsonValue
    hashtags: JsonValue
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
    _count: BuzzPostCountAggregateOutputType | null
    _avg: BuzzPostAvgAggregateOutputType | null
    _sum: BuzzPostSumAggregateOutputType | null
    _min: BuzzPostMinAggregateOutputType | null
    _max: BuzzPostMaxAggregateOutputType | null
  }

  type GetBuzzPostGroupByPayload<T extends BuzzPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzPostGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzPostGroupByOutputType[P]>
        }
      >
    >


  export type BuzzPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
    scheduledPosts?: boolean | BuzzPost$scheduledPostsArgs<ExtArgs>
    _count?: boolean | BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectScalar = {
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }

  export type BuzzPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPosts?: boolean | BuzzPost$scheduledPostsArgs<ExtArgs>
    _count?: boolean | BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuzzPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BuzzPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzPost"
    objects: {
      scheduledPosts: Prisma.$ScheduledPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      content: string
      authorUsername: string
      authorId: string
      likesCount: number
      retweetsCount: number
      repliesCount: number
      impressionsCount: number
      postedAt: Date
      collectedAt: Date
      url: string
      theme: string
      language: string
      mediaUrls: Prisma.JsonValue
      hashtags: Prisma.JsonValue
      chromaId: string | null
      authorFollowers: number | null
      authorFollowing: number | null
      authorVerified: boolean | null
    }, ExtArgs["result"]["buzzPost"]>
    composites: {}
  }

  type BuzzPostGetPayload<S extends boolean | null | undefined | BuzzPostDefaultArgs> = $Result.GetResult<Prisma.$BuzzPostPayload, S>

  type BuzzPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuzzPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuzzPostCountAggregateInputType | true
    }

  export interface BuzzPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzPost'], meta: { name: 'BuzzPost' } }
    /**
     * Find zero or one BuzzPost that matches the filter.
     * @param {BuzzPostFindUniqueArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzPostFindUniqueArgs>(args: SelectSubset<T, BuzzPostFindUniqueArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuzzPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuzzPostFindUniqueOrThrowArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuzzPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindFirstArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzPostFindFirstArgs>(args?: SelectSubset<T, BuzzPostFindFirstArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuzzPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindFirstOrThrowArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuzzPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzPosts
     * const buzzPosts = await prisma.buzzPost.findMany()
     * 
     * // Get first 10 BuzzPosts
     * const buzzPosts = await prisma.buzzPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzPostFindManyArgs>(args?: SelectSubset<T, BuzzPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuzzPost.
     * @param {BuzzPostCreateArgs} args - Arguments to create a BuzzPost.
     * @example
     * // Create one BuzzPost
     * const BuzzPost = await prisma.buzzPost.create({
     *   data: {
     *     // ... data to create a BuzzPost
     *   }
     * })
     * 
     */
    create<T extends BuzzPostCreateArgs>(args: SelectSubset<T, BuzzPostCreateArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuzzPosts.
     * @param {BuzzPostCreateManyArgs} args - Arguments to create many BuzzPosts.
     * @example
     * // Create many BuzzPosts
     * const buzzPost = await prisma.buzzPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzPostCreateManyArgs>(args?: SelectSubset<T, BuzzPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuzzPosts and returns the data saved in the database.
     * @param {BuzzPostCreateManyAndReturnArgs} args - Arguments to create many BuzzPosts.
     * @example
     * // Create many BuzzPosts
     * const buzzPost = await prisma.buzzPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuzzPosts and only return the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuzzPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BuzzPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuzzPost.
     * @param {BuzzPostDeleteArgs} args - Arguments to delete one BuzzPost.
     * @example
     * // Delete one BuzzPost
     * const BuzzPost = await prisma.buzzPost.delete({
     *   where: {
     *     // ... filter to delete one BuzzPost
     *   }
     * })
     * 
     */
    delete<T extends BuzzPostDeleteArgs>(args: SelectSubset<T, BuzzPostDeleteArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuzzPost.
     * @param {BuzzPostUpdateArgs} args - Arguments to update one BuzzPost.
     * @example
     * // Update one BuzzPost
     * const buzzPost = await prisma.buzzPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzPostUpdateArgs>(args: SelectSubset<T, BuzzPostUpdateArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuzzPosts.
     * @param {BuzzPostDeleteManyArgs} args - Arguments to filter BuzzPosts to delete.
     * @example
     * // Delete a few BuzzPosts
     * const { count } = await prisma.buzzPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzPostDeleteManyArgs>(args?: SelectSubset<T, BuzzPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzPosts
     * const buzzPost = await prisma.buzzPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzPostUpdateManyArgs>(args: SelectSubset<T, BuzzPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuzzPost.
     * @param {BuzzPostUpsertArgs} args - Arguments to update or create a BuzzPost.
     * @example
     * // Update or create a BuzzPost
     * const buzzPost = await prisma.buzzPost.upsert({
     *   create: {
     *     // ... data to create a BuzzPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzPost we want to update
     *   }
     * })
     */
    upsert<T extends BuzzPostUpsertArgs>(args: SelectSubset<T, BuzzPostUpsertArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuzzPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostCountArgs} args - Arguments to filter BuzzPosts to count.
     * @example
     * // Count the number of BuzzPosts
     * const count = await prisma.buzzPost.count({
     *   where: {
     *     // ... the filter for the BuzzPosts we want to count
     *   }
     * })
    **/
    count<T extends BuzzPostCountArgs>(
      args?: Subset<T, BuzzPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzPostAggregateArgs>(args: Subset<T, BuzzPostAggregateArgs>): Prisma.PrismaPromise<GetBuzzPostAggregateType<T>>

    /**
     * Group by BuzzPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzPostGroupByArgs['orderBy'] }
        : { orderBy?: BuzzPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzPost model
   */
  readonly fields: BuzzPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scheduledPosts<T extends BuzzPost$scheduledPostsArgs<ExtArgs> = {}>(args?: Subset<T, BuzzPost$scheduledPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzPost model
   */ 
  interface BuzzPostFieldRefs {
    readonly id: FieldRef<"BuzzPost", 'String'>
    readonly postId: FieldRef<"BuzzPost", 'String'>
    readonly content: FieldRef<"BuzzPost", 'String'>
    readonly authorUsername: FieldRef<"BuzzPost", 'String'>
    readonly authorId: FieldRef<"BuzzPost", 'String'>
    readonly likesCount: FieldRef<"BuzzPost", 'Int'>
    readonly retweetsCount: FieldRef<"BuzzPost", 'Int'>
    readonly repliesCount: FieldRef<"BuzzPost", 'Int'>
    readonly impressionsCount: FieldRef<"BuzzPost", 'Int'>
    readonly postedAt: FieldRef<"BuzzPost", 'DateTime'>
    readonly collectedAt: FieldRef<"BuzzPost", 'DateTime'>
    readonly url: FieldRef<"BuzzPost", 'String'>
    readonly theme: FieldRef<"BuzzPost", 'String'>
    readonly language: FieldRef<"BuzzPost", 'String'>
    readonly mediaUrls: FieldRef<"BuzzPost", 'Json'>
    readonly hashtags: FieldRef<"BuzzPost", 'Json'>
    readonly chromaId: FieldRef<"BuzzPost", 'String'>
    readonly authorFollowers: FieldRef<"BuzzPost", 'Int'>
    readonly authorFollowing: FieldRef<"BuzzPost", 'Int'>
    readonly authorVerified: FieldRef<"BuzzPost", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BuzzPost findUnique
   */
  export type BuzzPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost findUniqueOrThrow
   */
  export type BuzzPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost findFirst
   */
  export type BuzzPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzPosts.
     */
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost findFirstOrThrow
   */
  export type BuzzPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzPosts.
     */
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost findMany
   */
  export type BuzzPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPosts to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost create
   */
  export type BuzzPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BuzzPost.
     */
    data: XOR<BuzzPostCreateInput, BuzzPostUncheckedCreateInput>
  }

  /**
   * BuzzPost createMany
   */
  export type BuzzPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzPosts.
     */
    data: BuzzPostCreateManyInput | BuzzPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzPost createManyAndReturn
   */
  export type BuzzPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuzzPosts.
     */
    data: BuzzPostCreateManyInput | BuzzPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzPost update
   */
  export type BuzzPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BuzzPost.
     */
    data: XOR<BuzzPostUpdateInput, BuzzPostUncheckedUpdateInput>
    /**
     * Choose, which BuzzPost to update.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost updateMany
   */
  export type BuzzPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzPosts.
     */
    data: XOR<BuzzPostUpdateManyMutationInput, BuzzPostUncheckedUpdateManyInput>
    /**
     * Filter which BuzzPosts to update
     */
    where?: BuzzPostWhereInput
  }

  /**
   * BuzzPost upsert
   */
  export type BuzzPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BuzzPost to update in case it exists.
     */
    where: BuzzPostWhereUniqueInput
    /**
     * In case the BuzzPost found by the `where` argument doesn't exist, create a new BuzzPost with this data.
     */
    create: XOR<BuzzPostCreateInput, BuzzPostUncheckedCreateInput>
    /**
     * In case the BuzzPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzPostUpdateInput, BuzzPostUncheckedUpdateInput>
  }

  /**
   * BuzzPost delete
   */
  export type BuzzPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter which BuzzPost to delete.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost deleteMany
   */
  export type BuzzPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzPosts to delete
     */
    where?: BuzzPostWhereInput
  }

  /**
   * BuzzPost.scheduledPosts
   */
  export type BuzzPost$scheduledPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    cursor?: ScheduledPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * BuzzPost without action
   */
  export type BuzzPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
  }


  /**
   * Model BuzzConfig
   */

  export type AggregateBuzzConfig = {
    _count: BuzzConfigCountAggregateOutputType | null
    _avg: BuzzConfigAvgAggregateOutputType | null
    _sum: BuzzConfigSumAggregateOutputType | null
    _min: BuzzConfigMinAggregateOutputType | null
    _max: BuzzConfigMaxAggregateOutputType | null
  }

  export type BuzzConfigAvgAggregateOutputType = {
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
  }

  export type BuzzConfigSumAggregateOutputType = {
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
  }

  export type BuzzConfigMinAggregateOutputType = {
    id: string | null
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuzzConfigMaxAggregateOutputType = {
    id: string | null
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuzzConfigCountAggregateOutputType = {
    id: number
    keywords: number
    accounts: number
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuzzConfigAvgAggregateInputType = {
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
  }

  export type BuzzConfigSumAggregateInputType = {
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
  }

  export type BuzzConfigMinAggregateInputType = {
    id?: true
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuzzConfigMaxAggregateInputType = {
    id?: true
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuzzConfigCountAggregateInputType = {
    id?: true
    keywords?: true
    accounts?: true
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuzzConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzConfig to aggregate.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzConfigs
    **/
    _count?: true | BuzzConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzConfigMaxAggregateInputType
  }

  export type GetBuzzConfigAggregateType<T extends BuzzConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzConfig[P]>
      : GetScalarType<T[P], AggregateBuzzConfig[P]>
  }




  export type BuzzConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzConfigWhereInput
    orderBy?: BuzzConfigOrderByWithAggregationInput | BuzzConfigOrderByWithAggregationInput[]
    by: BuzzConfigScalarFieldEnum[] | BuzzConfigScalarFieldEnum
    having?: BuzzConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzConfigCountAggregateInputType | true
    _avg?: BuzzConfigAvgAggregateInputType
    _sum?: BuzzConfigSumAggregateInputType
    _min?: BuzzConfigMinAggregateInputType
    _max?: BuzzConfigMaxAggregateInputType
  }

  export type BuzzConfigGroupByOutputType = {
    id: string
    keywords: string[]
    accounts: string[]
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: BuzzConfigCountAggregateOutputType | null
    _avg: BuzzConfigAvgAggregateOutputType | null
    _sum: BuzzConfigSumAggregateOutputType | null
    _min: BuzzConfigMinAggregateOutputType | null
    _max: BuzzConfigMaxAggregateOutputType | null
  }

  type GetBuzzConfigGroupByPayload<T extends BuzzConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzConfigGroupByOutputType[P]>
        }
      >
    >


  export type BuzzConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzConfig"]>

  export type BuzzConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzConfig"]>

  export type BuzzConfigSelectScalar = {
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BuzzConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keywords: string[]
      accounts: string[]
      minEngagement: number
      minImpressions: number
      collectInterval: number
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buzzConfig"]>
    composites: {}
  }

  type BuzzConfigGetPayload<S extends boolean | null | undefined | BuzzConfigDefaultArgs> = $Result.GetResult<Prisma.$BuzzConfigPayload, S>

  type BuzzConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuzzConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuzzConfigCountAggregateInputType | true
    }

  export interface BuzzConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzConfig'], meta: { name: 'BuzzConfig' } }
    /**
     * Find zero or one BuzzConfig that matches the filter.
     * @param {BuzzConfigFindUniqueArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzConfigFindUniqueArgs>(args: SelectSubset<T, BuzzConfigFindUniqueArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuzzConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuzzConfigFindUniqueOrThrowArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuzzConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigFindFirstArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzConfigFindFirstArgs>(args?: SelectSubset<T, BuzzConfigFindFirstArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuzzConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigFindFirstOrThrowArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuzzConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzConfigs
     * const buzzConfigs = await prisma.buzzConfig.findMany()
     * 
     * // Get first 10 BuzzConfigs
     * const buzzConfigs = await prisma.buzzConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzConfigWithIdOnly = await prisma.buzzConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzConfigFindManyArgs>(args?: SelectSubset<T, BuzzConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuzzConfig.
     * @param {BuzzConfigCreateArgs} args - Arguments to create a BuzzConfig.
     * @example
     * // Create one BuzzConfig
     * const BuzzConfig = await prisma.buzzConfig.create({
     *   data: {
     *     // ... data to create a BuzzConfig
     *   }
     * })
     * 
     */
    create<T extends BuzzConfigCreateArgs>(args: SelectSubset<T, BuzzConfigCreateArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuzzConfigs.
     * @param {BuzzConfigCreateManyArgs} args - Arguments to create many BuzzConfigs.
     * @example
     * // Create many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzConfigCreateManyArgs>(args?: SelectSubset<T, BuzzConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuzzConfigs and returns the data saved in the database.
     * @param {BuzzConfigCreateManyAndReturnArgs} args - Arguments to create many BuzzConfigs.
     * @example
     * // Create many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuzzConfigs and only return the `id`
     * const buzzConfigWithIdOnly = await prisma.buzzConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuzzConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BuzzConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuzzConfig.
     * @param {BuzzConfigDeleteArgs} args - Arguments to delete one BuzzConfig.
     * @example
     * // Delete one BuzzConfig
     * const BuzzConfig = await prisma.buzzConfig.delete({
     *   where: {
     *     // ... filter to delete one BuzzConfig
     *   }
     * })
     * 
     */
    delete<T extends BuzzConfigDeleteArgs>(args: SelectSubset<T, BuzzConfigDeleteArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuzzConfig.
     * @param {BuzzConfigUpdateArgs} args - Arguments to update one BuzzConfig.
     * @example
     * // Update one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzConfigUpdateArgs>(args: SelectSubset<T, BuzzConfigUpdateArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuzzConfigs.
     * @param {BuzzConfigDeleteManyArgs} args - Arguments to filter BuzzConfigs to delete.
     * @example
     * // Delete a few BuzzConfigs
     * const { count } = await prisma.buzzConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzConfigDeleteManyArgs>(args?: SelectSubset<T, BuzzConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzConfigUpdateManyArgs>(args: SelectSubset<T, BuzzConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuzzConfig.
     * @param {BuzzConfigUpsertArgs} args - Arguments to update or create a BuzzConfig.
     * @example
     * // Update or create a BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.upsert({
     *   create: {
     *     // ... data to create a BuzzConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzConfig we want to update
     *   }
     * })
     */
    upsert<T extends BuzzConfigUpsertArgs>(args: SelectSubset<T, BuzzConfigUpsertArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuzzConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigCountArgs} args - Arguments to filter BuzzConfigs to count.
     * @example
     * // Count the number of BuzzConfigs
     * const count = await prisma.buzzConfig.count({
     *   where: {
     *     // ... the filter for the BuzzConfigs we want to count
     *   }
     * })
    **/
    count<T extends BuzzConfigCountArgs>(
      args?: Subset<T, BuzzConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzConfigAggregateArgs>(args: Subset<T, BuzzConfigAggregateArgs>): Prisma.PrismaPromise<GetBuzzConfigAggregateType<T>>

    /**
     * Group by BuzzConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzConfigGroupByArgs['orderBy'] }
        : { orderBy?: BuzzConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzConfig model
   */
  readonly fields: BuzzConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzConfig model
   */ 
  interface BuzzConfigFieldRefs {
    readonly id: FieldRef<"BuzzConfig", 'String'>
    readonly keywords: FieldRef<"BuzzConfig", 'String[]'>
    readonly accounts: FieldRef<"BuzzConfig", 'String[]'>
    readonly minEngagement: FieldRef<"BuzzConfig", 'Int'>
    readonly minImpressions: FieldRef<"BuzzConfig", 'Int'>
    readonly collectInterval: FieldRef<"BuzzConfig", 'Int'>
    readonly enabled: FieldRef<"BuzzConfig", 'Boolean'>
    readonly createdAt: FieldRef<"BuzzConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BuzzConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuzzConfig findUnique
   */
  export type BuzzConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig findUniqueOrThrow
   */
  export type BuzzConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig findFirst
   */
  export type BuzzConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzConfigs.
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzConfigs.
     */
    distinct?: BuzzConfigScalarFieldEnum | BuzzConfigScalarFieldEnum[]
  }

  /**
   * BuzzConfig findFirstOrThrow
   */
  export type BuzzConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzConfigs.
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzConfigs.
     */
    distinct?: BuzzConfigScalarFieldEnum | BuzzConfigScalarFieldEnum[]
  }

  /**
   * BuzzConfig findMany
   */
  export type BuzzConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Filter, which BuzzConfigs to fetch.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzConfigs.
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    distinct?: BuzzConfigScalarFieldEnum | BuzzConfigScalarFieldEnum[]
  }

  /**
   * BuzzConfig create
   */
  export type BuzzConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a BuzzConfig.
     */
    data: XOR<BuzzConfigCreateInput, BuzzConfigUncheckedCreateInput>
  }

  /**
   * BuzzConfig createMany
   */
  export type BuzzConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzConfigs.
     */
    data: BuzzConfigCreateManyInput | BuzzConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzConfig createManyAndReturn
   */
  export type BuzzConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuzzConfigs.
     */
    data: BuzzConfigCreateManyInput | BuzzConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzConfig update
   */
  export type BuzzConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a BuzzConfig.
     */
    data: XOR<BuzzConfigUpdateInput, BuzzConfigUncheckedUpdateInput>
    /**
     * Choose, which BuzzConfig to update.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig updateMany
   */
  export type BuzzConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzConfigs.
     */
    data: XOR<BuzzConfigUpdateManyMutationInput, BuzzConfigUncheckedUpdateManyInput>
    /**
     * Filter which BuzzConfigs to update
     */
    where?: BuzzConfigWhereInput
  }

  /**
   * BuzzConfig upsert
   */
  export type BuzzConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the BuzzConfig to update in case it exists.
     */
    where: BuzzConfigWhereUniqueInput
    /**
     * In case the BuzzConfig found by the `where` argument doesn't exist, create a new BuzzConfig with this data.
     */
    create: XOR<BuzzConfigCreateInput, BuzzConfigUncheckedCreateInput>
    /**
     * In case the BuzzConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzConfigUpdateInput, BuzzConfigUncheckedUpdateInput>
  }

  /**
   * BuzzConfig delete
   */
  export type BuzzConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Filter which BuzzConfig to delete.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig deleteMany
   */
  export type BuzzConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzConfigs to delete
     */
    where?: BuzzConfigWhereInput
  }

  /**
   * BuzzConfig without action
   */
  export type BuzzConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
  }


  /**
   * Model ScheduledPost
   */

  export type AggregateScheduledPost = {
    _count: ScheduledPostCountAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  export type ScheduledPostMinAggregateOutputType = {
    id: string | null
    content: string | null
    scheduledTime: Date | null
    status: $Enums.PostStatus | null
    postType: $Enums.PostType | null
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean | null
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    scheduledTime: Date | null
    status: $Enums.PostStatus | null
    postType: $Enums.PostType | null
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean | null
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPostCountAggregateOutputType = {
    id: number
    content: number
    scheduledTime: number
    status: number
    postType: number
    refPostId: number
    templateType: number
    aiGenerated: number
    aiPrompt: number
    editedContent: number
    postedAt: number
    postResult: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledPostMinAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPostMaxAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPostCountAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    postResult?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPost to aggregate.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledPosts
    **/
    _count?: true | ScheduledPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type GetScheduledPostAggregateType<T extends ScheduledPostAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledPost[P]>
      : GetScalarType<T[P], AggregateScheduledPost[P]>
  }




  export type ScheduledPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithAggregationInput | ScheduledPostOrderByWithAggregationInput[]
    by: ScheduledPostScalarFieldEnum[] | ScheduledPostScalarFieldEnum
    having?: ScheduledPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledPostCountAggregateInputType | true
    _min?: ScheduledPostMinAggregateInputType
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type ScheduledPostGroupByOutputType = {
    id: string
    content: string
    scheduledTime: Date
    status: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    postResult: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledPostCountAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  type GetScheduledPostGroupByPayload<T extends ScheduledPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectScalar = {
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }
  export type ScheduledPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }

  export type $ScheduledPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledPost"
    objects: {
      refPost: Prisma.$BuzzPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      scheduledTime: Date
      status: $Enums.PostStatus
      postType: $Enums.PostType
      refPostId: string | null
      templateType: string | null
      aiGenerated: boolean
      aiPrompt: string | null
      editedContent: string | null
      postedAt: Date | null
      postResult: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledPost"]>
    composites: {}
  }

  type ScheduledPostGetPayload<S extends boolean | null | undefined | ScheduledPostDefaultArgs> = $Result.GetResult<Prisma.$ScheduledPostPayload, S>

  type ScheduledPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledPostCountAggregateInputType | true
    }

  export interface ScheduledPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledPost'], meta: { name: 'ScheduledPost' } }
    /**
     * Find zero or one ScheduledPost that matches the filter.
     * @param {ScheduledPostFindUniqueArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledPostFindUniqueArgs>(args: SelectSubset<T, ScheduledPostFindUniqueArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledPostFindUniqueOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledPostFindFirstArgs>(args?: SelectSubset<T, ScheduledPostFindFirstArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany()
     * 
     * // Get first 10 ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledPostFindManyArgs>(args?: SelectSubset<T, ScheduledPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledPost.
     * @param {ScheduledPostCreateArgs} args - Arguments to create a ScheduledPost.
     * @example
     * // Create one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.create({
     *   data: {
     *     // ... data to create a ScheduledPost
     *   }
     * })
     * 
     */
    create<T extends ScheduledPostCreateArgs>(args: SelectSubset<T, ScheduledPostCreateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledPosts.
     * @param {ScheduledPostCreateManyArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledPostCreateManyArgs>(args?: SelectSubset<T, ScheduledPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledPosts and returns the data saved in the database.
     * @param {ScheduledPostCreateManyAndReturnArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledPosts and only return the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledPost.
     * @param {ScheduledPostDeleteArgs} args - Arguments to delete one ScheduledPost.
     * @example
     * // Delete one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.delete({
     *   where: {
     *     // ... filter to delete one ScheduledPost
     *   }
     * })
     * 
     */
    delete<T extends ScheduledPostDeleteArgs>(args: SelectSubset<T, ScheduledPostDeleteArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledPost.
     * @param {ScheduledPostUpdateArgs} args - Arguments to update one ScheduledPost.
     * @example
     * // Update one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledPostUpdateArgs>(args: SelectSubset<T, ScheduledPostUpdateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledPosts.
     * @param {ScheduledPostDeleteManyArgs} args - Arguments to filter ScheduledPosts to delete.
     * @example
     * // Delete a few ScheduledPosts
     * const { count } = await prisma.scheduledPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledPostDeleteManyArgs>(args?: SelectSubset<T, ScheduledPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledPostUpdateManyArgs>(args: SelectSubset<T, ScheduledPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledPost.
     * @param {ScheduledPostUpsertArgs} args - Arguments to update or create a ScheduledPost.
     * @example
     * // Update or create a ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.upsert({
     *   create: {
     *     // ... data to create a ScheduledPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledPost we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledPostUpsertArgs>(args: SelectSubset<T, ScheduledPostUpsertArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostCountArgs} args - Arguments to filter ScheduledPosts to count.
     * @example
     * // Count the number of ScheduledPosts
     * const count = await prisma.scheduledPost.count({
     *   where: {
     *     // ... the filter for the ScheduledPosts we want to count
     *   }
     * })
    **/
    count<T extends ScheduledPostCountArgs>(
      args?: Subset<T, ScheduledPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledPostAggregateArgs>(args: Subset<T, ScheduledPostAggregateArgs>): Prisma.PrismaPromise<GetScheduledPostAggregateType<T>>

    /**
     * Group by ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledPostGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledPost model
   */
  readonly fields: ScheduledPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refPost<T extends ScheduledPost$refPostArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledPost$refPostArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledPost model
   */ 
  interface ScheduledPostFieldRefs {
    readonly id: FieldRef<"ScheduledPost", 'String'>
    readonly content: FieldRef<"ScheduledPost", 'String'>
    readonly scheduledTime: FieldRef<"ScheduledPost", 'DateTime'>
    readonly status: FieldRef<"ScheduledPost", 'PostStatus'>
    readonly postType: FieldRef<"ScheduledPost", 'PostType'>
    readonly refPostId: FieldRef<"ScheduledPost", 'String'>
    readonly templateType: FieldRef<"ScheduledPost", 'String'>
    readonly aiGenerated: FieldRef<"ScheduledPost", 'Boolean'>
    readonly aiPrompt: FieldRef<"ScheduledPost", 'String'>
    readonly editedContent: FieldRef<"ScheduledPost", 'String'>
    readonly postedAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly postResult: FieldRef<"ScheduledPost", 'Json'>
    readonly createdAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledPost findUnique
   */
  export type ScheduledPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findUniqueOrThrow
   */
  export type ScheduledPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findFirst
   */
  export type ScheduledPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findFirstOrThrow
   */
  export type ScheduledPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findMany
   */
  export type ScheduledPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPosts to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost create
   */
  export type ScheduledPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledPost.
     */
    data: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
  }

  /**
   * ScheduledPost createMany
   */
  export type ScheduledPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledPost createManyAndReturn
   */
  export type ScheduledPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledPost update
   */
  export type ScheduledPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledPost.
     */
    data: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
    /**
     * Choose, which ScheduledPost to update.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost updateMany
   */
  export type ScheduledPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledPosts.
     */
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPosts to update
     */
    where?: ScheduledPostWhereInput
  }

  /**
   * ScheduledPost upsert
   */
  export type ScheduledPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledPost to update in case it exists.
     */
    where: ScheduledPostWhereUniqueInput
    /**
     * In case the ScheduledPost found by the `where` argument doesn't exist, create a new ScheduledPost with this data.
     */
    create: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
    /**
     * In case the ScheduledPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
  }

  /**
   * ScheduledPost delete
   */
  export type ScheduledPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter which ScheduledPost to delete.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost deleteMany
   */
  export type ScheduledPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPosts to delete
     */
    where?: ScheduledPostWhereInput
  }

  /**
   * ScheduledPost.refPost
   */
  export type ScheduledPost$refPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    where?: BuzzPostWhereInput
  }

  /**
   * ScheduledPost without action
   */
  export type ScheduledPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
  }


  /**
   * Model PostAnalytics
   */

  export type AggregatePostAnalytics = {
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  export type PostAnalyticsAvgAggregateOutputType = {
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
  }

  export type PostAnalyticsSumAggregateOutputType = {
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
  }

  export type PostAnalyticsMinAggregateOutputType = {
    id: string | null
    postId: string | null
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
    collectedAt: Date | null
  }

  export type PostAnalyticsMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
    collectedAt: Date | null
  }

  export type PostAnalyticsCountAggregateOutputType = {
    id: number
    postId: number
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt: number
    _all: number
  }


  export type PostAnalyticsAvgAggregateInputType = {
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
  }

  export type PostAnalyticsSumAggregateInputType = {
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
  }

  export type PostAnalyticsMinAggregateInputType = {
    id?: true
    postId?: true
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
    collectedAt?: true
  }

  export type PostAnalyticsMaxAggregateInputType = {
    id?: true
    postId?: true
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
    collectedAt?: true
  }

  export type PostAnalyticsCountAggregateInputType = {
    id?: true
    postId?: true
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
    collectedAt?: true
    _all?: true
  }

  export type PostAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to aggregate.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAnalytics
    **/
    _count?: true | PostAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type GetPostAnalyticsAggregateType<T extends PostAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAnalytics[P]>
      : GetScalarType<T[P], AggregatePostAnalytics[P]>
  }




  export type PostAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAnalyticsWhereInput
    orderBy?: PostAnalyticsOrderByWithAggregationInput | PostAnalyticsOrderByWithAggregationInput[]
    by: PostAnalyticsScalarFieldEnum[] | PostAnalyticsScalarFieldEnum
    having?: PostAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAnalyticsCountAggregateInputType | true
    _avg?: PostAnalyticsAvgAggregateInputType
    _sum?: PostAnalyticsSumAggregateInputType
    _min?: PostAnalyticsMinAggregateInputType
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type PostAnalyticsGroupByOutputType = {
    id: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt: Date
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  type GetPostAnalyticsGroupByPayload<T extends PostAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PostAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    impressions?: boolean
    engagements?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    urlClicks?: boolean
    detailExpands?: boolean
    engagementRate?: boolean
    collectedAt?: boolean
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    impressions?: boolean
    engagements?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    urlClicks?: boolean
    detailExpands?: boolean
    engagementRate?: boolean
    collectedAt?: boolean
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectScalar = {
    id?: boolean
    postId?: boolean
    impressions?: boolean
    engagements?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    urlClicks?: boolean
    detailExpands?: boolean
    engagementRate?: boolean
    collectedAt?: boolean
  }


  export type $PostAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      impressions: number
      engagements: number
      likes: number
      retweets: number
      replies: number
      profileClicks: number
      urlClicks: number
      detailExpands: number
      engagementRate: number
      collectedAt: Date
    }, ExtArgs["result"]["postAnalytics"]>
    composites: {}
  }

  type PostAnalyticsGetPayload<S extends boolean | null | undefined | PostAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PostAnalyticsPayload, S>

  type PostAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostAnalyticsCountAggregateInputType | true
    }

  export interface PostAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAnalytics'], meta: { name: 'PostAnalytics' } }
    /**
     * Find zero or one PostAnalytics that matches the filter.
     * @param {PostAnalyticsFindUniqueArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostAnalyticsFindUniqueArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostAnalyticsFindFirstArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany()
     * 
     * // Get first 10 PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostAnalyticsFindManyArgs>(args?: SelectSubset<T, PostAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostAnalytics.
     * @param {PostAnalyticsCreateArgs} args - Arguments to create a PostAnalytics.
     * @example
     * // Create one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.create({
     *   data: {
     *     // ... data to create a PostAnalytics
     *   }
     * })
     * 
     */
    create<T extends PostAnalyticsCreateArgs>(args: SelectSubset<T, PostAnalyticsCreateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostAnalytics.
     * @param {PostAnalyticsCreateManyArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostAnalyticsCreateManyArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostAnalytics and returns the data saved in the database.
     * @param {PostAnalyticsCreateManyAndReturnArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostAnalytics and only return the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostAnalytics.
     * @param {PostAnalyticsDeleteArgs} args - Arguments to delete one PostAnalytics.
     * @example
     * // Delete one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PostAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PostAnalyticsDeleteArgs>(args: SelectSubset<T, PostAnalyticsDeleteArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostAnalytics.
     * @param {PostAnalyticsUpdateArgs} args - Arguments to update one PostAnalytics.
     * @example
     * // Update one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostAnalyticsUpdateArgs>(args: SelectSubset<T, PostAnalyticsUpdateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostAnalytics.
     * @param {PostAnalyticsDeleteManyArgs} args - Arguments to filter PostAnalytics to delete.
     * @example
     * // Delete a few PostAnalytics
     * const { count } = await prisma.postAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PostAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostAnalyticsUpdateManyArgs>(args: SelectSubset<T, PostAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostAnalytics.
     * @param {PostAnalyticsUpsertArgs} args - Arguments to update or create a PostAnalytics.
     * @example
     * // Update or create a PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.upsert({
     *   create: {
     *     // ... data to create a PostAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PostAnalyticsUpsertArgs>(args: SelectSubset<T, PostAnalyticsUpsertArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsCountArgs} args - Arguments to filter PostAnalytics to count.
     * @example
     * // Count the number of PostAnalytics
     * const count = await prisma.postAnalytics.count({
     *   where: {
     *     // ... the filter for the PostAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PostAnalyticsCountArgs>(
      args?: Subset<T, PostAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAnalyticsAggregateArgs>(args: Subset<T, PostAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPostAnalyticsAggregateType<T>>

    /**
     * Group by PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PostAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAnalytics model
   */
  readonly fields: PostAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAnalytics model
   */ 
  interface PostAnalyticsFieldRefs {
    readonly id: FieldRef<"PostAnalytics", 'String'>
    readonly postId: FieldRef<"PostAnalytics", 'String'>
    readonly impressions: FieldRef<"PostAnalytics", 'Int'>
    readonly engagements: FieldRef<"PostAnalytics", 'Int'>
    readonly likes: FieldRef<"PostAnalytics", 'Int'>
    readonly retweets: FieldRef<"PostAnalytics", 'Int'>
    readonly replies: FieldRef<"PostAnalytics", 'Int'>
    readonly profileClicks: FieldRef<"PostAnalytics", 'Int'>
    readonly urlClicks: FieldRef<"PostAnalytics", 'Int'>
    readonly detailExpands: FieldRef<"PostAnalytics", 'Int'>
    readonly engagementRate: FieldRef<"PostAnalytics", 'Float'>
    readonly collectedAt: FieldRef<"PostAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostAnalytics findUnique
   */
  export type PostAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findUniqueOrThrow
   */
  export type PostAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findFirst
   */
  export type PostAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findFirstOrThrow
   */
  export type PostAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findMany
   */
  export type PostAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics create
   */
  export type PostAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a PostAnalytics.
     */
    data: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
  }

  /**
   * PostAnalytics createMany
   */
  export type PostAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAnalytics createManyAndReturn
   */
  export type PostAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAnalytics update
   */
  export type PostAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PostAnalytics to update.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics updateMany
   */
  export type PostAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PostAnalytics to update
     */
    where?: PostAnalyticsWhereInput
  }

  /**
   * PostAnalytics upsert
   */
  export type PostAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the PostAnalytics to update in case it exists.
     */
    where: PostAnalyticsWhereUniqueInput
    /**
     * In case the PostAnalytics found by the `where` argument doesn't exist, create a new PostAnalytics with this data.
     */
    create: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
    /**
     * In case the PostAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
  }

  /**
   * PostAnalytics delete
   */
  export type PostAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which PostAnalytics to delete.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics deleteMany
   */
  export type PostAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to delete
     */
    where?: PostAnalyticsWhereInput
  }

  /**
   * PostAnalytics without action
   */
  export type PostAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    name: string | null
    email: string | null
    image: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    name: string | null
    email: string | null
    image: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    twitterId: number
    username: number
    name: number
    email: number
    image: number
    accessToken: number
    refreshToken: number
    tokenSecret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    twitterId: string
    username: string
    name: string | null
    email: string | null
    image: string | null
    accessToken: string
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    watchlistUsers?: boolean | User$watchlistUsersArgs<ExtArgs>
    characterProfiles?: boolean | User$characterProfilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    watchlistUsers?: boolean | User$watchlistUsersArgs<ExtArgs>
    characterProfiles?: boolean | User$characterProfilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      watchlistUsers: Prisma.$WatchlistUserPayload<ExtArgs>[]
      characterProfiles: Prisma.$CharacterProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      twitterId: string
      username: string
      name: string | null
      email: string | null
      image: string | null
      accessToken: string
      refreshToken: string | null
      tokenSecret: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    watchlistUsers<T extends User$watchlistUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$watchlistUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findMany"> | Null>
    characterProfiles<T extends User$characterProfilesArgs<ExtArgs> = {}>(args?: Subset<T, User$characterProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly twitterId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly tokenSecret: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.watchlistUsers
   */
  export type User$watchlistUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    where?: WatchlistUserWhereInput
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    cursor?: WatchlistUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * User.characterProfiles
   */
  export type User$characterProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    where?: CharacterProfileWhereInput
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    cursor?: CharacterProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model NewsSource
   */

  export type AggregateNewsSource = {
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  export type NewsSourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    rssUrl: string | null
    category: string | null
    language: string | null
    isActive: boolean | null
    lastFetched: Date | null
    createdAt: Date | null
  }

  export type NewsSourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    rssUrl: string | null
    category: string | null
    language: string | null
    isActive: boolean | null
    lastFetched: Date | null
    createdAt: Date | null
  }

  export type NewsSourceCountAggregateOutputType = {
    id: number
    name: number
    url: number
    rssUrl: number
    category: number
    language: number
    isActive: number
    lastFetched: number
    createdAt: number
    _all: number
  }


  export type NewsSourceMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    rssUrl?: true
    category?: true
    language?: true
    isActive?: true
    lastFetched?: true
    createdAt?: true
  }

  export type NewsSourceMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    rssUrl?: true
    category?: true
    language?: true
    isActive?: true
    lastFetched?: true
    createdAt?: true
  }

  export type NewsSourceCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    rssUrl?: true
    category?: true
    language?: true
    isActive?: true
    lastFetched?: true
    createdAt?: true
    _all?: true
  }

  export type NewsSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSource to aggregate.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsSources
    **/
    _count?: true | NewsSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsSourceMaxAggregateInputType
  }

  export type GetNewsSourceAggregateType<T extends NewsSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsSource[P]>
      : GetScalarType<T[P], AggregateNewsSource[P]>
  }




  export type NewsSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsSourceWhereInput
    orderBy?: NewsSourceOrderByWithAggregationInput | NewsSourceOrderByWithAggregationInput[]
    by: NewsSourceScalarFieldEnum[] | NewsSourceScalarFieldEnum
    having?: NewsSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsSourceCountAggregateInputType | true
    _min?: NewsSourceMinAggregateInputType
    _max?: NewsSourceMaxAggregateInputType
  }

  export type NewsSourceGroupByOutputType = {
    id: string
    name: string
    url: string
    rssUrl: string
    category: string
    language: string
    isActive: boolean
    lastFetched: Date | null
    createdAt: Date
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  type GetNewsSourceGroupByPayload<T extends NewsSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
            : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
        }
      >
    >


  export type NewsSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    rssUrl?: boolean
    category?: boolean
    language?: boolean
    isActive?: boolean
    lastFetched?: boolean
    createdAt?: boolean
    articles?: boolean | NewsSource$articlesArgs<ExtArgs>
    _count?: boolean | NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    rssUrl?: boolean
    category?: boolean
    language?: boolean
    isActive?: boolean
    lastFetched?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    rssUrl?: boolean
    category?: boolean
    language?: boolean
    isActive?: boolean
    lastFetched?: boolean
    createdAt?: boolean
  }

  export type NewsSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | NewsSource$articlesArgs<ExtArgs>
    _count?: boolean | NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsSource"
    objects: {
      articles: Prisma.$NewsArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      rssUrl: string
      category: string
      language: string
      isActive: boolean
      lastFetched: Date | null
      createdAt: Date
    }, ExtArgs["result"]["newsSource"]>
    composites: {}
  }

  type NewsSourceGetPayload<S extends boolean | null | undefined | NewsSourceDefaultArgs> = $Result.GetResult<Prisma.$NewsSourcePayload, S>

  type NewsSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsSourceCountAggregateInputType | true
    }

  export interface NewsSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsSource'], meta: { name: 'NewsSource' } }
    /**
     * Find zero or one NewsSource that matches the filter.
     * @param {NewsSourceFindUniqueArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsSourceFindUniqueArgs>(args: SelectSubset<T, NewsSourceFindUniqueArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsSource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsSourceFindUniqueOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsSourceFindFirstArgs>(args?: SelectSubset<T, NewsSourceFindFirstArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsSources
     * const newsSources = await prisma.newsSource.findMany()
     * 
     * // Get first 10 NewsSources
     * const newsSources = await prisma.newsSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsSourceFindManyArgs>(args?: SelectSubset<T, NewsSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsSource.
     * @param {NewsSourceCreateArgs} args - Arguments to create a NewsSource.
     * @example
     * // Create one NewsSource
     * const NewsSource = await prisma.newsSource.create({
     *   data: {
     *     // ... data to create a NewsSource
     *   }
     * })
     * 
     */
    create<T extends NewsSourceCreateArgs>(args: SelectSubset<T, NewsSourceCreateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsSources.
     * @param {NewsSourceCreateManyArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsSourceCreateManyArgs>(args?: SelectSubset<T, NewsSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsSources and returns the data saved in the database.
     * @param {NewsSourceCreateManyAndReturnArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsSources and only return the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsSource.
     * @param {NewsSourceDeleteArgs} args - Arguments to delete one NewsSource.
     * @example
     * // Delete one NewsSource
     * const NewsSource = await prisma.newsSource.delete({
     *   where: {
     *     // ... filter to delete one NewsSource
     *   }
     * })
     * 
     */
    delete<T extends NewsSourceDeleteArgs>(args: SelectSubset<T, NewsSourceDeleteArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsSource.
     * @param {NewsSourceUpdateArgs} args - Arguments to update one NewsSource.
     * @example
     * // Update one NewsSource
     * const newsSource = await prisma.newsSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsSourceUpdateArgs>(args: SelectSubset<T, NewsSourceUpdateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsSources.
     * @param {NewsSourceDeleteManyArgs} args - Arguments to filter NewsSources to delete.
     * @example
     * // Delete a few NewsSources
     * const { count } = await prisma.newsSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsSourceDeleteManyArgs>(args?: SelectSubset<T, NewsSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsSources
     * const newsSource = await prisma.newsSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsSourceUpdateManyArgs>(args: SelectSubset<T, NewsSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsSource.
     * @param {NewsSourceUpsertArgs} args - Arguments to update or create a NewsSource.
     * @example
     * // Update or create a NewsSource
     * const newsSource = await prisma.newsSource.upsert({
     *   create: {
     *     // ... data to create a NewsSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsSource we want to update
     *   }
     * })
     */
    upsert<T extends NewsSourceUpsertArgs>(args: SelectSubset<T, NewsSourceUpsertArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceCountArgs} args - Arguments to filter NewsSources to count.
     * @example
     * // Count the number of NewsSources
     * const count = await prisma.newsSource.count({
     *   where: {
     *     // ... the filter for the NewsSources we want to count
     *   }
     * })
    **/
    count<T extends NewsSourceCountArgs>(
      args?: Subset<T, NewsSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsSourceAggregateArgs>(args: Subset<T, NewsSourceAggregateArgs>): Prisma.PrismaPromise<GetNewsSourceAggregateType<T>>

    /**
     * Group by NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsSourceGroupByArgs['orderBy'] }
        : { orderBy?: NewsSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsSource model
   */
  readonly fields: NewsSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends NewsSource$articlesArgs<ExtArgs> = {}>(args?: Subset<T, NewsSource$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsSource model
   */ 
  interface NewsSourceFieldRefs {
    readonly id: FieldRef<"NewsSource", 'String'>
    readonly name: FieldRef<"NewsSource", 'String'>
    readonly url: FieldRef<"NewsSource", 'String'>
    readonly rssUrl: FieldRef<"NewsSource", 'String'>
    readonly category: FieldRef<"NewsSource", 'String'>
    readonly language: FieldRef<"NewsSource", 'String'>
    readonly isActive: FieldRef<"NewsSource", 'Boolean'>
    readonly lastFetched: FieldRef<"NewsSource", 'DateTime'>
    readonly createdAt: FieldRef<"NewsSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsSource findUnique
   */
  export type NewsSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findUniqueOrThrow
   */
  export type NewsSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findFirst
   */
  export type NewsSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findFirstOrThrow
   */
  export type NewsSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findMany
   */
  export type NewsSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSources to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource create
   */
  export type NewsSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsSource.
     */
    data: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
  }

  /**
   * NewsSource createMany
   */
  export type NewsSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsSource createManyAndReturn
   */
  export type NewsSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsSource update
   */
  export type NewsSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsSource.
     */
    data: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
    /**
     * Choose, which NewsSource to update.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource updateMany
   */
  export type NewsSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsSources.
     */
    data: XOR<NewsSourceUpdateManyMutationInput, NewsSourceUncheckedUpdateManyInput>
    /**
     * Filter which NewsSources to update
     */
    where?: NewsSourceWhereInput
  }

  /**
   * NewsSource upsert
   */
  export type NewsSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsSource to update in case it exists.
     */
    where: NewsSourceWhereUniqueInput
    /**
     * In case the NewsSource found by the `where` argument doesn't exist, create a new NewsSource with this data.
     */
    create: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
    /**
     * In case the NewsSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
  }

  /**
   * NewsSource delete
   */
  export type NewsSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter which NewsSource to delete.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource deleteMany
   */
  export type NewsSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSources to delete
     */
    where?: NewsSourceWhereInput
  }

  /**
   * NewsSource.articles
   */
  export type NewsSource$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    cursor?: NewsArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsSource without action
   */
  export type NewsSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
  }


  /**
   * Model NewsArticle
   */

  export type AggregateNewsArticle = {
    _count: NewsArticleCountAggregateOutputType | null
    _avg: NewsArticleAvgAggregateOutputType | null
    _sum: NewsArticleSumAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  export type NewsArticleAvgAggregateOutputType = {
    importance: number | null
  }

  export type NewsArticleSumAggregateOutputType = {
    importance: number | null
  }

  export type NewsArticleMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    title: string | null
    description: string | null
    url: string | null
    publishedAt: Date | null
    category: string | null
    importance: number | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type NewsArticleMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    title: string | null
    description: string | null
    url: string | null
    publishedAt: Date | null
    category: string | null
    importance: number | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type NewsArticleCountAggregateOutputType = {
    id: number
    sourceId: number
    title: number
    description: number
    url: number
    publishedAt: number
    category: number
    tags: number
    importance: number
    processed: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type NewsArticleAvgAggregateInputType = {
    importance?: true
  }

  export type NewsArticleSumAggregateInputType = {
    importance?: true
  }

  export type NewsArticleMinAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    description?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
  }

  export type NewsArticleMaxAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    description?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
  }

  export type NewsArticleCountAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    description?: true
    url?: true
    publishedAt?: true
    category?: true
    tags?: true
    importance?: true
    processed?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type NewsArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticle to aggregate.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsArticles
    **/
    _count?: true | NewsArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsArticleMaxAggregateInputType
  }

  export type GetNewsArticleAggregateType<T extends NewsArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsArticle[P]>
      : GetScalarType<T[P], AggregateNewsArticle[P]>
  }




  export type NewsArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithAggregationInput | NewsArticleOrderByWithAggregationInput[]
    by: NewsArticleScalarFieldEnum[] | NewsArticleScalarFieldEnum
    having?: NewsArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsArticleCountAggregateInputType | true
    _avg?: NewsArticleAvgAggregateInputType
    _sum?: NewsArticleSumAggregateInputType
    _min?: NewsArticleMinAggregateInputType
    _max?: NewsArticleMaxAggregateInputType
  }

  export type NewsArticleGroupByOutputType = {
    id: string
    sourceId: string
    title: string
    description: string | null
    url: string
    publishedAt: Date
    category: string | null
    tags: string[]
    importance: number | null
    processed: boolean
    createdAt: Date
    metadata: JsonValue | null
    _count: NewsArticleCountAggregateOutputType | null
    _avg: NewsArticleAvgAggregateOutputType | null
    _sum: NewsArticleSumAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  type GetNewsArticleGroupByPayload<T extends NewsArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
            : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
        }
      >
    >


  export type NewsArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    tags?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    analysis?: boolean | NewsArticle$analysisArgs<ExtArgs>
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
    newsThreadItems?: boolean | NewsArticle$newsThreadItemsArgs<ExtArgs>
    viralRelations?: boolean | NewsArticle$viralRelationsArgs<ExtArgs>
    _count?: boolean | NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    tags?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectScalar = {
    id?: boolean
    sourceId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    tags?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type NewsArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysis?: boolean | NewsArticle$analysisArgs<ExtArgs>
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
    newsThreadItems?: boolean | NewsArticle$newsThreadItemsArgs<ExtArgs>
    viralRelations?: boolean | NewsArticle$viralRelationsArgs<ExtArgs>
    _count?: boolean | NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }

  export type $NewsArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsArticle"
    objects: {
      analysis: Prisma.$NewsAnalysisPayload<ExtArgs> | null
      source: Prisma.$NewsSourcePayload<ExtArgs>
      newsThreadItems: Prisma.$NewsThreadItemPayload<ExtArgs>[]
      viralRelations: Prisma.$NewsViralRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      title: string
      description: string | null
      url: string
      publishedAt: Date
      category: string | null
      tags: string[]
      importance: number | null
      processed: boolean
      createdAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["newsArticle"]>
    composites: {}
  }

  type NewsArticleGetPayload<S extends boolean | null | undefined | NewsArticleDefaultArgs> = $Result.GetResult<Prisma.$NewsArticlePayload, S>

  type NewsArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsArticleCountAggregateInputType | true
    }

  export interface NewsArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsArticle'], meta: { name: 'NewsArticle' } }
    /**
     * Find zero or one NewsArticle that matches the filter.
     * @param {NewsArticleFindUniqueArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsArticleFindUniqueArgs>(args: SelectSubset<T, NewsArticleFindUniqueArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsArticleFindUniqueOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsArticleFindFirstArgs>(args?: SelectSubset<T, NewsArticleFindFirstArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany()
     * 
     * // Get first 10 NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsArticleFindManyArgs>(args?: SelectSubset<T, NewsArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsArticle.
     * @param {NewsArticleCreateArgs} args - Arguments to create a NewsArticle.
     * @example
     * // Create one NewsArticle
     * const NewsArticle = await prisma.newsArticle.create({
     *   data: {
     *     // ... data to create a NewsArticle
     *   }
     * })
     * 
     */
    create<T extends NewsArticleCreateArgs>(args: SelectSubset<T, NewsArticleCreateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsArticles.
     * @param {NewsArticleCreateManyArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsArticleCreateManyArgs>(args?: SelectSubset<T, NewsArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsArticles and returns the data saved in the database.
     * @param {NewsArticleCreateManyAndReturnArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsArticles and only return the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsArticle.
     * @param {NewsArticleDeleteArgs} args - Arguments to delete one NewsArticle.
     * @example
     * // Delete one NewsArticle
     * const NewsArticle = await prisma.newsArticle.delete({
     *   where: {
     *     // ... filter to delete one NewsArticle
     *   }
     * })
     * 
     */
    delete<T extends NewsArticleDeleteArgs>(args: SelectSubset<T, NewsArticleDeleteArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsArticle.
     * @param {NewsArticleUpdateArgs} args - Arguments to update one NewsArticle.
     * @example
     * // Update one NewsArticle
     * const newsArticle = await prisma.newsArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsArticleUpdateArgs>(args: SelectSubset<T, NewsArticleUpdateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsArticles.
     * @param {NewsArticleDeleteManyArgs} args - Arguments to filter NewsArticles to delete.
     * @example
     * // Delete a few NewsArticles
     * const { count } = await prisma.newsArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsArticleDeleteManyArgs>(args?: SelectSubset<T, NewsArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsArticles
     * const newsArticle = await prisma.newsArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsArticleUpdateManyArgs>(args: SelectSubset<T, NewsArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsArticle.
     * @param {NewsArticleUpsertArgs} args - Arguments to update or create a NewsArticle.
     * @example
     * // Update or create a NewsArticle
     * const newsArticle = await prisma.newsArticle.upsert({
     *   create: {
     *     // ... data to create a NewsArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsArticle we want to update
     *   }
     * })
     */
    upsert<T extends NewsArticleUpsertArgs>(args: SelectSubset<T, NewsArticleUpsertArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleCountArgs} args - Arguments to filter NewsArticles to count.
     * @example
     * // Count the number of NewsArticles
     * const count = await prisma.newsArticle.count({
     *   where: {
     *     // ... the filter for the NewsArticles we want to count
     *   }
     * })
    **/
    count<T extends NewsArticleCountArgs>(
      args?: Subset<T, NewsArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsArticleAggregateArgs>(args: Subset<T, NewsArticleAggregateArgs>): Prisma.PrismaPromise<GetNewsArticleAggregateType<T>>

    /**
     * Group by NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsArticleGroupByArgs['orderBy'] }
        : { orderBy?: NewsArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsArticle model
   */
  readonly fields: NewsArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analysis<T extends NewsArticle$analysisArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$analysisArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    source<T extends NewsSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsSourceDefaultArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    newsThreadItems<T extends NewsArticle$newsThreadItemsArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$newsThreadItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany"> | Null>
    viralRelations<T extends NewsArticle$viralRelationsArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$viralRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsArticle model
   */ 
  interface NewsArticleFieldRefs {
    readonly id: FieldRef<"NewsArticle", 'String'>
    readonly sourceId: FieldRef<"NewsArticle", 'String'>
    readonly title: FieldRef<"NewsArticle", 'String'>
    readonly description: FieldRef<"NewsArticle", 'String'>
    readonly url: FieldRef<"NewsArticle", 'String'>
    readonly publishedAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly category: FieldRef<"NewsArticle", 'String'>
    readonly tags: FieldRef<"NewsArticle", 'String[]'>
    readonly importance: FieldRef<"NewsArticle", 'Float'>
    readonly processed: FieldRef<"NewsArticle", 'Boolean'>
    readonly createdAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly metadata: FieldRef<"NewsArticle", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NewsArticle findUnique
   */
  export type NewsArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findUniqueOrThrow
   */
  export type NewsArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findFirst
   */
  export type NewsArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findFirstOrThrow
   */
  export type NewsArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findMany
   */
  export type NewsArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticles to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle create
   */
  export type NewsArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsArticle.
     */
    data: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
  }

  /**
   * NewsArticle createMany
   */
  export type NewsArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsArticle createManyAndReturn
   */
  export type NewsArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsArticle update
   */
  export type NewsArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsArticle.
     */
    data: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
    /**
     * Choose, which NewsArticle to update.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle updateMany
   */
  export type NewsArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsArticles.
     */
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyInput>
    /**
     * Filter which NewsArticles to update
     */
    where?: NewsArticleWhereInput
  }

  /**
   * NewsArticle upsert
   */
  export type NewsArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsArticle to update in case it exists.
     */
    where: NewsArticleWhereUniqueInput
    /**
     * In case the NewsArticle found by the `where` argument doesn't exist, create a new NewsArticle with this data.
     */
    create: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
    /**
     * In case the NewsArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
  }

  /**
   * NewsArticle delete
   */
  export type NewsArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter which NewsArticle to delete.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle deleteMany
   */
  export type NewsArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticles to delete
     */
    where?: NewsArticleWhereInput
  }

  /**
   * NewsArticle.analysis
   */
  export type NewsArticle$analysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsArticle.newsThreadItems
   */
  export type NewsArticle$newsThreadItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    cursor?: NewsThreadItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsArticle.viralRelations
   */
  export type NewsArticle$viralRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    where?: NewsViralRelationWhereInput
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    cursor?: NewsViralRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsArticle without action
   */
  export type NewsArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
  }


  /**
   * Model NewsThread
   */

  export type AggregateNewsThread = {
    _count: NewsThreadCountAggregateOutputType | null
    _min: NewsThreadMinAggregateOutputType | null
    _max: NewsThreadMaxAggregateOutputType | null
  }

  export type NewsThreadMinAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    title: string | null
    postedAt: Date | null
  }

  export type NewsThreadMaxAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    title: string | null
    postedAt: Date | null
  }

  export type NewsThreadCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    metadata: number
    scheduledAt: number
    title: number
    postedAt: number
    _all: number
  }


  export type NewsThreadMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
  }

  export type NewsThreadMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
  }

  export type NewsThreadCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    metadata?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
    _all?: true
  }

  export type NewsThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThread to aggregate.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsThreads
    **/
    _count?: true | NewsThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsThreadMaxAggregateInputType
  }

  export type GetNewsThreadAggregateType<T extends NewsThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsThread[P]>
      : GetScalarType<T[P], AggregateNewsThread[P]>
  }




  export type NewsThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadWhereInput
    orderBy?: NewsThreadOrderByWithAggregationInput | NewsThreadOrderByWithAggregationInput[]
    by: NewsThreadScalarFieldEnum[] | NewsThreadScalarFieldEnum
    having?: NewsThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsThreadCountAggregateInputType | true
    _min?: NewsThreadMinAggregateInputType
    _max?: NewsThreadMaxAggregateInputType
  }

  export type NewsThreadGroupByOutputType = {
    id: string
    status: string
    createdAt: Date
    metadata: JsonValue | null
    scheduledAt: Date | null
    title: string
    postedAt: Date | null
    _count: NewsThreadCountAggregateOutputType | null
    _min: NewsThreadMinAggregateOutputType | null
    _max: NewsThreadMaxAggregateOutputType | null
  }

  type GetNewsThreadGroupByPayload<T extends NewsThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsThreadGroupByOutputType[P]>
            : GetScalarType<T[P], NewsThreadGroupByOutputType[P]>
        }
      >
    >


  export type NewsThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
    items?: boolean | NewsThread$itemsArgs<ExtArgs>
    _count?: boolean | NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }

  export type NewsThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NewsThread$itemsArgs<ExtArgs>
    _count?: boolean | NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsThread"
    objects: {
      items: Prisma.$NewsThreadItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      createdAt: Date
      metadata: Prisma.JsonValue | null
      scheduledAt: Date | null
      title: string
      postedAt: Date | null
    }, ExtArgs["result"]["newsThread"]>
    composites: {}
  }

  type NewsThreadGetPayload<S extends boolean | null | undefined | NewsThreadDefaultArgs> = $Result.GetResult<Prisma.$NewsThreadPayload, S>

  type NewsThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsThreadCountAggregateInputType | true
    }

  export interface NewsThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsThread'], meta: { name: 'NewsThread' } }
    /**
     * Find zero or one NewsThread that matches the filter.
     * @param {NewsThreadFindUniqueArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsThreadFindUniqueArgs>(args: SelectSubset<T, NewsThreadFindUniqueArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsThread that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsThreadFindUniqueOrThrowArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindFirstArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsThreadFindFirstArgs>(args?: SelectSubset<T, NewsThreadFindFirstArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindFirstOrThrowArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsThreads
     * const newsThreads = await prisma.newsThread.findMany()
     * 
     * // Get first 10 NewsThreads
     * const newsThreads = await prisma.newsThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsThreadFindManyArgs>(args?: SelectSubset<T, NewsThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsThread.
     * @param {NewsThreadCreateArgs} args - Arguments to create a NewsThread.
     * @example
     * // Create one NewsThread
     * const NewsThread = await prisma.newsThread.create({
     *   data: {
     *     // ... data to create a NewsThread
     *   }
     * })
     * 
     */
    create<T extends NewsThreadCreateArgs>(args: SelectSubset<T, NewsThreadCreateArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsThreads.
     * @param {NewsThreadCreateManyArgs} args - Arguments to create many NewsThreads.
     * @example
     * // Create many NewsThreads
     * const newsThread = await prisma.newsThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsThreadCreateManyArgs>(args?: SelectSubset<T, NewsThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsThreads and returns the data saved in the database.
     * @param {NewsThreadCreateManyAndReturnArgs} args - Arguments to create many NewsThreads.
     * @example
     * // Create many NewsThreads
     * const newsThread = await prisma.newsThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsThreads and only return the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsThread.
     * @param {NewsThreadDeleteArgs} args - Arguments to delete one NewsThread.
     * @example
     * // Delete one NewsThread
     * const NewsThread = await prisma.newsThread.delete({
     *   where: {
     *     // ... filter to delete one NewsThread
     *   }
     * })
     * 
     */
    delete<T extends NewsThreadDeleteArgs>(args: SelectSubset<T, NewsThreadDeleteArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsThread.
     * @param {NewsThreadUpdateArgs} args - Arguments to update one NewsThread.
     * @example
     * // Update one NewsThread
     * const newsThread = await prisma.newsThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsThreadUpdateArgs>(args: SelectSubset<T, NewsThreadUpdateArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsThreads.
     * @param {NewsThreadDeleteManyArgs} args - Arguments to filter NewsThreads to delete.
     * @example
     * // Delete a few NewsThreads
     * const { count } = await prisma.newsThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsThreadDeleteManyArgs>(args?: SelectSubset<T, NewsThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsThreads
     * const newsThread = await prisma.newsThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsThreadUpdateManyArgs>(args: SelectSubset<T, NewsThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsThread.
     * @param {NewsThreadUpsertArgs} args - Arguments to update or create a NewsThread.
     * @example
     * // Update or create a NewsThread
     * const newsThread = await prisma.newsThread.upsert({
     *   create: {
     *     // ... data to create a NewsThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsThread we want to update
     *   }
     * })
     */
    upsert<T extends NewsThreadUpsertArgs>(args: SelectSubset<T, NewsThreadUpsertArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadCountArgs} args - Arguments to filter NewsThreads to count.
     * @example
     * // Count the number of NewsThreads
     * const count = await prisma.newsThread.count({
     *   where: {
     *     // ... the filter for the NewsThreads we want to count
     *   }
     * })
    **/
    count<T extends NewsThreadCountArgs>(
      args?: Subset<T, NewsThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsThreadAggregateArgs>(args: Subset<T, NewsThreadAggregateArgs>): Prisma.PrismaPromise<GetNewsThreadAggregateType<T>>

    /**
     * Group by NewsThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsThreadGroupByArgs['orderBy'] }
        : { orderBy?: NewsThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsThread model
   */
  readonly fields: NewsThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends NewsThread$itemsArgs<ExtArgs> = {}>(args?: Subset<T, NewsThread$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsThread model
   */ 
  interface NewsThreadFieldRefs {
    readonly id: FieldRef<"NewsThread", 'String'>
    readonly status: FieldRef<"NewsThread", 'String'>
    readonly createdAt: FieldRef<"NewsThread", 'DateTime'>
    readonly metadata: FieldRef<"NewsThread", 'Json'>
    readonly scheduledAt: FieldRef<"NewsThread", 'DateTime'>
    readonly title: FieldRef<"NewsThread", 'String'>
    readonly postedAt: FieldRef<"NewsThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsThread findUnique
   */
  export type NewsThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread findUniqueOrThrow
   */
  export type NewsThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread findFirst
   */
  export type NewsThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreads.
     */
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread findFirstOrThrow
   */
  export type NewsThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreads.
     */
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread findMany
   */
  export type NewsThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreads to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread create
   */
  export type NewsThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsThread.
     */
    data: XOR<NewsThreadCreateInput, NewsThreadUncheckedCreateInput>
  }

  /**
   * NewsThread createMany
   */
  export type NewsThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsThreads.
     */
    data: NewsThreadCreateManyInput | NewsThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThread createManyAndReturn
   */
  export type NewsThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsThreads.
     */
    data: NewsThreadCreateManyInput | NewsThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThread update
   */
  export type NewsThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsThread.
     */
    data: XOR<NewsThreadUpdateInput, NewsThreadUncheckedUpdateInput>
    /**
     * Choose, which NewsThread to update.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread updateMany
   */
  export type NewsThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsThreads.
     */
    data: XOR<NewsThreadUpdateManyMutationInput, NewsThreadUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreads to update
     */
    where?: NewsThreadWhereInput
  }

  /**
   * NewsThread upsert
   */
  export type NewsThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsThread to update in case it exists.
     */
    where: NewsThreadWhereUniqueInput
    /**
     * In case the NewsThread found by the `where` argument doesn't exist, create a new NewsThread with this data.
     */
    create: XOR<NewsThreadCreateInput, NewsThreadUncheckedCreateInput>
    /**
     * In case the NewsThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsThreadUpdateInput, NewsThreadUncheckedUpdateInput>
  }

  /**
   * NewsThread delete
   */
  export type NewsThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter which NewsThread to delete.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread deleteMany
   */
  export type NewsThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreads to delete
     */
    where?: NewsThreadWhereInput
  }

  /**
   * NewsThread.items
   */
  export type NewsThread$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    cursor?: NewsThreadItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThread without action
   */
  export type NewsThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
  }


  /**
   * Model NewsThreadItem
   */

  export type AggregateNewsThreadItem = {
    _count: NewsThreadItemCountAggregateOutputType | null
    _avg: NewsThreadItemAvgAggregateOutputType | null
    _sum: NewsThreadItemSumAggregateOutputType | null
    _min: NewsThreadItemMinAggregateOutputType | null
    _max: NewsThreadItemMaxAggregateOutputType | null
  }

  export type NewsThreadItemAvgAggregateOutputType = {
    order: number | null
  }

  export type NewsThreadItemSumAggregateOutputType = {
    order: number | null
  }

  export type NewsThreadItemMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    articleId: string | null
    order: number | null
    content: string | null
    createdAt: Date | null
  }

  export type NewsThreadItemMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    articleId: string | null
    order: number | null
    content: string | null
    createdAt: Date | null
  }

  export type NewsThreadItemCountAggregateOutputType = {
    id: number
    threadId: number
    articleId: number
    order: number
    content: number
    createdAt: number
    _all: number
  }


  export type NewsThreadItemAvgAggregateInputType = {
    order?: true
  }

  export type NewsThreadItemSumAggregateInputType = {
    order?: true
  }

  export type NewsThreadItemMinAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    order?: true
    content?: true
    createdAt?: true
  }

  export type NewsThreadItemMaxAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    order?: true
    content?: true
    createdAt?: true
  }

  export type NewsThreadItemCountAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    order?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type NewsThreadItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreadItem to aggregate.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsThreadItems
    **/
    _count?: true | NewsThreadItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsThreadItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsThreadItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsThreadItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsThreadItemMaxAggregateInputType
  }

  export type GetNewsThreadItemAggregateType<T extends NewsThreadItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsThreadItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsThreadItem[P]>
      : GetScalarType<T[P], AggregateNewsThreadItem[P]>
  }




  export type NewsThreadItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithAggregationInput | NewsThreadItemOrderByWithAggregationInput[]
    by: NewsThreadItemScalarFieldEnum[] | NewsThreadItemScalarFieldEnum
    having?: NewsThreadItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsThreadItemCountAggregateInputType | true
    _avg?: NewsThreadItemAvgAggregateInputType
    _sum?: NewsThreadItemSumAggregateInputType
    _min?: NewsThreadItemMinAggregateInputType
    _max?: NewsThreadItemMaxAggregateInputType
  }

  export type NewsThreadItemGroupByOutputType = {
    id: string
    threadId: string
    articleId: string
    order: number
    content: string | null
    createdAt: Date
    _count: NewsThreadItemCountAggregateOutputType | null
    _avg: NewsThreadItemAvgAggregateOutputType | null
    _sum: NewsThreadItemSumAggregateOutputType | null
    _min: NewsThreadItemMinAggregateOutputType | null
    _max: NewsThreadItemMaxAggregateOutputType | null
  }

  type GetNewsThreadItemGroupByPayload<T extends NewsThreadItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsThreadItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsThreadItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsThreadItemGroupByOutputType[P]>
            : GetScalarType<T[P], NewsThreadItemGroupByOutputType[P]>
        }
      >
    >


  export type NewsThreadItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectScalar = {
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type NewsThreadItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }
  export type NewsThreadItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }

  export type $NewsThreadItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsThreadItem"
    objects: {
      thread: Prisma.$NewsThreadPayload<ExtArgs>
      article: Prisma.$NewsArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      articleId: string
      order: number
      content: string | null
      createdAt: Date
    }, ExtArgs["result"]["newsThreadItem"]>
    composites: {}
  }

  type NewsThreadItemGetPayload<S extends boolean | null | undefined | NewsThreadItemDefaultArgs> = $Result.GetResult<Prisma.$NewsThreadItemPayload, S>

  type NewsThreadItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsThreadItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsThreadItemCountAggregateInputType | true
    }

  export interface NewsThreadItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsThreadItem'], meta: { name: 'NewsThreadItem' } }
    /**
     * Find zero or one NewsThreadItem that matches the filter.
     * @param {NewsThreadItemFindUniqueArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsThreadItemFindUniqueArgs>(args: SelectSubset<T, NewsThreadItemFindUniqueArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsThreadItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsThreadItemFindUniqueOrThrowArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsThreadItemFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsThreadItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsThreadItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindFirstArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsThreadItemFindFirstArgs>(args?: SelectSubset<T, NewsThreadItemFindFirstArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsThreadItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindFirstOrThrowArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsThreadItemFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsThreadItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsThreadItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsThreadItems
     * const newsThreadItems = await prisma.newsThreadItem.findMany()
     * 
     * // Get first 10 NewsThreadItems
     * const newsThreadItems = await prisma.newsThreadItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsThreadItemFindManyArgs>(args?: SelectSubset<T, NewsThreadItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsThreadItem.
     * @param {NewsThreadItemCreateArgs} args - Arguments to create a NewsThreadItem.
     * @example
     * // Create one NewsThreadItem
     * const NewsThreadItem = await prisma.newsThreadItem.create({
     *   data: {
     *     // ... data to create a NewsThreadItem
     *   }
     * })
     * 
     */
    create<T extends NewsThreadItemCreateArgs>(args: SelectSubset<T, NewsThreadItemCreateArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsThreadItems.
     * @param {NewsThreadItemCreateManyArgs} args - Arguments to create many NewsThreadItems.
     * @example
     * // Create many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsThreadItemCreateManyArgs>(args?: SelectSubset<T, NewsThreadItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsThreadItems and returns the data saved in the database.
     * @param {NewsThreadItemCreateManyAndReturnArgs} args - Arguments to create many NewsThreadItems.
     * @example
     * // Create many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsThreadItems and only return the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsThreadItemCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsThreadItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsThreadItem.
     * @param {NewsThreadItemDeleteArgs} args - Arguments to delete one NewsThreadItem.
     * @example
     * // Delete one NewsThreadItem
     * const NewsThreadItem = await prisma.newsThreadItem.delete({
     *   where: {
     *     // ... filter to delete one NewsThreadItem
     *   }
     * })
     * 
     */
    delete<T extends NewsThreadItemDeleteArgs>(args: SelectSubset<T, NewsThreadItemDeleteArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsThreadItem.
     * @param {NewsThreadItemUpdateArgs} args - Arguments to update one NewsThreadItem.
     * @example
     * // Update one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsThreadItemUpdateArgs>(args: SelectSubset<T, NewsThreadItemUpdateArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsThreadItems.
     * @param {NewsThreadItemDeleteManyArgs} args - Arguments to filter NewsThreadItems to delete.
     * @example
     * // Delete a few NewsThreadItems
     * const { count } = await prisma.newsThreadItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsThreadItemDeleteManyArgs>(args?: SelectSubset<T, NewsThreadItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreadItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsThreadItemUpdateManyArgs>(args: SelectSubset<T, NewsThreadItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsThreadItem.
     * @param {NewsThreadItemUpsertArgs} args - Arguments to update or create a NewsThreadItem.
     * @example
     * // Update or create a NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.upsert({
     *   create: {
     *     // ... data to create a NewsThreadItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsThreadItem we want to update
     *   }
     * })
     */
    upsert<T extends NewsThreadItemUpsertArgs>(args: SelectSubset<T, NewsThreadItemUpsertArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsThreadItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemCountArgs} args - Arguments to filter NewsThreadItems to count.
     * @example
     * // Count the number of NewsThreadItems
     * const count = await prisma.newsThreadItem.count({
     *   where: {
     *     // ... the filter for the NewsThreadItems we want to count
     *   }
     * })
    **/
    count<T extends NewsThreadItemCountArgs>(
      args?: Subset<T, NewsThreadItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsThreadItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsThreadItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsThreadItemAggregateArgs>(args: Subset<T, NewsThreadItemAggregateArgs>): Prisma.PrismaPromise<GetNewsThreadItemAggregateType<T>>

    /**
     * Group by NewsThreadItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsThreadItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsThreadItemGroupByArgs['orderBy'] }
        : { orderBy?: NewsThreadItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsThreadItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsThreadItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsThreadItem model
   */
  readonly fields: NewsThreadItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsThreadItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsThreadItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends NewsThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsThreadDefaultArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    article<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsThreadItem model
   */ 
  interface NewsThreadItemFieldRefs {
    readonly id: FieldRef<"NewsThreadItem", 'String'>
    readonly threadId: FieldRef<"NewsThreadItem", 'String'>
    readonly articleId: FieldRef<"NewsThreadItem", 'String'>
    readonly order: FieldRef<"NewsThreadItem", 'Int'>
    readonly content: FieldRef<"NewsThreadItem", 'String'>
    readonly createdAt: FieldRef<"NewsThreadItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsThreadItem findUnique
   */
  export type NewsThreadItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem findUniqueOrThrow
   */
  export type NewsThreadItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem findFirst
   */
  export type NewsThreadItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreadItems.
     */
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem findFirstOrThrow
   */
  export type NewsThreadItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreadItems.
     */
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem findMany
   */
  export type NewsThreadItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItems to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem create
   */
  export type NewsThreadItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsThreadItem.
     */
    data: XOR<NewsThreadItemCreateInput, NewsThreadItemUncheckedCreateInput>
  }

  /**
   * NewsThreadItem createMany
   */
  export type NewsThreadItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsThreadItems.
     */
    data: NewsThreadItemCreateManyInput | NewsThreadItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThreadItem createManyAndReturn
   */
  export type NewsThreadItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsThreadItems.
     */
    data: NewsThreadItemCreateManyInput | NewsThreadItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsThreadItem update
   */
  export type NewsThreadItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsThreadItem.
     */
    data: XOR<NewsThreadItemUpdateInput, NewsThreadItemUncheckedUpdateInput>
    /**
     * Choose, which NewsThreadItem to update.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem updateMany
   */
  export type NewsThreadItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsThreadItems.
     */
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreadItems to update
     */
    where?: NewsThreadItemWhereInput
  }

  /**
   * NewsThreadItem upsert
   */
  export type NewsThreadItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsThreadItem to update in case it exists.
     */
    where: NewsThreadItemWhereUniqueInput
    /**
     * In case the NewsThreadItem found by the `where` argument doesn't exist, create a new NewsThreadItem with this data.
     */
    create: XOR<NewsThreadItemCreateInput, NewsThreadItemUncheckedCreateInput>
    /**
     * In case the NewsThreadItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsThreadItemUpdateInput, NewsThreadItemUncheckedUpdateInput>
  }

  /**
   * NewsThreadItem delete
   */
  export type NewsThreadItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter which NewsThreadItem to delete.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem deleteMany
   */
  export type NewsThreadItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreadItems to delete
     */
    where?: NewsThreadItemWhereInput
  }

  /**
   * NewsThreadItem without action
   */
  export type NewsThreadItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
  }


  /**
   * Model NewsAnalysis
   */

  export type AggregateNewsAnalysis = {
    _count: NewsAnalysisCountAggregateOutputType | null
    _min: NewsAnalysisMinAggregateOutputType | null
    _max: NewsAnalysisMaxAggregateOutputType | null
  }

  export type NewsAnalysisMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    summary: string | null
    sentiment: string | null
    createdAt: Date | null
  }

  export type NewsAnalysisMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    summary: string | null
    sentiment: string | null
    createdAt: Date | null
  }

  export type NewsAnalysisCountAggregateOutputType = {
    id: number
    articleId: number
    summary: number
    sentiment: number
    keywords: number
    topics: number
    createdAt: number
    _all: number
  }


  export type NewsAnalysisMinAggregateInputType = {
    id?: true
    articleId?: true
    summary?: true
    sentiment?: true
    createdAt?: true
  }

  export type NewsAnalysisMaxAggregateInputType = {
    id?: true
    articleId?: true
    summary?: true
    sentiment?: true
    createdAt?: true
  }

  export type NewsAnalysisCountAggregateInputType = {
    id?: true
    articleId?: true
    summary?: true
    sentiment?: true
    keywords?: true
    topics?: true
    createdAt?: true
    _all?: true
  }

  export type NewsAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsAnalysis to aggregate.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsAnalyses
    **/
    _count?: true | NewsAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsAnalysisMaxAggregateInputType
  }

  export type GetNewsAnalysisAggregateType<T extends NewsAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsAnalysis[P]>
      : GetScalarType<T[P], AggregateNewsAnalysis[P]>
  }




  export type NewsAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsAnalysisWhereInput
    orderBy?: NewsAnalysisOrderByWithAggregationInput | NewsAnalysisOrderByWithAggregationInput[]
    by: NewsAnalysisScalarFieldEnum[] | NewsAnalysisScalarFieldEnum
    having?: NewsAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsAnalysisCountAggregateInputType | true
    _min?: NewsAnalysisMinAggregateInputType
    _max?: NewsAnalysisMaxAggregateInputType
  }

  export type NewsAnalysisGroupByOutputType = {
    id: string
    articleId: string
    summary: string
    sentiment: string
    keywords: string[]
    topics: string[]
    createdAt: Date
    _count: NewsAnalysisCountAggregateOutputType | null
    _min: NewsAnalysisMinAggregateOutputType | null
    _max: NewsAnalysisMaxAggregateOutputType | null
  }

  type GetNewsAnalysisGroupByPayload<T extends NewsAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], NewsAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type NewsAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    summary?: boolean
    sentiment?: boolean
    keywords?: boolean
    topics?: boolean
    createdAt?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    summary?: boolean
    sentiment?: boolean
    keywords?: boolean
    topics?: boolean
    createdAt?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectScalar = {
    id?: boolean
    articleId?: boolean
    summary?: boolean
    sentiment?: boolean
    keywords?: boolean
    topics?: boolean
    createdAt?: boolean
  }

  export type NewsAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }
  export type NewsAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }

  export type $NewsAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsAnalysis"
    objects: {
      article: Prisma.$NewsArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      summary: string
      sentiment: string
      keywords: string[]
      topics: string[]
      createdAt: Date
    }, ExtArgs["result"]["newsAnalysis"]>
    composites: {}
  }

  type NewsAnalysisGetPayload<S extends boolean | null | undefined | NewsAnalysisDefaultArgs> = $Result.GetResult<Prisma.$NewsAnalysisPayload, S>

  type NewsAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsAnalysisCountAggregateInputType | true
    }

  export interface NewsAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsAnalysis'], meta: { name: 'NewsAnalysis' } }
    /**
     * Find zero or one NewsAnalysis that matches the filter.
     * @param {NewsAnalysisFindUniqueArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsAnalysisFindUniqueArgs>(args: SelectSubset<T, NewsAnalysisFindUniqueArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsAnalysisFindUniqueOrThrowArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindFirstArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsAnalysisFindFirstArgs>(args?: SelectSubset<T, NewsAnalysisFindFirstArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindFirstOrThrowArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsAnalyses
     * const newsAnalyses = await prisma.newsAnalysis.findMany()
     * 
     * // Get first 10 NewsAnalyses
     * const newsAnalyses = await prisma.newsAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsAnalysisFindManyArgs>(args?: SelectSubset<T, NewsAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsAnalysis.
     * @param {NewsAnalysisCreateArgs} args - Arguments to create a NewsAnalysis.
     * @example
     * // Create one NewsAnalysis
     * const NewsAnalysis = await prisma.newsAnalysis.create({
     *   data: {
     *     // ... data to create a NewsAnalysis
     *   }
     * })
     * 
     */
    create<T extends NewsAnalysisCreateArgs>(args: SelectSubset<T, NewsAnalysisCreateArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsAnalyses.
     * @param {NewsAnalysisCreateManyArgs} args - Arguments to create many NewsAnalyses.
     * @example
     * // Create many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsAnalysisCreateManyArgs>(args?: SelectSubset<T, NewsAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsAnalyses and returns the data saved in the database.
     * @param {NewsAnalysisCreateManyAndReturnArgs} args - Arguments to create many NewsAnalyses.
     * @example
     * // Create many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsAnalyses and only return the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsAnalysis.
     * @param {NewsAnalysisDeleteArgs} args - Arguments to delete one NewsAnalysis.
     * @example
     * // Delete one NewsAnalysis
     * const NewsAnalysis = await prisma.newsAnalysis.delete({
     *   where: {
     *     // ... filter to delete one NewsAnalysis
     *   }
     * })
     * 
     */
    delete<T extends NewsAnalysisDeleteArgs>(args: SelectSubset<T, NewsAnalysisDeleteArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsAnalysis.
     * @param {NewsAnalysisUpdateArgs} args - Arguments to update one NewsAnalysis.
     * @example
     * // Update one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsAnalysisUpdateArgs>(args: SelectSubset<T, NewsAnalysisUpdateArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsAnalyses.
     * @param {NewsAnalysisDeleteManyArgs} args - Arguments to filter NewsAnalyses to delete.
     * @example
     * // Delete a few NewsAnalyses
     * const { count } = await prisma.newsAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsAnalysisDeleteManyArgs>(args?: SelectSubset<T, NewsAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsAnalysisUpdateManyArgs>(args: SelectSubset<T, NewsAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsAnalysis.
     * @param {NewsAnalysisUpsertArgs} args - Arguments to update or create a NewsAnalysis.
     * @example
     * // Update or create a NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.upsert({
     *   create: {
     *     // ... data to create a NewsAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends NewsAnalysisUpsertArgs>(args: SelectSubset<T, NewsAnalysisUpsertArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisCountArgs} args - Arguments to filter NewsAnalyses to count.
     * @example
     * // Count the number of NewsAnalyses
     * const count = await prisma.newsAnalysis.count({
     *   where: {
     *     // ... the filter for the NewsAnalyses we want to count
     *   }
     * })
    **/
    count<T extends NewsAnalysisCountArgs>(
      args?: Subset<T, NewsAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAnalysisAggregateArgs>(args: Subset<T, NewsAnalysisAggregateArgs>): Prisma.PrismaPromise<GetNewsAnalysisAggregateType<T>>

    /**
     * Group by NewsAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: NewsAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsAnalysis model
   */
  readonly fields: NewsAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsAnalysis model
   */ 
  interface NewsAnalysisFieldRefs {
    readonly id: FieldRef<"NewsAnalysis", 'String'>
    readonly articleId: FieldRef<"NewsAnalysis", 'String'>
    readonly summary: FieldRef<"NewsAnalysis", 'String'>
    readonly sentiment: FieldRef<"NewsAnalysis", 'String'>
    readonly keywords: FieldRef<"NewsAnalysis", 'String[]'>
    readonly topics: FieldRef<"NewsAnalysis", 'String[]'>
    readonly createdAt: FieldRef<"NewsAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsAnalysis findUnique
   */
  export type NewsAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis findUniqueOrThrow
   */
  export type NewsAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis findFirst
   */
  export type NewsAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsAnalyses.
     */
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis findFirstOrThrow
   */
  export type NewsAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsAnalyses.
     */
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis findMany
   */
  export type NewsAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalyses to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis create
   */
  export type NewsAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsAnalysis.
     */
    data: XOR<NewsAnalysisCreateInput, NewsAnalysisUncheckedCreateInput>
  }

  /**
   * NewsAnalysis createMany
   */
  export type NewsAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsAnalyses.
     */
    data: NewsAnalysisCreateManyInput | NewsAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsAnalysis createManyAndReturn
   */
  export type NewsAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsAnalyses.
     */
    data: NewsAnalysisCreateManyInput | NewsAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsAnalysis update
   */
  export type NewsAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsAnalysis.
     */
    data: XOR<NewsAnalysisUpdateInput, NewsAnalysisUncheckedUpdateInput>
    /**
     * Choose, which NewsAnalysis to update.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis updateMany
   */
  export type NewsAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsAnalyses.
     */
    data: XOR<NewsAnalysisUpdateManyMutationInput, NewsAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which NewsAnalyses to update
     */
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsAnalysis upsert
   */
  export type NewsAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsAnalysis to update in case it exists.
     */
    where: NewsAnalysisWhereUniqueInput
    /**
     * In case the NewsAnalysis found by the `where` argument doesn't exist, create a new NewsAnalysis with this data.
     */
    create: XOR<NewsAnalysisCreateInput, NewsAnalysisUncheckedCreateInput>
    /**
     * In case the NewsAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsAnalysisUpdateInput, NewsAnalysisUncheckedUpdateInput>
  }

  /**
   * NewsAnalysis delete
   */
  export type NewsAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter which NewsAnalysis to delete.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis deleteMany
   */
  export type NewsAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsAnalyses to delete
     */
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsAnalysis without action
   */
  export type NewsAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model JobQueue
   */

  export type AggregateJobQueue = {
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  export type JobQueueAvgAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type JobQueueSumAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type JobQueueMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    runAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobQueueMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    runAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobQueueCountAggregateOutputType = {
    id: number
    type: number
    payload: number
    status: number
    priority: number
    attempts: number
    maxAttempts: number
    runAt: number
    completedAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobQueueAvgAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type JobQueueSumAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type JobQueueMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    runAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobQueueMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    runAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobQueueCountAggregateInputType = {
    id?: true
    type?: true
    payload?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    runAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueue to aggregate.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobQueues
    **/
    _count?: true | JobQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobQueueMaxAggregateInputType
  }

  export type GetJobQueueAggregateType<T extends JobQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateJobQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobQueue[P]>
      : GetScalarType<T[P], AggregateJobQueue[P]>
  }




  export type JobQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobQueueWhereInput
    orderBy?: JobQueueOrderByWithAggregationInput | JobQueueOrderByWithAggregationInput[]
    by: JobQueueScalarFieldEnum[] | JobQueueScalarFieldEnum
    having?: JobQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobQueueCountAggregateInputType | true
    _avg?: JobQueueAvgAggregateInputType
    _sum?: JobQueueSumAggregateInputType
    _min?: JobQueueMinAggregateInputType
    _max?: JobQueueMaxAggregateInputType
  }

  export type JobQueueGroupByOutputType = {
    id: string
    type: string
    payload: JsonValue
    status: string
    priority: number
    attempts: number
    maxAttempts: number
    runAt: Date
    completedAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  type GetJobQueueGroupByPayload<T extends JobQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
            : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
        }
      >
    >


  export type JobQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    runAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    runAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectScalar = {
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    runAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $JobQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      payload: Prisma.JsonValue
      status: string
      priority: number
      attempts: number
      maxAttempts: number
      runAt: Date
      completedAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobQueue"]>
    composites: {}
  }

  type JobQueueGetPayload<S extends boolean | null | undefined | JobQueueDefaultArgs> = $Result.GetResult<Prisma.$JobQueuePayload, S>

  type JobQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobQueueCountAggregateInputType | true
    }

  export interface JobQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobQueue'], meta: { name: 'JobQueue' } }
    /**
     * Find zero or one JobQueue that matches the filter.
     * @param {JobQueueFindUniqueArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobQueueFindUniqueArgs>(args: SelectSubset<T, JobQueueFindUniqueArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobQueueFindUniqueOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, JobQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobQueueFindFirstArgs>(args?: SelectSubset<T, JobQueueFindFirstArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, JobQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobQueues
     * const jobQueues = await prisma.jobQueue.findMany()
     * 
     * // Get first 10 JobQueues
     * const jobQueues = await prisma.jobQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobQueueFindManyArgs>(args?: SelectSubset<T, JobQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobQueue.
     * @param {JobQueueCreateArgs} args - Arguments to create a JobQueue.
     * @example
     * // Create one JobQueue
     * const JobQueue = await prisma.jobQueue.create({
     *   data: {
     *     // ... data to create a JobQueue
     *   }
     * })
     * 
     */
    create<T extends JobQueueCreateArgs>(args: SelectSubset<T, JobQueueCreateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobQueues.
     * @param {JobQueueCreateManyArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobQueueCreateManyArgs>(args?: SelectSubset<T, JobQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobQueues and returns the data saved in the database.
     * @param {JobQueueCreateManyAndReturnArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobQueues and only return the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, JobQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobQueue.
     * @param {JobQueueDeleteArgs} args - Arguments to delete one JobQueue.
     * @example
     * // Delete one JobQueue
     * const JobQueue = await prisma.jobQueue.delete({
     *   where: {
     *     // ... filter to delete one JobQueue
     *   }
     * })
     * 
     */
    delete<T extends JobQueueDeleteArgs>(args: SelectSubset<T, JobQueueDeleteArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobQueue.
     * @param {JobQueueUpdateArgs} args - Arguments to update one JobQueue.
     * @example
     * // Update one JobQueue
     * const jobQueue = await prisma.jobQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobQueueUpdateArgs>(args: SelectSubset<T, JobQueueUpdateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobQueues.
     * @param {JobQueueDeleteManyArgs} args - Arguments to filter JobQueues to delete.
     * @example
     * // Delete a few JobQueues
     * const { count } = await prisma.jobQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobQueueDeleteManyArgs>(args?: SelectSubset<T, JobQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobQueues
     * const jobQueue = await prisma.jobQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobQueueUpdateManyArgs>(args: SelectSubset<T, JobQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobQueue.
     * @param {JobQueueUpsertArgs} args - Arguments to update or create a JobQueue.
     * @example
     * // Update or create a JobQueue
     * const jobQueue = await prisma.jobQueue.upsert({
     *   create: {
     *     // ... data to create a JobQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobQueue we want to update
     *   }
     * })
     */
    upsert<T extends JobQueueUpsertArgs>(args: SelectSubset<T, JobQueueUpsertArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueCountArgs} args - Arguments to filter JobQueues to count.
     * @example
     * // Count the number of JobQueues
     * const count = await prisma.jobQueue.count({
     *   where: {
     *     // ... the filter for the JobQueues we want to count
     *   }
     * })
    **/
    count<T extends JobQueueCountArgs>(
      args?: Subset<T, JobQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobQueueAggregateArgs>(args: Subset<T, JobQueueAggregateArgs>): Prisma.PrismaPromise<GetJobQueueAggregateType<T>>

    /**
     * Group by JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobQueueGroupByArgs['orderBy'] }
        : { orderBy?: JobQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobQueue model
   */
  readonly fields: JobQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobQueue model
   */ 
  interface JobQueueFieldRefs {
    readonly id: FieldRef<"JobQueue", 'String'>
    readonly type: FieldRef<"JobQueue", 'String'>
    readonly payload: FieldRef<"JobQueue", 'Json'>
    readonly status: FieldRef<"JobQueue", 'String'>
    readonly priority: FieldRef<"JobQueue", 'Int'>
    readonly attempts: FieldRef<"JobQueue", 'Int'>
    readonly maxAttempts: FieldRef<"JobQueue", 'Int'>
    readonly runAt: FieldRef<"JobQueue", 'DateTime'>
    readonly completedAt: FieldRef<"JobQueue", 'DateTime'>
    readonly error: FieldRef<"JobQueue", 'String'>
    readonly createdAt: FieldRef<"JobQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"JobQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobQueue findUnique
   */
  export type JobQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findUniqueOrThrow
   */
  export type JobQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findFirst
   */
  export type JobQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findFirstOrThrow
   */
  export type JobQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findMany
   */
  export type JobQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueues to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue create
   */
  export type JobQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * The data needed to create a JobQueue.
     */
    data: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
  }

  /**
   * JobQueue createMany
   */
  export type JobQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue createManyAndReturn
   */
  export type JobQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue update
   */
  export type JobQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * The data needed to update a JobQueue.
     */
    data: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
    /**
     * Choose, which JobQueue to update.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue updateMany
   */
  export type JobQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobQueues.
     */
    data: XOR<JobQueueUpdateManyMutationInput, JobQueueUncheckedUpdateManyInput>
    /**
     * Filter which JobQueues to update
     */
    where?: JobQueueWhereInput
  }

  /**
   * JobQueue upsert
   */
  export type JobQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * The filter to search for the JobQueue to update in case it exists.
     */
    where: JobQueueWhereUniqueInput
    /**
     * In case the JobQueue found by the `where` argument doesn't exist, create a new JobQueue with this data.
     */
    create: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
    /**
     * In case the JobQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
  }

  /**
   * JobQueue delete
   */
  export type JobQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter which JobQueue to delete.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue deleteMany
   */
  export type JobQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueues to delete
     */
    where?: JobQueueWhereInput
  }

  /**
   * JobQueue without action
   */
  export type JobQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
  }


  /**
   * Model CollectionPreset
   */

  export type AggregateCollectionPreset = {
    _count: CollectionPresetCountAggregateOutputType | null
    _min: CollectionPresetMinAggregateOutputType | null
    _max: CollectionPresetMaxAggregateOutputType | null
  }

  export type CollectionPresetMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionPresetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionPresetCountAggregateOutputType = {
    id: number
    name: number
    description: number
    settings: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionPresetMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionPresetMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionPresetCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    settings?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionPresetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionPreset to aggregate.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionPresets
    **/
    _count?: true | CollectionPresetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionPresetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionPresetMaxAggregateInputType
  }

  export type GetCollectionPresetAggregateType<T extends CollectionPresetAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionPreset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionPreset[P]>
      : GetScalarType<T[P], AggregateCollectionPreset[P]>
  }




  export type CollectionPresetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionPresetWhereInput
    orderBy?: CollectionPresetOrderByWithAggregationInput | CollectionPresetOrderByWithAggregationInput[]
    by: CollectionPresetScalarFieldEnum[] | CollectionPresetScalarFieldEnum
    having?: CollectionPresetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionPresetCountAggregateInputType | true
    _min?: CollectionPresetMinAggregateInputType
    _max?: CollectionPresetMaxAggregateInputType
  }

  export type CollectionPresetGroupByOutputType = {
    id: string
    name: string
    description: string | null
    settings: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollectionPresetCountAggregateOutputType | null
    _min: CollectionPresetMinAggregateOutputType | null
    _max: CollectionPresetMaxAggregateOutputType | null
  }

  type GetCollectionPresetGroupByPayload<T extends CollectionPresetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionPresetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionPresetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionPresetGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionPresetGroupByOutputType[P]>
        }
      >
    >


  export type CollectionPresetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CollectionPresetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionPreset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      settings: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionPreset"]>
    composites: {}
  }

  type CollectionPresetGetPayload<S extends boolean | null | undefined | CollectionPresetDefaultArgs> = $Result.GetResult<Prisma.$CollectionPresetPayload, S>

  type CollectionPresetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CollectionPresetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollectionPresetCountAggregateInputType | true
    }

  export interface CollectionPresetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionPreset'], meta: { name: 'CollectionPreset' } }
    /**
     * Find zero or one CollectionPreset that matches the filter.
     * @param {CollectionPresetFindUniqueArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionPresetFindUniqueArgs>(args: SelectSubset<T, CollectionPresetFindUniqueArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CollectionPreset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CollectionPresetFindUniqueOrThrowArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionPresetFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionPresetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CollectionPreset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindFirstArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionPresetFindFirstArgs>(args?: SelectSubset<T, CollectionPresetFindFirstArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CollectionPreset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindFirstOrThrowArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionPresetFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionPresetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CollectionPresets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionPresets
     * const collectionPresets = await prisma.collectionPreset.findMany()
     * 
     * // Get first 10 CollectionPresets
     * const collectionPresets = await prisma.collectionPreset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionPresetFindManyArgs>(args?: SelectSubset<T, CollectionPresetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CollectionPreset.
     * @param {CollectionPresetCreateArgs} args - Arguments to create a CollectionPreset.
     * @example
     * // Create one CollectionPreset
     * const CollectionPreset = await prisma.collectionPreset.create({
     *   data: {
     *     // ... data to create a CollectionPreset
     *   }
     * })
     * 
     */
    create<T extends CollectionPresetCreateArgs>(args: SelectSubset<T, CollectionPresetCreateArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CollectionPresets.
     * @param {CollectionPresetCreateManyArgs} args - Arguments to create many CollectionPresets.
     * @example
     * // Create many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionPresetCreateManyArgs>(args?: SelectSubset<T, CollectionPresetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionPresets and returns the data saved in the database.
     * @param {CollectionPresetCreateManyAndReturnArgs} args - Arguments to create many CollectionPresets.
     * @example
     * // Create many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionPresets and only return the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionPresetCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionPresetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CollectionPreset.
     * @param {CollectionPresetDeleteArgs} args - Arguments to delete one CollectionPreset.
     * @example
     * // Delete one CollectionPreset
     * const CollectionPreset = await prisma.collectionPreset.delete({
     *   where: {
     *     // ... filter to delete one CollectionPreset
     *   }
     * })
     * 
     */
    delete<T extends CollectionPresetDeleteArgs>(args: SelectSubset<T, CollectionPresetDeleteArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CollectionPreset.
     * @param {CollectionPresetUpdateArgs} args - Arguments to update one CollectionPreset.
     * @example
     * // Update one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionPresetUpdateArgs>(args: SelectSubset<T, CollectionPresetUpdateArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CollectionPresets.
     * @param {CollectionPresetDeleteManyArgs} args - Arguments to filter CollectionPresets to delete.
     * @example
     * // Delete a few CollectionPresets
     * const { count } = await prisma.collectionPreset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionPresetDeleteManyArgs>(args?: SelectSubset<T, CollectionPresetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionPresetUpdateManyArgs>(args: SelectSubset<T, CollectionPresetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CollectionPreset.
     * @param {CollectionPresetUpsertArgs} args - Arguments to update or create a CollectionPreset.
     * @example
     * // Update or create a CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.upsert({
     *   create: {
     *     // ... data to create a CollectionPreset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionPreset we want to update
     *   }
     * })
     */
    upsert<T extends CollectionPresetUpsertArgs>(args: SelectSubset<T, CollectionPresetUpsertArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CollectionPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetCountArgs} args - Arguments to filter CollectionPresets to count.
     * @example
     * // Count the number of CollectionPresets
     * const count = await prisma.collectionPreset.count({
     *   where: {
     *     // ... the filter for the CollectionPresets we want to count
     *   }
     * })
    **/
    count<T extends CollectionPresetCountArgs>(
      args?: Subset<T, CollectionPresetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionPresetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionPresetAggregateArgs>(args: Subset<T, CollectionPresetAggregateArgs>): Prisma.PrismaPromise<GetCollectionPresetAggregateType<T>>

    /**
     * Group by CollectionPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionPresetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionPresetGroupByArgs['orderBy'] }
        : { orderBy?: CollectionPresetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionPresetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionPresetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionPreset model
   */
  readonly fields: CollectionPresetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionPreset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionPresetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionPreset model
   */ 
  interface CollectionPresetFieldRefs {
    readonly id: FieldRef<"CollectionPreset", 'String'>
    readonly name: FieldRef<"CollectionPreset", 'String'>
    readonly description: FieldRef<"CollectionPreset", 'String'>
    readonly settings: FieldRef<"CollectionPreset", 'Json'>
    readonly isActive: FieldRef<"CollectionPreset", 'Boolean'>
    readonly createdAt: FieldRef<"CollectionPreset", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionPreset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionPreset findUnique
   */
  export type CollectionPresetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset findUniqueOrThrow
   */
  export type CollectionPresetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset findFirst
   */
  export type CollectionPresetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionPresets.
     */
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset findFirstOrThrow
   */
  export type CollectionPresetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionPresets.
     */
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset findMany
   */
  export type CollectionPresetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPresets to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset create
   */
  export type CollectionPresetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * The data needed to create a CollectionPreset.
     */
    data: XOR<CollectionPresetCreateInput, CollectionPresetUncheckedCreateInput>
  }

  /**
   * CollectionPreset createMany
   */
  export type CollectionPresetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionPresets.
     */
    data: CollectionPresetCreateManyInput | CollectionPresetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionPreset createManyAndReturn
   */
  export type CollectionPresetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CollectionPresets.
     */
    data: CollectionPresetCreateManyInput | CollectionPresetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionPreset update
   */
  export type CollectionPresetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * The data needed to update a CollectionPreset.
     */
    data: XOR<CollectionPresetUpdateInput, CollectionPresetUncheckedUpdateInput>
    /**
     * Choose, which CollectionPreset to update.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset updateMany
   */
  export type CollectionPresetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionPresets.
     */
    data: XOR<CollectionPresetUpdateManyMutationInput, CollectionPresetUncheckedUpdateManyInput>
    /**
     * Filter which CollectionPresets to update
     */
    where?: CollectionPresetWhereInput
  }

  /**
   * CollectionPreset upsert
   */
  export type CollectionPresetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * The filter to search for the CollectionPreset to update in case it exists.
     */
    where: CollectionPresetWhereUniqueInput
    /**
     * In case the CollectionPreset found by the `where` argument doesn't exist, create a new CollectionPreset with this data.
     */
    create: XOR<CollectionPresetCreateInput, CollectionPresetUncheckedCreateInput>
    /**
     * In case the CollectionPreset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionPresetUpdateInput, CollectionPresetUncheckedUpdateInput>
  }

  /**
   * CollectionPreset delete
   */
  export type CollectionPresetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter which CollectionPreset to delete.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset deleteMany
   */
  export type CollectionPresetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionPresets to delete
     */
    where?: CollectionPresetWhereInput
  }

  /**
   * CollectionPreset without action
   */
  export type CollectionPresetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
  }


  /**
   * Model WatchlistUser
   */

  export type AggregateWatchlistUser = {
    _count: WatchlistUserCountAggregateOutputType | null
    _avg: WatchlistUserAvgAggregateOutputType | null
    _sum: WatchlistUserSumAggregateOutputType | null
    _min: WatchlistUserMinAggregateOutputType | null
    _max: WatchlistUserMaxAggregateOutputType | null
  }

  export type WatchlistUserAvgAggregateOutputType = {
    followers: number | null
    following: number | null
  }

  export type WatchlistUserSumAggregateOutputType = {
    followers: number | null
    following: number | null
  }

  export type WatchlistUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    twitterId: string | null
    username: string | null
    displayName: string | null
    followers: number | null
    following: number | null
    isActive: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
  }

  export type WatchlistUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    twitterId: string | null
    username: string | null
    displayName: string | null
    followers: number | null
    following: number | null
    isActive: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
  }

  export type WatchlistUserCountAggregateOutputType = {
    id: number
    userId: number
    twitterId: number
    username: number
    displayName: number
    followers: number
    following: number
    isActive: number
    lastChecked: number
    createdAt: number
    _all: number
  }


  export type WatchlistUserAvgAggregateInputType = {
    followers?: true
    following?: true
  }

  export type WatchlistUserSumAggregateInputType = {
    followers?: true
    following?: true
  }

  export type WatchlistUserMinAggregateInputType = {
    id?: true
    userId?: true
    twitterId?: true
    username?: true
    displayName?: true
    followers?: true
    following?: true
    isActive?: true
    lastChecked?: true
    createdAt?: true
  }

  export type WatchlistUserMaxAggregateInputType = {
    id?: true
    userId?: true
    twitterId?: true
    username?: true
    displayName?: true
    followers?: true
    following?: true
    isActive?: true
    lastChecked?: true
    createdAt?: true
  }

  export type WatchlistUserCountAggregateInputType = {
    id?: true
    userId?: true
    twitterId?: true
    username?: true
    displayName?: true
    followers?: true
    following?: true
    isActive?: true
    lastChecked?: true
    createdAt?: true
    _all?: true
  }

  export type WatchlistUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistUser to aggregate.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistUsers
    **/
    _count?: true | WatchlistUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistUserMaxAggregateInputType
  }

  export type GetWatchlistUserAggregateType<T extends WatchlistUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistUser[P]>
      : GetScalarType<T[P], AggregateWatchlistUser[P]>
  }




  export type WatchlistUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistUserWhereInput
    orderBy?: WatchlistUserOrderByWithAggregationInput | WatchlistUserOrderByWithAggregationInput[]
    by: WatchlistUserScalarFieldEnum[] | WatchlistUserScalarFieldEnum
    having?: WatchlistUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistUserCountAggregateInputType | true
    _avg?: WatchlistUserAvgAggregateInputType
    _sum?: WatchlistUserSumAggregateInputType
    _min?: WatchlistUserMinAggregateInputType
    _max?: WatchlistUserMaxAggregateInputType
  }

  export type WatchlistUserGroupByOutputType = {
    id: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers: number | null
    following: number | null
    isActive: boolean
    lastChecked: Date | null
    createdAt: Date
    _count: WatchlistUserCountAggregateOutputType | null
    _avg: WatchlistUserAvgAggregateOutputType | null
    _sum: WatchlistUserSumAggregateOutputType | null
    _min: WatchlistUserMinAggregateOutputType | null
    _max: WatchlistUserMaxAggregateOutputType | null
  }

  type GetWatchlistUserGroupByPayload<T extends WatchlistUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistUserGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistUserGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    followers?: boolean
    following?: boolean
    isActive?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tweets?: boolean | WatchlistUser$tweetsArgs<ExtArgs>
    interactions?: boolean | WatchlistUser$interactionsArgs<ExtArgs>
    _count?: boolean | WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    followers?: boolean
    following?: boolean
    isActive?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectScalar = {
    id?: boolean
    userId?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    followers?: boolean
    following?: boolean
    isActive?: boolean
    lastChecked?: boolean
    createdAt?: boolean
  }

  export type WatchlistUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tweets?: boolean | WatchlistUser$tweetsArgs<ExtArgs>
    interactions?: boolean | WatchlistUser$interactionsArgs<ExtArgs>
    _count?: boolean | WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WatchlistUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WatchlistUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tweets: Prisma.$WatchlistTweetPayload<ExtArgs>[]
      interactions: Prisma.$InteractionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      twitterId: string
      username: string
      displayName: string
      followers: number | null
      following: number | null
      isActive: boolean
      lastChecked: Date | null
      createdAt: Date
    }, ExtArgs["result"]["watchlistUser"]>
    composites: {}
  }

  type WatchlistUserGetPayload<S extends boolean | null | undefined | WatchlistUserDefaultArgs> = $Result.GetResult<Prisma.$WatchlistUserPayload, S>

  type WatchlistUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchlistUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchlistUserCountAggregateInputType | true
    }

  export interface WatchlistUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistUser'], meta: { name: 'WatchlistUser' } }
    /**
     * Find zero or one WatchlistUser that matches the filter.
     * @param {WatchlistUserFindUniqueArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistUserFindUniqueArgs>(args: SelectSubset<T, WatchlistUserFindUniqueArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WatchlistUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchlistUserFindUniqueOrThrowArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WatchlistUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindFirstArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistUserFindFirstArgs>(args?: SelectSubset<T, WatchlistUserFindFirstArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WatchlistUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindFirstOrThrowArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WatchlistUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistUsers
     * const watchlistUsers = await prisma.watchlistUser.findMany()
     * 
     * // Get first 10 WatchlistUsers
     * const watchlistUsers = await prisma.watchlistUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistUserFindManyArgs>(args?: SelectSubset<T, WatchlistUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WatchlistUser.
     * @param {WatchlistUserCreateArgs} args - Arguments to create a WatchlistUser.
     * @example
     * // Create one WatchlistUser
     * const WatchlistUser = await prisma.watchlistUser.create({
     *   data: {
     *     // ... data to create a WatchlistUser
     *   }
     * })
     * 
     */
    create<T extends WatchlistUserCreateArgs>(args: SelectSubset<T, WatchlistUserCreateArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WatchlistUsers.
     * @param {WatchlistUserCreateManyArgs} args - Arguments to create many WatchlistUsers.
     * @example
     * // Create many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistUserCreateManyArgs>(args?: SelectSubset<T, WatchlistUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistUsers and returns the data saved in the database.
     * @param {WatchlistUserCreateManyAndReturnArgs} args - Arguments to create many WatchlistUsers.
     * @example
     * // Create many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistUsers and only return the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WatchlistUser.
     * @param {WatchlistUserDeleteArgs} args - Arguments to delete one WatchlistUser.
     * @example
     * // Delete one WatchlistUser
     * const WatchlistUser = await prisma.watchlistUser.delete({
     *   where: {
     *     // ... filter to delete one WatchlistUser
     *   }
     * })
     * 
     */
    delete<T extends WatchlistUserDeleteArgs>(args: SelectSubset<T, WatchlistUserDeleteArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WatchlistUser.
     * @param {WatchlistUserUpdateArgs} args - Arguments to update one WatchlistUser.
     * @example
     * // Update one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistUserUpdateArgs>(args: SelectSubset<T, WatchlistUserUpdateArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WatchlistUsers.
     * @param {WatchlistUserDeleteManyArgs} args - Arguments to filter WatchlistUsers to delete.
     * @example
     * // Delete a few WatchlistUsers
     * const { count } = await prisma.watchlistUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistUserDeleteManyArgs>(args?: SelectSubset<T, WatchlistUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistUserUpdateManyArgs>(args: SelectSubset<T, WatchlistUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchlistUser.
     * @param {WatchlistUserUpsertArgs} args - Arguments to update or create a WatchlistUser.
     * @example
     * // Update or create a WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.upsert({
     *   create: {
     *     // ... data to create a WatchlistUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistUser we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistUserUpsertArgs>(args: SelectSubset<T, WatchlistUserUpsertArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WatchlistUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserCountArgs} args - Arguments to filter WatchlistUsers to count.
     * @example
     * // Count the number of WatchlistUsers
     * const count = await prisma.watchlistUser.count({
     *   where: {
     *     // ... the filter for the WatchlistUsers we want to count
     *   }
     * })
    **/
    count<T extends WatchlistUserCountArgs>(
      args?: Subset<T, WatchlistUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistUserAggregateArgs>(args: Subset<T, WatchlistUserAggregateArgs>): Prisma.PrismaPromise<GetWatchlistUserAggregateType<T>>

    /**
     * Group by WatchlistUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistUserGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistUser model
   */
  readonly fields: WatchlistUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tweets<T extends WatchlistUser$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUser$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findMany"> | Null>
    interactions<T extends WatchlistUser$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUser$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistUser model
   */ 
  interface WatchlistUserFieldRefs {
    readonly id: FieldRef<"WatchlistUser", 'String'>
    readonly userId: FieldRef<"WatchlistUser", 'String'>
    readonly twitterId: FieldRef<"WatchlistUser", 'String'>
    readonly username: FieldRef<"WatchlistUser", 'String'>
    readonly displayName: FieldRef<"WatchlistUser", 'String'>
    readonly followers: FieldRef<"WatchlistUser", 'Int'>
    readonly following: FieldRef<"WatchlistUser", 'Int'>
    readonly isActive: FieldRef<"WatchlistUser", 'Boolean'>
    readonly lastChecked: FieldRef<"WatchlistUser", 'DateTime'>
    readonly createdAt: FieldRef<"WatchlistUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistUser findUnique
   */
  export type WatchlistUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser findUniqueOrThrow
   */
  export type WatchlistUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser findFirst
   */
  export type WatchlistUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistUsers.
     */
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser findFirstOrThrow
   */
  export type WatchlistUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistUsers.
     */
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser findMany
   */
  export type WatchlistUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUsers to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser create
   */
  export type WatchlistUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistUser.
     */
    data: XOR<WatchlistUserCreateInput, WatchlistUserUncheckedCreateInput>
  }

  /**
   * WatchlistUser createMany
   */
  export type WatchlistUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistUsers.
     */
    data: WatchlistUserCreateManyInput | WatchlistUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistUser createManyAndReturn
   */
  export type WatchlistUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WatchlistUsers.
     */
    data: WatchlistUserCreateManyInput | WatchlistUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistUser update
   */
  export type WatchlistUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistUser.
     */
    data: XOR<WatchlistUserUpdateInput, WatchlistUserUncheckedUpdateInput>
    /**
     * Choose, which WatchlistUser to update.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser updateMany
   */
  export type WatchlistUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistUsers.
     */
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistUsers to update
     */
    where?: WatchlistUserWhereInput
  }

  /**
   * WatchlistUser upsert
   */
  export type WatchlistUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistUser to update in case it exists.
     */
    where: WatchlistUserWhereUniqueInput
    /**
     * In case the WatchlistUser found by the `where` argument doesn't exist, create a new WatchlistUser with this data.
     */
    create: XOR<WatchlistUserCreateInput, WatchlistUserUncheckedCreateInput>
    /**
     * In case the WatchlistUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistUserUpdateInput, WatchlistUserUncheckedUpdateInput>
  }

  /**
   * WatchlistUser delete
   */
  export type WatchlistUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter which WatchlistUser to delete.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser deleteMany
   */
  export type WatchlistUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistUsers to delete
     */
    where?: WatchlistUserWhereInput
  }

  /**
   * WatchlistUser.tweets
   */
  export type WatchlistUser$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    where?: WatchlistTweetWhereInput
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    cursor?: WatchlistTweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistUser.interactions
   */
  export type WatchlistUser$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    where?: InteractionHistoryWhereInput
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    cursor?: InteractionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * WatchlistUser without action
   */
  export type WatchlistUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
  }


  /**
   * Model WatchlistTweet
   */

  export type AggregateWatchlistTweet = {
    _count: WatchlistTweetCountAggregateOutputType | null
    _avg: WatchlistTweetAvgAggregateOutputType | null
    _sum: WatchlistTweetSumAggregateOutputType | null
    _min: WatchlistTweetMinAggregateOutputType | null
    _max: WatchlistTweetMaxAggregateOutputType | null
  }

  export type WatchlistTweetAvgAggregateOutputType = {
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
  }

  export type WatchlistTweetSumAggregateOutputType = {
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
  }

  export type WatchlistTweetMinAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    tweetId: string | null
    content: string | null
    createdAt: Date | null
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
    collectedAt: Date | null
  }

  export type WatchlistTweetMaxAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    tweetId: string | null
    content: string | null
    createdAt: Date | null
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
    collectedAt: Date | null
  }

  export type WatchlistTweetCountAggregateOutputType = {
    id: number
    watchlistUserId: number
    tweetId: number
    content: number
    createdAt: number
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt: number
    _all: number
  }


  export type WatchlistTweetAvgAggregateInputType = {
    retweetCount?: true
    likeCount?: true
    replyCount?: true
  }

  export type WatchlistTweetSumAggregateInputType = {
    retweetCount?: true
    likeCount?: true
    replyCount?: true
  }

  export type WatchlistTweetMinAggregateInputType = {
    id?: true
    watchlistUserId?: true
    tweetId?: true
    content?: true
    createdAt?: true
    retweetCount?: true
    likeCount?: true
    replyCount?: true
    collectedAt?: true
  }

  export type WatchlistTweetMaxAggregateInputType = {
    id?: true
    watchlistUserId?: true
    tweetId?: true
    content?: true
    createdAt?: true
    retweetCount?: true
    likeCount?: true
    replyCount?: true
    collectedAt?: true
  }

  export type WatchlistTweetCountAggregateInputType = {
    id?: true
    watchlistUserId?: true
    tweetId?: true
    content?: true
    createdAt?: true
    retweetCount?: true
    likeCount?: true
    replyCount?: true
    collectedAt?: true
    _all?: true
  }

  export type WatchlistTweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistTweet to aggregate.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistTweets
    **/
    _count?: true | WatchlistTweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistTweetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistTweetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistTweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistTweetMaxAggregateInputType
  }

  export type GetWatchlistTweetAggregateType<T extends WatchlistTweetAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistTweet[P]>
      : GetScalarType<T[P], AggregateWatchlistTweet[P]>
  }




  export type WatchlistTweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistTweetWhereInput
    orderBy?: WatchlistTweetOrderByWithAggregationInput | WatchlistTweetOrderByWithAggregationInput[]
    by: WatchlistTweetScalarFieldEnum[] | WatchlistTweetScalarFieldEnum
    having?: WatchlistTweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistTweetCountAggregateInputType | true
    _avg?: WatchlistTweetAvgAggregateInputType
    _sum?: WatchlistTweetSumAggregateInputType
    _min?: WatchlistTweetMinAggregateInputType
    _max?: WatchlistTweetMaxAggregateInputType
  }

  export type WatchlistTweetGroupByOutputType = {
    id: string
    watchlistUserId: string
    tweetId: string
    content: string
    createdAt: Date
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt: Date
    _count: WatchlistTweetCountAggregateOutputType | null
    _avg: WatchlistTweetAvgAggregateOutputType | null
    _sum: WatchlistTweetSumAggregateOutputType | null
    _min: WatchlistTweetMinAggregateOutputType | null
    _max: WatchlistTweetMaxAggregateOutputType | null
  }

  type GetWatchlistTweetGroupByPayload<T extends WatchlistTweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistTweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistTweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistTweetGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistTweetGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistTweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    tweetId?: boolean
    content?: boolean
    createdAt?: boolean
    retweetCount?: boolean
    likeCount?: boolean
    replyCount?: boolean
    collectedAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    tweetId?: boolean
    content?: boolean
    createdAt?: boolean
    retweetCount?: boolean
    likeCount?: boolean
    replyCount?: boolean
    collectedAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectScalar = {
    id?: boolean
    watchlistUserId?: boolean
    tweetId?: boolean
    content?: boolean
    createdAt?: boolean
    retweetCount?: boolean
    likeCount?: boolean
    replyCount?: boolean
    collectedAt?: boolean
  }

  export type WatchlistTweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }
  export type WatchlistTweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }

  export type $WatchlistTweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistTweet"
    objects: {
      watchlistUser: Prisma.$WatchlistUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      watchlistUserId: string
      tweetId: string
      content: string
      createdAt: Date
      retweetCount: number
      likeCount: number
      replyCount: number
      collectedAt: Date
    }, ExtArgs["result"]["watchlistTweet"]>
    composites: {}
  }

  type WatchlistTweetGetPayload<S extends boolean | null | undefined | WatchlistTweetDefaultArgs> = $Result.GetResult<Prisma.$WatchlistTweetPayload, S>

  type WatchlistTweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchlistTweetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchlistTweetCountAggregateInputType | true
    }

  export interface WatchlistTweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistTweet'], meta: { name: 'WatchlistTweet' } }
    /**
     * Find zero or one WatchlistTweet that matches the filter.
     * @param {WatchlistTweetFindUniqueArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistTweetFindUniqueArgs>(args: SelectSubset<T, WatchlistTweetFindUniqueArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WatchlistTweet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchlistTweetFindUniqueOrThrowArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistTweetFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistTweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WatchlistTweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindFirstArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistTweetFindFirstArgs>(args?: SelectSubset<T, WatchlistTweetFindFirstArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WatchlistTweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindFirstOrThrowArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistTweetFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistTweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WatchlistTweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistTweets
     * const watchlistTweets = await prisma.watchlistTweet.findMany()
     * 
     * // Get first 10 WatchlistTweets
     * const watchlistTweets = await prisma.watchlistTweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistTweetFindManyArgs>(args?: SelectSubset<T, WatchlistTweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WatchlistTweet.
     * @param {WatchlistTweetCreateArgs} args - Arguments to create a WatchlistTweet.
     * @example
     * // Create one WatchlistTweet
     * const WatchlistTweet = await prisma.watchlistTweet.create({
     *   data: {
     *     // ... data to create a WatchlistTweet
     *   }
     * })
     * 
     */
    create<T extends WatchlistTweetCreateArgs>(args: SelectSubset<T, WatchlistTweetCreateArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WatchlistTweets.
     * @param {WatchlistTweetCreateManyArgs} args - Arguments to create many WatchlistTweets.
     * @example
     * // Create many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistTweetCreateManyArgs>(args?: SelectSubset<T, WatchlistTweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistTweets and returns the data saved in the database.
     * @param {WatchlistTweetCreateManyAndReturnArgs} args - Arguments to create many WatchlistTweets.
     * @example
     * // Create many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistTweets and only return the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistTweetCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistTweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WatchlistTweet.
     * @param {WatchlistTweetDeleteArgs} args - Arguments to delete one WatchlistTweet.
     * @example
     * // Delete one WatchlistTweet
     * const WatchlistTweet = await prisma.watchlistTweet.delete({
     *   where: {
     *     // ... filter to delete one WatchlistTweet
     *   }
     * })
     * 
     */
    delete<T extends WatchlistTweetDeleteArgs>(args: SelectSubset<T, WatchlistTweetDeleteArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WatchlistTweet.
     * @param {WatchlistTweetUpdateArgs} args - Arguments to update one WatchlistTweet.
     * @example
     * // Update one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistTweetUpdateArgs>(args: SelectSubset<T, WatchlistTweetUpdateArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WatchlistTweets.
     * @param {WatchlistTweetDeleteManyArgs} args - Arguments to filter WatchlistTweets to delete.
     * @example
     * // Delete a few WatchlistTweets
     * const { count } = await prisma.watchlistTweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistTweetDeleteManyArgs>(args?: SelectSubset<T, WatchlistTweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistTweetUpdateManyArgs>(args: SelectSubset<T, WatchlistTweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchlistTweet.
     * @param {WatchlistTweetUpsertArgs} args - Arguments to update or create a WatchlistTweet.
     * @example
     * // Update or create a WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.upsert({
     *   create: {
     *     // ... data to create a WatchlistTweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistTweet we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistTweetUpsertArgs>(args: SelectSubset<T, WatchlistTweetUpsertArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WatchlistTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetCountArgs} args - Arguments to filter WatchlistTweets to count.
     * @example
     * // Count the number of WatchlistTweets
     * const count = await prisma.watchlistTweet.count({
     *   where: {
     *     // ... the filter for the WatchlistTweets we want to count
     *   }
     * })
    **/
    count<T extends WatchlistTweetCountArgs>(
      args?: Subset<T, WatchlistTweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistTweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistTweetAggregateArgs>(args: Subset<T, WatchlistTweetAggregateArgs>): Prisma.PrismaPromise<GetWatchlistTweetAggregateType<T>>

    /**
     * Group by WatchlistTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistTweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistTweetGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistTweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistTweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistTweet model
   */
  readonly fields: WatchlistTweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistTweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistTweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlistUser<T extends WatchlistUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUserDefaultArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistTweet model
   */ 
  interface WatchlistTweetFieldRefs {
    readonly id: FieldRef<"WatchlistTweet", 'String'>
    readonly watchlistUserId: FieldRef<"WatchlistTweet", 'String'>
    readonly tweetId: FieldRef<"WatchlistTweet", 'String'>
    readonly content: FieldRef<"WatchlistTweet", 'String'>
    readonly createdAt: FieldRef<"WatchlistTweet", 'DateTime'>
    readonly retweetCount: FieldRef<"WatchlistTweet", 'Int'>
    readonly likeCount: FieldRef<"WatchlistTweet", 'Int'>
    readonly replyCount: FieldRef<"WatchlistTweet", 'Int'>
    readonly collectedAt: FieldRef<"WatchlistTweet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistTweet findUnique
   */
  export type WatchlistTweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet findUniqueOrThrow
   */
  export type WatchlistTweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet findFirst
   */
  export type WatchlistTweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistTweets.
     */
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet findFirstOrThrow
   */
  export type WatchlistTweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistTweets.
     */
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet findMany
   */
  export type WatchlistTweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweets to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet create
   */
  export type WatchlistTweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistTweet.
     */
    data: XOR<WatchlistTweetCreateInput, WatchlistTweetUncheckedCreateInput>
  }

  /**
   * WatchlistTweet createMany
   */
  export type WatchlistTweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistTweets.
     */
    data: WatchlistTweetCreateManyInput | WatchlistTweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistTweet createManyAndReturn
   */
  export type WatchlistTweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WatchlistTweets.
     */
    data: WatchlistTweetCreateManyInput | WatchlistTweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistTweet update
   */
  export type WatchlistTweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistTweet.
     */
    data: XOR<WatchlistTweetUpdateInput, WatchlistTweetUncheckedUpdateInput>
    /**
     * Choose, which WatchlistTweet to update.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet updateMany
   */
  export type WatchlistTweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistTweets.
     */
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistTweets to update
     */
    where?: WatchlistTweetWhereInput
  }

  /**
   * WatchlistTweet upsert
   */
  export type WatchlistTweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistTweet to update in case it exists.
     */
    where: WatchlistTweetWhereUniqueInput
    /**
     * In case the WatchlistTweet found by the `where` argument doesn't exist, create a new WatchlistTweet with this data.
     */
    create: XOR<WatchlistTweetCreateInput, WatchlistTweetUncheckedCreateInput>
    /**
     * In case the WatchlistTweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistTweetUpdateInput, WatchlistTweetUncheckedUpdateInput>
  }

  /**
   * WatchlistTweet delete
   */
  export type WatchlistTweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter which WatchlistTweet to delete.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet deleteMany
   */
  export type WatchlistTweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistTweets to delete
     */
    where?: WatchlistTweetWhereInput
  }

  /**
   * WatchlistTweet without action
   */
  export type WatchlistTweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
  }


  /**
   * Model InteractionHistory
   */

  export type AggregateInteractionHistory = {
    _count: InteractionHistoryCountAggregateOutputType | null
    _min: InteractionHistoryMinAggregateOutputType | null
    _max: InteractionHistoryMaxAggregateOutputType | null
  }

  export type InteractionHistoryMinAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    interactionType: string | null
    tweetId: string | null
    createdAt: Date | null
  }

  export type InteractionHistoryMaxAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    interactionType: string | null
    tweetId: string | null
    createdAt: Date | null
  }

  export type InteractionHistoryCountAggregateOutputType = {
    id: number
    watchlistUserId: number
    interactionType: number
    tweetId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type InteractionHistoryMinAggregateInputType = {
    id?: true
    watchlistUserId?: true
    interactionType?: true
    tweetId?: true
    createdAt?: true
  }

  export type InteractionHistoryMaxAggregateInputType = {
    id?: true
    watchlistUserId?: true
    interactionType?: true
    tweetId?: true
    createdAt?: true
  }

  export type InteractionHistoryCountAggregateInputType = {
    id?: true
    watchlistUserId?: true
    interactionType?: true
    tweetId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type InteractionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionHistory to aggregate.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InteractionHistories
    **/
    _count?: true | InteractionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionHistoryMaxAggregateInputType
  }

  export type GetInteractionHistoryAggregateType<T extends InteractionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInteractionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteractionHistory[P]>
      : GetScalarType<T[P], AggregateInteractionHistory[P]>
  }




  export type InteractionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionHistoryWhereInput
    orderBy?: InteractionHistoryOrderByWithAggregationInput | InteractionHistoryOrderByWithAggregationInput[]
    by: InteractionHistoryScalarFieldEnum[] | InteractionHistoryScalarFieldEnum
    having?: InteractionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionHistoryCountAggregateInputType | true
    _min?: InteractionHistoryMinAggregateInputType
    _max?: InteractionHistoryMaxAggregateInputType
  }

  export type InteractionHistoryGroupByOutputType = {
    id: string
    watchlistUserId: string
    interactionType: string
    tweetId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: InteractionHistoryCountAggregateOutputType | null
    _min: InteractionHistoryMinAggregateOutputType | null
    _max: InteractionHistoryMaxAggregateOutputType | null
  }

  type GetInteractionHistoryGroupByPayload<T extends InteractionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type InteractionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    interactionType?: boolean
    tweetId?: boolean
    metadata?: boolean
    createdAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    interactionType?: boolean
    tweetId?: boolean
    metadata?: boolean
    createdAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectScalar = {
    id?: boolean
    watchlistUserId?: boolean
    interactionType?: boolean
    tweetId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type InteractionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }
  export type InteractionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }

  export type $InteractionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InteractionHistory"
    objects: {
      watchlistUser: Prisma.$WatchlistUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      watchlistUserId: string
      interactionType: string
      tweetId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["interactionHistory"]>
    composites: {}
  }

  type InteractionHistoryGetPayload<S extends boolean | null | undefined | InteractionHistoryDefaultArgs> = $Result.GetResult<Prisma.$InteractionHistoryPayload, S>

  type InteractionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InteractionHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InteractionHistoryCountAggregateInputType | true
    }

  export interface InteractionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InteractionHistory'], meta: { name: 'InteractionHistory' } }
    /**
     * Find zero or one InteractionHistory that matches the filter.
     * @param {InteractionHistoryFindUniqueArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionHistoryFindUniqueArgs>(args: SelectSubset<T, InteractionHistoryFindUniqueArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InteractionHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InteractionHistoryFindUniqueOrThrowArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InteractionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindFirstArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionHistoryFindFirstArgs>(args?: SelectSubset<T, InteractionHistoryFindFirstArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InteractionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindFirstOrThrowArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InteractionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InteractionHistories
     * const interactionHistories = await prisma.interactionHistory.findMany()
     * 
     * // Get first 10 InteractionHistories
     * const interactionHistories = await prisma.interactionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionHistoryFindManyArgs>(args?: SelectSubset<T, InteractionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InteractionHistory.
     * @param {InteractionHistoryCreateArgs} args - Arguments to create a InteractionHistory.
     * @example
     * // Create one InteractionHistory
     * const InteractionHistory = await prisma.interactionHistory.create({
     *   data: {
     *     // ... data to create a InteractionHistory
     *   }
     * })
     * 
     */
    create<T extends InteractionHistoryCreateArgs>(args: SelectSubset<T, InteractionHistoryCreateArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InteractionHistories.
     * @param {InteractionHistoryCreateManyArgs} args - Arguments to create many InteractionHistories.
     * @example
     * // Create many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionHistoryCreateManyArgs>(args?: SelectSubset<T, InteractionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InteractionHistories and returns the data saved in the database.
     * @param {InteractionHistoryCreateManyAndReturnArgs} args - Arguments to create many InteractionHistories.
     * @example
     * // Create many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InteractionHistories and only return the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InteractionHistory.
     * @param {InteractionHistoryDeleteArgs} args - Arguments to delete one InteractionHistory.
     * @example
     * // Delete one InteractionHistory
     * const InteractionHistory = await prisma.interactionHistory.delete({
     *   where: {
     *     // ... filter to delete one InteractionHistory
     *   }
     * })
     * 
     */
    delete<T extends InteractionHistoryDeleteArgs>(args: SelectSubset<T, InteractionHistoryDeleteArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InteractionHistory.
     * @param {InteractionHistoryUpdateArgs} args - Arguments to update one InteractionHistory.
     * @example
     * // Update one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionHistoryUpdateArgs>(args: SelectSubset<T, InteractionHistoryUpdateArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InteractionHistories.
     * @param {InteractionHistoryDeleteManyArgs} args - Arguments to filter InteractionHistories to delete.
     * @example
     * // Delete a few InteractionHistories
     * const { count } = await prisma.interactionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionHistoryDeleteManyArgs>(args?: SelectSubset<T, InteractionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionHistoryUpdateManyArgs>(args: SelectSubset<T, InteractionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InteractionHistory.
     * @param {InteractionHistoryUpsertArgs} args - Arguments to update or create a InteractionHistory.
     * @example
     * // Update or create a InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.upsert({
     *   create: {
     *     // ... data to create a InteractionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InteractionHistory we want to update
     *   }
     * })
     */
    upsert<T extends InteractionHistoryUpsertArgs>(args: SelectSubset<T, InteractionHistoryUpsertArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InteractionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryCountArgs} args - Arguments to filter InteractionHistories to count.
     * @example
     * // Count the number of InteractionHistories
     * const count = await prisma.interactionHistory.count({
     *   where: {
     *     // ... the filter for the InteractionHistories we want to count
     *   }
     * })
    **/
    count<T extends InteractionHistoryCountArgs>(
      args?: Subset<T, InteractionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InteractionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionHistoryAggregateArgs>(args: Subset<T, InteractionHistoryAggregateArgs>): Prisma.PrismaPromise<GetInteractionHistoryAggregateType<T>>

    /**
     * Group by InteractionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: InteractionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InteractionHistory model
   */
  readonly fields: InteractionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InteractionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlistUser<T extends WatchlistUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUserDefaultArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InteractionHistory model
   */ 
  interface InteractionHistoryFieldRefs {
    readonly id: FieldRef<"InteractionHistory", 'String'>
    readonly watchlistUserId: FieldRef<"InteractionHistory", 'String'>
    readonly interactionType: FieldRef<"InteractionHistory", 'String'>
    readonly tweetId: FieldRef<"InteractionHistory", 'String'>
    readonly metadata: FieldRef<"InteractionHistory", 'Json'>
    readonly createdAt: FieldRef<"InteractionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InteractionHistory findUnique
   */
  export type InteractionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory findUniqueOrThrow
   */
  export type InteractionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory findFirst
   */
  export type InteractionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionHistories.
     */
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory findFirstOrThrow
   */
  export type InteractionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionHistories.
     */
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory findMany
   */
  export type InteractionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistories to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory create
   */
  export type InteractionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a InteractionHistory.
     */
    data: XOR<InteractionHistoryCreateInput, InteractionHistoryUncheckedCreateInput>
  }

  /**
   * InteractionHistory createMany
   */
  export type InteractionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InteractionHistories.
     */
    data: InteractionHistoryCreateManyInput | InteractionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InteractionHistory createManyAndReturn
   */
  export type InteractionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InteractionHistories.
     */
    data: InteractionHistoryCreateManyInput | InteractionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteractionHistory update
   */
  export type InteractionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a InteractionHistory.
     */
    data: XOR<InteractionHistoryUpdateInput, InteractionHistoryUncheckedUpdateInput>
    /**
     * Choose, which InteractionHistory to update.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory updateMany
   */
  export type InteractionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InteractionHistories.
     */
    data: XOR<InteractionHistoryUpdateManyMutationInput, InteractionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InteractionHistories to update
     */
    where?: InteractionHistoryWhereInput
  }

  /**
   * InteractionHistory upsert
   */
  export type InteractionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the InteractionHistory to update in case it exists.
     */
    where: InteractionHistoryWhereUniqueInput
    /**
     * In case the InteractionHistory found by the `where` argument doesn't exist, create a new InteractionHistory with this data.
     */
    create: XOR<InteractionHistoryCreateInput, InteractionHistoryUncheckedCreateInput>
    /**
     * In case the InteractionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionHistoryUpdateInput, InteractionHistoryUncheckedUpdateInput>
  }

  /**
   * InteractionHistory delete
   */
  export type InteractionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter which InteractionHistory to delete.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory deleteMany
   */
  export type InteractionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionHistories to delete
     */
    where?: InteractionHistoryWhereInput
  }

  /**
   * InteractionHistory without action
   */
  export type InteractionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PerplexityReport
   */

  export type AggregatePerplexityReport = {
    _count: PerplexityReportCountAggregateOutputType | null
    _min: PerplexityReportMinAggregateOutputType | null
    _max: PerplexityReportMaxAggregateOutputType | null
  }

  export type PerplexityReportMinAggregateOutputType = {
    id: string | null
    query: string | null
    focus: string | null
    rawAnalysis: string | null
    createdAt: Date | null
  }

  export type PerplexityReportMaxAggregateOutputType = {
    id: string | null
    query: string | null
    focus: string | null
    rawAnalysis: string | null
    createdAt: Date | null
  }

  export type PerplexityReportCountAggregateOutputType = {
    id: number
    query: number
    focus: number
    rawAnalysis: number
    trends: number
    insights: number
    contentAngles: number
    marketContext: number
    competitorActivity: number
    riskFactors: number
    createdAt: number
    _all: number
  }


  export type PerplexityReportMinAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    createdAt?: true
  }

  export type PerplexityReportMaxAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    createdAt?: true
  }

  export type PerplexityReportCountAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    trends?: true
    insights?: true
    contentAngles?: true
    marketContext?: true
    competitorActivity?: true
    riskFactors?: true
    createdAt?: true
    _all?: true
  }

  export type PerplexityReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerplexityReport to aggregate.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerplexityReports
    **/
    _count?: true | PerplexityReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerplexityReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerplexityReportMaxAggregateInputType
  }

  export type GetPerplexityReportAggregateType<T extends PerplexityReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePerplexityReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerplexityReport[P]>
      : GetScalarType<T[P], AggregatePerplexityReport[P]>
  }




  export type PerplexityReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerplexityReportWhereInput
    orderBy?: PerplexityReportOrderByWithAggregationInput | PerplexityReportOrderByWithAggregationInput[]
    by: PerplexityReportScalarFieldEnum[] | PerplexityReportScalarFieldEnum
    having?: PerplexityReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerplexityReportCountAggregateInputType | true
    _min?: PerplexityReportMinAggregateInputType
    _max?: PerplexityReportMaxAggregateInputType
  }

  export type PerplexityReportGroupByOutputType = {
    id: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonValue
    insights: JsonValue
    contentAngles: JsonValue
    marketContext: JsonValue
    competitorActivity: JsonValue
    riskFactors: JsonValue
    createdAt: Date
    _count: PerplexityReportCountAggregateOutputType | null
    _min: PerplexityReportMinAggregateOutputType | null
    _max: PerplexityReportMaxAggregateOutputType | null
  }

  type GetPerplexityReportGroupByPayload<T extends PerplexityReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerplexityReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerplexityReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerplexityReportGroupByOutputType[P]>
            : GetScalarType<T[P], PerplexityReportGroupByOutputType[P]>
        }
      >
    >


  export type PerplexityReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    contentAngles?: boolean
    marketContext?: boolean
    competitorActivity?: boolean
    riskFactors?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    contentAngles?: boolean
    marketContext?: boolean
    competitorActivity?: boolean
    riskFactors?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectScalar = {
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    contentAngles?: boolean
    marketContext?: boolean
    competitorActivity?: boolean
    riskFactors?: boolean
    createdAt?: boolean
  }


  export type $PerplexityReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerplexityReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      focus: string
      rawAnalysis: string
      trends: Prisma.JsonValue
      insights: Prisma.JsonValue
      contentAngles: Prisma.JsonValue
      marketContext: Prisma.JsonValue
      competitorActivity: Prisma.JsonValue
      riskFactors: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["perplexityReport"]>
    composites: {}
  }

  type PerplexityReportGetPayload<S extends boolean | null | undefined | PerplexityReportDefaultArgs> = $Result.GetResult<Prisma.$PerplexityReportPayload, S>

  type PerplexityReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerplexityReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerplexityReportCountAggregateInputType | true
    }

  export interface PerplexityReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerplexityReport'], meta: { name: 'PerplexityReport' } }
    /**
     * Find zero or one PerplexityReport that matches the filter.
     * @param {PerplexityReportFindUniqueArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerplexityReportFindUniqueArgs>(args: SelectSubset<T, PerplexityReportFindUniqueArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerplexityReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerplexityReportFindUniqueOrThrowArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerplexityReportFindUniqueOrThrowArgs>(args: SelectSubset<T, PerplexityReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerplexityReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindFirstArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerplexityReportFindFirstArgs>(args?: SelectSubset<T, PerplexityReportFindFirstArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerplexityReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindFirstOrThrowArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerplexityReportFindFirstOrThrowArgs>(args?: SelectSubset<T, PerplexityReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerplexityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerplexityReports
     * const perplexityReports = await prisma.perplexityReport.findMany()
     * 
     * // Get first 10 PerplexityReports
     * const perplexityReports = await prisma.perplexityReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerplexityReportFindManyArgs>(args?: SelectSubset<T, PerplexityReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerplexityReport.
     * @param {PerplexityReportCreateArgs} args - Arguments to create a PerplexityReport.
     * @example
     * // Create one PerplexityReport
     * const PerplexityReport = await prisma.perplexityReport.create({
     *   data: {
     *     // ... data to create a PerplexityReport
     *   }
     * })
     * 
     */
    create<T extends PerplexityReportCreateArgs>(args: SelectSubset<T, PerplexityReportCreateArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerplexityReports.
     * @param {PerplexityReportCreateManyArgs} args - Arguments to create many PerplexityReports.
     * @example
     * // Create many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerplexityReportCreateManyArgs>(args?: SelectSubset<T, PerplexityReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerplexityReports and returns the data saved in the database.
     * @param {PerplexityReportCreateManyAndReturnArgs} args - Arguments to create many PerplexityReports.
     * @example
     * // Create many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerplexityReports and only return the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerplexityReportCreateManyAndReturnArgs>(args?: SelectSubset<T, PerplexityReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerplexityReport.
     * @param {PerplexityReportDeleteArgs} args - Arguments to delete one PerplexityReport.
     * @example
     * // Delete one PerplexityReport
     * const PerplexityReport = await prisma.perplexityReport.delete({
     *   where: {
     *     // ... filter to delete one PerplexityReport
     *   }
     * })
     * 
     */
    delete<T extends PerplexityReportDeleteArgs>(args: SelectSubset<T, PerplexityReportDeleteArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerplexityReport.
     * @param {PerplexityReportUpdateArgs} args - Arguments to update one PerplexityReport.
     * @example
     * // Update one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerplexityReportUpdateArgs>(args: SelectSubset<T, PerplexityReportUpdateArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerplexityReports.
     * @param {PerplexityReportDeleteManyArgs} args - Arguments to filter PerplexityReports to delete.
     * @example
     * // Delete a few PerplexityReports
     * const { count } = await prisma.perplexityReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerplexityReportDeleteManyArgs>(args?: SelectSubset<T, PerplexityReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerplexityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerplexityReportUpdateManyArgs>(args: SelectSubset<T, PerplexityReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerplexityReport.
     * @param {PerplexityReportUpsertArgs} args - Arguments to update or create a PerplexityReport.
     * @example
     * // Update or create a PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.upsert({
     *   create: {
     *     // ... data to create a PerplexityReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerplexityReport we want to update
     *   }
     * })
     */
    upsert<T extends PerplexityReportUpsertArgs>(args: SelectSubset<T, PerplexityReportUpsertArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerplexityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportCountArgs} args - Arguments to filter PerplexityReports to count.
     * @example
     * // Count the number of PerplexityReports
     * const count = await prisma.perplexityReport.count({
     *   where: {
     *     // ... the filter for the PerplexityReports we want to count
     *   }
     * })
    **/
    count<T extends PerplexityReportCountArgs>(
      args?: Subset<T, PerplexityReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerplexityReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerplexityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerplexityReportAggregateArgs>(args: Subset<T, PerplexityReportAggregateArgs>): Prisma.PrismaPromise<GetPerplexityReportAggregateType<T>>

    /**
     * Group by PerplexityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerplexityReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerplexityReportGroupByArgs['orderBy'] }
        : { orderBy?: PerplexityReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerplexityReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerplexityReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerplexityReport model
   */
  readonly fields: PerplexityReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerplexityReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerplexityReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerplexityReport model
   */ 
  interface PerplexityReportFieldRefs {
    readonly id: FieldRef<"PerplexityReport", 'String'>
    readonly query: FieldRef<"PerplexityReport", 'String'>
    readonly focus: FieldRef<"PerplexityReport", 'String'>
    readonly rawAnalysis: FieldRef<"PerplexityReport", 'String'>
    readonly trends: FieldRef<"PerplexityReport", 'Json'>
    readonly insights: FieldRef<"PerplexityReport", 'Json'>
    readonly contentAngles: FieldRef<"PerplexityReport", 'Json'>
    readonly marketContext: FieldRef<"PerplexityReport", 'Json'>
    readonly competitorActivity: FieldRef<"PerplexityReport", 'Json'>
    readonly riskFactors: FieldRef<"PerplexityReport", 'Json'>
    readonly createdAt: FieldRef<"PerplexityReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerplexityReport findUnique
   */
  export type PerplexityReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport findUniqueOrThrow
   */
  export type PerplexityReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport findFirst
   */
  export type PerplexityReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerplexityReports.
     */
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport findFirstOrThrow
   */
  export type PerplexityReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerplexityReports.
     */
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport findMany
   */
  export type PerplexityReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReports to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport create
   */
  export type PerplexityReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * The data needed to create a PerplexityReport.
     */
    data: XOR<PerplexityReportCreateInput, PerplexityReportUncheckedCreateInput>
  }

  /**
   * PerplexityReport createMany
   */
  export type PerplexityReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerplexityReports.
     */
    data: PerplexityReportCreateManyInput | PerplexityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerplexityReport createManyAndReturn
   */
  export type PerplexityReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerplexityReports.
     */
    data: PerplexityReportCreateManyInput | PerplexityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerplexityReport update
   */
  export type PerplexityReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * The data needed to update a PerplexityReport.
     */
    data: XOR<PerplexityReportUpdateInput, PerplexityReportUncheckedUpdateInput>
    /**
     * Choose, which PerplexityReport to update.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport updateMany
   */
  export type PerplexityReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerplexityReports.
     */
    data: XOR<PerplexityReportUpdateManyMutationInput, PerplexityReportUncheckedUpdateManyInput>
    /**
     * Filter which PerplexityReports to update
     */
    where?: PerplexityReportWhereInput
  }

  /**
   * PerplexityReport upsert
   */
  export type PerplexityReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * The filter to search for the PerplexityReport to update in case it exists.
     */
    where: PerplexityReportWhereUniqueInput
    /**
     * In case the PerplexityReport found by the `where` argument doesn't exist, create a new PerplexityReport with this data.
     */
    create: XOR<PerplexityReportCreateInput, PerplexityReportUncheckedCreateInput>
    /**
     * In case the PerplexityReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerplexityReportUpdateInput, PerplexityReportUncheckedUpdateInput>
  }

  /**
   * PerplexityReport delete
   */
  export type PerplexityReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter which PerplexityReport to delete.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport deleteMany
   */
  export type PerplexityReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerplexityReports to delete
     */
    where?: PerplexityReportWhereInput
  }

  /**
   * PerplexityReport without action
   */
  export type PerplexityReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
  }


  /**
   * Model CotSession
   */

  export type AggregateCotSession = {
    _count: CotSessionCountAggregateOutputType | null
    _avg: CotSessionAvgAggregateOutputType | null
    _sum: CotSessionSumAggregateOutputType | null
    _min: CotSessionMinAggregateOutputType | null
    _max: CotSessionMaxAggregateOutputType | null
  }

  export type CotSessionAvgAggregateOutputType = {
    currentPhase: number | null
    retryCount: number | null
    totalTokens: number | null
    totalDuration: number | null
  }

  export type CotSessionSumAggregateOutputType = {
    currentPhase: number | null
    retryCount: number | null
    totalTokens: number | null
    totalDuration: number | null
  }

  export type CotSessionMinAggregateOutputType = {
    id: string | null
    theme: string | null
    style: string | null
    platform: string | null
    status: $Enums.CotSessionStatus | null
    currentPhase: number | null
    currentStep: $Enums.CotPhaseStep | null
    lastError: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    totalTokens: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type CotSessionMaxAggregateOutputType = {
    id: string | null
    theme: string | null
    style: string | null
    platform: string | null
    status: $Enums.CotSessionStatus | null
    currentPhase: number | null
    currentStep: $Enums.CotPhaseStep | null
    lastError: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    totalTokens: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type CotSessionCountAggregateOutputType = {
    id: number
    theme: number
    style: number
    platform: number
    status: number
    currentPhase: number
    currentStep: number
    lastError: number
    retryCount: number
    nextRetryAt: number
    totalTokens: number
    totalDuration: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type CotSessionAvgAggregateInputType = {
    currentPhase?: true
    retryCount?: true
    totalTokens?: true
    totalDuration?: true
  }

  export type CotSessionSumAggregateInputType = {
    currentPhase?: true
    retryCount?: true
    totalTokens?: true
    totalDuration?: true
  }

  export type CotSessionMinAggregateInputType = {
    id?: true
    theme?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type CotSessionMaxAggregateInputType = {
    id?: true
    theme?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type CotSessionCountAggregateInputType = {
    id?: true
    theme?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type CotSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotSession to aggregate.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotSessions
    **/
    _count?: true | CotSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotSessionMaxAggregateInputType
  }

  export type GetCotSessionAggregateType<T extends CotSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCotSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotSession[P]>
      : GetScalarType<T[P], AggregateCotSession[P]>
  }




  export type CotSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotSessionWhereInput
    orderBy?: CotSessionOrderByWithAggregationInput | CotSessionOrderByWithAggregationInput[]
    by: CotSessionScalarFieldEnum[] | CotSessionScalarFieldEnum
    having?: CotSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotSessionCountAggregateInputType | true
    _avg?: CotSessionAvgAggregateInputType
    _sum?: CotSessionSumAggregateInputType
    _min?: CotSessionMinAggregateInputType
    _max?: CotSessionMaxAggregateInputType
  }

  export type CotSessionGroupByOutputType = {
    id: string
    theme: string
    style: string
    platform: string
    status: $Enums.CotSessionStatus
    currentPhase: number
    currentStep: $Enums.CotPhaseStep
    lastError: string | null
    retryCount: number
    nextRetryAt: Date | null
    totalTokens: number
    totalDuration: number
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: CotSessionCountAggregateOutputType | null
    _avg: CotSessionAvgAggregateOutputType | null
    _sum: CotSessionSumAggregateOutputType | null
    _min: CotSessionMinAggregateOutputType | null
    _max: CotSessionMaxAggregateOutputType | null
  }

  type GetCotSessionGroupByPayload<T extends CotSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CotSessionGroupByOutputType[P]>
        }
      >
    >


  export type CotSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    phases?: boolean | CotSession$phasesArgs<ExtArgs>
    drafts?: boolean | CotSession$draftsArgs<ExtArgs>
    _count?: boolean | CotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectScalar = {
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type CotSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | CotSession$phasesArgs<ExtArgs>
    drafts?: boolean | CotSession$draftsArgs<ExtArgs>
    _count?: boolean | CotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CotSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CotSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotSession"
    objects: {
      phases: Prisma.$CotPhasePayload<ExtArgs>[]
      drafts: Prisma.$CotDraftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      theme: string
      style: string
      platform: string
      status: $Enums.CotSessionStatus
      currentPhase: number
      currentStep: $Enums.CotPhaseStep
      lastError: string | null
      retryCount: number
      nextRetryAt: Date | null
      totalTokens: number
      totalDuration: number
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["cotSession"]>
    composites: {}
  }

  type CotSessionGetPayload<S extends boolean | null | undefined | CotSessionDefaultArgs> = $Result.GetResult<Prisma.$CotSessionPayload, S>

  type CotSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotSessionCountAggregateInputType | true
    }

  export interface CotSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotSession'], meta: { name: 'CotSession' } }
    /**
     * Find zero or one CotSession that matches the filter.
     * @param {CotSessionFindUniqueArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotSessionFindUniqueArgs>(args: SelectSubset<T, CotSessionFindUniqueArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotSessionFindUniqueOrThrowArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CotSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindFirstArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotSessionFindFirstArgs>(args?: SelectSubset<T, CotSessionFindFirstArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindFirstOrThrowArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CotSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotSessions
     * const cotSessions = await prisma.cotSession.findMany()
     * 
     * // Get first 10 CotSessions
     * const cotSessions = await prisma.cotSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotSessionFindManyArgs>(args?: SelectSubset<T, CotSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotSession.
     * @param {CotSessionCreateArgs} args - Arguments to create a CotSession.
     * @example
     * // Create one CotSession
     * const CotSession = await prisma.cotSession.create({
     *   data: {
     *     // ... data to create a CotSession
     *   }
     * })
     * 
     */
    create<T extends CotSessionCreateArgs>(args: SelectSubset<T, CotSessionCreateArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotSessions.
     * @param {CotSessionCreateManyArgs} args - Arguments to create many CotSessions.
     * @example
     * // Create many CotSessions
     * const cotSession = await prisma.cotSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotSessionCreateManyArgs>(args?: SelectSubset<T, CotSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotSessions and returns the data saved in the database.
     * @param {CotSessionCreateManyAndReturnArgs} args - Arguments to create many CotSessions.
     * @example
     * // Create many CotSessions
     * const cotSession = await prisma.cotSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotSessions and only return the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CotSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotSession.
     * @param {CotSessionDeleteArgs} args - Arguments to delete one CotSession.
     * @example
     * // Delete one CotSession
     * const CotSession = await prisma.cotSession.delete({
     *   where: {
     *     // ... filter to delete one CotSession
     *   }
     * })
     * 
     */
    delete<T extends CotSessionDeleteArgs>(args: SelectSubset<T, CotSessionDeleteArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotSession.
     * @param {CotSessionUpdateArgs} args - Arguments to update one CotSession.
     * @example
     * // Update one CotSession
     * const cotSession = await prisma.cotSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotSessionUpdateArgs>(args: SelectSubset<T, CotSessionUpdateArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotSessions.
     * @param {CotSessionDeleteManyArgs} args - Arguments to filter CotSessions to delete.
     * @example
     * // Delete a few CotSessions
     * const { count } = await prisma.cotSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotSessionDeleteManyArgs>(args?: SelectSubset<T, CotSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotSessions
     * const cotSession = await prisma.cotSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotSessionUpdateManyArgs>(args: SelectSubset<T, CotSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotSession.
     * @param {CotSessionUpsertArgs} args - Arguments to update or create a CotSession.
     * @example
     * // Update or create a CotSession
     * const cotSession = await prisma.cotSession.upsert({
     *   create: {
     *     // ... data to create a CotSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotSession we want to update
     *   }
     * })
     */
    upsert<T extends CotSessionUpsertArgs>(args: SelectSubset<T, CotSessionUpsertArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionCountArgs} args - Arguments to filter CotSessions to count.
     * @example
     * // Count the number of CotSessions
     * const count = await prisma.cotSession.count({
     *   where: {
     *     // ... the filter for the CotSessions we want to count
     *   }
     * })
    **/
    count<T extends CotSessionCountArgs>(
      args?: Subset<T, CotSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotSessionAggregateArgs>(args: Subset<T, CotSessionAggregateArgs>): Prisma.PrismaPromise<GetCotSessionAggregateType<T>>

    /**
     * Group by CotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotSessionGroupByArgs['orderBy'] }
        : { orderBy?: CotSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotSession model
   */
  readonly fields: CotSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phases<T extends CotSession$phasesArgs<ExtArgs> = {}>(args?: Subset<T, CotSession$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findMany"> | Null>
    drafts<T extends CotSession$draftsArgs<ExtArgs> = {}>(args?: Subset<T, CotSession$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotSession model
   */ 
  interface CotSessionFieldRefs {
    readonly id: FieldRef<"CotSession", 'String'>
    readonly theme: FieldRef<"CotSession", 'String'>
    readonly style: FieldRef<"CotSession", 'String'>
    readonly platform: FieldRef<"CotSession", 'String'>
    readonly status: FieldRef<"CotSession", 'CotSessionStatus'>
    readonly currentPhase: FieldRef<"CotSession", 'Int'>
    readonly currentStep: FieldRef<"CotSession", 'CotPhaseStep'>
    readonly lastError: FieldRef<"CotSession", 'String'>
    readonly retryCount: FieldRef<"CotSession", 'Int'>
    readonly nextRetryAt: FieldRef<"CotSession", 'DateTime'>
    readonly totalTokens: FieldRef<"CotSession", 'Int'>
    readonly totalDuration: FieldRef<"CotSession", 'Int'>
    readonly createdAt: FieldRef<"CotSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CotSession", 'DateTime'>
    readonly completedAt: FieldRef<"CotSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotSession findUnique
   */
  export type CotSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession findUniqueOrThrow
   */
  export type CotSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession findFirst
   */
  export type CotSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotSessions.
     */
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession findFirstOrThrow
   */
  export type CotSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotSessions.
     */
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession findMany
   */
  export type CotSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSessions to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession create
   */
  export type CotSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CotSession.
     */
    data: XOR<CotSessionCreateInput, CotSessionUncheckedCreateInput>
  }

  /**
   * CotSession createMany
   */
  export type CotSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotSessions.
     */
    data: CotSessionCreateManyInput | CotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotSession createManyAndReturn
   */
  export type CotSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotSessions.
     */
    data: CotSessionCreateManyInput | CotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotSession update
   */
  export type CotSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CotSession.
     */
    data: XOR<CotSessionUpdateInput, CotSessionUncheckedUpdateInput>
    /**
     * Choose, which CotSession to update.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession updateMany
   */
  export type CotSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotSessions.
     */
    data: XOR<CotSessionUpdateManyMutationInput, CotSessionUncheckedUpdateManyInput>
    /**
     * Filter which CotSessions to update
     */
    where?: CotSessionWhereInput
  }

  /**
   * CotSession upsert
   */
  export type CotSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CotSession to update in case it exists.
     */
    where: CotSessionWhereUniqueInput
    /**
     * In case the CotSession found by the `where` argument doesn't exist, create a new CotSession with this data.
     */
    create: XOR<CotSessionCreateInput, CotSessionUncheckedCreateInput>
    /**
     * In case the CotSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotSessionUpdateInput, CotSessionUncheckedUpdateInput>
  }

  /**
   * CotSession delete
   */
  export type CotSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter which CotSession to delete.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession deleteMany
   */
  export type CotSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotSessions to delete
     */
    where?: CotSessionWhereInput
  }

  /**
   * CotSession.phases
   */
  export type CotSession$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    where?: CotPhaseWhereInput
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    cursor?: CotPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotSession.drafts
   */
  export type CotSession$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    where?: CotDraftWhereInput
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    cursor?: CotDraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotSession without action
   */
  export type CotSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
  }


  /**
   * Model CotPhase
   */

  export type AggregateCotPhase = {
    _count: CotPhaseCountAggregateOutputType | null
    _avg: CotPhaseAvgAggregateOutputType | null
    _sum: CotPhaseSumAggregateOutputType | null
    _min: CotPhaseMinAggregateOutputType | null
    _max: CotPhaseMaxAggregateOutputType | null
  }

  export type CotPhaseAvgAggregateOutputType = {
    phaseNumber: number | null
    thinkTokens: number | null
    executeDuration: number | null
    integrateTokens: number | null
  }

  export type CotPhaseSumAggregateOutputType = {
    phaseNumber: number | null
    thinkTokens: number | null
    executeDuration: number | null
    integrateTokens: number | null
  }

  export type CotPhaseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phaseNumber: number | null
    thinkPrompt: string | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotPhaseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phaseNumber: number | null
    thinkPrompt: string | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotPhaseCountAggregateOutputType = {
    id: number
    sessionId: number
    phaseNumber: number
    thinkPrompt: number
    thinkResult: number
    thinkTokens: number
    thinkAt: number
    executeResult: number
    executeDuration: number
    executeAt: number
    integratePrompt: number
    integrateResult: number
    integrateTokens: number
    integrateAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CotPhaseAvgAggregateInputType = {
    phaseNumber?: true
    thinkTokens?: true
    executeDuration?: true
    integrateTokens?: true
  }

  export type CotPhaseSumAggregateInputType = {
    phaseNumber?: true
    thinkTokens?: true
    executeDuration?: true
    integrateTokens?: true
  }

  export type CotPhaseMinAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkTokens?: true
    thinkAt?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotPhaseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkTokens?: true
    thinkAt?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotPhaseCountAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkResult?: true
    thinkTokens?: true
    thinkAt?: true
    executeResult?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateResult?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CotPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotPhase to aggregate.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotPhases
    **/
    _count?: true | CotPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotPhaseMaxAggregateInputType
  }

  export type GetCotPhaseAggregateType<T extends CotPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCotPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotPhase[P]>
      : GetScalarType<T[P], AggregateCotPhase[P]>
  }




  export type CotPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotPhaseWhereInput
    orderBy?: CotPhaseOrderByWithAggregationInput | CotPhaseOrderByWithAggregationInput[]
    by: CotPhaseScalarFieldEnum[] | CotPhaseScalarFieldEnum
    having?: CotPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotPhaseCountAggregateInputType | true
    _avg?: CotPhaseAvgAggregateInputType
    _sum?: CotPhaseSumAggregateInputType
    _min?: CotPhaseMinAggregateInputType
    _max?: CotPhaseMaxAggregateInputType
  }

  export type CotPhaseGroupByOutputType = {
    id: string
    sessionId: string
    phaseNumber: number
    thinkPrompt: string | null
    thinkResult: JsonValue | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeResult: JsonValue | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateResult: JsonValue | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus
    createdAt: Date
    updatedAt: Date
    _count: CotPhaseCountAggregateOutputType | null
    _avg: CotPhaseAvgAggregateOutputType | null
    _sum: CotPhaseSumAggregateOutputType | null
    _min: CotPhaseMinAggregateOutputType | null
    _max: CotPhaseMaxAggregateOutputType | null
  }

  type GetCotPhaseGroupByPayload<T extends CotPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], CotPhaseGroupByOutputType[P]>
        }
      >
    >


  export type CotPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CotPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }
  export type CotPhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }

  export type $CotPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotPhase"
    objects: {
      session: Prisma.$CotSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      phaseNumber: number
      thinkPrompt: string | null
      thinkResult: Prisma.JsonValue | null
      thinkTokens: number | null
      thinkAt: Date | null
      executeResult: Prisma.JsonValue | null
      executeDuration: number | null
      executeAt: Date | null
      integratePrompt: string | null
      integrateResult: Prisma.JsonValue | null
      integrateTokens: number | null
      integrateAt: Date | null
      status: $Enums.CotPhaseStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cotPhase"]>
    composites: {}
  }

  type CotPhaseGetPayload<S extends boolean | null | undefined | CotPhaseDefaultArgs> = $Result.GetResult<Prisma.$CotPhasePayload, S>

  type CotPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotPhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotPhaseCountAggregateInputType | true
    }

  export interface CotPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotPhase'], meta: { name: 'CotPhase' } }
    /**
     * Find zero or one CotPhase that matches the filter.
     * @param {CotPhaseFindUniqueArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotPhaseFindUniqueArgs>(args: SelectSubset<T, CotPhaseFindUniqueArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotPhase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotPhaseFindUniqueOrThrowArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CotPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindFirstArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotPhaseFindFirstArgs>(args?: SelectSubset<T, CotPhaseFindFirstArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindFirstOrThrowArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CotPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotPhases
     * const cotPhases = await prisma.cotPhase.findMany()
     * 
     * // Get first 10 CotPhases
     * const cotPhases = await prisma.cotPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotPhaseFindManyArgs>(args?: SelectSubset<T, CotPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotPhase.
     * @param {CotPhaseCreateArgs} args - Arguments to create a CotPhase.
     * @example
     * // Create one CotPhase
     * const CotPhase = await prisma.cotPhase.create({
     *   data: {
     *     // ... data to create a CotPhase
     *   }
     * })
     * 
     */
    create<T extends CotPhaseCreateArgs>(args: SelectSubset<T, CotPhaseCreateArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotPhases.
     * @param {CotPhaseCreateManyArgs} args - Arguments to create many CotPhases.
     * @example
     * // Create many CotPhases
     * const cotPhase = await prisma.cotPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotPhaseCreateManyArgs>(args?: SelectSubset<T, CotPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotPhases and returns the data saved in the database.
     * @param {CotPhaseCreateManyAndReturnArgs} args - Arguments to create many CotPhases.
     * @example
     * // Create many CotPhases
     * const cotPhase = await prisma.cotPhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotPhases and only return the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotPhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CotPhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotPhase.
     * @param {CotPhaseDeleteArgs} args - Arguments to delete one CotPhase.
     * @example
     * // Delete one CotPhase
     * const CotPhase = await prisma.cotPhase.delete({
     *   where: {
     *     // ... filter to delete one CotPhase
     *   }
     * })
     * 
     */
    delete<T extends CotPhaseDeleteArgs>(args: SelectSubset<T, CotPhaseDeleteArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotPhase.
     * @param {CotPhaseUpdateArgs} args - Arguments to update one CotPhase.
     * @example
     * // Update one CotPhase
     * const cotPhase = await prisma.cotPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotPhaseUpdateArgs>(args: SelectSubset<T, CotPhaseUpdateArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotPhases.
     * @param {CotPhaseDeleteManyArgs} args - Arguments to filter CotPhases to delete.
     * @example
     * // Delete a few CotPhases
     * const { count } = await prisma.cotPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotPhaseDeleteManyArgs>(args?: SelectSubset<T, CotPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotPhases
     * const cotPhase = await prisma.cotPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotPhaseUpdateManyArgs>(args: SelectSubset<T, CotPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotPhase.
     * @param {CotPhaseUpsertArgs} args - Arguments to update or create a CotPhase.
     * @example
     * // Update or create a CotPhase
     * const cotPhase = await prisma.cotPhase.upsert({
     *   create: {
     *     // ... data to create a CotPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotPhase we want to update
     *   }
     * })
     */
    upsert<T extends CotPhaseUpsertArgs>(args: SelectSubset<T, CotPhaseUpsertArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseCountArgs} args - Arguments to filter CotPhases to count.
     * @example
     * // Count the number of CotPhases
     * const count = await prisma.cotPhase.count({
     *   where: {
     *     // ... the filter for the CotPhases we want to count
     *   }
     * })
    **/
    count<T extends CotPhaseCountArgs>(
      args?: Subset<T, CotPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotPhaseAggregateArgs>(args: Subset<T, CotPhaseAggregateArgs>): Prisma.PrismaPromise<GetCotPhaseAggregateType<T>>

    /**
     * Group by CotPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotPhaseGroupByArgs['orderBy'] }
        : { orderBy?: CotPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotPhase model
   */
  readonly fields: CotPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotSessionDefaultArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotPhase model
   */ 
  interface CotPhaseFieldRefs {
    readonly id: FieldRef<"CotPhase", 'String'>
    readonly sessionId: FieldRef<"CotPhase", 'String'>
    readonly phaseNumber: FieldRef<"CotPhase", 'Int'>
    readonly thinkPrompt: FieldRef<"CotPhase", 'String'>
    readonly thinkResult: FieldRef<"CotPhase", 'Json'>
    readonly thinkTokens: FieldRef<"CotPhase", 'Int'>
    readonly thinkAt: FieldRef<"CotPhase", 'DateTime'>
    readonly executeResult: FieldRef<"CotPhase", 'Json'>
    readonly executeDuration: FieldRef<"CotPhase", 'Int'>
    readonly executeAt: FieldRef<"CotPhase", 'DateTime'>
    readonly integratePrompt: FieldRef<"CotPhase", 'String'>
    readonly integrateResult: FieldRef<"CotPhase", 'Json'>
    readonly integrateTokens: FieldRef<"CotPhase", 'Int'>
    readonly integrateAt: FieldRef<"CotPhase", 'DateTime'>
    readonly status: FieldRef<"CotPhase", 'CotPhaseStatus'>
    readonly createdAt: FieldRef<"CotPhase", 'DateTime'>
    readonly updatedAt: FieldRef<"CotPhase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotPhase findUnique
   */
  export type CotPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase findUniqueOrThrow
   */
  export type CotPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase findFirst
   */
  export type CotPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotPhases.
     */
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase findFirstOrThrow
   */
  export type CotPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotPhases.
     */
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase findMany
   */
  export type CotPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhases to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase create
   */
  export type CotPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CotPhase.
     */
    data: XOR<CotPhaseCreateInput, CotPhaseUncheckedCreateInput>
  }

  /**
   * CotPhase createMany
   */
  export type CotPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotPhases.
     */
    data: CotPhaseCreateManyInput | CotPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotPhase createManyAndReturn
   */
  export type CotPhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotPhases.
     */
    data: CotPhaseCreateManyInput | CotPhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotPhase update
   */
  export type CotPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CotPhase.
     */
    data: XOR<CotPhaseUpdateInput, CotPhaseUncheckedUpdateInput>
    /**
     * Choose, which CotPhase to update.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase updateMany
   */
  export type CotPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotPhases.
     */
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyInput>
    /**
     * Filter which CotPhases to update
     */
    where?: CotPhaseWhereInput
  }

  /**
   * CotPhase upsert
   */
  export type CotPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CotPhase to update in case it exists.
     */
    where: CotPhaseWhereUniqueInput
    /**
     * In case the CotPhase found by the `where` argument doesn't exist, create a new CotPhase with this data.
     */
    create: XOR<CotPhaseCreateInput, CotPhaseUncheckedCreateInput>
    /**
     * In case the CotPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotPhaseUpdateInput, CotPhaseUncheckedUpdateInput>
  }

  /**
   * CotPhase delete
   */
  export type CotPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter which CotPhase to delete.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase deleteMany
   */
  export type CotPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotPhases to delete
     */
    where?: CotPhaseWhereInput
  }

  /**
   * CotPhase without action
   */
  export type CotPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
  }


  /**
   * Model CotDraft
   */

  export type AggregateCotDraft = {
    _count: CotDraftCountAggregateOutputType | null
    _avg: CotDraftAvgAggregateOutputType | null
    _sum: CotDraftSumAggregateOutputType | null
    _min: CotDraftMinAggregateOutputType | null
    _max: CotDraftMaxAggregateOutputType | null
  }

  export type CotDraftAvgAggregateOutputType = {
    conceptNumber: number | null
    viralScore: number | null
  }

  export type CotDraftSumAggregateOutputType = {
    conceptNumber: number | null
    viralScore: number | null
  }

  export type CotDraftMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptNumber: number | null
    title: string | null
    hook: string | null
    angle: string | null
    format: string | null
    content: string | null
    visualGuide: string | null
    timing: string | null
    newsSource: string | null
    sourceUrl: string | null
    status: $Enums.CotDraftStatus | null
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotDraftMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptNumber: number | null
    title: string | null
    hook: string | null
    angle: string | null
    format: string | null
    content: string | null
    visualGuide: string | null
    timing: string | null
    newsSource: string | null
    sourceUrl: string | null
    status: $Enums.CotDraftStatus | null
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotDraftCountAggregateOutputType = {
    id: number
    sessionId: number
    conceptNumber: number
    title: number
    hook: number
    angle: number
    format: number
    content: number
    visualGuide: number
    timing: number
    hashtags: number
    newsSource: number
    sourceUrl: number
    kpis: number
    riskAssessment: number
    optimizationTips: number
    status: number
    editedContent: number
    scheduledAt: number
    postedAt: number
    postId: number
    viralScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CotDraftAvgAggregateInputType = {
    conceptNumber?: true
    viralScore?: true
  }

  export type CotDraftSumAggregateInputType = {
    conceptNumber?: true
    viralScore?: true
  }

  export type CotDraftMinAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    newsSource?: true
    sourceUrl?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotDraftMaxAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    newsSource?: true
    sourceUrl?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotDraftCountAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    hashtags?: true
    newsSource?: true
    sourceUrl?: true
    kpis?: true
    riskAssessment?: true
    optimizationTips?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CotDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraft to aggregate.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotDrafts
    **/
    _count?: true | CotDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotDraftMaxAggregateInputType
  }

  export type GetCotDraftAggregateType<T extends CotDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateCotDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotDraft[P]>
      : GetScalarType<T[P], AggregateCotDraft[P]>
  }




  export type CotDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftWhereInput
    orderBy?: CotDraftOrderByWithAggregationInput | CotDraftOrderByWithAggregationInput[]
    by: CotDraftScalarFieldEnum[] | CotDraftScalarFieldEnum
    having?: CotDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotDraftCountAggregateInputType | true
    _avg?: CotDraftAvgAggregateInputType
    _sum?: CotDraftSumAggregateInputType
    _min?: CotDraftMinAggregateInputType
    _max?: CotDraftMaxAggregateInputType
  }

  export type CotDraftGroupByOutputType = {
    id: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content: string | null
    visualGuide: string | null
    timing: string
    hashtags: string[]
    newsSource: string | null
    sourceUrl: string | null
    kpis: JsonValue | null
    riskAssessment: JsonValue | null
    optimizationTips: JsonValue | null
    status: $Enums.CotDraftStatus
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: CotDraftCountAggregateOutputType | null
    _avg: CotDraftAvgAggregateOutputType | null
    _sum: CotDraftSumAggregateOutputType | null
    _min: CotDraftMinAggregateOutputType | null
    _max: CotDraftMaxAggregateOutputType | null
  }

  type GetCotDraftGroupByPayload<T extends CotDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotDraftGroupByOutputType[P]>
            : GetScalarType<T[P], CotDraftGroupByOutputType[P]>
        }
      >
    >


  export type CotDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
    performance?: boolean | CotDraft$performanceArgs<ExtArgs>
    scheduledRTs?: boolean | CotDraft$scheduledRTsArgs<ExtArgs>
    _count?: boolean | CotDraftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectScalar = {
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CotDraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
    performance?: boolean | CotDraft$performanceArgs<ExtArgs>
    scheduledRTs?: boolean | CotDraft$scheduledRTsArgs<ExtArgs>
    _count?: boolean | CotDraftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CotDraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }

  export type $CotDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotDraft"
    objects: {
      session: Prisma.$CotSessionPayload<ExtArgs>
      performance: Prisma.$CotDraftPerformancePayload<ExtArgs> | null
      scheduledRTs: Prisma.$ScheduledRetweetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      conceptNumber: number
      title: string
      hook: string
      angle: string
      format: string
      content: string | null
      visualGuide: string | null
      timing: string
      hashtags: string[]
      newsSource: string | null
      sourceUrl: string | null
      kpis: Prisma.JsonValue | null
      riskAssessment: Prisma.JsonValue | null
      optimizationTips: Prisma.JsonValue | null
      status: $Enums.CotDraftStatus
      editedContent: string | null
      scheduledAt: Date | null
      postedAt: Date | null
      postId: string | null
      viralScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cotDraft"]>
    composites: {}
  }

  type CotDraftGetPayload<S extends boolean | null | undefined | CotDraftDefaultArgs> = $Result.GetResult<Prisma.$CotDraftPayload, S>

  type CotDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotDraftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotDraftCountAggregateInputType | true
    }

  export interface CotDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotDraft'], meta: { name: 'CotDraft' } }
    /**
     * Find zero or one CotDraft that matches the filter.
     * @param {CotDraftFindUniqueArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotDraftFindUniqueArgs>(args: SelectSubset<T, CotDraftFindUniqueArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotDraft that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotDraftFindUniqueOrThrowArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotDraftFindUniqueOrThrowArgs>(args: SelectSubset<T, CotDraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindFirstArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotDraftFindFirstArgs>(args?: SelectSubset<T, CotDraftFindFirstArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindFirstOrThrowArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotDraftFindFirstOrThrowArgs>(args?: SelectSubset<T, CotDraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotDrafts
     * const cotDrafts = await prisma.cotDraft.findMany()
     * 
     * // Get first 10 CotDrafts
     * const cotDrafts = await prisma.cotDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotDraftFindManyArgs>(args?: SelectSubset<T, CotDraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotDraft.
     * @param {CotDraftCreateArgs} args - Arguments to create a CotDraft.
     * @example
     * // Create one CotDraft
     * const CotDraft = await prisma.cotDraft.create({
     *   data: {
     *     // ... data to create a CotDraft
     *   }
     * })
     * 
     */
    create<T extends CotDraftCreateArgs>(args: SelectSubset<T, CotDraftCreateArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotDrafts.
     * @param {CotDraftCreateManyArgs} args - Arguments to create many CotDrafts.
     * @example
     * // Create many CotDrafts
     * const cotDraft = await prisma.cotDraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotDraftCreateManyArgs>(args?: SelectSubset<T, CotDraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotDrafts and returns the data saved in the database.
     * @param {CotDraftCreateManyAndReturnArgs} args - Arguments to create many CotDrafts.
     * @example
     * // Create many CotDrafts
     * const cotDraft = await prisma.cotDraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotDrafts and only return the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotDraftCreateManyAndReturnArgs>(args?: SelectSubset<T, CotDraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotDraft.
     * @param {CotDraftDeleteArgs} args - Arguments to delete one CotDraft.
     * @example
     * // Delete one CotDraft
     * const CotDraft = await prisma.cotDraft.delete({
     *   where: {
     *     // ... filter to delete one CotDraft
     *   }
     * })
     * 
     */
    delete<T extends CotDraftDeleteArgs>(args: SelectSubset<T, CotDraftDeleteArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotDraft.
     * @param {CotDraftUpdateArgs} args - Arguments to update one CotDraft.
     * @example
     * // Update one CotDraft
     * const cotDraft = await prisma.cotDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotDraftUpdateArgs>(args: SelectSubset<T, CotDraftUpdateArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotDrafts.
     * @param {CotDraftDeleteManyArgs} args - Arguments to filter CotDrafts to delete.
     * @example
     * // Delete a few CotDrafts
     * const { count } = await prisma.cotDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotDraftDeleteManyArgs>(args?: SelectSubset<T, CotDraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotDrafts
     * const cotDraft = await prisma.cotDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotDraftUpdateManyArgs>(args: SelectSubset<T, CotDraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotDraft.
     * @param {CotDraftUpsertArgs} args - Arguments to update or create a CotDraft.
     * @example
     * // Update or create a CotDraft
     * const cotDraft = await prisma.cotDraft.upsert({
     *   create: {
     *     // ... data to create a CotDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotDraft we want to update
     *   }
     * })
     */
    upsert<T extends CotDraftUpsertArgs>(args: SelectSubset<T, CotDraftUpsertArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftCountArgs} args - Arguments to filter CotDrafts to count.
     * @example
     * // Count the number of CotDrafts
     * const count = await prisma.cotDraft.count({
     *   where: {
     *     // ... the filter for the CotDrafts we want to count
     *   }
     * })
    **/
    count<T extends CotDraftCountArgs>(
      args?: Subset<T, CotDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotDraftAggregateArgs>(args: Subset<T, CotDraftAggregateArgs>): Prisma.PrismaPromise<GetCotDraftAggregateType<T>>

    /**
     * Group by CotDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotDraftGroupByArgs['orderBy'] }
        : { orderBy?: CotDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotDraft model
   */
  readonly fields: CotDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotSessionDefaultArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    performance<T extends CotDraft$performanceArgs<ExtArgs> = {}>(args?: Subset<T, CotDraft$performanceArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    scheduledRTs<T extends CotDraft$scheduledRTsArgs<ExtArgs> = {}>(args?: Subset<T, CotDraft$scheduledRTsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotDraft model
   */ 
  interface CotDraftFieldRefs {
    readonly id: FieldRef<"CotDraft", 'String'>
    readonly sessionId: FieldRef<"CotDraft", 'String'>
    readonly conceptNumber: FieldRef<"CotDraft", 'Int'>
    readonly title: FieldRef<"CotDraft", 'String'>
    readonly hook: FieldRef<"CotDraft", 'String'>
    readonly angle: FieldRef<"CotDraft", 'String'>
    readonly format: FieldRef<"CotDraft", 'String'>
    readonly content: FieldRef<"CotDraft", 'String'>
    readonly visualGuide: FieldRef<"CotDraft", 'String'>
    readonly timing: FieldRef<"CotDraft", 'String'>
    readonly hashtags: FieldRef<"CotDraft", 'String[]'>
    readonly newsSource: FieldRef<"CotDraft", 'String'>
    readonly sourceUrl: FieldRef<"CotDraft", 'String'>
    readonly kpis: FieldRef<"CotDraft", 'Json'>
    readonly riskAssessment: FieldRef<"CotDraft", 'Json'>
    readonly optimizationTips: FieldRef<"CotDraft", 'Json'>
    readonly status: FieldRef<"CotDraft", 'CotDraftStatus'>
    readonly editedContent: FieldRef<"CotDraft", 'String'>
    readonly scheduledAt: FieldRef<"CotDraft", 'DateTime'>
    readonly postedAt: FieldRef<"CotDraft", 'DateTime'>
    readonly postId: FieldRef<"CotDraft", 'String'>
    readonly viralScore: FieldRef<"CotDraft", 'Float'>
    readonly createdAt: FieldRef<"CotDraft", 'DateTime'>
    readonly updatedAt: FieldRef<"CotDraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotDraft findUnique
   */
  export type CotDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft findUniqueOrThrow
   */
  export type CotDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft findFirst
   */
  export type CotDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDrafts.
     */
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft findFirstOrThrow
   */
  export type CotDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDrafts.
     */
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft findMany
   */
  export type CotDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDrafts to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft create
   */
  export type CotDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The data needed to create a CotDraft.
     */
    data: XOR<CotDraftCreateInput, CotDraftUncheckedCreateInput>
  }

  /**
   * CotDraft createMany
   */
  export type CotDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotDrafts.
     */
    data: CotDraftCreateManyInput | CotDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotDraft createManyAndReturn
   */
  export type CotDraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotDrafts.
     */
    data: CotDraftCreateManyInput | CotDraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraft update
   */
  export type CotDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The data needed to update a CotDraft.
     */
    data: XOR<CotDraftUpdateInput, CotDraftUncheckedUpdateInput>
    /**
     * Choose, which CotDraft to update.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft updateMany
   */
  export type CotDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotDrafts.
     */
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyInput>
    /**
     * Filter which CotDrafts to update
     */
    where?: CotDraftWhereInput
  }

  /**
   * CotDraft upsert
   */
  export type CotDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The filter to search for the CotDraft to update in case it exists.
     */
    where: CotDraftWhereUniqueInput
    /**
     * In case the CotDraft found by the `where` argument doesn't exist, create a new CotDraft with this data.
     */
    create: XOR<CotDraftCreateInput, CotDraftUncheckedCreateInput>
    /**
     * In case the CotDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotDraftUpdateInput, CotDraftUncheckedUpdateInput>
  }

  /**
   * CotDraft delete
   */
  export type CotDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter which CotDraft to delete.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft deleteMany
   */
  export type CotDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDrafts to delete
     */
    where?: CotDraftWhereInput
  }

  /**
   * CotDraft.performance
   */
  export type CotDraft$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraft.scheduledRTs
   */
  export type CotDraft$scheduledRTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    where?: ScheduledRetweetWhereInput
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    cursor?: ScheduledRetweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * CotDraft without action
   */
  export type CotDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
  }


  /**
   * Model CotDraftPerformance
   */

  export type AggregateCotDraftPerformance = {
    _count: CotDraftPerformanceCountAggregateOutputType | null
    _avg: CotDraftPerformanceAvgAggregateOutputType | null
    _sum: CotDraftPerformanceSumAggregateOutputType | null
    _min: CotDraftPerformanceMinAggregateOutputType | null
    _max: CotDraftPerformanceMaxAggregateOutputType | null
  }

  export type CotDraftPerformanceAvgAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type CotDraftPerformanceSumAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type CotDraftPerformanceMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    lastUpdateAt: Date | null
  }

  export type CotDraftPerformanceMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    lastUpdateAt: Date | null
  }

  export type CotDraftPerformanceCountAggregateOutputType = {
    id: number
    draftId: number
    likes30m: number
    retweets30m: number
    replies30m: number
    impressions30m: number
    likes1h: number
    retweets1h: number
    replies1h: number
    impressions1h: number
    likes24h: number
    retweets24h: number
    replies24h: number
    impressions24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    lastUpdateAt: number
    _all: number
  }


  export type CotDraftPerformanceAvgAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type CotDraftPerformanceSumAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type CotDraftPerformanceMinAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
  }

  export type CotDraftPerformanceMaxAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
  }

  export type CotDraftPerformanceCountAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
    _all?: true
  }

  export type CotDraftPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraftPerformance to aggregate.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotDraftPerformances
    **/
    _count?: true | CotDraftPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotDraftPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotDraftPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotDraftPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotDraftPerformanceMaxAggregateInputType
  }

  export type GetCotDraftPerformanceAggregateType<T extends CotDraftPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCotDraftPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotDraftPerformance[P]>
      : GetScalarType<T[P], AggregateCotDraftPerformance[P]>
  }




  export type CotDraftPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftPerformanceWhereInput
    orderBy?: CotDraftPerformanceOrderByWithAggregationInput | CotDraftPerformanceOrderByWithAggregationInput[]
    by: CotDraftPerformanceScalarFieldEnum[] | CotDraftPerformanceScalarFieldEnum
    having?: CotDraftPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotDraftPerformanceCountAggregateInputType | true
    _avg?: CotDraftPerformanceAvgAggregateInputType
    _sum?: CotDraftPerformanceSumAggregateInputType
    _min?: CotDraftPerformanceMinAggregateInputType
    _max?: CotDraftPerformanceMaxAggregateInputType
  }

  export type CotDraftPerformanceGroupByOutputType = {
    id: string
    draftId: string
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    lastUpdateAt: Date
    _count: CotDraftPerformanceCountAggregateOutputType | null
    _avg: CotDraftPerformanceAvgAggregateOutputType | null
    _sum: CotDraftPerformanceSumAggregateOutputType | null
    _min: CotDraftPerformanceMinAggregateOutputType | null
    _max: CotDraftPerformanceMaxAggregateOutputType | null
  }

  type GetCotDraftPerformanceGroupByPayload<T extends CotDraftPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotDraftPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotDraftPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotDraftPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], CotDraftPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type CotDraftPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectScalar = {
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
  }

  export type CotDraftPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }
  export type CotDraftPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }

  export type $CotDraftPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotDraftPerformance"
    objects: {
      draft: Prisma.$CotDraftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      likes30m: number | null
      retweets30m: number | null
      replies30m: number | null
      impressions30m: number | null
      likes1h: number | null
      retweets1h: number | null
      replies1h: number | null
      impressions1h: number | null
      likes24h: number | null
      retweets24h: number | null
      replies24h: number | null
      impressions24h: number | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      lastUpdateAt: Date
    }, ExtArgs["result"]["cotDraftPerformance"]>
    composites: {}
  }

  type CotDraftPerformanceGetPayload<S extends boolean | null | undefined | CotDraftPerformanceDefaultArgs> = $Result.GetResult<Prisma.$CotDraftPerformancePayload, S>

  type CotDraftPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotDraftPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotDraftPerformanceCountAggregateInputType | true
    }

  export interface CotDraftPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotDraftPerformance'], meta: { name: 'CotDraftPerformance' } }
    /**
     * Find zero or one CotDraftPerformance that matches the filter.
     * @param {CotDraftPerformanceFindUniqueArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotDraftPerformanceFindUniqueArgs>(args: SelectSubset<T, CotDraftPerformanceFindUniqueArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotDraftPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotDraftPerformanceFindUniqueOrThrowArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotDraftPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotDraftPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindFirstArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotDraftPerformanceFindFirstArgs>(args?: SelectSubset<T, CotDraftPerformanceFindFirstArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotDraftPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindFirstOrThrowArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotDraftPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotDraftPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotDraftPerformances
     * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany()
     * 
     * // Get first 10 CotDraftPerformances
     * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotDraftPerformanceFindManyArgs>(args?: SelectSubset<T, CotDraftPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotDraftPerformance.
     * @param {CotDraftPerformanceCreateArgs} args - Arguments to create a CotDraftPerformance.
     * @example
     * // Create one CotDraftPerformance
     * const CotDraftPerformance = await prisma.cotDraftPerformance.create({
     *   data: {
     *     // ... data to create a CotDraftPerformance
     *   }
     * })
     * 
     */
    create<T extends CotDraftPerformanceCreateArgs>(args: SelectSubset<T, CotDraftPerformanceCreateArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotDraftPerformances.
     * @param {CotDraftPerformanceCreateManyArgs} args - Arguments to create many CotDraftPerformances.
     * @example
     * // Create many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotDraftPerformanceCreateManyArgs>(args?: SelectSubset<T, CotDraftPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotDraftPerformances and returns the data saved in the database.
     * @param {CotDraftPerformanceCreateManyAndReturnArgs} args - Arguments to create many CotDraftPerformances.
     * @example
     * // Create many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotDraftPerformances and only return the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotDraftPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotDraftPerformance.
     * @param {CotDraftPerformanceDeleteArgs} args - Arguments to delete one CotDraftPerformance.
     * @example
     * // Delete one CotDraftPerformance
     * const CotDraftPerformance = await prisma.cotDraftPerformance.delete({
     *   where: {
     *     // ... filter to delete one CotDraftPerformance
     *   }
     * })
     * 
     */
    delete<T extends CotDraftPerformanceDeleteArgs>(args: SelectSubset<T, CotDraftPerformanceDeleteArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotDraftPerformance.
     * @param {CotDraftPerformanceUpdateArgs} args - Arguments to update one CotDraftPerformance.
     * @example
     * // Update one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotDraftPerformanceUpdateArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotDraftPerformances.
     * @param {CotDraftPerformanceDeleteManyArgs} args - Arguments to filter CotDraftPerformances to delete.
     * @example
     * // Delete a few CotDraftPerformances
     * const { count } = await prisma.cotDraftPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotDraftPerformanceDeleteManyArgs>(args?: SelectSubset<T, CotDraftPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotDraftPerformanceUpdateManyArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotDraftPerformance.
     * @param {CotDraftPerformanceUpsertArgs} args - Arguments to update or create a CotDraftPerformance.
     * @example
     * // Update or create a CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.upsert({
     *   create: {
     *     // ... data to create a CotDraftPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotDraftPerformance we want to update
     *   }
     * })
     */
    upsert<T extends CotDraftPerformanceUpsertArgs>(args: SelectSubset<T, CotDraftPerformanceUpsertArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceCountArgs} args - Arguments to filter CotDraftPerformances to count.
     * @example
     * // Count the number of CotDraftPerformances
     * const count = await prisma.cotDraftPerformance.count({
     *   where: {
     *     // ... the filter for the CotDraftPerformances we want to count
     *   }
     * })
    **/
    count<T extends CotDraftPerformanceCountArgs>(
      args?: Subset<T, CotDraftPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotDraftPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotDraftPerformanceAggregateArgs>(args: Subset<T, CotDraftPerformanceAggregateArgs>): Prisma.PrismaPromise<GetCotDraftPerformanceAggregateType<T>>

    /**
     * Group by CotDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotDraftPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotDraftPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: CotDraftPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotDraftPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotDraftPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotDraftPerformance model
   */
  readonly fields: CotDraftPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotDraftPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotDraftPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends CotDraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotDraftDefaultArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotDraftPerformance model
   */ 
  interface CotDraftPerformanceFieldRefs {
    readonly id: FieldRef<"CotDraftPerformance", 'String'>
    readonly draftId: FieldRef<"CotDraftPerformance", 'String'>
    readonly likes30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly likes1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly likes24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly engagementRate: FieldRef<"CotDraftPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"CotDraftPerformance", 'Float'>
    readonly collectedAt: FieldRef<"CotDraftPerformance", 'DateTime'>
    readonly lastUpdateAt: FieldRef<"CotDraftPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotDraftPerformance findUnique
   */
  export type CotDraftPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance findUniqueOrThrow
   */
  export type CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance findFirst
   */
  export type CotDraftPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDraftPerformances.
     */
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance findFirstOrThrow
   */
  export type CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDraftPerformances.
     */
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance findMany
   */
  export type CotDraftPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformances to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance create
   */
  export type CotDraftPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a CotDraftPerformance.
     */
    data: XOR<CotDraftPerformanceCreateInput, CotDraftPerformanceUncheckedCreateInput>
  }

  /**
   * CotDraftPerformance createMany
   */
  export type CotDraftPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotDraftPerformances.
     */
    data: CotDraftPerformanceCreateManyInput | CotDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotDraftPerformance createManyAndReturn
   */
  export type CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotDraftPerformances.
     */
    data: CotDraftPerformanceCreateManyInput | CotDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraftPerformance update
   */
  export type CotDraftPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a CotDraftPerformance.
     */
    data: XOR<CotDraftPerformanceUpdateInput, CotDraftPerformanceUncheckedUpdateInput>
    /**
     * Choose, which CotDraftPerformance to update.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance updateMany
   */
  export type CotDraftPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotDraftPerformances.
     */
    data: XOR<CotDraftPerformanceUpdateManyMutationInput, CotDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which CotDraftPerformances to update
     */
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraftPerformance upsert
   */
  export type CotDraftPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the CotDraftPerformance to update in case it exists.
     */
    where: CotDraftPerformanceWhereUniqueInput
    /**
     * In case the CotDraftPerformance found by the `where` argument doesn't exist, create a new CotDraftPerformance with this data.
     */
    create: XOR<CotDraftPerformanceCreateInput, CotDraftPerformanceUncheckedCreateInput>
    /**
     * In case the CotDraftPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotDraftPerformanceUpdateInput, CotDraftPerformanceUncheckedUpdateInput>
  }

  /**
   * CotDraftPerformance delete
   */
  export type CotDraftPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter which CotDraftPerformance to delete.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance deleteMany
   */
  export type CotDraftPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraftPerformances to delete
     */
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraftPerformance without action
   */
  export type CotDraftPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model UnifiedContentSource
   */

  export type AggregateUnifiedContentSource = {
    _count: UnifiedContentSourceCountAggregateOutputType | null
    _avg: UnifiedContentSourceAvgAggregateOutputType | null
    _sum: UnifiedContentSourceSumAggregateOutputType | null
    _min: UnifiedContentSourceMinAggregateOutputType | null
    _max: UnifiedContentSourceMaxAggregateOutputType | null
  }

  export type UnifiedContentSourceAvgAggregateOutputType = {
    importanceScore: number | null
    viralPotential: number | null
  }

  export type UnifiedContentSourceSumAggregateOutputType = {
    importanceScore: number | null
    viralPotential: number | null
  }

  export type UnifiedContentSourceMinAggregateOutputType = {
    id: string | null
    sourceType: string | null
    sourceId: string | null
    contentSummary: string | null
    importanceScore: number | null
    viralPotential: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedContentSourceMaxAggregateOutputType = {
    id: string | null
    sourceType: string | null
    sourceId: string | null
    contentSummary: string | null
    importanceScore: number | null
    viralPotential: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedContentSourceCountAggregateOutputType = {
    id: number
    sourceType: number
    sourceId: number
    contentSummary: number
    importanceScore: number
    viralPotential: number
    keywords: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnifiedContentSourceAvgAggregateInputType = {
    importanceScore?: true
    viralPotential?: true
  }

  export type UnifiedContentSourceSumAggregateInputType = {
    importanceScore?: true
    viralPotential?: true
  }

  export type UnifiedContentSourceMinAggregateInputType = {
    id?: true
    sourceType?: true
    sourceId?: true
    contentSummary?: true
    importanceScore?: true
    viralPotential?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnifiedContentSourceMaxAggregateInputType = {
    id?: true
    sourceType?: true
    sourceId?: true
    contentSummary?: true
    importanceScore?: true
    viralPotential?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnifiedContentSourceCountAggregateInputType = {
    id?: true
    sourceType?: true
    sourceId?: true
    contentSummary?: true
    importanceScore?: true
    viralPotential?: true
    keywords?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnifiedContentSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedContentSource to aggregate.
     */
    where?: UnifiedContentSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedContentSources to fetch.
     */
    orderBy?: UnifiedContentSourceOrderByWithRelationInput | UnifiedContentSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnifiedContentSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedContentSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedContentSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnifiedContentSources
    **/
    _count?: true | UnifiedContentSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnifiedContentSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnifiedContentSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnifiedContentSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnifiedContentSourceMaxAggregateInputType
  }

  export type GetUnifiedContentSourceAggregateType<T extends UnifiedContentSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateUnifiedContentSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnifiedContentSource[P]>
      : GetScalarType<T[P], AggregateUnifiedContentSource[P]>
  }




  export type UnifiedContentSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnifiedContentSourceWhereInput
    orderBy?: UnifiedContentSourceOrderByWithAggregationInput | UnifiedContentSourceOrderByWithAggregationInput[]
    by: UnifiedContentSourceScalarFieldEnum[] | UnifiedContentSourceScalarFieldEnum
    having?: UnifiedContentSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnifiedContentSourceCountAggregateInputType | true
    _avg?: UnifiedContentSourceAvgAggregateInputType
    _sum?: UnifiedContentSourceSumAggregateInputType
    _min?: UnifiedContentSourceMinAggregateInputType
    _max?: UnifiedContentSourceMaxAggregateInputType
  }

  export type UnifiedContentSourceGroupByOutputType = {
    id: string
    sourceType: string
    sourceId: string
    contentSummary: string | null
    importanceScore: number | null
    viralPotential: number | null
    keywords: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UnifiedContentSourceCountAggregateOutputType | null
    _avg: UnifiedContentSourceAvgAggregateOutputType | null
    _sum: UnifiedContentSourceSumAggregateOutputType | null
    _min: UnifiedContentSourceMinAggregateOutputType | null
    _max: UnifiedContentSourceMaxAggregateOutputType | null
  }

  type GetUnifiedContentSourceGroupByPayload<T extends UnifiedContentSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnifiedContentSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnifiedContentSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnifiedContentSourceGroupByOutputType[P]>
            : GetScalarType<T[P], UnifiedContentSourceGroupByOutputType[P]>
        }
      >
    >


  export type UnifiedContentSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceType?: boolean
    sourceId?: boolean
    contentSummary?: boolean
    importanceScore?: boolean
    viralPotential?: boolean
    keywords?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    integratedSessions?: boolean | UnifiedContentSource$integratedSessionsArgs<ExtArgs>
    _count?: boolean | UnifiedContentSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unifiedContentSource"]>

  export type UnifiedContentSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceType?: boolean
    sourceId?: boolean
    contentSummary?: boolean
    importanceScore?: boolean
    viralPotential?: boolean
    keywords?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedContentSource"]>

  export type UnifiedContentSourceSelectScalar = {
    id?: boolean
    sourceType?: boolean
    sourceId?: boolean
    contentSummary?: boolean
    importanceScore?: boolean
    viralPotential?: boolean
    keywords?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnifiedContentSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integratedSessions?: boolean | UnifiedContentSource$integratedSessionsArgs<ExtArgs>
    _count?: boolean | UnifiedContentSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnifiedContentSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnifiedContentSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnifiedContentSource"
    objects: {
      integratedSessions: Prisma.$IntegratedSessionSourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceType: string
      sourceId: string
      contentSummary: string | null
      importanceScore: number | null
      viralPotential: number | null
      keywords: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unifiedContentSource"]>
    composites: {}
  }

  type UnifiedContentSourceGetPayload<S extends boolean | null | undefined | UnifiedContentSourceDefaultArgs> = $Result.GetResult<Prisma.$UnifiedContentSourcePayload, S>

  type UnifiedContentSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnifiedContentSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnifiedContentSourceCountAggregateInputType | true
    }

  export interface UnifiedContentSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnifiedContentSource'], meta: { name: 'UnifiedContentSource' } }
    /**
     * Find zero or one UnifiedContentSource that matches the filter.
     * @param {UnifiedContentSourceFindUniqueArgs} args - Arguments to find a UnifiedContentSource
     * @example
     * // Get one UnifiedContentSource
     * const unifiedContentSource = await prisma.unifiedContentSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnifiedContentSourceFindUniqueArgs>(args: SelectSubset<T, UnifiedContentSourceFindUniqueArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnifiedContentSource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnifiedContentSourceFindUniqueOrThrowArgs} args - Arguments to find a UnifiedContentSource
     * @example
     * // Get one UnifiedContentSource
     * const unifiedContentSource = await prisma.unifiedContentSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnifiedContentSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, UnifiedContentSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnifiedContentSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceFindFirstArgs} args - Arguments to find a UnifiedContentSource
     * @example
     * // Get one UnifiedContentSource
     * const unifiedContentSource = await prisma.unifiedContentSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnifiedContentSourceFindFirstArgs>(args?: SelectSubset<T, UnifiedContentSourceFindFirstArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnifiedContentSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceFindFirstOrThrowArgs} args - Arguments to find a UnifiedContentSource
     * @example
     * // Get one UnifiedContentSource
     * const unifiedContentSource = await prisma.unifiedContentSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnifiedContentSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, UnifiedContentSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnifiedContentSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnifiedContentSources
     * const unifiedContentSources = await prisma.unifiedContentSource.findMany()
     * 
     * // Get first 10 UnifiedContentSources
     * const unifiedContentSources = await prisma.unifiedContentSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unifiedContentSourceWithIdOnly = await prisma.unifiedContentSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnifiedContentSourceFindManyArgs>(args?: SelectSubset<T, UnifiedContentSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnifiedContentSource.
     * @param {UnifiedContentSourceCreateArgs} args - Arguments to create a UnifiedContentSource.
     * @example
     * // Create one UnifiedContentSource
     * const UnifiedContentSource = await prisma.unifiedContentSource.create({
     *   data: {
     *     // ... data to create a UnifiedContentSource
     *   }
     * })
     * 
     */
    create<T extends UnifiedContentSourceCreateArgs>(args: SelectSubset<T, UnifiedContentSourceCreateArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnifiedContentSources.
     * @param {UnifiedContentSourceCreateManyArgs} args - Arguments to create many UnifiedContentSources.
     * @example
     * // Create many UnifiedContentSources
     * const unifiedContentSource = await prisma.unifiedContentSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnifiedContentSourceCreateManyArgs>(args?: SelectSubset<T, UnifiedContentSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnifiedContentSources and returns the data saved in the database.
     * @param {UnifiedContentSourceCreateManyAndReturnArgs} args - Arguments to create many UnifiedContentSources.
     * @example
     * // Create many UnifiedContentSources
     * const unifiedContentSource = await prisma.unifiedContentSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnifiedContentSources and only return the `id`
     * const unifiedContentSourceWithIdOnly = await prisma.unifiedContentSource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnifiedContentSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, UnifiedContentSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnifiedContentSource.
     * @param {UnifiedContentSourceDeleteArgs} args - Arguments to delete one UnifiedContentSource.
     * @example
     * // Delete one UnifiedContentSource
     * const UnifiedContentSource = await prisma.unifiedContentSource.delete({
     *   where: {
     *     // ... filter to delete one UnifiedContentSource
     *   }
     * })
     * 
     */
    delete<T extends UnifiedContentSourceDeleteArgs>(args: SelectSubset<T, UnifiedContentSourceDeleteArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnifiedContentSource.
     * @param {UnifiedContentSourceUpdateArgs} args - Arguments to update one UnifiedContentSource.
     * @example
     * // Update one UnifiedContentSource
     * const unifiedContentSource = await prisma.unifiedContentSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnifiedContentSourceUpdateArgs>(args: SelectSubset<T, UnifiedContentSourceUpdateArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnifiedContentSources.
     * @param {UnifiedContentSourceDeleteManyArgs} args - Arguments to filter UnifiedContentSources to delete.
     * @example
     * // Delete a few UnifiedContentSources
     * const { count } = await prisma.unifiedContentSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnifiedContentSourceDeleteManyArgs>(args?: SelectSubset<T, UnifiedContentSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedContentSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnifiedContentSources
     * const unifiedContentSource = await prisma.unifiedContentSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnifiedContentSourceUpdateManyArgs>(args: SelectSubset<T, UnifiedContentSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnifiedContentSource.
     * @param {UnifiedContentSourceUpsertArgs} args - Arguments to update or create a UnifiedContentSource.
     * @example
     * // Update or create a UnifiedContentSource
     * const unifiedContentSource = await prisma.unifiedContentSource.upsert({
     *   create: {
     *     // ... data to create a UnifiedContentSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnifiedContentSource we want to update
     *   }
     * })
     */
    upsert<T extends UnifiedContentSourceUpsertArgs>(args: SelectSubset<T, UnifiedContentSourceUpsertArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnifiedContentSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceCountArgs} args - Arguments to filter UnifiedContentSources to count.
     * @example
     * // Count the number of UnifiedContentSources
     * const count = await prisma.unifiedContentSource.count({
     *   where: {
     *     // ... the filter for the UnifiedContentSources we want to count
     *   }
     * })
    **/
    count<T extends UnifiedContentSourceCountArgs>(
      args?: Subset<T, UnifiedContentSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnifiedContentSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnifiedContentSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnifiedContentSourceAggregateArgs>(args: Subset<T, UnifiedContentSourceAggregateArgs>): Prisma.PrismaPromise<GetUnifiedContentSourceAggregateType<T>>

    /**
     * Group by UnifiedContentSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedContentSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnifiedContentSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnifiedContentSourceGroupByArgs['orderBy'] }
        : { orderBy?: UnifiedContentSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnifiedContentSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnifiedContentSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnifiedContentSource model
   */
  readonly fields: UnifiedContentSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnifiedContentSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnifiedContentSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integratedSessions<T extends UnifiedContentSource$integratedSessionsArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedContentSource$integratedSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnifiedContentSource model
   */ 
  interface UnifiedContentSourceFieldRefs {
    readonly id: FieldRef<"UnifiedContentSource", 'String'>
    readonly sourceType: FieldRef<"UnifiedContentSource", 'String'>
    readonly sourceId: FieldRef<"UnifiedContentSource", 'String'>
    readonly contentSummary: FieldRef<"UnifiedContentSource", 'String'>
    readonly importanceScore: FieldRef<"UnifiedContentSource", 'Float'>
    readonly viralPotential: FieldRef<"UnifiedContentSource", 'Float'>
    readonly keywords: FieldRef<"UnifiedContentSource", 'String[]'>
    readonly metadata: FieldRef<"UnifiedContentSource", 'Json'>
    readonly createdAt: FieldRef<"UnifiedContentSource", 'DateTime'>
    readonly updatedAt: FieldRef<"UnifiedContentSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnifiedContentSource findUnique
   */
  export type UnifiedContentSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedContentSource to fetch.
     */
    where: UnifiedContentSourceWhereUniqueInput
  }

  /**
   * UnifiedContentSource findUniqueOrThrow
   */
  export type UnifiedContentSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedContentSource to fetch.
     */
    where: UnifiedContentSourceWhereUniqueInput
  }

  /**
   * UnifiedContentSource findFirst
   */
  export type UnifiedContentSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedContentSource to fetch.
     */
    where?: UnifiedContentSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedContentSources to fetch.
     */
    orderBy?: UnifiedContentSourceOrderByWithRelationInput | UnifiedContentSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedContentSources.
     */
    cursor?: UnifiedContentSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedContentSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedContentSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedContentSources.
     */
    distinct?: UnifiedContentSourceScalarFieldEnum | UnifiedContentSourceScalarFieldEnum[]
  }

  /**
   * UnifiedContentSource findFirstOrThrow
   */
  export type UnifiedContentSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedContentSource to fetch.
     */
    where?: UnifiedContentSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedContentSources to fetch.
     */
    orderBy?: UnifiedContentSourceOrderByWithRelationInput | UnifiedContentSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedContentSources.
     */
    cursor?: UnifiedContentSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedContentSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedContentSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedContentSources.
     */
    distinct?: UnifiedContentSourceScalarFieldEnum | UnifiedContentSourceScalarFieldEnum[]
  }

  /**
   * UnifiedContentSource findMany
   */
  export type UnifiedContentSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedContentSources to fetch.
     */
    where?: UnifiedContentSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedContentSources to fetch.
     */
    orderBy?: UnifiedContentSourceOrderByWithRelationInput | UnifiedContentSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnifiedContentSources.
     */
    cursor?: UnifiedContentSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedContentSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedContentSources.
     */
    skip?: number
    distinct?: UnifiedContentSourceScalarFieldEnum | UnifiedContentSourceScalarFieldEnum[]
  }

  /**
   * UnifiedContentSource create
   */
  export type UnifiedContentSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a UnifiedContentSource.
     */
    data: XOR<UnifiedContentSourceCreateInput, UnifiedContentSourceUncheckedCreateInput>
  }

  /**
   * UnifiedContentSource createMany
   */
  export type UnifiedContentSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnifiedContentSources.
     */
    data: UnifiedContentSourceCreateManyInput | UnifiedContentSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedContentSource createManyAndReturn
   */
  export type UnifiedContentSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnifiedContentSources.
     */
    data: UnifiedContentSourceCreateManyInput | UnifiedContentSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedContentSource update
   */
  export type UnifiedContentSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a UnifiedContentSource.
     */
    data: XOR<UnifiedContentSourceUpdateInput, UnifiedContentSourceUncheckedUpdateInput>
    /**
     * Choose, which UnifiedContentSource to update.
     */
    where: UnifiedContentSourceWhereUniqueInput
  }

  /**
   * UnifiedContentSource updateMany
   */
  export type UnifiedContentSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnifiedContentSources.
     */
    data: XOR<UnifiedContentSourceUpdateManyMutationInput, UnifiedContentSourceUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedContentSources to update
     */
    where?: UnifiedContentSourceWhereInput
  }

  /**
   * UnifiedContentSource upsert
   */
  export type UnifiedContentSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the UnifiedContentSource to update in case it exists.
     */
    where: UnifiedContentSourceWhereUniqueInput
    /**
     * In case the UnifiedContentSource found by the `where` argument doesn't exist, create a new UnifiedContentSource with this data.
     */
    create: XOR<UnifiedContentSourceCreateInput, UnifiedContentSourceUncheckedCreateInput>
    /**
     * In case the UnifiedContentSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnifiedContentSourceUpdateInput, UnifiedContentSourceUncheckedUpdateInput>
  }

  /**
   * UnifiedContentSource delete
   */
  export type UnifiedContentSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
    /**
     * Filter which UnifiedContentSource to delete.
     */
    where: UnifiedContentSourceWhereUniqueInput
  }

  /**
   * UnifiedContentSource deleteMany
   */
  export type UnifiedContentSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedContentSources to delete
     */
    where?: UnifiedContentSourceWhereInput
  }

  /**
   * UnifiedContentSource.integratedSessions
   */
  export type UnifiedContentSource$integratedSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    where?: IntegratedSessionSourceWhereInput
    orderBy?: IntegratedSessionSourceOrderByWithRelationInput | IntegratedSessionSourceOrderByWithRelationInput[]
    cursor?: IntegratedSessionSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegratedSessionSourceScalarFieldEnum | IntegratedSessionSourceScalarFieldEnum[]
  }

  /**
   * UnifiedContentSource without action
   */
  export type UnifiedContentSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedContentSource
     */
    select?: UnifiedContentSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedContentSourceInclude<ExtArgs> | null
  }


  /**
   * Model IntegratedSession
   */

  export type AggregateIntegratedSession = {
    _count: IntegratedSessionCountAggregateOutputType | null
    _min: IntegratedSessionMinAggregateOutputType | null
    _max: IntegratedSessionMaxAggregateOutputType | null
  }

  export type IntegratedSessionMinAggregateOutputType = {
    id: string | null
    sessionType: string | null
    v2SessionId: string | null
    status: string | null
    currentStep: string | null
    theme: string | null
    character: string | null
    platform: string | null
    strategy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type IntegratedSessionMaxAggregateOutputType = {
    id: string | null
    sessionType: string | null
    v2SessionId: string | null
    status: string | null
    currentStep: string | null
    theme: string | null
    character: string | null
    platform: string | null
    strategy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type IntegratedSessionCountAggregateOutputType = {
    id: number
    sessionType: number
    v2SessionId: number
    newsArticleIds: number
    buzzPostIds: number
    generationContext: number
    performanceMetrics: number
    status: number
    currentStep: number
    theme: number
    character: number
    platform: number
    strategy: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type IntegratedSessionMinAggregateInputType = {
    id?: true
    sessionType?: true
    v2SessionId?: true
    status?: true
    currentStep?: true
    theme?: true
    character?: true
    platform?: true
    strategy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type IntegratedSessionMaxAggregateInputType = {
    id?: true
    sessionType?: true
    v2SessionId?: true
    status?: true
    currentStep?: true
    theme?: true
    character?: true
    platform?: true
    strategy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type IntegratedSessionCountAggregateInputType = {
    id?: true
    sessionType?: true
    v2SessionId?: true
    newsArticleIds?: true
    buzzPostIds?: true
    generationContext?: true
    performanceMetrics?: true
    status?: true
    currentStep?: true
    theme?: true
    character?: true
    platform?: true
    strategy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type IntegratedSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedSession to aggregate.
     */
    where?: IntegratedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessions to fetch.
     */
    orderBy?: IntegratedSessionOrderByWithRelationInput | IntegratedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegratedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegratedSessions
    **/
    _count?: true | IntegratedSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegratedSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegratedSessionMaxAggregateInputType
  }

  export type GetIntegratedSessionAggregateType<T extends IntegratedSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegratedSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegratedSession[P]>
      : GetScalarType<T[P], AggregateIntegratedSession[P]>
  }




  export type IntegratedSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedSessionWhereInput
    orderBy?: IntegratedSessionOrderByWithAggregationInput | IntegratedSessionOrderByWithAggregationInput[]
    by: IntegratedSessionScalarFieldEnum[] | IntegratedSessionScalarFieldEnum
    having?: IntegratedSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegratedSessionCountAggregateInputType | true
    _min?: IntegratedSessionMinAggregateInputType
    _max?: IntegratedSessionMaxAggregateInputType
  }

  export type IntegratedSessionGroupByOutputType = {
    id: string
    sessionType: string
    v2SessionId: string | null
    newsArticleIds: string[]
    buzzPostIds: string[]
    generationContext: JsonValue | null
    performanceMetrics: JsonValue | null
    status: string
    currentStep: string | null
    theme: string | null
    character: string | null
    platform: string | null
    strategy: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: IntegratedSessionCountAggregateOutputType | null
    _min: IntegratedSessionMinAggregateOutputType | null
    _max: IntegratedSessionMaxAggregateOutputType | null
  }

  type GetIntegratedSessionGroupByPayload<T extends IntegratedSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegratedSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegratedSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegratedSessionGroupByOutputType[P]>
            : GetScalarType<T[P], IntegratedSessionGroupByOutputType[P]>
        }
      >
    >


  export type IntegratedSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionType?: boolean
    v2SessionId?: boolean
    newsArticleIds?: boolean
    buzzPostIds?: boolean
    generationContext?: boolean
    performanceMetrics?: boolean
    status?: boolean
    currentStep?: boolean
    theme?: boolean
    character?: boolean
    platform?: boolean
    strategy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    v2Session?: boolean | IntegratedSession$v2SessionArgs<ExtArgs>
    sources?: boolean | IntegratedSession$sourcesArgs<ExtArgs>
    drafts?: boolean | IntegratedSession$draftsArgs<ExtArgs>
    _count?: boolean | IntegratedSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integratedSession"]>

  export type IntegratedSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionType?: boolean
    v2SessionId?: boolean
    newsArticleIds?: boolean
    buzzPostIds?: boolean
    generationContext?: boolean
    performanceMetrics?: boolean
    status?: boolean
    currentStep?: boolean
    theme?: boolean
    character?: boolean
    platform?: boolean
    strategy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    v2Session?: boolean | IntegratedSession$v2SessionArgs<ExtArgs>
  }, ExtArgs["result"]["integratedSession"]>

  export type IntegratedSessionSelectScalar = {
    id?: boolean
    sessionType?: boolean
    v2SessionId?: boolean
    newsArticleIds?: boolean
    buzzPostIds?: boolean
    generationContext?: boolean
    performanceMetrics?: boolean
    status?: boolean
    currentStep?: boolean
    theme?: boolean
    character?: boolean
    platform?: boolean
    strategy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type IntegratedSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    v2Session?: boolean | IntegratedSession$v2SessionArgs<ExtArgs>
    sources?: boolean | IntegratedSession$sourcesArgs<ExtArgs>
    drafts?: boolean | IntegratedSession$draftsArgs<ExtArgs>
    _count?: boolean | IntegratedSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IntegratedSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    v2Session?: boolean | IntegratedSession$v2SessionArgs<ExtArgs>
  }

  export type $IntegratedSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegratedSession"
    objects: {
      v2Session: Prisma.$ViralSessionPayload<ExtArgs> | null
      sources: Prisma.$IntegratedSessionSourcePayload<ExtArgs>[]
      drafts: Prisma.$IntegratedDraftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionType: string
      v2SessionId: string | null
      newsArticleIds: string[]
      buzzPostIds: string[]
      generationContext: Prisma.JsonValue | null
      performanceMetrics: Prisma.JsonValue | null
      status: string
      currentStep: string | null
      theme: string | null
      character: string | null
      platform: string | null
      strategy: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["integratedSession"]>
    composites: {}
  }

  type IntegratedSessionGetPayload<S extends boolean | null | undefined | IntegratedSessionDefaultArgs> = $Result.GetResult<Prisma.$IntegratedSessionPayload, S>

  type IntegratedSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegratedSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegratedSessionCountAggregateInputType | true
    }

  export interface IntegratedSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegratedSession'], meta: { name: 'IntegratedSession' } }
    /**
     * Find zero or one IntegratedSession that matches the filter.
     * @param {IntegratedSessionFindUniqueArgs} args - Arguments to find a IntegratedSession
     * @example
     * // Get one IntegratedSession
     * const integratedSession = await prisma.integratedSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegratedSessionFindUniqueArgs>(args: SelectSubset<T, IntegratedSessionFindUniqueArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntegratedSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegratedSessionFindUniqueOrThrowArgs} args - Arguments to find a IntegratedSession
     * @example
     * // Get one IntegratedSession
     * const integratedSession = await prisma.integratedSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegratedSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegratedSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntegratedSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionFindFirstArgs} args - Arguments to find a IntegratedSession
     * @example
     * // Get one IntegratedSession
     * const integratedSession = await prisma.integratedSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegratedSessionFindFirstArgs>(args?: SelectSubset<T, IntegratedSessionFindFirstArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntegratedSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionFindFirstOrThrowArgs} args - Arguments to find a IntegratedSession
     * @example
     * // Get one IntegratedSession
     * const integratedSession = await prisma.integratedSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegratedSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegratedSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntegratedSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegratedSessions
     * const integratedSessions = await prisma.integratedSession.findMany()
     * 
     * // Get first 10 IntegratedSessions
     * const integratedSessions = await prisma.integratedSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integratedSessionWithIdOnly = await prisma.integratedSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegratedSessionFindManyArgs>(args?: SelectSubset<T, IntegratedSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntegratedSession.
     * @param {IntegratedSessionCreateArgs} args - Arguments to create a IntegratedSession.
     * @example
     * // Create one IntegratedSession
     * const IntegratedSession = await prisma.integratedSession.create({
     *   data: {
     *     // ... data to create a IntegratedSession
     *   }
     * })
     * 
     */
    create<T extends IntegratedSessionCreateArgs>(args: SelectSubset<T, IntegratedSessionCreateArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntegratedSessions.
     * @param {IntegratedSessionCreateManyArgs} args - Arguments to create many IntegratedSessions.
     * @example
     * // Create many IntegratedSessions
     * const integratedSession = await prisma.integratedSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegratedSessionCreateManyArgs>(args?: SelectSubset<T, IntegratedSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegratedSessions and returns the data saved in the database.
     * @param {IntegratedSessionCreateManyAndReturnArgs} args - Arguments to create many IntegratedSessions.
     * @example
     * // Create many IntegratedSessions
     * const integratedSession = await prisma.integratedSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegratedSessions and only return the `id`
     * const integratedSessionWithIdOnly = await prisma.integratedSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegratedSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegratedSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntegratedSession.
     * @param {IntegratedSessionDeleteArgs} args - Arguments to delete one IntegratedSession.
     * @example
     * // Delete one IntegratedSession
     * const IntegratedSession = await prisma.integratedSession.delete({
     *   where: {
     *     // ... filter to delete one IntegratedSession
     *   }
     * })
     * 
     */
    delete<T extends IntegratedSessionDeleteArgs>(args: SelectSubset<T, IntegratedSessionDeleteArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntegratedSession.
     * @param {IntegratedSessionUpdateArgs} args - Arguments to update one IntegratedSession.
     * @example
     * // Update one IntegratedSession
     * const integratedSession = await prisma.integratedSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegratedSessionUpdateArgs>(args: SelectSubset<T, IntegratedSessionUpdateArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntegratedSessions.
     * @param {IntegratedSessionDeleteManyArgs} args - Arguments to filter IntegratedSessions to delete.
     * @example
     * // Delete a few IntegratedSessions
     * const { count } = await prisma.integratedSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegratedSessionDeleteManyArgs>(args?: SelectSubset<T, IntegratedSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegratedSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegratedSessions
     * const integratedSession = await prisma.integratedSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegratedSessionUpdateManyArgs>(args: SelectSubset<T, IntegratedSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegratedSession.
     * @param {IntegratedSessionUpsertArgs} args - Arguments to update or create a IntegratedSession.
     * @example
     * // Update or create a IntegratedSession
     * const integratedSession = await prisma.integratedSession.upsert({
     *   create: {
     *     // ... data to create a IntegratedSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegratedSession we want to update
     *   }
     * })
     */
    upsert<T extends IntegratedSessionUpsertArgs>(args: SelectSubset<T, IntegratedSessionUpsertArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntegratedSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionCountArgs} args - Arguments to filter IntegratedSessions to count.
     * @example
     * // Count the number of IntegratedSessions
     * const count = await prisma.integratedSession.count({
     *   where: {
     *     // ... the filter for the IntegratedSessions we want to count
     *   }
     * })
    **/
    count<T extends IntegratedSessionCountArgs>(
      args?: Subset<T, IntegratedSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegratedSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegratedSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegratedSessionAggregateArgs>(args: Subset<T, IntegratedSessionAggregateArgs>): Prisma.PrismaPromise<GetIntegratedSessionAggregateType<T>>

    /**
     * Group by IntegratedSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegratedSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegratedSessionGroupByArgs['orderBy'] }
        : { orderBy?: IntegratedSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegratedSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegratedSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegratedSession model
   */
  readonly fields: IntegratedSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegratedSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegratedSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    v2Session<T extends IntegratedSession$v2SessionArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedSession$v2SessionArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sources<T extends IntegratedSession$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedSession$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findMany"> | Null>
    drafts<T extends IntegratedSession$draftsArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedSession$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegratedSession model
   */ 
  interface IntegratedSessionFieldRefs {
    readonly id: FieldRef<"IntegratedSession", 'String'>
    readonly sessionType: FieldRef<"IntegratedSession", 'String'>
    readonly v2SessionId: FieldRef<"IntegratedSession", 'String'>
    readonly newsArticleIds: FieldRef<"IntegratedSession", 'String[]'>
    readonly buzzPostIds: FieldRef<"IntegratedSession", 'String[]'>
    readonly generationContext: FieldRef<"IntegratedSession", 'Json'>
    readonly performanceMetrics: FieldRef<"IntegratedSession", 'Json'>
    readonly status: FieldRef<"IntegratedSession", 'String'>
    readonly currentStep: FieldRef<"IntegratedSession", 'String'>
    readonly theme: FieldRef<"IntegratedSession", 'String'>
    readonly character: FieldRef<"IntegratedSession", 'String'>
    readonly platform: FieldRef<"IntegratedSession", 'String'>
    readonly strategy: FieldRef<"IntegratedSession", 'String'>
    readonly createdAt: FieldRef<"IntegratedSession", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegratedSession", 'DateTime'>
    readonly completedAt: FieldRef<"IntegratedSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegratedSession findUnique
   */
  export type IntegratedSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSession to fetch.
     */
    where: IntegratedSessionWhereUniqueInput
  }

  /**
   * IntegratedSession findUniqueOrThrow
   */
  export type IntegratedSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSession to fetch.
     */
    where: IntegratedSessionWhereUniqueInput
  }

  /**
   * IntegratedSession findFirst
   */
  export type IntegratedSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSession to fetch.
     */
    where?: IntegratedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessions to fetch.
     */
    orderBy?: IntegratedSessionOrderByWithRelationInput | IntegratedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedSessions.
     */
    cursor?: IntegratedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedSessions.
     */
    distinct?: IntegratedSessionScalarFieldEnum | IntegratedSessionScalarFieldEnum[]
  }

  /**
   * IntegratedSession findFirstOrThrow
   */
  export type IntegratedSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSession to fetch.
     */
    where?: IntegratedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessions to fetch.
     */
    orderBy?: IntegratedSessionOrderByWithRelationInput | IntegratedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedSessions.
     */
    cursor?: IntegratedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedSessions.
     */
    distinct?: IntegratedSessionScalarFieldEnum | IntegratedSessionScalarFieldEnum[]
  }

  /**
   * IntegratedSession findMany
   */
  export type IntegratedSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSessions to fetch.
     */
    where?: IntegratedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessions to fetch.
     */
    orderBy?: IntegratedSessionOrderByWithRelationInput | IntegratedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegratedSessions.
     */
    cursor?: IntegratedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessions.
     */
    skip?: number
    distinct?: IntegratedSessionScalarFieldEnum | IntegratedSessionScalarFieldEnum[]
  }

  /**
   * IntegratedSession create
   */
  export type IntegratedSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegratedSession.
     */
    data: XOR<IntegratedSessionCreateInput, IntegratedSessionUncheckedCreateInput>
  }

  /**
   * IntegratedSession createMany
   */
  export type IntegratedSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegratedSessions.
     */
    data: IntegratedSessionCreateManyInput | IntegratedSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegratedSession createManyAndReturn
   */
  export type IntegratedSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntegratedSessions.
     */
    data: IntegratedSessionCreateManyInput | IntegratedSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegratedSession update
   */
  export type IntegratedSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegratedSession.
     */
    data: XOR<IntegratedSessionUpdateInput, IntegratedSessionUncheckedUpdateInput>
    /**
     * Choose, which IntegratedSession to update.
     */
    where: IntegratedSessionWhereUniqueInput
  }

  /**
   * IntegratedSession updateMany
   */
  export type IntegratedSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegratedSessions.
     */
    data: XOR<IntegratedSessionUpdateManyMutationInput, IntegratedSessionUncheckedUpdateManyInput>
    /**
     * Filter which IntegratedSessions to update
     */
    where?: IntegratedSessionWhereInput
  }

  /**
   * IntegratedSession upsert
   */
  export type IntegratedSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegratedSession to update in case it exists.
     */
    where: IntegratedSessionWhereUniqueInput
    /**
     * In case the IntegratedSession found by the `where` argument doesn't exist, create a new IntegratedSession with this data.
     */
    create: XOR<IntegratedSessionCreateInput, IntegratedSessionUncheckedCreateInput>
    /**
     * In case the IntegratedSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegratedSessionUpdateInput, IntegratedSessionUncheckedUpdateInput>
  }

  /**
   * IntegratedSession delete
   */
  export type IntegratedSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    /**
     * Filter which IntegratedSession to delete.
     */
    where: IntegratedSessionWhereUniqueInput
  }

  /**
   * IntegratedSession deleteMany
   */
  export type IntegratedSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedSessions to delete
     */
    where?: IntegratedSessionWhereInput
  }

  /**
   * IntegratedSession.v2Session
   */
  export type IntegratedSession$v2SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    where?: ViralSessionWhereInput
  }

  /**
   * IntegratedSession.sources
   */
  export type IntegratedSession$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    where?: IntegratedSessionSourceWhereInput
    orderBy?: IntegratedSessionSourceOrderByWithRelationInput | IntegratedSessionSourceOrderByWithRelationInput[]
    cursor?: IntegratedSessionSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegratedSessionSourceScalarFieldEnum | IntegratedSessionSourceScalarFieldEnum[]
  }

  /**
   * IntegratedSession.drafts
   */
  export type IntegratedSession$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    where?: IntegratedDraftWhereInput
    orderBy?: IntegratedDraftOrderByWithRelationInput | IntegratedDraftOrderByWithRelationInput[]
    cursor?: IntegratedDraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegratedDraftScalarFieldEnum | IntegratedDraftScalarFieldEnum[]
  }

  /**
   * IntegratedSession without action
   */
  export type IntegratedSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
  }


  /**
   * Model IntegratedSessionSource
   */

  export type AggregateIntegratedSessionSource = {
    _count: IntegratedSessionSourceCountAggregateOutputType | null
    _avg: IntegratedSessionSourceAvgAggregateOutputType | null
    _sum: IntegratedSessionSourceSumAggregateOutputType | null
    _min: IntegratedSessionSourceMinAggregateOutputType | null
    _max: IntegratedSessionSourceMaxAggregateOutputType | null
  }

  export type IntegratedSessionSourceAvgAggregateOutputType = {
    relevanceScore: number | null
  }

  export type IntegratedSessionSourceSumAggregateOutputType = {
    relevanceScore: number | null
  }

  export type IntegratedSessionSourceMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sourceId: string | null
    relevanceScore: number | null
    usageType: string | null
  }

  export type IntegratedSessionSourceMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sourceId: string | null
    relevanceScore: number | null
    usageType: string | null
  }

  export type IntegratedSessionSourceCountAggregateOutputType = {
    id: number
    sessionId: number
    sourceId: number
    relevanceScore: number
    usageType: number
    _all: number
  }


  export type IntegratedSessionSourceAvgAggregateInputType = {
    relevanceScore?: true
  }

  export type IntegratedSessionSourceSumAggregateInputType = {
    relevanceScore?: true
  }

  export type IntegratedSessionSourceMinAggregateInputType = {
    id?: true
    sessionId?: true
    sourceId?: true
    relevanceScore?: true
    usageType?: true
  }

  export type IntegratedSessionSourceMaxAggregateInputType = {
    id?: true
    sessionId?: true
    sourceId?: true
    relevanceScore?: true
    usageType?: true
  }

  export type IntegratedSessionSourceCountAggregateInputType = {
    id?: true
    sessionId?: true
    sourceId?: true
    relevanceScore?: true
    usageType?: true
    _all?: true
  }

  export type IntegratedSessionSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedSessionSource to aggregate.
     */
    where?: IntegratedSessionSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessionSources to fetch.
     */
    orderBy?: IntegratedSessionSourceOrderByWithRelationInput | IntegratedSessionSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegratedSessionSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessionSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessionSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegratedSessionSources
    **/
    _count?: true | IntegratedSessionSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegratedSessionSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegratedSessionSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegratedSessionSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegratedSessionSourceMaxAggregateInputType
  }

  export type GetIntegratedSessionSourceAggregateType<T extends IntegratedSessionSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegratedSessionSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegratedSessionSource[P]>
      : GetScalarType<T[P], AggregateIntegratedSessionSource[P]>
  }




  export type IntegratedSessionSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedSessionSourceWhereInput
    orderBy?: IntegratedSessionSourceOrderByWithAggregationInput | IntegratedSessionSourceOrderByWithAggregationInput[]
    by: IntegratedSessionSourceScalarFieldEnum[] | IntegratedSessionSourceScalarFieldEnum
    having?: IntegratedSessionSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegratedSessionSourceCountAggregateInputType | true
    _avg?: IntegratedSessionSourceAvgAggregateInputType
    _sum?: IntegratedSessionSourceSumAggregateInputType
    _min?: IntegratedSessionSourceMinAggregateInputType
    _max?: IntegratedSessionSourceMaxAggregateInputType
  }

  export type IntegratedSessionSourceGroupByOutputType = {
    id: string
    sessionId: string
    sourceId: string
    relevanceScore: number | null
    usageType: string
    _count: IntegratedSessionSourceCountAggregateOutputType | null
    _avg: IntegratedSessionSourceAvgAggregateOutputType | null
    _sum: IntegratedSessionSourceSumAggregateOutputType | null
    _min: IntegratedSessionSourceMinAggregateOutputType | null
    _max: IntegratedSessionSourceMaxAggregateOutputType | null
  }

  type GetIntegratedSessionSourceGroupByPayload<T extends IntegratedSessionSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegratedSessionSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegratedSessionSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegratedSessionSourceGroupByOutputType[P]>
            : GetScalarType<T[P], IntegratedSessionSourceGroupByOutputType[P]>
        }
      >
    >


  export type IntegratedSessionSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sourceId?: boolean
    relevanceScore?: boolean
    usageType?: boolean
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
    source?: boolean | UnifiedContentSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integratedSessionSource"]>

  export type IntegratedSessionSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sourceId?: boolean
    relevanceScore?: boolean
    usageType?: boolean
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
    source?: boolean | UnifiedContentSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integratedSessionSource"]>

  export type IntegratedSessionSourceSelectScalar = {
    id?: boolean
    sessionId?: boolean
    sourceId?: boolean
    relevanceScore?: boolean
    usageType?: boolean
  }

  export type IntegratedSessionSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
    source?: boolean | UnifiedContentSourceDefaultArgs<ExtArgs>
  }
  export type IntegratedSessionSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
    source?: boolean | UnifiedContentSourceDefaultArgs<ExtArgs>
  }

  export type $IntegratedSessionSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegratedSessionSource"
    objects: {
      session: Prisma.$IntegratedSessionPayload<ExtArgs>
      source: Prisma.$UnifiedContentSourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      sourceId: string
      relevanceScore: number | null
      usageType: string
    }, ExtArgs["result"]["integratedSessionSource"]>
    composites: {}
  }

  type IntegratedSessionSourceGetPayload<S extends boolean | null | undefined | IntegratedSessionSourceDefaultArgs> = $Result.GetResult<Prisma.$IntegratedSessionSourcePayload, S>

  type IntegratedSessionSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegratedSessionSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegratedSessionSourceCountAggregateInputType | true
    }

  export interface IntegratedSessionSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegratedSessionSource'], meta: { name: 'IntegratedSessionSource' } }
    /**
     * Find zero or one IntegratedSessionSource that matches the filter.
     * @param {IntegratedSessionSourceFindUniqueArgs} args - Arguments to find a IntegratedSessionSource
     * @example
     * // Get one IntegratedSessionSource
     * const integratedSessionSource = await prisma.integratedSessionSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegratedSessionSourceFindUniqueArgs>(args: SelectSubset<T, IntegratedSessionSourceFindUniqueArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntegratedSessionSource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegratedSessionSourceFindUniqueOrThrowArgs} args - Arguments to find a IntegratedSessionSource
     * @example
     * // Get one IntegratedSessionSource
     * const integratedSessionSource = await prisma.integratedSessionSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegratedSessionSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegratedSessionSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntegratedSessionSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceFindFirstArgs} args - Arguments to find a IntegratedSessionSource
     * @example
     * // Get one IntegratedSessionSource
     * const integratedSessionSource = await prisma.integratedSessionSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegratedSessionSourceFindFirstArgs>(args?: SelectSubset<T, IntegratedSessionSourceFindFirstArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntegratedSessionSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceFindFirstOrThrowArgs} args - Arguments to find a IntegratedSessionSource
     * @example
     * // Get one IntegratedSessionSource
     * const integratedSessionSource = await prisma.integratedSessionSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegratedSessionSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegratedSessionSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntegratedSessionSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegratedSessionSources
     * const integratedSessionSources = await prisma.integratedSessionSource.findMany()
     * 
     * // Get first 10 IntegratedSessionSources
     * const integratedSessionSources = await prisma.integratedSessionSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integratedSessionSourceWithIdOnly = await prisma.integratedSessionSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegratedSessionSourceFindManyArgs>(args?: SelectSubset<T, IntegratedSessionSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntegratedSessionSource.
     * @param {IntegratedSessionSourceCreateArgs} args - Arguments to create a IntegratedSessionSource.
     * @example
     * // Create one IntegratedSessionSource
     * const IntegratedSessionSource = await prisma.integratedSessionSource.create({
     *   data: {
     *     // ... data to create a IntegratedSessionSource
     *   }
     * })
     * 
     */
    create<T extends IntegratedSessionSourceCreateArgs>(args: SelectSubset<T, IntegratedSessionSourceCreateArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntegratedSessionSources.
     * @param {IntegratedSessionSourceCreateManyArgs} args - Arguments to create many IntegratedSessionSources.
     * @example
     * // Create many IntegratedSessionSources
     * const integratedSessionSource = await prisma.integratedSessionSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegratedSessionSourceCreateManyArgs>(args?: SelectSubset<T, IntegratedSessionSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegratedSessionSources and returns the data saved in the database.
     * @param {IntegratedSessionSourceCreateManyAndReturnArgs} args - Arguments to create many IntegratedSessionSources.
     * @example
     * // Create many IntegratedSessionSources
     * const integratedSessionSource = await prisma.integratedSessionSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegratedSessionSources and only return the `id`
     * const integratedSessionSourceWithIdOnly = await prisma.integratedSessionSource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegratedSessionSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegratedSessionSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntegratedSessionSource.
     * @param {IntegratedSessionSourceDeleteArgs} args - Arguments to delete one IntegratedSessionSource.
     * @example
     * // Delete one IntegratedSessionSource
     * const IntegratedSessionSource = await prisma.integratedSessionSource.delete({
     *   where: {
     *     // ... filter to delete one IntegratedSessionSource
     *   }
     * })
     * 
     */
    delete<T extends IntegratedSessionSourceDeleteArgs>(args: SelectSubset<T, IntegratedSessionSourceDeleteArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntegratedSessionSource.
     * @param {IntegratedSessionSourceUpdateArgs} args - Arguments to update one IntegratedSessionSource.
     * @example
     * // Update one IntegratedSessionSource
     * const integratedSessionSource = await prisma.integratedSessionSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegratedSessionSourceUpdateArgs>(args: SelectSubset<T, IntegratedSessionSourceUpdateArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntegratedSessionSources.
     * @param {IntegratedSessionSourceDeleteManyArgs} args - Arguments to filter IntegratedSessionSources to delete.
     * @example
     * // Delete a few IntegratedSessionSources
     * const { count } = await prisma.integratedSessionSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegratedSessionSourceDeleteManyArgs>(args?: SelectSubset<T, IntegratedSessionSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegratedSessionSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegratedSessionSources
     * const integratedSessionSource = await prisma.integratedSessionSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegratedSessionSourceUpdateManyArgs>(args: SelectSubset<T, IntegratedSessionSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegratedSessionSource.
     * @param {IntegratedSessionSourceUpsertArgs} args - Arguments to update or create a IntegratedSessionSource.
     * @example
     * // Update or create a IntegratedSessionSource
     * const integratedSessionSource = await prisma.integratedSessionSource.upsert({
     *   create: {
     *     // ... data to create a IntegratedSessionSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegratedSessionSource we want to update
     *   }
     * })
     */
    upsert<T extends IntegratedSessionSourceUpsertArgs>(args: SelectSubset<T, IntegratedSessionSourceUpsertArgs<ExtArgs>>): Prisma__IntegratedSessionSourceClient<$Result.GetResult<Prisma.$IntegratedSessionSourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntegratedSessionSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceCountArgs} args - Arguments to filter IntegratedSessionSources to count.
     * @example
     * // Count the number of IntegratedSessionSources
     * const count = await prisma.integratedSessionSource.count({
     *   where: {
     *     // ... the filter for the IntegratedSessionSources we want to count
     *   }
     * })
    **/
    count<T extends IntegratedSessionSourceCountArgs>(
      args?: Subset<T, IntegratedSessionSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegratedSessionSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegratedSessionSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegratedSessionSourceAggregateArgs>(args: Subset<T, IntegratedSessionSourceAggregateArgs>): Prisma.PrismaPromise<GetIntegratedSessionSourceAggregateType<T>>

    /**
     * Group by IntegratedSessionSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedSessionSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegratedSessionSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegratedSessionSourceGroupByArgs['orderBy'] }
        : { orderBy?: IntegratedSessionSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegratedSessionSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegratedSessionSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegratedSessionSource model
   */
  readonly fields: IntegratedSessionSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegratedSessionSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegratedSessionSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends IntegratedSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedSessionDefaultArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    source<T extends UnifiedContentSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedContentSourceDefaultArgs<ExtArgs>>): Prisma__UnifiedContentSourceClient<$Result.GetResult<Prisma.$UnifiedContentSourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegratedSessionSource model
   */ 
  interface IntegratedSessionSourceFieldRefs {
    readonly id: FieldRef<"IntegratedSessionSource", 'String'>
    readonly sessionId: FieldRef<"IntegratedSessionSource", 'String'>
    readonly sourceId: FieldRef<"IntegratedSessionSource", 'String'>
    readonly relevanceScore: FieldRef<"IntegratedSessionSource", 'Float'>
    readonly usageType: FieldRef<"IntegratedSessionSource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IntegratedSessionSource findUnique
   */
  export type IntegratedSessionSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSessionSource to fetch.
     */
    where: IntegratedSessionSourceWhereUniqueInput
  }

  /**
   * IntegratedSessionSource findUniqueOrThrow
   */
  export type IntegratedSessionSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSessionSource to fetch.
     */
    where: IntegratedSessionSourceWhereUniqueInput
  }

  /**
   * IntegratedSessionSource findFirst
   */
  export type IntegratedSessionSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSessionSource to fetch.
     */
    where?: IntegratedSessionSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessionSources to fetch.
     */
    orderBy?: IntegratedSessionSourceOrderByWithRelationInput | IntegratedSessionSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedSessionSources.
     */
    cursor?: IntegratedSessionSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessionSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessionSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedSessionSources.
     */
    distinct?: IntegratedSessionSourceScalarFieldEnum | IntegratedSessionSourceScalarFieldEnum[]
  }

  /**
   * IntegratedSessionSource findFirstOrThrow
   */
  export type IntegratedSessionSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSessionSource to fetch.
     */
    where?: IntegratedSessionSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessionSources to fetch.
     */
    orderBy?: IntegratedSessionSourceOrderByWithRelationInput | IntegratedSessionSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedSessionSources.
     */
    cursor?: IntegratedSessionSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessionSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessionSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedSessionSources.
     */
    distinct?: IntegratedSessionSourceScalarFieldEnum | IntegratedSessionSourceScalarFieldEnum[]
  }

  /**
   * IntegratedSessionSource findMany
   */
  export type IntegratedSessionSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedSessionSources to fetch.
     */
    where?: IntegratedSessionSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedSessionSources to fetch.
     */
    orderBy?: IntegratedSessionSourceOrderByWithRelationInput | IntegratedSessionSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegratedSessionSources.
     */
    cursor?: IntegratedSessionSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedSessionSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedSessionSources.
     */
    skip?: number
    distinct?: IntegratedSessionSourceScalarFieldEnum | IntegratedSessionSourceScalarFieldEnum[]
  }

  /**
   * IntegratedSessionSource create
   */
  export type IntegratedSessionSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegratedSessionSource.
     */
    data: XOR<IntegratedSessionSourceCreateInput, IntegratedSessionSourceUncheckedCreateInput>
  }

  /**
   * IntegratedSessionSource createMany
   */
  export type IntegratedSessionSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegratedSessionSources.
     */
    data: IntegratedSessionSourceCreateManyInput | IntegratedSessionSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegratedSessionSource createManyAndReturn
   */
  export type IntegratedSessionSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntegratedSessionSources.
     */
    data: IntegratedSessionSourceCreateManyInput | IntegratedSessionSourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegratedSessionSource update
   */
  export type IntegratedSessionSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegratedSessionSource.
     */
    data: XOR<IntegratedSessionSourceUpdateInput, IntegratedSessionSourceUncheckedUpdateInput>
    /**
     * Choose, which IntegratedSessionSource to update.
     */
    where: IntegratedSessionSourceWhereUniqueInput
  }

  /**
   * IntegratedSessionSource updateMany
   */
  export type IntegratedSessionSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegratedSessionSources.
     */
    data: XOR<IntegratedSessionSourceUpdateManyMutationInput, IntegratedSessionSourceUncheckedUpdateManyInput>
    /**
     * Filter which IntegratedSessionSources to update
     */
    where?: IntegratedSessionSourceWhereInput
  }

  /**
   * IntegratedSessionSource upsert
   */
  export type IntegratedSessionSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegratedSessionSource to update in case it exists.
     */
    where: IntegratedSessionSourceWhereUniqueInput
    /**
     * In case the IntegratedSessionSource found by the `where` argument doesn't exist, create a new IntegratedSessionSource with this data.
     */
    create: XOR<IntegratedSessionSourceCreateInput, IntegratedSessionSourceUncheckedCreateInput>
    /**
     * In case the IntegratedSessionSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegratedSessionSourceUpdateInput, IntegratedSessionSourceUncheckedUpdateInput>
  }

  /**
   * IntegratedSessionSource delete
   */
  export type IntegratedSessionSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
    /**
     * Filter which IntegratedSessionSource to delete.
     */
    where: IntegratedSessionSourceWhereUniqueInput
  }

  /**
   * IntegratedSessionSource deleteMany
   */
  export type IntegratedSessionSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedSessionSources to delete
     */
    where?: IntegratedSessionSourceWhereInput
  }

  /**
   * IntegratedSessionSource without action
   */
  export type IntegratedSessionSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSessionSource
     */
    select?: IntegratedSessionSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionSourceInclude<ExtArgs> | null
  }


  /**
   * Model IntegratedDraft
   */

  export type AggregateIntegratedDraft = {
    _count: IntegratedDraftCountAggregateOutputType | null
    _avg: IntegratedDraftAvgAggregateOutputType | null
    _sum: IntegratedDraftSumAggregateOutputType | null
    _min: IntegratedDraftMinAggregateOutputType | null
    _max: IntegratedDraftMaxAggregateOutputType | null
  }

  export type IntegratedDraftAvgAggregateOutputType = {
    viralScore: number | null
  }

  export type IntegratedDraftSumAggregateOutputType = {
    viralScore: number | null
  }

  export type IntegratedDraftMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    title: string | null
    content: string | null
    contentType: string | null
    sourcesSummary: string | null
    newsContext: string | null
    buzzContext: string | null
    conceptId: string | null
    hook: string | null
    angle: string | null
    generationStrategy: string | null
    visualGuide: string | null
    status: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegratedDraftMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    title: string | null
    content: string | null
    contentType: string | null
    sourcesSummary: string | null
    newsContext: string | null
    buzzContext: string | null
    conceptId: string | null
    hook: string | null
    angle: string | null
    generationStrategy: string | null
    visualGuide: string | null
    status: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegratedDraftCountAggregateOutputType = {
    id: number
    sessionId: number
    title: number
    content: number
    contentType: number
    sourcesSummary: number
    newsContext: number
    buzzContext: number
    conceptId: number
    hook: number
    angle: number
    sourceNewsIds: number
    sourceBuzzIds: number
    generationStrategy: number
    generationData: number
    hashtags: number
    visualGuide: number
    status: number
    scheduledAt: number
    postedAt: number
    postId: number
    viralScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegratedDraftAvgAggregateInputType = {
    viralScore?: true
  }

  export type IntegratedDraftSumAggregateInputType = {
    viralScore?: true
  }

  export type IntegratedDraftMinAggregateInputType = {
    id?: true
    sessionId?: true
    title?: true
    content?: true
    contentType?: true
    sourcesSummary?: true
    newsContext?: true
    buzzContext?: true
    conceptId?: true
    hook?: true
    angle?: true
    generationStrategy?: true
    visualGuide?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegratedDraftMaxAggregateInputType = {
    id?: true
    sessionId?: true
    title?: true
    content?: true
    contentType?: true
    sourcesSummary?: true
    newsContext?: true
    buzzContext?: true
    conceptId?: true
    hook?: true
    angle?: true
    generationStrategy?: true
    visualGuide?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegratedDraftCountAggregateInputType = {
    id?: true
    sessionId?: true
    title?: true
    content?: true
    contentType?: true
    sourcesSummary?: true
    newsContext?: true
    buzzContext?: true
    conceptId?: true
    hook?: true
    angle?: true
    sourceNewsIds?: true
    sourceBuzzIds?: true
    generationStrategy?: true
    generationData?: true
    hashtags?: true
    visualGuide?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegratedDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedDraft to aggregate.
     */
    where?: IntegratedDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDrafts to fetch.
     */
    orderBy?: IntegratedDraftOrderByWithRelationInput | IntegratedDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegratedDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegratedDrafts
    **/
    _count?: true | IntegratedDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegratedDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegratedDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegratedDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegratedDraftMaxAggregateInputType
  }

  export type GetIntegratedDraftAggregateType<T extends IntegratedDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegratedDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegratedDraft[P]>
      : GetScalarType<T[P], AggregateIntegratedDraft[P]>
  }




  export type IntegratedDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedDraftWhereInput
    orderBy?: IntegratedDraftOrderByWithAggregationInput | IntegratedDraftOrderByWithAggregationInput[]
    by: IntegratedDraftScalarFieldEnum[] | IntegratedDraftScalarFieldEnum
    having?: IntegratedDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegratedDraftCountAggregateInputType | true
    _avg?: IntegratedDraftAvgAggregateInputType
    _sum?: IntegratedDraftSumAggregateInputType
    _min?: IntegratedDraftMinAggregateInputType
    _max?: IntegratedDraftMaxAggregateInputType
  }

  export type IntegratedDraftGroupByOutputType = {
    id: string
    sessionId: string
    title: string
    content: string
    contentType: string
    sourcesSummary: string | null
    newsContext: string | null
    buzzContext: string | null
    conceptId: string | null
    hook: string | null
    angle: string | null
    sourceNewsIds: string[]
    sourceBuzzIds: string[]
    generationStrategy: string | null
    generationData: JsonValue | null
    hashtags: string[]
    visualGuide: string | null
    status: string
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: IntegratedDraftCountAggregateOutputType | null
    _avg: IntegratedDraftAvgAggregateOutputType | null
    _sum: IntegratedDraftSumAggregateOutputType | null
    _min: IntegratedDraftMinAggregateOutputType | null
    _max: IntegratedDraftMaxAggregateOutputType | null
  }

  type GetIntegratedDraftGroupByPayload<T extends IntegratedDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegratedDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegratedDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegratedDraftGroupByOutputType[P]>
            : GetScalarType<T[P], IntegratedDraftGroupByOutputType[P]>
        }
      >
    >


  export type IntegratedDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    title?: boolean
    content?: boolean
    contentType?: boolean
    sourcesSummary?: boolean
    newsContext?: boolean
    buzzContext?: boolean
    conceptId?: boolean
    hook?: boolean
    angle?: boolean
    sourceNewsIds?: boolean
    sourceBuzzIds?: boolean
    generationStrategy?: boolean
    generationData?: boolean
    hashtags?: boolean
    visualGuide?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
    performance?: boolean | IntegratedDraft$performanceArgs<ExtArgs>
  }, ExtArgs["result"]["integratedDraft"]>

  export type IntegratedDraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    title?: boolean
    content?: boolean
    contentType?: boolean
    sourcesSummary?: boolean
    newsContext?: boolean
    buzzContext?: boolean
    conceptId?: boolean
    hook?: boolean
    angle?: boolean
    sourceNewsIds?: boolean
    sourceBuzzIds?: boolean
    generationStrategy?: boolean
    generationData?: boolean
    hashtags?: boolean
    visualGuide?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integratedDraft"]>

  export type IntegratedDraftSelectScalar = {
    id?: boolean
    sessionId?: boolean
    title?: boolean
    content?: boolean
    contentType?: boolean
    sourcesSummary?: boolean
    newsContext?: boolean
    buzzContext?: boolean
    conceptId?: boolean
    hook?: boolean
    angle?: boolean
    sourceNewsIds?: boolean
    sourceBuzzIds?: boolean
    generationStrategy?: boolean
    generationData?: boolean
    hashtags?: boolean
    visualGuide?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegratedDraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
    performance?: boolean | IntegratedDraft$performanceArgs<ExtArgs>
  }
  export type IntegratedDraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | IntegratedSessionDefaultArgs<ExtArgs>
  }

  export type $IntegratedDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegratedDraft"
    objects: {
      session: Prisma.$IntegratedSessionPayload<ExtArgs>
      performance: Prisma.$IntegratedDraftPerformancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      title: string
      content: string
      contentType: string
      sourcesSummary: string | null
      newsContext: string | null
      buzzContext: string | null
      conceptId: string | null
      hook: string | null
      angle: string | null
      sourceNewsIds: string[]
      sourceBuzzIds: string[]
      generationStrategy: string | null
      generationData: Prisma.JsonValue | null
      hashtags: string[]
      visualGuide: string | null
      status: string
      scheduledAt: Date | null
      postedAt: Date | null
      postId: string | null
      viralScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integratedDraft"]>
    composites: {}
  }

  type IntegratedDraftGetPayload<S extends boolean | null | undefined | IntegratedDraftDefaultArgs> = $Result.GetResult<Prisma.$IntegratedDraftPayload, S>

  type IntegratedDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegratedDraftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegratedDraftCountAggregateInputType | true
    }

  export interface IntegratedDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegratedDraft'], meta: { name: 'IntegratedDraft' } }
    /**
     * Find zero or one IntegratedDraft that matches the filter.
     * @param {IntegratedDraftFindUniqueArgs} args - Arguments to find a IntegratedDraft
     * @example
     * // Get one IntegratedDraft
     * const integratedDraft = await prisma.integratedDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegratedDraftFindUniqueArgs>(args: SelectSubset<T, IntegratedDraftFindUniqueArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntegratedDraft that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegratedDraftFindUniqueOrThrowArgs} args - Arguments to find a IntegratedDraft
     * @example
     * // Get one IntegratedDraft
     * const integratedDraft = await prisma.integratedDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegratedDraftFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegratedDraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntegratedDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftFindFirstArgs} args - Arguments to find a IntegratedDraft
     * @example
     * // Get one IntegratedDraft
     * const integratedDraft = await prisma.integratedDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegratedDraftFindFirstArgs>(args?: SelectSubset<T, IntegratedDraftFindFirstArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntegratedDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftFindFirstOrThrowArgs} args - Arguments to find a IntegratedDraft
     * @example
     * // Get one IntegratedDraft
     * const integratedDraft = await prisma.integratedDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegratedDraftFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegratedDraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntegratedDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegratedDrafts
     * const integratedDrafts = await prisma.integratedDraft.findMany()
     * 
     * // Get first 10 IntegratedDrafts
     * const integratedDrafts = await prisma.integratedDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integratedDraftWithIdOnly = await prisma.integratedDraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegratedDraftFindManyArgs>(args?: SelectSubset<T, IntegratedDraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntegratedDraft.
     * @param {IntegratedDraftCreateArgs} args - Arguments to create a IntegratedDraft.
     * @example
     * // Create one IntegratedDraft
     * const IntegratedDraft = await prisma.integratedDraft.create({
     *   data: {
     *     // ... data to create a IntegratedDraft
     *   }
     * })
     * 
     */
    create<T extends IntegratedDraftCreateArgs>(args: SelectSubset<T, IntegratedDraftCreateArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntegratedDrafts.
     * @param {IntegratedDraftCreateManyArgs} args - Arguments to create many IntegratedDrafts.
     * @example
     * // Create many IntegratedDrafts
     * const integratedDraft = await prisma.integratedDraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegratedDraftCreateManyArgs>(args?: SelectSubset<T, IntegratedDraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegratedDrafts and returns the data saved in the database.
     * @param {IntegratedDraftCreateManyAndReturnArgs} args - Arguments to create many IntegratedDrafts.
     * @example
     * // Create many IntegratedDrafts
     * const integratedDraft = await prisma.integratedDraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegratedDrafts and only return the `id`
     * const integratedDraftWithIdOnly = await prisma.integratedDraft.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegratedDraftCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegratedDraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntegratedDraft.
     * @param {IntegratedDraftDeleteArgs} args - Arguments to delete one IntegratedDraft.
     * @example
     * // Delete one IntegratedDraft
     * const IntegratedDraft = await prisma.integratedDraft.delete({
     *   where: {
     *     // ... filter to delete one IntegratedDraft
     *   }
     * })
     * 
     */
    delete<T extends IntegratedDraftDeleteArgs>(args: SelectSubset<T, IntegratedDraftDeleteArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntegratedDraft.
     * @param {IntegratedDraftUpdateArgs} args - Arguments to update one IntegratedDraft.
     * @example
     * // Update one IntegratedDraft
     * const integratedDraft = await prisma.integratedDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegratedDraftUpdateArgs>(args: SelectSubset<T, IntegratedDraftUpdateArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntegratedDrafts.
     * @param {IntegratedDraftDeleteManyArgs} args - Arguments to filter IntegratedDrafts to delete.
     * @example
     * // Delete a few IntegratedDrafts
     * const { count } = await prisma.integratedDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegratedDraftDeleteManyArgs>(args?: SelectSubset<T, IntegratedDraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegratedDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegratedDrafts
     * const integratedDraft = await prisma.integratedDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegratedDraftUpdateManyArgs>(args: SelectSubset<T, IntegratedDraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegratedDraft.
     * @param {IntegratedDraftUpsertArgs} args - Arguments to update or create a IntegratedDraft.
     * @example
     * // Update or create a IntegratedDraft
     * const integratedDraft = await prisma.integratedDraft.upsert({
     *   create: {
     *     // ... data to create a IntegratedDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegratedDraft we want to update
     *   }
     * })
     */
    upsert<T extends IntegratedDraftUpsertArgs>(args: SelectSubset<T, IntegratedDraftUpsertArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntegratedDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftCountArgs} args - Arguments to filter IntegratedDrafts to count.
     * @example
     * // Count the number of IntegratedDrafts
     * const count = await prisma.integratedDraft.count({
     *   where: {
     *     // ... the filter for the IntegratedDrafts we want to count
     *   }
     * })
    **/
    count<T extends IntegratedDraftCountArgs>(
      args?: Subset<T, IntegratedDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegratedDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegratedDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegratedDraftAggregateArgs>(args: Subset<T, IntegratedDraftAggregateArgs>): Prisma.PrismaPromise<GetIntegratedDraftAggregateType<T>>

    /**
     * Group by IntegratedDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegratedDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegratedDraftGroupByArgs['orderBy'] }
        : { orderBy?: IntegratedDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegratedDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegratedDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegratedDraft model
   */
  readonly fields: IntegratedDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegratedDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegratedDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends IntegratedSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedSessionDefaultArgs<ExtArgs>>): Prisma__IntegratedSessionClient<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    performance<T extends IntegratedDraft$performanceArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedDraft$performanceArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegratedDraft model
   */ 
  interface IntegratedDraftFieldRefs {
    readonly id: FieldRef<"IntegratedDraft", 'String'>
    readonly sessionId: FieldRef<"IntegratedDraft", 'String'>
    readonly title: FieldRef<"IntegratedDraft", 'String'>
    readonly content: FieldRef<"IntegratedDraft", 'String'>
    readonly contentType: FieldRef<"IntegratedDraft", 'String'>
    readonly sourcesSummary: FieldRef<"IntegratedDraft", 'String'>
    readonly newsContext: FieldRef<"IntegratedDraft", 'String'>
    readonly buzzContext: FieldRef<"IntegratedDraft", 'String'>
    readonly conceptId: FieldRef<"IntegratedDraft", 'String'>
    readonly hook: FieldRef<"IntegratedDraft", 'String'>
    readonly angle: FieldRef<"IntegratedDraft", 'String'>
    readonly sourceNewsIds: FieldRef<"IntegratedDraft", 'String[]'>
    readonly sourceBuzzIds: FieldRef<"IntegratedDraft", 'String[]'>
    readonly generationStrategy: FieldRef<"IntegratedDraft", 'String'>
    readonly generationData: FieldRef<"IntegratedDraft", 'Json'>
    readonly hashtags: FieldRef<"IntegratedDraft", 'String[]'>
    readonly visualGuide: FieldRef<"IntegratedDraft", 'String'>
    readonly status: FieldRef<"IntegratedDraft", 'String'>
    readonly scheduledAt: FieldRef<"IntegratedDraft", 'DateTime'>
    readonly postedAt: FieldRef<"IntegratedDraft", 'DateTime'>
    readonly postId: FieldRef<"IntegratedDraft", 'String'>
    readonly viralScore: FieldRef<"IntegratedDraft", 'Float'>
    readonly createdAt: FieldRef<"IntegratedDraft", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegratedDraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegratedDraft findUnique
   */
  export type IntegratedDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraft to fetch.
     */
    where: IntegratedDraftWhereUniqueInput
  }

  /**
   * IntegratedDraft findUniqueOrThrow
   */
  export type IntegratedDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraft to fetch.
     */
    where: IntegratedDraftWhereUniqueInput
  }

  /**
   * IntegratedDraft findFirst
   */
  export type IntegratedDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraft to fetch.
     */
    where?: IntegratedDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDrafts to fetch.
     */
    orderBy?: IntegratedDraftOrderByWithRelationInput | IntegratedDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedDrafts.
     */
    cursor?: IntegratedDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedDrafts.
     */
    distinct?: IntegratedDraftScalarFieldEnum | IntegratedDraftScalarFieldEnum[]
  }

  /**
   * IntegratedDraft findFirstOrThrow
   */
  export type IntegratedDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraft to fetch.
     */
    where?: IntegratedDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDrafts to fetch.
     */
    orderBy?: IntegratedDraftOrderByWithRelationInput | IntegratedDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedDrafts.
     */
    cursor?: IntegratedDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedDrafts.
     */
    distinct?: IntegratedDraftScalarFieldEnum | IntegratedDraftScalarFieldEnum[]
  }

  /**
   * IntegratedDraft findMany
   */
  export type IntegratedDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDrafts to fetch.
     */
    where?: IntegratedDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDrafts to fetch.
     */
    orderBy?: IntegratedDraftOrderByWithRelationInput | IntegratedDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegratedDrafts.
     */
    cursor?: IntegratedDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDrafts.
     */
    skip?: number
    distinct?: IntegratedDraftScalarFieldEnum | IntegratedDraftScalarFieldEnum[]
  }

  /**
   * IntegratedDraft create
   */
  export type IntegratedDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegratedDraft.
     */
    data: XOR<IntegratedDraftCreateInput, IntegratedDraftUncheckedCreateInput>
  }

  /**
   * IntegratedDraft createMany
   */
  export type IntegratedDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegratedDrafts.
     */
    data: IntegratedDraftCreateManyInput | IntegratedDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegratedDraft createManyAndReturn
   */
  export type IntegratedDraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntegratedDrafts.
     */
    data: IntegratedDraftCreateManyInput | IntegratedDraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegratedDraft update
   */
  export type IntegratedDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegratedDraft.
     */
    data: XOR<IntegratedDraftUpdateInput, IntegratedDraftUncheckedUpdateInput>
    /**
     * Choose, which IntegratedDraft to update.
     */
    where: IntegratedDraftWhereUniqueInput
  }

  /**
   * IntegratedDraft updateMany
   */
  export type IntegratedDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegratedDrafts.
     */
    data: XOR<IntegratedDraftUpdateManyMutationInput, IntegratedDraftUncheckedUpdateManyInput>
    /**
     * Filter which IntegratedDrafts to update
     */
    where?: IntegratedDraftWhereInput
  }

  /**
   * IntegratedDraft upsert
   */
  export type IntegratedDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegratedDraft to update in case it exists.
     */
    where: IntegratedDraftWhereUniqueInput
    /**
     * In case the IntegratedDraft found by the `where` argument doesn't exist, create a new IntegratedDraft with this data.
     */
    create: XOR<IntegratedDraftCreateInput, IntegratedDraftUncheckedCreateInput>
    /**
     * In case the IntegratedDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegratedDraftUpdateInput, IntegratedDraftUncheckedUpdateInput>
  }

  /**
   * IntegratedDraft delete
   */
  export type IntegratedDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
    /**
     * Filter which IntegratedDraft to delete.
     */
    where: IntegratedDraftWhereUniqueInput
  }

  /**
   * IntegratedDraft deleteMany
   */
  export type IntegratedDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedDrafts to delete
     */
    where?: IntegratedDraftWhereInput
  }

  /**
   * IntegratedDraft.performance
   */
  export type IntegratedDraft$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    where?: IntegratedDraftPerformanceWhereInput
  }

  /**
   * IntegratedDraft without action
   */
  export type IntegratedDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraft
     */
    select?: IntegratedDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftInclude<ExtArgs> | null
  }


  /**
   * Model IntegratedDraftPerformance
   */

  export type AggregateIntegratedDraftPerformance = {
    _count: IntegratedDraftPerformanceCountAggregateOutputType | null
    _avg: IntegratedDraftPerformanceAvgAggregateOutputType | null
    _sum: IntegratedDraftPerformanceSumAggregateOutputType | null
    _min: IntegratedDraftPerformanceMinAggregateOutputType | null
    _max: IntegratedDraftPerformanceMaxAggregateOutputType | null
  }

  export type IntegratedDraftPerformanceAvgAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    predictionAccuracy: number | null
  }

  export type IntegratedDraftPerformanceSumAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    predictionAccuracy: number | null
  }

  export type IntegratedDraftPerformanceMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    predictionAccuracy: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type IntegratedDraftPerformanceMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    predictionAccuracy: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type IntegratedDraftPerformanceCountAggregateOutputType = {
    id: number
    draftId: number
    likes30m: number
    retweets30m: number
    replies30m: number
    impressions30m: number
    likes1h: number
    retweets1h: number
    replies1h: number
    impressions1h: number
    likes24h: number
    retweets24h: number
    replies24h: number
    impressions24h: number
    engagementRate: number
    viralCoefficient: number
    predictionAccuracy: number
    collectedAt: number
    updatedAt: number
    _all: number
  }


  export type IntegratedDraftPerformanceAvgAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    predictionAccuracy?: true
  }

  export type IntegratedDraftPerformanceSumAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    predictionAccuracy?: true
  }

  export type IntegratedDraftPerformanceMinAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    predictionAccuracy?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type IntegratedDraftPerformanceMaxAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    predictionAccuracy?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type IntegratedDraftPerformanceCountAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    predictionAccuracy?: true
    collectedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegratedDraftPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedDraftPerformance to aggregate.
     */
    where?: IntegratedDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDraftPerformances to fetch.
     */
    orderBy?: IntegratedDraftPerformanceOrderByWithRelationInput | IntegratedDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegratedDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegratedDraftPerformances
    **/
    _count?: true | IntegratedDraftPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegratedDraftPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegratedDraftPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegratedDraftPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegratedDraftPerformanceMaxAggregateInputType
  }

  export type GetIntegratedDraftPerformanceAggregateType<T extends IntegratedDraftPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegratedDraftPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegratedDraftPerformance[P]>
      : GetScalarType<T[P], AggregateIntegratedDraftPerformance[P]>
  }




  export type IntegratedDraftPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegratedDraftPerformanceWhereInput
    orderBy?: IntegratedDraftPerformanceOrderByWithAggregationInput | IntegratedDraftPerformanceOrderByWithAggregationInput[]
    by: IntegratedDraftPerformanceScalarFieldEnum[] | IntegratedDraftPerformanceScalarFieldEnum
    having?: IntegratedDraftPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegratedDraftPerformanceCountAggregateInputType | true
    _avg?: IntegratedDraftPerformanceAvgAggregateInputType
    _sum?: IntegratedDraftPerformanceSumAggregateInputType
    _min?: IntegratedDraftPerformanceMinAggregateInputType
    _max?: IntegratedDraftPerformanceMaxAggregateInputType
  }

  export type IntegratedDraftPerformanceGroupByOutputType = {
    id: string
    draftId: string
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    predictionAccuracy: number | null
    collectedAt: Date
    updatedAt: Date
    _count: IntegratedDraftPerformanceCountAggregateOutputType | null
    _avg: IntegratedDraftPerformanceAvgAggregateOutputType | null
    _sum: IntegratedDraftPerformanceSumAggregateOutputType | null
    _min: IntegratedDraftPerformanceMinAggregateOutputType | null
    _max: IntegratedDraftPerformanceMaxAggregateOutputType | null
  }

  type GetIntegratedDraftPerformanceGroupByPayload<T extends IntegratedDraftPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegratedDraftPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegratedDraftPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegratedDraftPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], IntegratedDraftPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type IntegratedDraftPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    predictionAccuracy?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | IntegratedDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integratedDraftPerformance"]>

  export type IntegratedDraftPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    predictionAccuracy?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | IntegratedDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integratedDraftPerformance"]>

  export type IntegratedDraftPerformanceSelectScalar = {
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    predictionAccuracy?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }

  export type IntegratedDraftPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | IntegratedDraftDefaultArgs<ExtArgs>
  }
  export type IntegratedDraftPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | IntegratedDraftDefaultArgs<ExtArgs>
  }

  export type $IntegratedDraftPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegratedDraftPerformance"
    objects: {
      draft: Prisma.$IntegratedDraftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      likes30m: number | null
      retweets30m: number | null
      replies30m: number | null
      impressions30m: number | null
      likes1h: number | null
      retweets1h: number | null
      replies1h: number | null
      impressions1h: number | null
      likes24h: number | null
      retweets24h: number | null
      replies24h: number | null
      impressions24h: number | null
      engagementRate: number | null
      viralCoefficient: number | null
      predictionAccuracy: number | null
      collectedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integratedDraftPerformance"]>
    composites: {}
  }

  type IntegratedDraftPerformanceGetPayload<S extends boolean | null | undefined | IntegratedDraftPerformanceDefaultArgs> = $Result.GetResult<Prisma.$IntegratedDraftPerformancePayload, S>

  type IntegratedDraftPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegratedDraftPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegratedDraftPerformanceCountAggregateInputType | true
    }

  export interface IntegratedDraftPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegratedDraftPerformance'], meta: { name: 'IntegratedDraftPerformance' } }
    /**
     * Find zero or one IntegratedDraftPerformance that matches the filter.
     * @param {IntegratedDraftPerformanceFindUniqueArgs} args - Arguments to find a IntegratedDraftPerformance
     * @example
     * // Get one IntegratedDraftPerformance
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegratedDraftPerformanceFindUniqueArgs>(args: SelectSubset<T, IntegratedDraftPerformanceFindUniqueArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntegratedDraftPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegratedDraftPerformanceFindUniqueOrThrowArgs} args - Arguments to find a IntegratedDraftPerformance
     * @example
     * // Get one IntegratedDraftPerformance
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegratedDraftPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegratedDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntegratedDraftPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceFindFirstArgs} args - Arguments to find a IntegratedDraftPerformance
     * @example
     * // Get one IntegratedDraftPerformance
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegratedDraftPerformanceFindFirstArgs>(args?: SelectSubset<T, IntegratedDraftPerformanceFindFirstArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntegratedDraftPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceFindFirstOrThrowArgs} args - Arguments to find a IntegratedDraftPerformance
     * @example
     * // Get one IntegratedDraftPerformance
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegratedDraftPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegratedDraftPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntegratedDraftPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegratedDraftPerformances
     * const integratedDraftPerformances = await prisma.integratedDraftPerformance.findMany()
     * 
     * // Get first 10 IntegratedDraftPerformances
     * const integratedDraftPerformances = await prisma.integratedDraftPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integratedDraftPerformanceWithIdOnly = await prisma.integratedDraftPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegratedDraftPerformanceFindManyArgs>(args?: SelectSubset<T, IntegratedDraftPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntegratedDraftPerformance.
     * @param {IntegratedDraftPerformanceCreateArgs} args - Arguments to create a IntegratedDraftPerformance.
     * @example
     * // Create one IntegratedDraftPerformance
     * const IntegratedDraftPerformance = await prisma.integratedDraftPerformance.create({
     *   data: {
     *     // ... data to create a IntegratedDraftPerformance
     *   }
     * })
     * 
     */
    create<T extends IntegratedDraftPerformanceCreateArgs>(args: SelectSubset<T, IntegratedDraftPerformanceCreateArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntegratedDraftPerformances.
     * @param {IntegratedDraftPerformanceCreateManyArgs} args - Arguments to create many IntegratedDraftPerformances.
     * @example
     * // Create many IntegratedDraftPerformances
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegratedDraftPerformanceCreateManyArgs>(args?: SelectSubset<T, IntegratedDraftPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegratedDraftPerformances and returns the data saved in the database.
     * @param {IntegratedDraftPerformanceCreateManyAndReturnArgs} args - Arguments to create many IntegratedDraftPerformances.
     * @example
     * // Create many IntegratedDraftPerformances
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegratedDraftPerformances and only return the `id`
     * const integratedDraftPerformanceWithIdOnly = await prisma.integratedDraftPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegratedDraftPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegratedDraftPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntegratedDraftPerformance.
     * @param {IntegratedDraftPerformanceDeleteArgs} args - Arguments to delete one IntegratedDraftPerformance.
     * @example
     * // Delete one IntegratedDraftPerformance
     * const IntegratedDraftPerformance = await prisma.integratedDraftPerformance.delete({
     *   where: {
     *     // ... filter to delete one IntegratedDraftPerformance
     *   }
     * })
     * 
     */
    delete<T extends IntegratedDraftPerformanceDeleteArgs>(args: SelectSubset<T, IntegratedDraftPerformanceDeleteArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntegratedDraftPerformance.
     * @param {IntegratedDraftPerformanceUpdateArgs} args - Arguments to update one IntegratedDraftPerformance.
     * @example
     * // Update one IntegratedDraftPerformance
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegratedDraftPerformanceUpdateArgs>(args: SelectSubset<T, IntegratedDraftPerformanceUpdateArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntegratedDraftPerformances.
     * @param {IntegratedDraftPerformanceDeleteManyArgs} args - Arguments to filter IntegratedDraftPerformances to delete.
     * @example
     * // Delete a few IntegratedDraftPerformances
     * const { count } = await prisma.integratedDraftPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegratedDraftPerformanceDeleteManyArgs>(args?: SelectSubset<T, IntegratedDraftPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegratedDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegratedDraftPerformances
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegratedDraftPerformanceUpdateManyArgs>(args: SelectSubset<T, IntegratedDraftPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegratedDraftPerformance.
     * @param {IntegratedDraftPerformanceUpsertArgs} args - Arguments to update or create a IntegratedDraftPerformance.
     * @example
     * // Update or create a IntegratedDraftPerformance
     * const integratedDraftPerformance = await prisma.integratedDraftPerformance.upsert({
     *   create: {
     *     // ... data to create a IntegratedDraftPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegratedDraftPerformance we want to update
     *   }
     * })
     */
    upsert<T extends IntegratedDraftPerformanceUpsertArgs>(args: SelectSubset<T, IntegratedDraftPerformanceUpsertArgs<ExtArgs>>): Prisma__IntegratedDraftPerformanceClient<$Result.GetResult<Prisma.$IntegratedDraftPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntegratedDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceCountArgs} args - Arguments to filter IntegratedDraftPerformances to count.
     * @example
     * // Count the number of IntegratedDraftPerformances
     * const count = await prisma.integratedDraftPerformance.count({
     *   where: {
     *     // ... the filter for the IntegratedDraftPerformances we want to count
     *   }
     * })
    **/
    count<T extends IntegratedDraftPerformanceCountArgs>(
      args?: Subset<T, IntegratedDraftPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegratedDraftPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegratedDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegratedDraftPerformanceAggregateArgs>(args: Subset<T, IntegratedDraftPerformanceAggregateArgs>): Prisma.PrismaPromise<GetIntegratedDraftPerformanceAggregateType<T>>

    /**
     * Group by IntegratedDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegratedDraftPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegratedDraftPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegratedDraftPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: IntegratedDraftPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegratedDraftPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegratedDraftPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegratedDraftPerformance model
   */
  readonly fields: IntegratedDraftPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegratedDraftPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegratedDraftPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends IntegratedDraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntegratedDraftDefaultArgs<ExtArgs>>): Prisma__IntegratedDraftClient<$Result.GetResult<Prisma.$IntegratedDraftPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegratedDraftPerformance model
   */ 
  interface IntegratedDraftPerformanceFieldRefs {
    readonly id: FieldRef<"IntegratedDraftPerformance", 'String'>
    readonly draftId: FieldRef<"IntegratedDraftPerformance", 'String'>
    readonly likes30m: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly retweets30m: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly replies30m: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly impressions30m: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly likes1h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly retweets1h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly replies1h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly impressions1h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly likes24h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly retweets24h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly replies24h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly impressions24h: FieldRef<"IntegratedDraftPerformance", 'Int'>
    readonly engagementRate: FieldRef<"IntegratedDraftPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"IntegratedDraftPerformance", 'Float'>
    readonly predictionAccuracy: FieldRef<"IntegratedDraftPerformance", 'Float'>
    readonly collectedAt: FieldRef<"IntegratedDraftPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegratedDraftPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegratedDraftPerformance findUnique
   */
  export type IntegratedDraftPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraftPerformance to fetch.
     */
    where: IntegratedDraftPerformanceWhereUniqueInput
  }

  /**
   * IntegratedDraftPerformance findUniqueOrThrow
   */
  export type IntegratedDraftPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraftPerformance to fetch.
     */
    where: IntegratedDraftPerformanceWhereUniqueInput
  }

  /**
   * IntegratedDraftPerformance findFirst
   */
  export type IntegratedDraftPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraftPerformance to fetch.
     */
    where?: IntegratedDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDraftPerformances to fetch.
     */
    orderBy?: IntegratedDraftPerformanceOrderByWithRelationInput | IntegratedDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedDraftPerformances.
     */
    cursor?: IntegratedDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedDraftPerformances.
     */
    distinct?: IntegratedDraftPerformanceScalarFieldEnum | IntegratedDraftPerformanceScalarFieldEnum[]
  }

  /**
   * IntegratedDraftPerformance findFirstOrThrow
   */
  export type IntegratedDraftPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraftPerformance to fetch.
     */
    where?: IntegratedDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDraftPerformances to fetch.
     */
    orderBy?: IntegratedDraftPerformanceOrderByWithRelationInput | IntegratedDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegratedDraftPerformances.
     */
    cursor?: IntegratedDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegratedDraftPerformances.
     */
    distinct?: IntegratedDraftPerformanceScalarFieldEnum | IntegratedDraftPerformanceScalarFieldEnum[]
  }

  /**
   * IntegratedDraftPerformance findMany
   */
  export type IntegratedDraftPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which IntegratedDraftPerformances to fetch.
     */
    where?: IntegratedDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegratedDraftPerformances to fetch.
     */
    orderBy?: IntegratedDraftPerformanceOrderByWithRelationInput | IntegratedDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegratedDraftPerformances.
     */
    cursor?: IntegratedDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegratedDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegratedDraftPerformances.
     */
    skip?: number
    distinct?: IntegratedDraftPerformanceScalarFieldEnum | IntegratedDraftPerformanceScalarFieldEnum[]
  }

  /**
   * IntegratedDraftPerformance create
   */
  export type IntegratedDraftPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegratedDraftPerformance.
     */
    data: XOR<IntegratedDraftPerformanceCreateInput, IntegratedDraftPerformanceUncheckedCreateInput>
  }

  /**
   * IntegratedDraftPerformance createMany
   */
  export type IntegratedDraftPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegratedDraftPerformances.
     */
    data: IntegratedDraftPerformanceCreateManyInput | IntegratedDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegratedDraftPerformance createManyAndReturn
   */
  export type IntegratedDraftPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntegratedDraftPerformances.
     */
    data: IntegratedDraftPerformanceCreateManyInput | IntegratedDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegratedDraftPerformance update
   */
  export type IntegratedDraftPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegratedDraftPerformance.
     */
    data: XOR<IntegratedDraftPerformanceUpdateInput, IntegratedDraftPerformanceUncheckedUpdateInput>
    /**
     * Choose, which IntegratedDraftPerformance to update.
     */
    where: IntegratedDraftPerformanceWhereUniqueInput
  }

  /**
   * IntegratedDraftPerformance updateMany
   */
  export type IntegratedDraftPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegratedDraftPerformances.
     */
    data: XOR<IntegratedDraftPerformanceUpdateManyMutationInput, IntegratedDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which IntegratedDraftPerformances to update
     */
    where?: IntegratedDraftPerformanceWhereInput
  }

  /**
   * IntegratedDraftPerformance upsert
   */
  export type IntegratedDraftPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegratedDraftPerformance to update in case it exists.
     */
    where: IntegratedDraftPerformanceWhereUniqueInput
    /**
     * In case the IntegratedDraftPerformance found by the `where` argument doesn't exist, create a new IntegratedDraftPerformance with this data.
     */
    create: XOR<IntegratedDraftPerformanceCreateInput, IntegratedDraftPerformanceUncheckedCreateInput>
    /**
     * In case the IntegratedDraftPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegratedDraftPerformanceUpdateInput, IntegratedDraftPerformanceUncheckedUpdateInput>
  }

  /**
   * IntegratedDraftPerformance delete
   */
  export type IntegratedDraftPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter which IntegratedDraftPerformance to delete.
     */
    where: IntegratedDraftPerformanceWhereUniqueInput
  }

  /**
   * IntegratedDraftPerformance deleteMany
   */
  export type IntegratedDraftPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegratedDraftPerformances to delete
     */
    where?: IntegratedDraftPerformanceWhereInput
  }

  /**
   * IntegratedDraftPerformance without action
   */
  export type IntegratedDraftPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedDraftPerformance
     */
    select?: IntegratedDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedDraftPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledRetweet
   */

  export type AggregateScheduledRetweet = {
    _count: ScheduledRetweetCountAggregateOutputType | null
    _min: ScheduledRetweetMinAggregateOutputType | null
    _max: ScheduledRetweetMaxAggregateOutputType | null
  }

  export type ScheduledRetweetMinAggregateOutputType = {
    id: string | null
    originalPostId: string | null
    originalContent: string | null
    scheduledAt: Date | null
    status: $Enums.RTStatus | null
    rtStrategy: string | null
    addComment: boolean | null
    commentText: string | null
    viralDraftId: string | null
    cotDraftId: string | null
    executedAt: Date | null
    rtPostId: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledRetweetMaxAggregateOutputType = {
    id: string | null
    originalPostId: string | null
    originalContent: string | null
    scheduledAt: Date | null
    status: $Enums.RTStatus | null
    rtStrategy: string | null
    addComment: boolean | null
    commentText: string | null
    viralDraftId: string | null
    cotDraftId: string | null
    executedAt: Date | null
    rtPostId: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledRetweetCountAggregateOutputType = {
    id: number
    originalPostId: number
    originalContent: number
    scheduledAt: number
    status: number
    rtStrategy: number
    addComment: number
    commentText: number
    viralDraftId: number
    cotDraftId: number
    executedAt: number
    rtPostId: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledRetweetMinAggregateInputType = {
    id?: true
    originalPostId?: true
    originalContent?: true
    scheduledAt?: true
    status?: true
    rtStrategy?: true
    addComment?: true
    commentText?: true
    viralDraftId?: true
    cotDraftId?: true
    executedAt?: true
    rtPostId?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledRetweetMaxAggregateInputType = {
    id?: true
    originalPostId?: true
    originalContent?: true
    scheduledAt?: true
    status?: true
    rtStrategy?: true
    addComment?: true
    commentText?: true
    viralDraftId?: true
    cotDraftId?: true
    executedAt?: true
    rtPostId?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledRetweetCountAggregateInputType = {
    id?: true
    originalPostId?: true
    originalContent?: true
    scheduledAt?: true
    status?: true
    rtStrategy?: true
    addComment?: true
    commentText?: true
    viralDraftId?: true
    cotDraftId?: true
    executedAt?: true
    rtPostId?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledRetweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledRetweet to aggregate.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledRetweets
    **/
    _count?: true | ScheduledRetweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledRetweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledRetweetMaxAggregateInputType
  }

  export type GetScheduledRetweetAggregateType<T extends ScheduledRetweetAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledRetweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledRetweet[P]>
      : GetScalarType<T[P], AggregateScheduledRetweet[P]>
  }




  export type ScheduledRetweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledRetweetWhereInput
    orderBy?: ScheduledRetweetOrderByWithAggregationInput | ScheduledRetweetOrderByWithAggregationInput[]
    by: ScheduledRetweetScalarFieldEnum[] | ScheduledRetweetScalarFieldEnum
    having?: ScheduledRetweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledRetweetCountAggregateInputType | true
    _min?: ScheduledRetweetMinAggregateInputType
    _max?: ScheduledRetweetMaxAggregateInputType
  }

  export type ScheduledRetweetGroupByOutputType = {
    id: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date
    status: $Enums.RTStatus
    rtStrategy: string
    addComment: boolean
    commentText: string | null
    viralDraftId: string | null
    cotDraftId: string | null
    executedAt: Date | null
    rtPostId: string | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledRetweetCountAggregateOutputType | null
    _min: ScheduledRetweetMinAggregateOutputType | null
    _max: ScheduledRetweetMaxAggregateOutputType | null
  }

  type GetScheduledRetweetGroupByPayload<T extends ScheduledRetweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledRetweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledRetweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledRetweetGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledRetweetGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledRetweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    viralDraft?: boolean | ScheduledRetweet$viralDraftArgs<ExtArgs>
    cotDraft?: boolean | ScheduledRetweet$cotDraftArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledRetweet"]>

  export type ScheduledRetweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    viralDraft?: boolean | ScheduledRetweet$viralDraftArgs<ExtArgs>
    cotDraft?: boolean | ScheduledRetweet$cotDraftArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledRetweet"]>

  export type ScheduledRetweetSelectScalar = {
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledRetweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viralDraft?: boolean | ScheduledRetweet$viralDraftArgs<ExtArgs>
    cotDraft?: boolean | ScheduledRetweet$cotDraftArgs<ExtArgs>
  }
  export type ScheduledRetweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viralDraft?: boolean | ScheduledRetweet$viralDraftArgs<ExtArgs>
    cotDraft?: boolean | ScheduledRetweet$cotDraftArgs<ExtArgs>
  }

  export type $ScheduledRetweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledRetweet"
    objects: {
      viralDraft: Prisma.$ViralDraftV2Payload<ExtArgs> | null
      cotDraft: Prisma.$CotDraftPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      originalPostId: string
      originalContent: string
      scheduledAt: Date
      status: $Enums.RTStatus
      rtStrategy: string
      addComment: boolean
      commentText: string | null
      viralDraftId: string | null
      cotDraftId: string | null
      executedAt: Date | null
      rtPostId: string | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledRetweet"]>
    composites: {}
  }

  type ScheduledRetweetGetPayload<S extends boolean | null | undefined | ScheduledRetweetDefaultArgs> = $Result.GetResult<Prisma.$ScheduledRetweetPayload, S>

  type ScheduledRetweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledRetweetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledRetweetCountAggregateInputType | true
    }

  export interface ScheduledRetweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledRetweet'], meta: { name: 'ScheduledRetweet' } }
    /**
     * Find zero or one ScheduledRetweet that matches the filter.
     * @param {ScheduledRetweetFindUniqueArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledRetweetFindUniqueArgs>(args: SelectSubset<T, ScheduledRetweetFindUniqueArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledRetweet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledRetweetFindUniqueOrThrowArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledRetweetFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledRetweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledRetweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetFindFirstArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledRetweetFindFirstArgs>(args?: SelectSubset<T, ScheduledRetweetFindFirstArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledRetweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetFindFirstOrThrowArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledRetweetFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledRetweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledRetweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledRetweets
     * const scheduledRetweets = await prisma.scheduledRetweet.findMany()
     * 
     * // Get first 10 ScheduledRetweets
     * const scheduledRetweets = await prisma.scheduledRetweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledRetweetWithIdOnly = await prisma.scheduledRetweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledRetweetFindManyArgs>(args?: SelectSubset<T, ScheduledRetweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledRetweet.
     * @param {ScheduledRetweetCreateArgs} args - Arguments to create a ScheduledRetweet.
     * @example
     * // Create one ScheduledRetweet
     * const ScheduledRetweet = await prisma.scheduledRetweet.create({
     *   data: {
     *     // ... data to create a ScheduledRetweet
     *   }
     * })
     * 
     */
    create<T extends ScheduledRetweetCreateArgs>(args: SelectSubset<T, ScheduledRetweetCreateArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledRetweets.
     * @param {ScheduledRetweetCreateManyArgs} args - Arguments to create many ScheduledRetweets.
     * @example
     * // Create many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledRetweetCreateManyArgs>(args?: SelectSubset<T, ScheduledRetweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledRetweets and returns the data saved in the database.
     * @param {ScheduledRetweetCreateManyAndReturnArgs} args - Arguments to create many ScheduledRetweets.
     * @example
     * // Create many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledRetweets and only return the `id`
     * const scheduledRetweetWithIdOnly = await prisma.scheduledRetweet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledRetweetCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledRetweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledRetweet.
     * @param {ScheduledRetweetDeleteArgs} args - Arguments to delete one ScheduledRetweet.
     * @example
     * // Delete one ScheduledRetweet
     * const ScheduledRetweet = await prisma.scheduledRetweet.delete({
     *   where: {
     *     // ... filter to delete one ScheduledRetweet
     *   }
     * })
     * 
     */
    delete<T extends ScheduledRetweetDeleteArgs>(args: SelectSubset<T, ScheduledRetweetDeleteArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledRetweet.
     * @param {ScheduledRetweetUpdateArgs} args - Arguments to update one ScheduledRetweet.
     * @example
     * // Update one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledRetweetUpdateArgs>(args: SelectSubset<T, ScheduledRetweetUpdateArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledRetweets.
     * @param {ScheduledRetweetDeleteManyArgs} args - Arguments to filter ScheduledRetweets to delete.
     * @example
     * // Delete a few ScheduledRetweets
     * const { count } = await prisma.scheduledRetweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledRetweetDeleteManyArgs>(args?: SelectSubset<T, ScheduledRetweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledRetweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledRetweetUpdateManyArgs>(args: SelectSubset<T, ScheduledRetweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledRetweet.
     * @param {ScheduledRetweetUpsertArgs} args - Arguments to update or create a ScheduledRetweet.
     * @example
     * // Update or create a ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.upsert({
     *   create: {
     *     // ... data to create a ScheduledRetweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledRetweet we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledRetweetUpsertArgs>(args: SelectSubset<T, ScheduledRetweetUpsertArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledRetweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetCountArgs} args - Arguments to filter ScheduledRetweets to count.
     * @example
     * // Count the number of ScheduledRetweets
     * const count = await prisma.scheduledRetweet.count({
     *   where: {
     *     // ... the filter for the ScheduledRetweets we want to count
     *   }
     * })
    **/
    count<T extends ScheduledRetweetCountArgs>(
      args?: Subset<T, ScheduledRetweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledRetweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledRetweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledRetweetAggregateArgs>(args: Subset<T, ScheduledRetweetAggregateArgs>): Prisma.PrismaPromise<GetScheduledRetweetAggregateType<T>>

    /**
     * Group by ScheduledRetweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledRetweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledRetweetGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledRetweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledRetweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledRetweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledRetweet model
   */
  readonly fields: ScheduledRetweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledRetweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledRetweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viralDraft<T extends ScheduledRetweet$viralDraftArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledRetweet$viralDraftArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cotDraft<T extends ScheduledRetweet$cotDraftArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledRetweet$cotDraftArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledRetweet model
   */ 
  interface ScheduledRetweetFieldRefs {
    readonly id: FieldRef<"ScheduledRetweet", 'String'>
    readonly originalPostId: FieldRef<"ScheduledRetweet", 'String'>
    readonly originalContent: FieldRef<"ScheduledRetweet", 'String'>
    readonly scheduledAt: FieldRef<"ScheduledRetweet", 'DateTime'>
    readonly status: FieldRef<"ScheduledRetweet", 'RTStatus'>
    readonly rtStrategy: FieldRef<"ScheduledRetweet", 'String'>
    readonly addComment: FieldRef<"ScheduledRetweet", 'Boolean'>
    readonly commentText: FieldRef<"ScheduledRetweet", 'String'>
    readonly viralDraftId: FieldRef<"ScheduledRetweet", 'String'>
    readonly cotDraftId: FieldRef<"ScheduledRetweet", 'String'>
    readonly executedAt: FieldRef<"ScheduledRetweet", 'DateTime'>
    readonly rtPostId: FieldRef<"ScheduledRetweet", 'String'>
    readonly error: FieldRef<"ScheduledRetweet", 'String'>
    readonly createdAt: FieldRef<"ScheduledRetweet", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledRetweet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledRetweet findUnique
   */
  export type ScheduledRetweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet findUniqueOrThrow
   */
  export type ScheduledRetweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet findFirst
   */
  export type ScheduledRetweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledRetweets.
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledRetweets.
     */
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ScheduledRetweet findFirstOrThrow
   */
  export type ScheduledRetweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledRetweets.
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledRetweets.
     */
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ScheduledRetweet findMany
   */
  export type ScheduledRetweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweets to fetch.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledRetweets.
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ScheduledRetweet create
   */
  export type ScheduledRetweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledRetweet.
     */
    data: XOR<ScheduledRetweetCreateInput, ScheduledRetweetUncheckedCreateInput>
  }

  /**
   * ScheduledRetweet createMany
   */
  export type ScheduledRetweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledRetweets.
     */
    data: ScheduledRetweetCreateManyInput | ScheduledRetweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledRetweet createManyAndReturn
   */
  export type ScheduledRetweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledRetweets.
     */
    data: ScheduledRetweetCreateManyInput | ScheduledRetweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledRetweet update
   */
  export type ScheduledRetweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledRetweet.
     */
    data: XOR<ScheduledRetweetUpdateInput, ScheduledRetweetUncheckedUpdateInput>
    /**
     * Choose, which ScheduledRetweet to update.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet updateMany
   */
  export type ScheduledRetweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledRetweets.
     */
    data: XOR<ScheduledRetweetUpdateManyMutationInput, ScheduledRetweetUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledRetweets to update
     */
    where?: ScheduledRetweetWhereInput
  }

  /**
   * ScheduledRetweet upsert
   */
  export type ScheduledRetweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledRetweet to update in case it exists.
     */
    where: ScheduledRetweetWhereUniqueInput
    /**
     * In case the ScheduledRetweet found by the `where` argument doesn't exist, create a new ScheduledRetweet with this data.
     */
    create: XOR<ScheduledRetweetCreateInput, ScheduledRetweetUncheckedCreateInput>
    /**
     * In case the ScheduledRetweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledRetweetUpdateInput, ScheduledRetweetUncheckedUpdateInput>
  }

  /**
   * ScheduledRetweet delete
   */
  export type ScheduledRetweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    /**
     * Filter which ScheduledRetweet to delete.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet deleteMany
   */
  export type ScheduledRetweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledRetweets to delete
     */
    where?: ScheduledRetweetWhereInput
  }

  /**
   * ScheduledRetweet.viralDraft
   */
  export type ScheduledRetweet$viralDraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    where?: ViralDraftV2WhereInput
  }

  /**
   * ScheduledRetweet.cotDraft
   */
  export type ScheduledRetweet$cotDraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    where?: CotDraftWhereInput
  }

  /**
   * ScheduledRetweet without action
   */
  export type ScheduledRetweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
  }


  /**
   * Model UnifiedPerformance
   */

  export type AggregateUnifiedPerformance = {
    _count: UnifiedPerformanceCountAggregateOutputType | null
    _avg: UnifiedPerformanceAvgAggregateOutputType | null
    _sum: UnifiedPerformanceSumAggregateOutputType | null
    _min: UnifiedPerformanceMinAggregateOutputType | null
    _max: UnifiedPerformanceMaxAggregateOutputType | null
  }

  export type UnifiedPerformanceAvgAggregateOutputType = {
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type UnifiedPerformanceSumAggregateOutputType = {
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type UnifiedPerformanceMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    contentType: string | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedPerformanceMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    contentType: string | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedPerformanceCountAggregateOutputType = {
    id: number
    contentId: number
    contentType: number
    metrics30m: number
    metrics1h: number
    metrics24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    updatedAt: number
    _all: number
  }


  export type UnifiedPerformanceAvgAggregateInputType = {
    engagementRate?: true
    viralCoefficient?: true
  }

  export type UnifiedPerformanceSumAggregateInputType = {
    engagementRate?: true
    viralCoefficient?: true
  }

  export type UnifiedPerformanceMinAggregateInputType = {
    id?: true
    contentId?: true
    contentType?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type UnifiedPerformanceMaxAggregateInputType = {
    id?: true
    contentId?: true
    contentType?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type UnifiedPerformanceCountAggregateInputType = {
    id?: true
    contentId?: true
    contentType?: true
    metrics30m?: true
    metrics1h?: true
    metrics24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnifiedPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedPerformance to aggregate.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnifiedPerformances
    **/
    _count?: true | UnifiedPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnifiedPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnifiedPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnifiedPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnifiedPerformanceMaxAggregateInputType
  }

  export type GetUnifiedPerformanceAggregateType<T extends UnifiedPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateUnifiedPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnifiedPerformance[P]>
      : GetScalarType<T[P], AggregateUnifiedPerformance[P]>
  }




  export type UnifiedPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnifiedPerformanceWhereInput
    orderBy?: UnifiedPerformanceOrderByWithAggregationInput | UnifiedPerformanceOrderByWithAggregationInput[]
    by: UnifiedPerformanceScalarFieldEnum[] | UnifiedPerformanceScalarFieldEnum
    having?: UnifiedPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnifiedPerformanceCountAggregateInputType | true
    _avg?: UnifiedPerformanceAvgAggregateInputType
    _sum?: UnifiedPerformanceSumAggregateInputType
    _min?: UnifiedPerformanceMinAggregateInputType
    _max?: UnifiedPerformanceMaxAggregateInputType
  }

  export type UnifiedPerformanceGroupByOutputType = {
    id: string
    contentId: string
    contentType: string
    metrics30m: JsonValue | null
    metrics1h: JsonValue | null
    metrics24h: JsonValue | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    updatedAt: Date
    _count: UnifiedPerformanceCountAggregateOutputType | null
    _avg: UnifiedPerformanceAvgAggregateOutputType | null
    _sum: UnifiedPerformanceSumAggregateOutputType | null
    _min: UnifiedPerformanceMinAggregateOutputType | null
    _max: UnifiedPerformanceMaxAggregateOutputType | null
  }

  type GetUnifiedPerformanceGroupByPayload<T extends UnifiedPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnifiedPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnifiedPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnifiedPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], UnifiedPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type UnifiedPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedPerformance"]>

  export type UnifiedPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedPerformance"]>

  export type UnifiedPerformanceSelectScalar = {
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }


  export type $UnifiedPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnifiedPerformance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      contentType: string
      metrics30m: Prisma.JsonValue | null
      metrics1h: Prisma.JsonValue | null
      metrics24h: Prisma.JsonValue | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unifiedPerformance"]>
    composites: {}
  }

  type UnifiedPerformanceGetPayload<S extends boolean | null | undefined | UnifiedPerformanceDefaultArgs> = $Result.GetResult<Prisma.$UnifiedPerformancePayload, S>

  type UnifiedPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnifiedPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnifiedPerformanceCountAggregateInputType | true
    }

  export interface UnifiedPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnifiedPerformance'], meta: { name: 'UnifiedPerformance' } }
    /**
     * Find zero or one UnifiedPerformance that matches the filter.
     * @param {UnifiedPerformanceFindUniqueArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnifiedPerformanceFindUniqueArgs>(args: SelectSubset<T, UnifiedPerformanceFindUniqueArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnifiedPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnifiedPerformanceFindUniqueOrThrowArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnifiedPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, UnifiedPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnifiedPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceFindFirstArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnifiedPerformanceFindFirstArgs>(args?: SelectSubset<T, UnifiedPerformanceFindFirstArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnifiedPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceFindFirstOrThrowArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnifiedPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, UnifiedPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnifiedPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnifiedPerformances
     * const unifiedPerformances = await prisma.unifiedPerformance.findMany()
     * 
     * // Get first 10 UnifiedPerformances
     * const unifiedPerformances = await prisma.unifiedPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unifiedPerformanceWithIdOnly = await prisma.unifiedPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnifiedPerformanceFindManyArgs>(args?: SelectSubset<T, UnifiedPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnifiedPerformance.
     * @param {UnifiedPerformanceCreateArgs} args - Arguments to create a UnifiedPerformance.
     * @example
     * // Create one UnifiedPerformance
     * const UnifiedPerformance = await prisma.unifiedPerformance.create({
     *   data: {
     *     // ... data to create a UnifiedPerformance
     *   }
     * })
     * 
     */
    create<T extends UnifiedPerformanceCreateArgs>(args: SelectSubset<T, UnifiedPerformanceCreateArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnifiedPerformances.
     * @param {UnifiedPerformanceCreateManyArgs} args - Arguments to create many UnifiedPerformances.
     * @example
     * // Create many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnifiedPerformanceCreateManyArgs>(args?: SelectSubset<T, UnifiedPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnifiedPerformances and returns the data saved in the database.
     * @param {UnifiedPerformanceCreateManyAndReturnArgs} args - Arguments to create many UnifiedPerformances.
     * @example
     * // Create many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnifiedPerformances and only return the `id`
     * const unifiedPerformanceWithIdOnly = await prisma.unifiedPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnifiedPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, UnifiedPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnifiedPerformance.
     * @param {UnifiedPerformanceDeleteArgs} args - Arguments to delete one UnifiedPerformance.
     * @example
     * // Delete one UnifiedPerformance
     * const UnifiedPerformance = await prisma.unifiedPerformance.delete({
     *   where: {
     *     // ... filter to delete one UnifiedPerformance
     *   }
     * })
     * 
     */
    delete<T extends UnifiedPerformanceDeleteArgs>(args: SelectSubset<T, UnifiedPerformanceDeleteArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnifiedPerformance.
     * @param {UnifiedPerformanceUpdateArgs} args - Arguments to update one UnifiedPerformance.
     * @example
     * // Update one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnifiedPerformanceUpdateArgs>(args: SelectSubset<T, UnifiedPerformanceUpdateArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnifiedPerformances.
     * @param {UnifiedPerformanceDeleteManyArgs} args - Arguments to filter UnifiedPerformances to delete.
     * @example
     * // Delete a few UnifiedPerformances
     * const { count } = await prisma.unifiedPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnifiedPerformanceDeleteManyArgs>(args?: SelectSubset<T, UnifiedPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnifiedPerformanceUpdateManyArgs>(args: SelectSubset<T, UnifiedPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnifiedPerformance.
     * @param {UnifiedPerformanceUpsertArgs} args - Arguments to update or create a UnifiedPerformance.
     * @example
     * // Update or create a UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.upsert({
     *   create: {
     *     // ... data to create a UnifiedPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnifiedPerformance we want to update
     *   }
     * })
     */
    upsert<T extends UnifiedPerformanceUpsertArgs>(args: SelectSubset<T, UnifiedPerformanceUpsertArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnifiedPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceCountArgs} args - Arguments to filter UnifiedPerformances to count.
     * @example
     * // Count the number of UnifiedPerformances
     * const count = await prisma.unifiedPerformance.count({
     *   where: {
     *     // ... the filter for the UnifiedPerformances we want to count
     *   }
     * })
    **/
    count<T extends UnifiedPerformanceCountArgs>(
      args?: Subset<T, UnifiedPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnifiedPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnifiedPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnifiedPerformanceAggregateArgs>(args: Subset<T, UnifiedPerformanceAggregateArgs>): Prisma.PrismaPromise<GetUnifiedPerformanceAggregateType<T>>

    /**
     * Group by UnifiedPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnifiedPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnifiedPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: UnifiedPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnifiedPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnifiedPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnifiedPerformance model
   */
  readonly fields: UnifiedPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnifiedPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnifiedPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnifiedPerformance model
   */ 
  interface UnifiedPerformanceFieldRefs {
    readonly id: FieldRef<"UnifiedPerformance", 'String'>
    readonly contentId: FieldRef<"UnifiedPerformance", 'String'>
    readonly contentType: FieldRef<"UnifiedPerformance", 'String'>
    readonly metrics30m: FieldRef<"UnifiedPerformance", 'Json'>
    readonly metrics1h: FieldRef<"UnifiedPerformance", 'Json'>
    readonly metrics24h: FieldRef<"UnifiedPerformance", 'Json'>
    readonly engagementRate: FieldRef<"UnifiedPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"UnifiedPerformance", 'Float'>
    readonly collectedAt: FieldRef<"UnifiedPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"UnifiedPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnifiedPerformance findUnique
   */
  export type UnifiedPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance findUniqueOrThrow
   */
  export type UnifiedPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance findFirst
   */
  export type UnifiedPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedPerformances.
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedPerformances.
     */
    distinct?: UnifiedPerformanceScalarFieldEnum | UnifiedPerformanceScalarFieldEnum[]
  }

  /**
   * UnifiedPerformance findFirstOrThrow
   */
  export type UnifiedPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedPerformances.
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedPerformances.
     */
    distinct?: UnifiedPerformanceScalarFieldEnum | UnifiedPerformanceScalarFieldEnum[]
  }

  /**
   * UnifiedPerformance findMany
   */
  export type UnifiedPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformances to fetch.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnifiedPerformances.
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    distinct?: UnifiedPerformanceScalarFieldEnum | UnifiedPerformanceScalarFieldEnum[]
  }

  /**
   * UnifiedPerformance create
   */
  export type UnifiedPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * The data needed to create a UnifiedPerformance.
     */
    data: XOR<UnifiedPerformanceCreateInput, UnifiedPerformanceUncheckedCreateInput>
  }

  /**
   * UnifiedPerformance createMany
   */
  export type UnifiedPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnifiedPerformances.
     */
    data: UnifiedPerformanceCreateManyInput | UnifiedPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedPerformance createManyAndReturn
   */
  export type UnifiedPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnifiedPerformances.
     */
    data: UnifiedPerformanceCreateManyInput | UnifiedPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedPerformance update
   */
  export type UnifiedPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * The data needed to update a UnifiedPerformance.
     */
    data: XOR<UnifiedPerformanceUpdateInput, UnifiedPerformanceUncheckedUpdateInput>
    /**
     * Choose, which UnifiedPerformance to update.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance updateMany
   */
  export type UnifiedPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnifiedPerformances.
     */
    data: XOR<UnifiedPerformanceUpdateManyMutationInput, UnifiedPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedPerformances to update
     */
    where?: UnifiedPerformanceWhereInput
  }

  /**
   * UnifiedPerformance upsert
   */
  export type UnifiedPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * The filter to search for the UnifiedPerformance to update in case it exists.
     */
    where: UnifiedPerformanceWhereUniqueInput
    /**
     * In case the UnifiedPerformance found by the `where` argument doesn't exist, create a new UnifiedPerformance with this data.
     */
    create: XOR<UnifiedPerformanceCreateInput, UnifiedPerformanceUncheckedCreateInput>
    /**
     * In case the UnifiedPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnifiedPerformanceUpdateInput, UnifiedPerformanceUncheckedUpdateInput>
  }

  /**
   * UnifiedPerformance delete
   */
  export type UnifiedPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Filter which UnifiedPerformance to delete.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance deleteMany
   */
  export type UnifiedPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedPerformances to delete
     */
    where?: UnifiedPerformanceWhereInput
  }

  /**
   * UnifiedPerformance without action
   */
  export type UnifiedPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
  }


  /**
   * Model NewsViralRelation
   */

  export type AggregateNewsViralRelation = {
    _count: NewsViralRelationCountAggregateOutputType | null
    _avg: NewsViralRelationAvgAggregateOutputType | null
    _sum: NewsViralRelationSumAggregateOutputType | null
    _min: NewsViralRelationMinAggregateOutputType | null
    _max: NewsViralRelationMaxAggregateOutputType | null
  }

  export type NewsViralRelationAvgAggregateOutputType = {
    relevanceScore: number | null
  }

  export type NewsViralRelationSumAggregateOutputType = {
    relevanceScore: number | null
  }

  export type NewsViralRelationMinAggregateOutputType = {
    id: string | null
    newsId: string | null
    sessionId: string | null
    relevanceScore: number | null
    usedInContent: boolean | null
    createdAt: Date | null
  }

  export type NewsViralRelationMaxAggregateOutputType = {
    id: string | null
    newsId: string | null
    sessionId: string | null
    relevanceScore: number | null
    usedInContent: boolean | null
    createdAt: Date | null
  }

  export type NewsViralRelationCountAggregateOutputType = {
    id: number
    newsId: number
    sessionId: number
    relevanceScore: number
    usedInContent: number
    createdAt: number
    _all: number
  }


  export type NewsViralRelationAvgAggregateInputType = {
    relevanceScore?: true
  }

  export type NewsViralRelationSumAggregateInputType = {
    relevanceScore?: true
  }

  export type NewsViralRelationMinAggregateInputType = {
    id?: true
    newsId?: true
    sessionId?: true
    relevanceScore?: true
    usedInContent?: true
    createdAt?: true
  }

  export type NewsViralRelationMaxAggregateInputType = {
    id?: true
    newsId?: true
    sessionId?: true
    relevanceScore?: true
    usedInContent?: true
    createdAt?: true
  }

  export type NewsViralRelationCountAggregateInputType = {
    id?: true
    newsId?: true
    sessionId?: true
    relevanceScore?: true
    usedInContent?: true
    createdAt?: true
    _all?: true
  }

  export type NewsViralRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsViralRelation to aggregate.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsViralRelations
    **/
    _count?: true | NewsViralRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsViralRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsViralRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsViralRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsViralRelationMaxAggregateInputType
  }

  export type GetNewsViralRelationAggregateType<T extends NewsViralRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsViralRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsViralRelation[P]>
      : GetScalarType<T[P], AggregateNewsViralRelation[P]>
  }




  export type NewsViralRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsViralRelationWhereInput
    orderBy?: NewsViralRelationOrderByWithAggregationInput | NewsViralRelationOrderByWithAggregationInput[]
    by: NewsViralRelationScalarFieldEnum[] | NewsViralRelationScalarFieldEnum
    having?: NewsViralRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsViralRelationCountAggregateInputType | true
    _avg?: NewsViralRelationAvgAggregateInputType
    _sum?: NewsViralRelationSumAggregateInputType
    _min?: NewsViralRelationMinAggregateInputType
    _max?: NewsViralRelationMaxAggregateInputType
  }

  export type NewsViralRelationGroupByOutputType = {
    id: string
    newsId: string
    sessionId: string
    relevanceScore: number | null
    usedInContent: boolean
    createdAt: Date
    _count: NewsViralRelationCountAggregateOutputType | null
    _avg: NewsViralRelationAvgAggregateOutputType | null
    _sum: NewsViralRelationSumAggregateOutputType | null
    _min: NewsViralRelationMinAggregateOutputType | null
    _max: NewsViralRelationMaxAggregateOutputType | null
  }

  type GetNewsViralRelationGroupByPayload<T extends NewsViralRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsViralRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsViralRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsViralRelationGroupByOutputType[P]>
            : GetScalarType<T[P], NewsViralRelationGroupByOutputType[P]>
        }
      >
    >


  export type NewsViralRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
    newsArticle?: boolean | NewsArticleDefaultArgs<ExtArgs>
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsViralRelation"]>

  export type NewsViralRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
    newsArticle?: boolean | NewsArticleDefaultArgs<ExtArgs>
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsViralRelation"]>

  export type NewsViralRelationSelectScalar = {
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
  }

  export type NewsViralRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsArticle?: boolean | NewsArticleDefaultArgs<ExtArgs>
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }
  export type NewsViralRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsArticle?: boolean | NewsArticleDefaultArgs<ExtArgs>
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }

  export type $NewsViralRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsViralRelation"
    objects: {
      newsArticle: Prisma.$NewsArticlePayload<ExtArgs>
      session: Prisma.$ViralSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      newsId: string
      sessionId: string
      relevanceScore: number | null
      usedInContent: boolean
      createdAt: Date
    }, ExtArgs["result"]["newsViralRelation"]>
    composites: {}
  }

  type NewsViralRelationGetPayload<S extends boolean | null | undefined | NewsViralRelationDefaultArgs> = $Result.GetResult<Prisma.$NewsViralRelationPayload, S>

  type NewsViralRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsViralRelationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsViralRelationCountAggregateInputType | true
    }

  export interface NewsViralRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsViralRelation'], meta: { name: 'NewsViralRelation' } }
    /**
     * Find zero or one NewsViralRelation that matches the filter.
     * @param {NewsViralRelationFindUniqueArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsViralRelationFindUniqueArgs>(args: SelectSubset<T, NewsViralRelationFindUniqueArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsViralRelation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsViralRelationFindUniqueOrThrowArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsViralRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsViralRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsViralRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationFindFirstArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsViralRelationFindFirstArgs>(args?: SelectSubset<T, NewsViralRelationFindFirstArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsViralRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationFindFirstOrThrowArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsViralRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsViralRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsViralRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsViralRelations
     * const newsViralRelations = await prisma.newsViralRelation.findMany()
     * 
     * // Get first 10 NewsViralRelations
     * const newsViralRelations = await prisma.newsViralRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsViralRelationWithIdOnly = await prisma.newsViralRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsViralRelationFindManyArgs>(args?: SelectSubset<T, NewsViralRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsViralRelation.
     * @param {NewsViralRelationCreateArgs} args - Arguments to create a NewsViralRelation.
     * @example
     * // Create one NewsViralRelation
     * const NewsViralRelation = await prisma.newsViralRelation.create({
     *   data: {
     *     // ... data to create a NewsViralRelation
     *   }
     * })
     * 
     */
    create<T extends NewsViralRelationCreateArgs>(args: SelectSubset<T, NewsViralRelationCreateArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsViralRelations.
     * @param {NewsViralRelationCreateManyArgs} args - Arguments to create many NewsViralRelations.
     * @example
     * // Create many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsViralRelationCreateManyArgs>(args?: SelectSubset<T, NewsViralRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsViralRelations and returns the data saved in the database.
     * @param {NewsViralRelationCreateManyAndReturnArgs} args - Arguments to create many NewsViralRelations.
     * @example
     * // Create many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsViralRelations and only return the `id`
     * const newsViralRelationWithIdOnly = await prisma.newsViralRelation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsViralRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsViralRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsViralRelation.
     * @param {NewsViralRelationDeleteArgs} args - Arguments to delete one NewsViralRelation.
     * @example
     * // Delete one NewsViralRelation
     * const NewsViralRelation = await prisma.newsViralRelation.delete({
     *   where: {
     *     // ... filter to delete one NewsViralRelation
     *   }
     * })
     * 
     */
    delete<T extends NewsViralRelationDeleteArgs>(args: SelectSubset<T, NewsViralRelationDeleteArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsViralRelation.
     * @param {NewsViralRelationUpdateArgs} args - Arguments to update one NewsViralRelation.
     * @example
     * // Update one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsViralRelationUpdateArgs>(args: SelectSubset<T, NewsViralRelationUpdateArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsViralRelations.
     * @param {NewsViralRelationDeleteManyArgs} args - Arguments to filter NewsViralRelations to delete.
     * @example
     * // Delete a few NewsViralRelations
     * const { count } = await prisma.newsViralRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsViralRelationDeleteManyArgs>(args?: SelectSubset<T, NewsViralRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsViralRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsViralRelationUpdateManyArgs>(args: SelectSubset<T, NewsViralRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsViralRelation.
     * @param {NewsViralRelationUpsertArgs} args - Arguments to update or create a NewsViralRelation.
     * @example
     * // Update or create a NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.upsert({
     *   create: {
     *     // ... data to create a NewsViralRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsViralRelation we want to update
     *   }
     * })
     */
    upsert<T extends NewsViralRelationUpsertArgs>(args: SelectSubset<T, NewsViralRelationUpsertArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsViralRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationCountArgs} args - Arguments to filter NewsViralRelations to count.
     * @example
     * // Count the number of NewsViralRelations
     * const count = await prisma.newsViralRelation.count({
     *   where: {
     *     // ... the filter for the NewsViralRelations we want to count
     *   }
     * })
    **/
    count<T extends NewsViralRelationCountArgs>(
      args?: Subset<T, NewsViralRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsViralRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsViralRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsViralRelationAggregateArgs>(args: Subset<T, NewsViralRelationAggregateArgs>): Prisma.PrismaPromise<GetNewsViralRelationAggregateType<T>>

    /**
     * Group by NewsViralRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsViralRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsViralRelationGroupByArgs['orderBy'] }
        : { orderBy?: NewsViralRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsViralRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsViralRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsViralRelation model
   */
  readonly fields: NewsViralRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsViralRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsViralRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    newsArticle<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends ViralSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViralSessionDefaultArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsViralRelation model
   */ 
  interface NewsViralRelationFieldRefs {
    readonly id: FieldRef<"NewsViralRelation", 'String'>
    readonly newsId: FieldRef<"NewsViralRelation", 'String'>
    readonly sessionId: FieldRef<"NewsViralRelation", 'String'>
    readonly relevanceScore: FieldRef<"NewsViralRelation", 'Float'>
    readonly usedInContent: FieldRef<"NewsViralRelation", 'Boolean'>
    readonly createdAt: FieldRef<"NewsViralRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsViralRelation findUnique
   */
  export type NewsViralRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation findUniqueOrThrow
   */
  export type NewsViralRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation findFirst
   */
  export type NewsViralRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsViralRelations.
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsViralRelations.
     */
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsViralRelation findFirstOrThrow
   */
  export type NewsViralRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsViralRelations.
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsViralRelations.
     */
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsViralRelation findMany
   */
  export type NewsViralRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * Filter, which NewsViralRelations to fetch.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsViralRelations.
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsViralRelation create
   */
  export type NewsViralRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsViralRelation.
     */
    data: XOR<NewsViralRelationCreateInput, NewsViralRelationUncheckedCreateInput>
  }

  /**
   * NewsViralRelation createMany
   */
  export type NewsViralRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsViralRelations.
     */
    data: NewsViralRelationCreateManyInput | NewsViralRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsViralRelation createManyAndReturn
   */
  export type NewsViralRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsViralRelations.
     */
    data: NewsViralRelationCreateManyInput | NewsViralRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsViralRelation update
   */
  export type NewsViralRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsViralRelation.
     */
    data: XOR<NewsViralRelationUpdateInput, NewsViralRelationUncheckedUpdateInput>
    /**
     * Choose, which NewsViralRelation to update.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation updateMany
   */
  export type NewsViralRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsViralRelations.
     */
    data: XOR<NewsViralRelationUpdateManyMutationInput, NewsViralRelationUncheckedUpdateManyInput>
    /**
     * Filter which NewsViralRelations to update
     */
    where?: NewsViralRelationWhereInput
  }

  /**
   * NewsViralRelation upsert
   */
  export type NewsViralRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsViralRelation to update in case it exists.
     */
    where: NewsViralRelationWhereUniqueInput
    /**
     * In case the NewsViralRelation found by the `where` argument doesn't exist, create a new NewsViralRelation with this data.
     */
    create: XOR<NewsViralRelationCreateInput, NewsViralRelationUncheckedCreateInput>
    /**
     * In case the NewsViralRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsViralRelationUpdateInput, NewsViralRelationUncheckedUpdateInput>
  }

  /**
   * NewsViralRelation delete
   */
  export type NewsViralRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    /**
     * Filter which NewsViralRelation to delete.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation deleteMany
   */
  export type NewsViralRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsViralRelations to delete
     */
    where?: NewsViralRelationWhereInput
  }

  /**
   * NewsViralRelation without action
   */
  export type NewsViralRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
  }


  /**
   * Model SessionActivityLog
   */

  export type AggregateSessionActivityLog = {
    _count: SessionActivityLogCountAggregateOutputType | null
    _min: SessionActivityLogMinAggregateOutputType | null
    _max: SessionActivityLogMaxAggregateOutputType | null
  }

  export type SessionActivityLogMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sessionType: string | null
    activityType: string | null
    createdAt: Date | null
  }

  export type SessionActivityLogMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sessionType: string | null
    activityType: string | null
    createdAt: Date | null
  }

  export type SessionActivityLogCountAggregateOutputType = {
    id: number
    sessionId: number
    sessionType: number
    activityType: number
    details: number
    createdAt: number
    _all: number
  }


  export type SessionActivityLogMinAggregateInputType = {
    id?: true
    sessionId?: true
    sessionType?: true
    activityType?: true
    createdAt?: true
  }

  export type SessionActivityLogMaxAggregateInputType = {
    id?: true
    sessionId?: true
    sessionType?: true
    activityType?: true
    createdAt?: true
  }

  export type SessionActivityLogCountAggregateInputType = {
    id?: true
    sessionId?: true
    sessionType?: true
    activityType?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type SessionActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionActivityLog to aggregate.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionActivityLogs
    **/
    _count?: true | SessionActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionActivityLogMaxAggregateInputType
  }

  export type GetSessionActivityLogAggregateType<T extends SessionActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionActivityLog[P]>
      : GetScalarType<T[P], AggregateSessionActivityLog[P]>
  }




  export type SessionActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionActivityLogWhereInput
    orderBy?: SessionActivityLogOrderByWithAggregationInput | SessionActivityLogOrderByWithAggregationInput[]
    by: SessionActivityLogScalarFieldEnum[] | SessionActivityLogScalarFieldEnum
    having?: SessionActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionActivityLogCountAggregateInputType | true
    _min?: SessionActivityLogMinAggregateInputType
    _max?: SessionActivityLogMaxAggregateInputType
  }

  export type SessionActivityLogGroupByOutputType = {
    id: string
    sessionId: string
    sessionType: string
    activityType: string
    details: JsonValue | null
    createdAt: Date
    _count: SessionActivityLogCountAggregateOutputType | null
    _min: SessionActivityLogMinAggregateOutputType | null
    _max: SessionActivityLogMaxAggregateOutputType | null
  }

  type GetSessionActivityLogGroupByPayload<T extends SessionActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], SessionActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type SessionActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sessionActivityLog"]>

  export type SessionActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sessionActivityLog"]>

  export type SessionActivityLogSelectScalar = {
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }


  export type $SessionActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionActivityLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      sessionType: string
      activityType: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["sessionActivityLog"]>
    composites: {}
  }

  type SessionActivityLogGetPayload<S extends boolean | null | undefined | SessionActivityLogDefaultArgs> = $Result.GetResult<Prisma.$SessionActivityLogPayload, S>

  type SessionActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionActivityLogCountAggregateInputType | true
    }

  export interface SessionActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionActivityLog'], meta: { name: 'SessionActivityLog' } }
    /**
     * Find zero or one SessionActivityLog that matches the filter.
     * @param {SessionActivityLogFindUniqueArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionActivityLogFindUniqueArgs>(args: SelectSubset<T, SessionActivityLogFindUniqueArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionActivityLogFindUniqueOrThrowArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogFindFirstArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionActivityLogFindFirstArgs>(args?: SelectSubset<T, SessionActivityLogFindFirstArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogFindFirstOrThrowArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionActivityLogs
     * const sessionActivityLogs = await prisma.sessionActivityLog.findMany()
     * 
     * // Get first 10 SessionActivityLogs
     * const sessionActivityLogs = await prisma.sessionActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionActivityLogWithIdOnly = await prisma.sessionActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionActivityLogFindManyArgs>(args?: SelectSubset<T, SessionActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionActivityLog.
     * @param {SessionActivityLogCreateArgs} args - Arguments to create a SessionActivityLog.
     * @example
     * // Create one SessionActivityLog
     * const SessionActivityLog = await prisma.sessionActivityLog.create({
     *   data: {
     *     // ... data to create a SessionActivityLog
     *   }
     * })
     * 
     */
    create<T extends SessionActivityLogCreateArgs>(args: SelectSubset<T, SessionActivityLogCreateArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionActivityLogs.
     * @param {SessionActivityLogCreateManyArgs} args - Arguments to create many SessionActivityLogs.
     * @example
     * // Create many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionActivityLogCreateManyArgs>(args?: SelectSubset<T, SessionActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionActivityLogs and returns the data saved in the database.
     * @param {SessionActivityLogCreateManyAndReturnArgs} args - Arguments to create many SessionActivityLogs.
     * @example
     * // Create many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionActivityLogs and only return the `id`
     * const sessionActivityLogWithIdOnly = await prisma.sessionActivityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionActivityLog.
     * @param {SessionActivityLogDeleteArgs} args - Arguments to delete one SessionActivityLog.
     * @example
     * // Delete one SessionActivityLog
     * const SessionActivityLog = await prisma.sessionActivityLog.delete({
     *   where: {
     *     // ... filter to delete one SessionActivityLog
     *   }
     * })
     * 
     */
    delete<T extends SessionActivityLogDeleteArgs>(args: SelectSubset<T, SessionActivityLogDeleteArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionActivityLog.
     * @param {SessionActivityLogUpdateArgs} args - Arguments to update one SessionActivityLog.
     * @example
     * // Update one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionActivityLogUpdateArgs>(args: SelectSubset<T, SessionActivityLogUpdateArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionActivityLogs.
     * @param {SessionActivityLogDeleteManyArgs} args - Arguments to filter SessionActivityLogs to delete.
     * @example
     * // Delete a few SessionActivityLogs
     * const { count } = await prisma.sessionActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionActivityLogDeleteManyArgs>(args?: SelectSubset<T, SessionActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionActivityLogUpdateManyArgs>(args: SelectSubset<T, SessionActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionActivityLog.
     * @param {SessionActivityLogUpsertArgs} args - Arguments to update or create a SessionActivityLog.
     * @example
     * // Update or create a SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.upsert({
     *   create: {
     *     // ... data to create a SessionActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends SessionActivityLogUpsertArgs>(args: SelectSubset<T, SessionActivityLogUpsertArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogCountArgs} args - Arguments to filter SessionActivityLogs to count.
     * @example
     * // Count the number of SessionActivityLogs
     * const count = await prisma.sessionActivityLog.count({
     *   where: {
     *     // ... the filter for the SessionActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends SessionActivityLogCountArgs>(
      args?: Subset<T, SessionActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionActivityLogAggregateArgs>(args: Subset<T, SessionActivityLogAggregateArgs>): Prisma.PrismaPromise<GetSessionActivityLogAggregateType<T>>

    /**
     * Group by SessionActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: SessionActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionActivityLog model
   */
  readonly fields: SessionActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionActivityLog model
   */ 
  interface SessionActivityLogFieldRefs {
    readonly id: FieldRef<"SessionActivityLog", 'String'>
    readonly sessionId: FieldRef<"SessionActivityLog", 'String'>
    readonly sessionType: FieldRef<"SessionActivityLog", 'String'>
    readonly activityType: FieldRef<"SessionActivityLog", 'String'>
    readonly details: FieldRef<"SessionActivityLog", 'Json'>
    readonly createdAt: FieldRef<"SessionActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionActivityLog findUnique
   */
  export type SessionActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog findUniqueOrThrow
   */
  export type SessionActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog findFirst
   */
  export type SessionActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionActivityLogs.
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionActivityLogs.
     */
    distinct?: SessionActivityLogScalarFieldEnum | SessionActivityLogScalarFieldEnum[]
  }

  /**
   * SessionActivityLog findFirstOrThrow
   */
  export type SessionActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionActivityLogs.
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionActivityLogs.
     */
    distinct?: SessionActivityLogScalarFieldEnum | SessionActivityLogScalarFieldEnum[]
  }

  /**
   * SessionActivityLog findMany
   */
  export type SessionActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which SessionActivityLogs to fetch.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionActivityLogs.
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    distinct?: SessionActivityLogScalarFieldEnum | SessionActivityLogScalarFieldEnum[]
  }

  /**
   * SessionActivityLog create
   */
  export type SessionActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * The data needed to create a SessionActivityLog.
     */
    data: XOR<SessionActivityLogCreateInput, SessionActivityLogUncheckedCreateInput>
  }

  /**
   * SessionActivityLog createMany
   */
  export type SessionActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionActivityLogs.
     */
    data: SessionActivityLogCreateManyInput | SessionActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionActivityLog createManyAndReturn
   */
  export type SessionActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionActivityLogs.
     */
    data: SessionActivityLogCreateManyInput | SessionActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionActivityLog update
   */
  export type SessionActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * The data needed to update a SessionActivityLog.
     */
    data: XOR<SessionActivityLogUpdateInput, SessionActivityLogUncheckedUpdateInput>
    /**
     * Choose, which SessionActivityLog to update.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog updateMany
   */
  export type SessionActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionActivityLogs.
     */
    data: XOR<SessionActivityLogUpdateManyMutationInput, SessionActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which SessionActivityLogs to update
     */
    where?: SessionActivityLogWhereInput
  }

  /**
   * SessionActivityLog upsert
   */
  export type SessionActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * The filter to search for the SessionActivityLog to update in case it exists.
     */
    where: SessionActivityLogWhereUniqueInput
    /**
     * In case the SessionActivityLog found by the `where` argument doesn't exist, create a new SessionActivityLog with this data.
     */
    create: XOR<SessionActivityLogCreateInput, SessionActivityLogUncheckedCreateInput>
    /**
     * In case the SessionActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionActivityLogUpdateInput, SessionActivityLogUncheckedUpdateInput>
  }

  /**
   * SessionActivityLog delete
   */
  export type SessionActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Filter which SessionActivityLog to delete.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog deleteMany
   */
  export type SessionActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionActivityLogs to delete
     */
    where?: SessionActivityLogWhereInput
  }

  /**
   * SessionActivityLog without action
   */
  export type SessionActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
  }


  /**
   * Model ApiErrorLog
   */

  export type AggregateApiErrorLog = {
    _count: ApiErrorLogCountAggregateOutputType | null
    _avg: ApiErrorLogAvgAggregateOutputType | null
    _sum: ApiErrorLogSumAggregateOutputType | null
    _min: ApiErrorLogMinAggregateOutputType | null
    _max: ApiErrorLogMaxAggregateOutputType | null
  }

  export type ApiErrorLogAvgAggregateOutputType = {
    statusCode: number | null
  }

  export type ApiErrorLogSumAggregateOutputType = {
    statusCode: number | null
  }

  export type ApiErrorLogMinAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    errorMessage: string | null
    stackTrace: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type ApiErrorLogMaxAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    errorMessage: string | null
    stackTrace: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type ApiErrorLogCountAggregateOutputType = {
    id: number
    endpoint: number
    method: number
    statusCode: number
    errorMessage: number
    stackTrace: number
    requestBody: number
    requestHeaders: number
    userAgent: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type ApiErrorLogAvgAggregateInputType = {
    statusCode?: true
  }

  export type ApiErrorLogSumAggregateInputType = {
    statusCode?: true
  }

  export type ApiErrorLogMinAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    errorMessage?: true
    stackTrace?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type ApiErrorLogMaxAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    errorMessage?: true
    stackTrace?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type ApiErrorLogCountAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    errorMessage?: true
    stackTrace?: true
    requestBody?: true
    requestHeaders?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type ApiErrorLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiErrorLog to aggregate.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiErrorLogs
    **/
    _count?: true | ApiErrorLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiErrorLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiErrorLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiErrorLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiErrorLogMaxAggregateInputType
  }

  export type GetApiErrorLogAggregateType<T extends ApiErrorLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiErrorLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiErrorLog[P]>
      : GetScalarType<T[P], AggregateApiErrorLog[P]>
  }




  export type ApiErrorLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiErrorLogWhereInput
    orderBy?: ApiErrorLogOrderByWithAggregationInput | ApiErrorLogOrderByWithAggregationInput[]
    by: ApiErrorLogScalarFieldEnum[] | ApiErrorLogScalarFieldEnum
    having?: ApiErrorLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiErrorLogCountAggregateInputType | true
    _avg?: ApiErrorLogAvgAggregateInputType
    _sum?: ApiErrorLogSumAggregateInputType
    _min?: ApiErrorLogMinAggregateInputType
    _max?: ApiErrorLogMaxAggregateInputType
  }

  export type ApiErrorLogGroupByOutputType = {
    id: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage: string | null
    stackTrace: string | null
    requestBody: JsonValue | null
    requestHeaders: JsonValue | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    _count: ApiErrorLogCountAggregateOutputType | null
    _avg: ApiErrorLogAvgAggregateOutputType | null
    _sum: ApiErrorLogSumAggregateOutputType | null
    _min: ApiErrorLogMinAggregateOutputType | null
    _max: ApiErrorLogMaxAggregateOutputType | null
  }

  type GetApiErrorLogGroupByPayload<T extends ApiErrorLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiErrorLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiErrorLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiErrorLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiErrorLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiErrorLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiErrorLog"]>

  export type ApiErrorLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiErrorLog"]>

  export type ApiErrorLogSelectScalar = {
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }


  export type $ApiErrorLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiErrorLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endpoint: string
      method: string
      statusCode: number
      errorMessage: string | null
      stackTrace: string | null
      requestBody: Prisma.JsonValue | null
      requestHeaders: Prisma.JsonValue | null
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["apiErrorLog"]>
    composites: {}
  }

  type ApiErrorLogGetPayload<S extends boolean | null | undefined | ApiErrorLogDefaultArgs> = $Result.GetResult<Prisma.$ApiErrorLogPayload, S>

  type ApiErrorLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiErrorLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiErrorLogCountAggregateInputType | true
    }

  export interface ApiErrorLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiErrorLog'], meta: { name: 'ApiErrorLog' } }
    /**
     * Find zero or one ApiErrorLog that matches the filter.
     * @param {ApiErrorLogFindUniqueArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiErrorLogFindUniqueArgs>(args: SelectSubset<T, ApiErrorLogFindUniqueArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiErrorLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiErrorLogFindUniqueOrThrowArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiErrorLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiErrorLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiErrorLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogFindFirstArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiErrorLogFindFirstArgs>(args?: SelectSubset<T, ApiErrorLogFindFirstArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiErrorLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogFindFirstOrThrowArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiErrorLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiErrorLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiErrorLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiErrorLogs
     * const apiErrorLogs = await prisma.apiErrorLog.findMany()
     * 
     * // Get first 10 ApiErrorLogs
     * const apiErrorLogs = await prisma.apiErrorLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiErrorLogWithIdOnly = await prisma.apiErrorLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiErrorLogFindManyArgs>(args?: SelectSubset<T, ApiErrorLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiErrorLog.
     * @param {ApiErrorLogCreateArgs} args - Arguments to create a ApiErrorLog.
     * @example
     * // Create one ApiErrorLog
     * const ApiErrorLog = await prisma.apiErrorLog.create({
     *   data: {
     *     // ... data to create a ApiErrorLog
     *   }
     * })
     * 
     */
    create<T extends ApiErrorLogCreateArgs>(args: SelectSubset<T, ApiErrorLogCreateArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiErrorLogs.
     * @param {ApiErrorLogCreateManyArgs} args - Arguments to create many ApiErrorLogs.
     * @example
     * // Create many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiErrorLogCreateManyArgs>(args?: SelectSubset<T, ApiErrorLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiErrorLogs and returns the data saved in the database.
     * @param {ApiErrorLogCreateManyAndReturnArgs} args - Arguments to create many ApiErrorLogs.
     * @example
     * // Create many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiErrorLogs and only return the `id`
     * const apiErrorLogWithIdOnly = await prisma.apiErrorLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiErrorLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiErrorLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiErrorLog.
     * @param {ApiErrorLogDeleteArgs} args - Arguments to delete one ApiErrorLog.
     * @example
     * // Delete one ApiErrorLog
     * const ApiErrorLog = await prisma.apiErrorLog.delete({
     *   where: {
     *     // ... filter to delete one ApiErrorLog
     *   }
     * })
     * 
     */
    delete<T extends ApiErrorLogDeleteArgs>(args: SelectSubset<T, ApiErrorLogDeleteArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiErrorLog.
     * @param {ApiErrorLogUpdateArgs} args - Arguments to update one ApiErrorLog.
     * @example
     * // Update one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiErrorLogUpdateArgs>(args: SelectSubset<T, ApiErrorLogUpdateArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiErrorLogs.
     * @param {ApiErrorLogDeleteManyArgs} args - Arguments to filter ApiErrorLogs to delete.
     * @example
     * // Delete a few ApiErrorLogs
     * const { count } = await prisma.apiErrorLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiErrorLogDeleteManyArgs>(args?: SelectSubset<T, ApiErrorLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiErrorLogUpdateManyArgs>(args: SelectSubset<T, ApiErrorLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiErrorLog.
     * @param {ApiErrorLogUpsertArgs} args - Arguments to update or create a ApiErrorLog.
     * @example
     * // Update or create a ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.upsert({
     *   create: {
     *     // ... data to create a ApiErrorLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiErrorLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiErrorLogUpsertArgs>(args: SelectSubset<T, ApiErrorLogUpsertArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogCountArgs} args - Arguments to filter ApiErrorLogs to count.
     * @example
     * // Count the number of ApiErrorLogs
     * const count = await prisma.apiErrorLog.count({
     *   where: {
     *     // ... the filter for the ApiErrorLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiErrorLogCountArgs>(
      args?: Subset<T, ApiErrorLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiErrorLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiErrorLogAggregateArgs>(args: Subset<T, ApiErrorLogAggregateArgs>): Prisma.PrismaPromise<GetApiErrorLogAggregateType<T>>

    /**
     * Group by ApiErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiErrorLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiErrorLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiErrorLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiErrorLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiErrorLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiErrorLog model
   */
  readonly fields: ApiErrorLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiErrorLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiErrorLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiErrorLog model
   */ 
  interface ApiErrorLogFieldRefs {
    readonly id: FieldRef<"ApiErrorLog", 'String'>
    readonly endpoint: FieldRef<"ApiErrorLog", 'String'>
    readonly method: FieldRef<"ApiErrorLog", 'String'>
    readonly statusCode: FieldRef<"ApiErrorLog", 'Int'>
    readonly errorMessage: FieldRef<"ApiErrorLog", 'String'>
    readonly stackTrace: FieldRef<"ApiErrorLog", 'String'>
    readonly requestBody: FieldRef<"ApiErrorLog", 'Json'>
    readonly requestHeaders: FieldRef<"ApiErrorLog", 'Json'>
    readonly userAgent: FieldRef<"ApiErrorLog", 'String'>
    readonly ipAddress: FieldRef<"ApiErrorLog", 'String'>
    readonly createdAt: FieldRef<"ApiErrorLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiErrorLog findUnique
   */
  export type ApiErrorLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog findUniqueOrThrow
   */
  export type ApiErrorLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog findFirst
   */
  export type ApiErrorLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiErrorLogs.
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiErrorLogs.
     */
    distinct?: ApiErrorLogScalarFieldEnum | ApiErrorLogScalarFieldEnum[]
  }

  /**
   * ApiErrorLog findFirstOrThrow
   */
  export type ApiErrorLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiErrorLogs.
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiErrorLogs.
     */
    distinct?: ApiErrorLogScalarFieldEnum | ApiErrorLogScalarFieldEnum[]
  }

  /**
   * ApiErrorLog findMany
   */
  export type ApiErrorLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiErrorLogs to fetch.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiErrorLogs.
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    distinct?: ApiErrorLogScalarFieldEnum | ApiErrorLogScalarFieldEnum[]
  }

  /**
   * ApiErrorLog create
   */
  export type ApiErrorLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * The data needed to create a ApiErrorLog.
     */
    data: XOR<ApiErrorLogCreateInput, ApiErrorLogUncheckedCreateInput>
  }

  /**
   * ApiErrorLog createMany
   */
  export type ApiErrorLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiErrorLogs.
     */
    data: ApiErrorLogCreateManyInput | ApiErrorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiErrorLog createManyAndReturn
   */
  export type ApiErrorLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiErrorLogs.
     */
    data: ApiErrorLogCreateManyInput | ApiErrorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiErrorLog update
   */
  export type ApiErrorLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * The data needed to update a ApiErrorLog.
     */
    data: XOR<ApiErrorLogUpdateInput, ApiErrorLogUncheckedUpdateInput>
    /**
     * Choose, which ApiErrorLog to update.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog updateMany
   */
  export type ApiErrorLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiErrorLogs.
     */
    data: XOR<ApiErrorLogUpdateManyMutationInput, ApiErrorLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiErrorLogs to update
     */
    where?: ApiErrorLogWhereInput
  }

  /**
   * ApiErrorLog upsert
   */
  export type ApiErrorLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * The filter to search for the ApiErrorLog to update in case it exists.
     */
    where: ApiErrorLogWhereUniqueInput
    /**
     * In case the ApiErrorLog found by the `where` argument doesn't exist, create a new ApiErrorLog with this data.
     */
    create: XOR<ApiErrorLogCreateInput, ApiErrorLogUncheckedCreateInput>
    /**
     * In case the ApiErrorLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiErrorLogUpdateInput, ApiErrorLogUncheckedUpdateInput>
  }

  /**
   * ApiErrorLog delete
   */
  export type ApiErrorLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Filter which ApiErrorLog to delete.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog deleteMany
   */
  export type ApiErrorLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiErrorLogs to delete
     */
    where?: ApiErrorLogWhereInput
  }

  /**
   * ApiErrorLog without action
   */
  export type ApiErrorLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
  }


  /**
   * Model ViralSession
   */

  export type AggregateViralSession = {
    _count: ViralSessionCountAggregateOutputType | null
    _min: ViralSessionMinAggregateOutputType | null
    _max: ViralSessionMaxAggregateOutputType | null
  }

  export type ViralSessionMinAggregateOutputType = {
    id: string | null
    theme: string | null
    platform: string | null
    style: string | null
    status: string | null
    createdAt: Date | null
    characterProfileId: string | null
    voiceStyleMode: string | null
  }

  export type ViralSessionMaxAggregateOutputType = {
    id: string | null
    theme: string | null
    platform: string | null
    style: string | null
    status: string | null
    createdAt: Date | null
    characterProfileId: string | null
    voiceStyleMode: string | null
  }

  export type ViralSessionCountAggregateOutputType = {
    id: number
    theme: number
    platform: number
    style: number
    status: number
    createdAt: number
    characterProfileId: number
    voiceStyleMode: number
    topics: number
    concepts: number
    selectedIds: number
    contents: number
    _all: number
  }


  export type ViralSessionMinAggregateInputType = {
    id?: true
    theme?: true
    platform?: true
    style?: true
    status?: true
    createdAt?: true
    characterProfileId?: true
    voiceStyleMode?: true
  }

  export type ViralSessionMaxAggregateInputType = {
    id?: true
    theme?: true
    platform?: true
    style?: true
    status?: true
    createdAt?: true
    characterProfileId?: true
    voiceStyleMode?: true
  }

  export type ViralSessionCountAggregateInputType = {
    id?: true
    theme?: true
    platform?: true
    style?: true
    status?: true
    createdAt?: true
    characterProfileId?: true
    voiceStyleMode?: true
    topics?: true
    concepts?: true
    selectedIds?: true
    contents?: true
    _all?: true
  }

  export type ViralSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralSession to aggregate.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViralSessions
    **/
    _count?: true | ViralSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViralSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViralSessionMaxAggregateInputType
  }

  export type GetViralSessionAggregateType<T extends ViralSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateViralSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViralSession[P]>
      : GetScalarType<T[P], AggregateViralSession[P]>
  }




  export type ViralSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralSessionWhereInput
    orderBy?: ViralSessionOrderByWithAggregationInput | ViralSessionOrderByWithAggregationInput[]
    by: ViralSessionScalarFieldEnum[] | ViralSessionScalarFieldEnum
    having?: ViralSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViralSessionCountAggregateInputType | true
    _min?: ViralSessionMinAggregateInputType
    _max?: ViralSessionMaxAggregateInputType
  }

  export type ViralSessionGroupByOutputType = {
    id: string
    theme: string
    platform: string
    style: string
    status: string
    createdAt: Date
    characterProfileId: string | null
    voiceStyleMode: string | null
    topics: JsonValue | null
    concepts: JsonValue | null
    selectedIds: string[]
    contents: JsonValue | null
    _count: ViralSessionCountAggregateOutputType | null
    _min: ViralSessionMinAggregateOutputType | null
    _max: ViralSessionMaxAggregateOutputType | null
  }

  type GetViralSessionGroupByPayload<T extends ViralSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViralSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViralSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViralSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ViralSessionGroupByOutputType[P]>
        }
      >
    >


  export type ViralSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
    drafts?: boolean | ViralSession$draftsArgs<ExtArgs>
    characterProfile?: boolean | ViralSession$characterProfileArgs<ExtArgs>
    newsRelations?: boolean | ViralSession$newsRelationsArgs<ExtArgs>
    integratedSessions?: boolean | ViralSession$integratedSessionsArgs<ExtArgs>
    _count?: boolean | ViralSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralSession"]>

  export type ViralSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
    characterProfile?: boolean | ViralSession$characterProfileArgs<ExtArgs>
  }, ExtArgs["result"]["viralSession"]>

  export type ViralSessionSelectScalar = {
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
  }

  export type ViralSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | ViralSession$draftsArgs<ExtArgs>
    characterProfile?: boolean | ViralSession$characterProfileArgs<ExtArgs>
    newsRelations?: boolean | ViralSession$newsRelationsArgs<ExtArgs>
    integratedSessions?: boolean | ViralSession$integratedSessionsArgs<ExtArgs>
    _count?: boolean | ViralSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViralSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterProfile?: boolean | ViralSession$characterProfileArgs<ExtArgs>
  }

  export type $ViralSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViralSession"
    objects: {
      drafts: Prisma.$ViralDraftV2Payload<ExtArgs>[]
      characterProfile: Prisma.$CharacterProfilePayload<ExtArgs> | null
      newsRelations: Prisma.$NewsViralRelationPayload<ExtArgs>[]
      integratedSessions: Prisma.$IntegratedSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      theme: string
      platform: string
      style: string
      status: string
      createdAt: Date
      characterProfileId: string | null
      voiceStyleMode: string | null
      topics: Prisma.JsonValue | null
      concepts: Prisma.JsonValue | null
      selectedIds: string[]
      contents: Prisma.JsonValue | null
    }, ExtArgs["result"]["viralSession"]>
    composites: {}
  }

  type ViralSessionGetPayload<S extends boolean | null | undefined | ViralSessionDefaultArgs> = $Result.GetResult<Prisma.$ViralSessionPayload, S>

  type ViralSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViralSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViralSessionCountAggregateInputType | true
    }

  export interface ViralSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViralSession'], meta: { name: 'ViralSession' } }
    /**
     * Find zero or one ViralSession that matches the filter.
     * @param {ViralSessionFindUniqueArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViralSessionFindUniqueArgs>(args: SelectSubset<T, ViralSessionFindUniqueArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ViralSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViralSessionFindUniqueOrThrowArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViralSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ViralSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ViralSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionFindFirstArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViralSessionFindFirstArgs>(args?: SelectSubset<T, ViralSessionFindFirstArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ViralSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionFindFirstOrThrowArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViralSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ViralSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ViralSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViralSessions
     * const viralSessions = await prisma.viralSession.findMany()
     * 
     * // Get first 10 ViralSessions
     * const viralSessions = await prisma.viralSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viralSessionWithIdOnly = await prisma.viralSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViralSessionFindManyArgs>(args?: SelectSubset<T, ViralSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ViralSession.
     * @param {ViralSessionCreateArgs} args - Arguments to create a ViralSession.
     * @example
     * // Create one ViralSession
     * const ViralSession = await prisma.viralSession.create({
     *   data: {
     *     // ... data to create a ViralSession
     *   }
     * })
     * 
     */
    create<T extends ViralSessionCreateArgs>(args: SelectSubset<T, ViralSessionCreateArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ViralSessions.
     * @param {ViralSessionCreateManyArgs} args - Arguments to create many ViralSessions.
     * @example
     * // Create many ViralSessions
     * const viralSession = await prisma.viralSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViralSessionCreateManyArgs>(args?: SelectSubset<T, ViralSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViralSessions and returns the data saved in the database.
     * @param {ViralSessionCreateManyAndReturnArgs} args - Arguments to create many ViralSessions.
     * @example
     * // Create many ViralSessions
     * const viralSession = await prisma.viralSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViralSessions and only return the `id`
     * const viralSessionWithIdOnly = await prisma.viralSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViralSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ViralSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ViralSession.
     * @param {ViralSessionDeleteArgs} args - Arguments to delete one ViralSession.
     * @example
     * // Delete one ViralSession
     * const ViralSession = await prisma.viralSession.delete({
     *   where: {
     *     // ... filter to delete one ViralSession
     *   }
     * })
     * 
     */
    delete<T extends ViralSessionDeleteArgs>(args: SelectSubset<T, ViralSessionDeleteArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ViralSession.
     * @param {ViralSessionUpdateArgs} args - Arguments to update one ViralSession.
     * @example
     * // Update one ViralSession
     * const viralSession = await prisma.viralSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViralSessionUpdateArgs>(args: SelectSubset<T, ViralSessionUpdateArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ViralSessions.
     * @param {ViralSessionDeleteManyArgs} args - Arguments to filter ViralSessions to delete.
     * @example
     * // Delete a few ViralSessions
     * const { count } = await prisma.viralSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViralSessionDeleteManyArgs>(args?: SelectSubset<T, ViralSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViralSessions
     * const viralSession = await prisma.viralSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViralSessionUpdateManyArgs>(args: SelectSubset<T, ViralSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViralSession.
     * @param {ViralSessionUpsertArgs} args - Arguments to update or create a ViralSession.
     * @example
     * // Update or create a ViralSession
     * const viralSession = await prisma.viralSession.upsert({
     *   create: {
     *     // ... data to create a ViralSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViralSession we want to update
     *   }
     * })
     */
    upsert<T extends ViralSessionUpsertArgs>(args: SelectSubset<T, ViralSessionUpsertArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ViralSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionCountArgs} args - Arguments to filter ViralSessions to count.
     * @example
     * // Count the number of ViralSessions
     * const count = await prisma.viralSession.count({
     *   where: {
     *     // ... the filter for the ViralSessions we want to count
     *   }
     * })
    **/
    count<T extends ViralSessionCountArgs>(
      args?: Subset<T, ViralSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViralSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViralSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViralSessionAggregateArgs>(args: Subset<T, ViralSessionAggregateArgs>): Prisma.PrismaPromise<GetViralSessionAggregateType<T>>

    /**
     * Group by ViralSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViralSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViralSessionGroupByArgs['orderBy'] }
        : { orderBy?: ViralSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViralSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViralSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViralSession model
   */
  readonly fields: ViralSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViralSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViralSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drafts<T extends ViralSession$draftsArgs<ExtArgs> = {}>(args?: Subset<T, ViralSession$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findMany"> | Null>
    characterProfile<T extends ViralSession$characterProfileArgs<ExtArgs> = {}>(args?: Subset<T, ViralSession$characterProfileArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    newsRelations<T extends ViralSession$newsRelationsArgs<ExtArgs> = {}>(args?: Subset<T, ViralSession$newsRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findMany"> | Null>
    integratedSessions<T extends ViralSession$integratedSessionsArgs<ExtArgs> = {}>(args?: Subset<T, ViralSession$integratedSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegratedSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViralSession model
   */ 
  interface ViralSessionFieldRefs {
    readonly id: FieldRef<"ViralSession", 'String'>
    readonly theme: FieldRef<"ViralSession", 'String'>
    readonly platform: FieldRef<"ViralSession", 'String'>
    readonly style: FieldRef<"ViralSession", 'String'>
    readonly status: FieldRef<"ViralSession", 'String'>
    readonly createdAt: FieldRef<"ViralSession", 'DateTime'>
    readonly characterProfileId: FieldRef<"ViralSession", 'String'>
    readonly voiceStyleMode: FieldRef<"ViralSession", 'String'>
    readonly topics: FieldRef<"ViralSession", 'Json'>
    readonly concepts: FieldRef<"ViralSession", 'Json'>
    readonly selectedIds: FieldRef<"ViralSession", 'String[]'>
    readonly contents: FieldRef<"ViralSession", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ViralSession findUnique
   */
  export type ViralSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession findUniqueOrThrow
   */
  export type ViralSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession findFirst
   */
  export type ViralSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralSessions.
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralSessions.
     */
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * ViralSession findFirstOrThrow
   */
  export type ViralSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralSessions.
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralSessions.
     */
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * ViralSession findMany
   */
  export type ViralSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSessions to fetch.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViralSessions.
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * ViralSession create
   */
  export type ViralSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ViralSession.
     */
    data: XOR<ViralSessionCreateInput, ViralSessionUncheckedCreateInput>
  }

  /**
   * ViralSession createMany
   */
  export type ViralSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViralSessions.
     */
    data: ViralSessionCreateManyInput | ViralSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralSession createManyAndReturn
   */
  export type ViralSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ViralSessions.
     */
    data: ViralSessionCreateManyInput | ViralSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralSession update
   */
  export type ViralSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ViralSession.
     */
    data: XOR<ViralSessionUpdateInput, ViralSessionUncheckedUpdateInput>
    /**
     * Choose, which ViralSession to update.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession updateMany
   */
  export type ViralSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViralSessions.
     */
    data: XOR<ViralSessionUpdateManyMutationInput, ViralSessionUncheckedUpdateManyInput>
    /**
     * Filter which ViralSessions to update
     */
    where?: ViralSessionWhereInput
  }

  /**
   * ViralSession upsert
   */
  export type ViralSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ViralSession to update in case it exists.
     */
    where: ViralSessionWhereUniqueInput
    /**
     * In case the ViralSession found by the `where` argument doesn't exist, create a new ViralSession with this data.
     */
    create: XOR<ViralSessionCreateInput, ViralSessionUncheckedCreateInput>
    /**
     * In case the ViralSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViralSessionUpdateInput, ViralSessionUncheckedUpdateInput>
  }

  /**
   * ViralSession delete
   */
  export type ViralSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter which ViralSession to delete.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession deleteMany
   */
  export type ViralSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralSessions to delete
     */
    where?: ViralSessionWhereInput
  }

  /**
   * ViralSession.drafts
   */
  export type ViralSession$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    where?: ViralDraftV2WhereInput
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    cursor?: ViralDraftV2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralSession.characterProfile
   */
  export type ViralSession$characterProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    where?: CharacterProfileWhereInput
  }

  /**
   * ViralSession.newsRelations
   */
  export type ViralSession$newsRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsViralRelationInclude<ExtArgs> | null
    where?: NewsViralRelationWhereInput
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    cursor?: NewsViralRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * ViralSession.integratedSessions
   */
  export type ViralSession$integratedSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegratedSession
     */
    select?: IntegratedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegratedSessionInclude<ExtArgs> | null
    where?: IntegratedSessionWhereInput
    orderBy?: IntegratedSessionOrderByWithRelationInput | IntegratedSessionOrderByWithRelationInput[]
    cursor?: IntegratedSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegratedSessionScalarFieldEnum | IntegratedSessionScalarFieldEnum[]
  }

  /**
   * ViralSession without action
   */
  export type ViralSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
  }


  /**
   * Model ViralDraftV2
   */

  export type AggregateViralDraftV2 = {
    _count: ViralDraftV2CountAggregateOutputType | null
    _min: ViralDraftV2MinAggregateOutputType | null
    _max: ViralDraftV2MaxAggregateOutputType | null
  }

  export type ViralDraftV2MinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptId: string | null
    title: string | null
    content: string | null
    visualNote: string | null
    sourceUrl: string | null
    characterId: string | null
    characterNote: string | null
    status: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    tweetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViralDraftV2MaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptId: string | null
    title: string | null
    content: string | null
    visualNote: string | null
    sourceUrl: string | null
    characterId: string | null
    characterNote: string | null
    status: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    tweetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViralDraftV2CountAggregateOutputType = {
    id: number
    sessionId: number
    conceptId: number
    title: number
    content: number
    hashtags: number
    visualNote: number
    sourceUrl: number
    characterId: number
    characterNote: number
    status: number
    scheduledAt: number
    postedAt: number
    tweetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ViralDraftV2MinAggregateInputType = {
    id?: true
    sessionId?: true
    conceptId?: true
    title?: true
    content?: true
    visualNote?: true
    sourceUrl?: true
    characterId?: true
    characterNote?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    tweetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViralDraftV2MaxAggregateInputType = {
    id?: true
    sessionId?: true
    conceptId?: true
    title?: true
    content?: true
    visualNote?: true
    sourceUrl?: true
    characterId?: true
    characterNote?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    tweetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViralDraftV2CountAggregateInputType = {
    id?: true
    sessionId?: true
    conceptId?: true
    title?: true
    content?: true
    hashtags?: true
    visualNote?: true
    sourceUrl?: true
    characterId?: true
    characterNote?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    tweetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ViralDraftV2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftV2 to aggregate.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViralDraftV2s
    **/
    _count?: true | ViralDraftV2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViralDraftV2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViralDraftV2MaxAggregateInputType
  }

  export type GetViralDraftV2AggregateType<T extends ViralDraftV2AggregateArgs> = {
        [P in keyof T & keyof AggregateViralDraftV2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViralDraftV2[P]>
      : GetScalarType<T[P], AggregateViralDraftV2[P]>
  }




  export type ViralDraftV2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralDraftV2WhereInput
    orderBy?: ViralDraftV2OrderByWithAggregationInput | ViralDraftV2OrderByWithAggregationInput[]
    by: ViralDraftV2ScalarFieldEnum[] | ViralDraftV2ScalarFieldEnum
    having?: ViralDraftV2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViralDraftV2CountAggregateInputType | true
    _min?: ViralDraftV2MinAggregateInputType
    _max?: ViralDraftV2MaxAggregateInputType
  }

  export type ViralDraftV2GroupByOutputType = {
    id: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags: string[]
    visualNote: string | null
    sourceUrl: string | null
    characterId: string | null
    characterNote: string | null
    status: string
    scheduledAt: Date | null
    postedAt: Date | null
    tweetId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ViralDraftV2CountAggregateOutputType | null
    _min: ViralDraftV2MinAggregateOutputType | null
    _max: ViralDraftV2MaxAggregateOutputType | null
  }

  type GetViralDraftV2GroupByPayload<T extends ViralDraftV2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViralDraftV2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViralDraftV2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViralDraftV2GroupByOutputType[P]>
            : GetScalarType<T[P], ViralDraftV2GroupByOutputType[P]>
        }
      >
    >


  export type ViralDraftV2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    sourceUrl?: boolean
    characterId?: boolean
    characterNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
    performance?: boolean | ViralDraftV2$performanceArgs<ExtArgs>
    scheduledRTs?: boolean | ViralDraftV2$scheduledRTsArgs<ExtArgs>
    _count?: boolean | ViralDraftV2CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftV2"]>

  export type ViralDraftV2SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    sourceUrl?: boolean
    characterId?: boolean
    characterNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftV2"]>

  export type ViralDraftV2SelectScalar = {
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    sourceUrl?: boolean
    characterId?: boolean
    characterNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ViralDraftV2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
    performance?: boolean | ViralDraftV2$performanceArgs<ExtArgs>
    scheduledRTs?: boolean | ViralDraftV2$scheduledRTsArgs<ExtArgs>
    _count?: boolean | ViralDraftV2CountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViralDraftV2IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }

  export type $ViralDraftV2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViralDraftV2"
    objects: {
      session: Prisma.$ViralSessionPayload<ExtArgs>
      performance: Prisma.$ViralDraftPerformancePayload<ExtArgs> | null
      scheduledRTs: Prisma.$ScheduledRetweetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      conceptId: string
      title: string
      content: string
      hashtags: string[]
      visualNote: string | null
      sourceUrl: string | null
      characterId: string | null
      characterNote: string | null
      status: string
      scheduledAt: Date | null
      postedAt: Date | null
      tweetId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["viralDraftV2"]>
    composites: {}
  }

  type ViralDraftV2GetPayload<S extends boolean | null | undefined | ViralDraftV2DefaultArgs> = $Result.GetResult<Prisma.$ViralDraftV2Payload, S>

  type ViralDraftV2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViralDraftV2FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViralDraftV2CountAggregateInputType | true
    }

  export interface ViralDraftV2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViralDraftV2'], meta: { name: 'ViralDraftV2' } }
    /**
     * Find zero or one ViralDraftV2 that matches the filter.
     * @param {ViralDraftV2FindUniqueArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViralDraftV2FindUniqueArgs>(args: SelectSubset<T, ViralDraftV2FindUniqueArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ViralDraftV2 that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViralDraftV2FindUniqueOrThrowArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViralDraftV2FindUniqueOrThrowArgs>(args: SelectSubset<T, ViralDraftV2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ViralDraftV2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2FindFirstArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViralDraftV2FindFirstArgs>(args?: SelectSubset<T, ViralDraftV2FindFirstArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ViralDraftV2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2FindFirstOrThrowArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViralDraftV2FindFirstOrThrowArgs>(args?: SelectSubset<T, ViralDraftV2FindFirstOrThrowArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ViralDraftV2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViralDraftV2s
     * const viralDraftV2s = await prisma.viralDraftV2.findMany()
     * 
     * // Get first 10 ViralDraftV2s
     * const viralDraftV2s = await prisma.viralDraftV2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viralDraftV2WithIdOnly = await prisma.viralDraftV2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViralDraftV2FindManyArgs>(args?: SelectSubset<T, ViralDraftV2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a ViralDraftV2.
     * @param {ViralDraftV2CreateArgs} args - Arguments to create a ViralDraftV2.
     * @example
     * // Create one ViralDraftV2
     * const ViralDraftV2 = await prisma.viralDraftV2.create({
     *   data: {
     *     // ... data to create a ViralDraftV2
     *   }
     * })
     * 
     */
    create<T extends ViralDraftV2CreateArgs>(args: SelectSubset<T, ViralDraftV2CreateArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ViralDraftV2s.
     * @param {ViralDraftV2CreateManyArgs} args - Arguments to create many ViralDraftV2s.
     * @example
     * // Create many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViralDraftV2CreateManyArgs>(args?: SelectSubset<T, ViralDraftV2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViralDraftV2s and returns the data saved in the database.
     * @param {ViralDraftV2CreateManyAndReturnArgs} args - Arguments to create many ViralDraftV2s.
     * @example
     * // Create many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViralDraftV2s and only return the `id`
     * const viralDraftV2WithIdOnly = await prisma.viralDraftV2.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViralDraftV2CreateManyAndReturnArgs>(args?: SelectSubset<T, ViralDraftV2CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ViralDraftV2.
     * @param {ViralDraftV2DeleteArgs} args - Arguments to delete one ViralDraftV2.
     * @example
     * // Delete one ViralDraftV2
     * const ViralDraftV2 = await prisma.viralDraftV2.delete({
     *   where: {
     *     // ... filter to delete one ViralDraftV2
     *   }
     * })
     * 
     */
    delete<T extends ViralDraftV2DeleteArgs>(args: SelectSubset<T, ViralDraftV2DeleteArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ViralDraftV2.
     * @param {ViralDraftV2UpdateArgs} args - Arguments to update one ViralDraftV2.
     * @example
     * // Update one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViralDraftV2UpdateArgs>(args: SelectSubset<T, ViralDraftV2UpdateArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ViralDraftV2s.
     * @param {ViralDraftV2DeleteManyArgs} args - Arguments to filter ViralDraftV2s to delete.
     * @example
     * // Delete a few ViralDraftV2s
     * const { count } = await prisma.viralDraftV2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViralDraftV2DeleteManyArgs>(args?: SelectSubset<T, ViralDraftV2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralDraftV2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViralDraftV2UpdateManyArgs>(args: SelectSubset<T, ViralDraftV2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViralDraftV2.
     * @param {ViralDraftV2UpsertArgs} args - Arguments to update or create a ViralDraftV2.
     * @example
     * // Update or create a ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.upsert({
     *   create: {
     *     // ... data to create a ViralDraftV2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViralDraftV2 we want to update
     *   }
     * })
     */
    upsert<T extends ViralDraftV2UpsertArgs>(args: SelectSubset<T, ViralDraftV2UpsertArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ViralDraftV2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2CountArgs} args - Arguments to filter ViralDraftV2s to count.
     * @example
     * // Count the number of ViralDraftV2s
     * const count = await prisma.viralDraftV2.count({
     *   where: {
     *     // ... the filter for the ViralDraftV2s we want to count
     *   }
     * })
    **/
    count<T extends ViralDraftV2CountArgs>(
      args?: Subset<T, ViralDraftV2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViralDraftV2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViralDraftV2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViralDraftV2AggregateArgs>(args: Subset<T, ViralDraftV2AggregateArgs>): Prisma.PrismaPromise<GetViralDraftV2AggregateType<T>>

    /**
     * Group by ViralDraftV2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViralDraftV2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViralDraftV2GroupByArgs['orderBy'] }
        : { orderBy?: ViralDraftV2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViralDraftV2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViralDraftV2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViralDraftV2 model
   */
  readonly fields: ViralDraftV2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViralDraftV2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViralDraftV2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ViralSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViralSessionDefaultArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    performance<T extends ViralDraftV2$performanceArgs<ExtArgs> = {}>(args?: Subset<T, ViralDraftV2$performanceArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    scheduledRTs<T extends ViralDraftV2$scheduledRTsArgs<ExtArgs> = {}>(args?: Subset<T, ViralDraftV2$scheduledRTsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViralDraftV2 model
   */ 
  interface ViralDraftV2FieldRefs {
    readonly id: FieldRef<"ViralDraftV2", 'String'>
    readonly sessionId: FieldRef<"ViralDraftV2", 'String'>
    readonly conceptId: FieldRef<"ViralDraftV2", 'String'>
    readonly title: FieldRef<"ViralDraftV2", 'String'>
    readonly content: FieldRef<"ViralDraftV2", 'String'>
    readonly hashtags: FieldRef<"ViralDraftV2", 'String[]'>
    readonly visualNote: FieldRef<"ViralDraftV2", 'String'>
    readonly sourceUrl: FieldRef<"ViralDraftV2", 'String'>
    readonly characterId: FieldRef<"ViralDraftV2", 'String'>
    readonly characterNote: FieldRef<"ViralDraftV2", 'String'>
    readonly status: FieldRef<"ViralDraftV2", 'String'>
    readonly scheduledAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly postedAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly tweetId: FieldRef<"ViralDraftV2", 'String'>
    readonly createdAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly updatedAt: FieldRef<"ViralDraftV2", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViralDraftV2 findUnique
   */
  export type ViralDraftV2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 findUniqueOrThrow
   */
  export type ViralDraftV2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 findFirst
   */
  export type ViralDraftV2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftV2s.
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftV2s.
     */
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 findFirstOrThrow
   */
  export type ViralDraftV2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftV2s.
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftV2s.
     */
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 findMany
   */
  export type ViralDraftV2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2s to fetch.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViralDraftV2s.
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 create
   */
  export type ViralDraftV2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * The data needed to create a ViralDraftV2.
     */
    data: XOR<ViralDraftV2CreateInput, ViralDraftV2UncheckedCreateInput>
  }

  /**
   * ViralDraftV2 createMany
   */
  export type ViralDraftV2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViralDraftV2s.
     */
    data: ViralDraftV2CreateManyInput | ViralDraftV2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralDraftV2 createManyAndReturn
   */
  export type ViralDraftV2CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ViralDraftV2s.
     */
    data: ViralDraftV2CreateManyInput | ViralDraftV2CreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2IncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralDraftV2 update
   */
  export type ViralDraftV2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * The data needed to update a ViralDraftV2.
     */
    data: XOR<ViralDraftV2UpdateInput, ViralDraftV2UncheckedUpdateInput>
    /**
     * Choose, which ViralDraftV2 to update.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 updateMany
   */
  export type ViralDraftV2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViralDraftV2s.
     */
    data: XOR<ViralDraftV2UpdateManyMutationInput, ViralDraftV2UncheckedUpdateManyInput>
    /**
     * Filter which ViralDraftV2s to update
     */
    where?: ViralDraftV2WhereInput
  }

  /**
   * ViralDraftV2 upsert
   */
  export type ViralDraftV2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * The filter to search for the ViralDraftV2 to update in case it exists.
     */
    where: ViralDraftV2WhereUniqueInput
    /**
     * In case the ViralDraftV2 found by the `where` argument doesn't exist, create a new ViralDraftV2 with this data.
     */
    create: XOR<ViralDraftV2CreateInput, ViralDraftV2UncheckedCreateInput>
    /**
     * In case the ViralDraftV2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViralDraftV2UpdateInput, ViralDraftV2UncheckedUpdateInput>
  }

  /**
   * ViralDraftV2 delete
   */
  export type ViralDraftV2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter which ViralDraftV2 to delete.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 deleteMany
   */
  export type ViralDraftV2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftV2s to delete
     */
    where?: ViralDraftV2WhereInput
  }

  /**
   * ViralDraftV2.performance
   */
  export type ViralDraftV2$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    where?: ViralDraftPerformanceWhereInput
  }

  /**
   * ViralDraftV2.scheduledRTs
   */
  export type ViralDraftV2$scheduledRTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRetweetInclude<ExtArgs> | null
    where?: ScheduledRetweetWhereInput
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    cursor?: ScheduledRetweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 without action
   */
  export type ViralDraftV2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
  }


  /**
   * Model ViralDraftPerformance
   */

  export type AggregateViralDraftPerformance = {
    _count: ViralDraftPerformanceCountAggregateOutputType | null
    _avg: ViralDraftPerformanceAvgAggregateOutputType | null
    _sum: ViralDraftPerformanceSumAggregateOutputType | null
    _min: ViralDraftPerformanceMinAggregateOutputType | null
    _max: ViralDraftPerformanceMaxAggregateOutputType | null
  }

  export type ViralDraftPerformanceAvgAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type ViralDraftPerformanceSumAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type ViralDraftPerformanceMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type ViralDraftPerformanceMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type ViralDraftPerformanceCountAggregateOutputType = {
    id: number
    draftId: number
    likes30m: number
    retweets30m: number
    replies30m: number
    impressions30m: number
    likes1h: number
    retweets1h: number
    replies1h: number
    impressions1h: number
    likes24h: number
    retweets24h: number
    replies24h: number
    impressions24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    updatedAt: number
    _all: number
  }


  export type ViralDraftPerformanceAvgAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type ViralDraftPerformanceSumAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type ViralDraftPerformanceMinAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type ViralDraftPerformanceMaxAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type ViralDraftPerformanceCountAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ViralDraftPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftPerformance to aggregate.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViralDraftPerformances
    **/
    _count?: true | ViralDraftPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViralDraftPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViralDraftPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViralDraftPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViralDraftPerformanceMaxAggregateInputType
  }

  export type GetViralDraftPerformanceAggregateType<T extends ViralDraftPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateViralDraftPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViralDraftPerformance[P]>
      : GetScalarType<T[P], AggregateViralDraftPerformance[P]>
  }




  export type ViralDraftPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralDraftPerformanceWhereInput
    orderBy?: ViralDraftPerformanceOrderByWithAggregationInput | ViralDraftPerformanceOrderByWithAggregationInput[]
    by: ViralDraftPerformanceScalarFieldEnum[] | ViralDraftPerformanceScalarFieldEnum
    having?: ViralDraftPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViralDraftPerformanceCountAggregateInputType | true
    _avg?: ViralDraftPerformanceAvgAggregateInputType
    _sum?: ViralDraftPerformanceSumAggregateInputType
    _min?: ViralDraftPerformanceMinAggregateInputType
    _max?: ViralDraftPerformanceMaxAggregateInputType
  }

  export type ViralDraftPerformanceGroupByOutputType = {
    id: string
    draftId: string
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    updatedAt: Date
    _count: ViralDraftPerformanceCountAggregateOutputType | null
    _avg: ViralDraftPerformanceAvgAggregateOutputType | null
    _sum: ViralDraftPerformanceSumAggregateOutputType | null
    _min: ViralDraftPerformanceMinAggregateOutputType | null
    _max: ViralDraftPerformanceMaxAggregateOutputType | null
  }

  type GetViralDraftPerformanceGroupByPayload<T extends ViralDraftPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViralDraftPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViralDraftPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViralDraftPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], ViralDraftPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type ViralDraftPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftPerformance"]>

  export type ViralDraftPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftPerformance"]>

  export type ViralDraftPerformanceSelectScalar = {
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }

  export type ViralDraftPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }
  export type ViralDraftPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }

  export type $ViralDraftPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViralDraftPerformance"
    objects: {
      draft: Prisma.$ViralDraftV2Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      likes30m: number | null
      retweets30m: number | null
      replies30m: number | null
      impressions30m: number | null
      likes1h: number | null
      retweets1h: number | null
      replies1h: number | null
      impressions1h: number | null
      likes24h: number | null
      retweets24h: number | null
      replies24h: number | null
      impressions24h: number | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["viralDraftPerformance"]>
    composites: {}
  }

  type ViralDraftPerformanceGetPayload<S extends boolean | null | undefined | ViralDraftPerformanceDefaultArgs> = $Result.GetResult<Prisma.$ViralDraftPerformancePayload, S>

  type ViralDraftPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViralDraftPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViralDraftPerformanceCountAggregateInputType | true
    }

  export interface ViralDraftPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViralDraftPerformance'], meta: { name: 'ViralDraftPerformance' } }
    /**
     * Find zero or one ViralDraftPerformance that matches the filter.
     * @param {ViralDraftPerformanceFindUniqueArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViralDraftPerformanceFindUniqueArgs>(args: SelectSubset<T, ViralDraftPerformanceFindUniqueArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ViralDraftPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViralDraftPerformanceFindUniqueOrThrowArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViralDraftPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ViralDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ViralDraftPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceFindFirstArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViralDraftPerformanceFindFirstArgs>(args?: SelectSubset<T, ViralDraftPerformanceFindFirstArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ViralDraftPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceFindFirstOrThrowArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViralDraftPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ViralDraftPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ViralDraftPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViralDraftPerformances
     * const viralDraftPerformances = await prisma.viralDraftPerformance.findMany()
     * 
     * // Get first 10 ViralDraftPerformances
     * const viralDraftPerformances = await prisma.viralDraftPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viralDraftPerformanceWithIdOnly = await prisma.viralDraftPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViralDraftPerformanceFindManyArgs>(args?: SelectSubset<T, ViralDraftPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ViralDraftPerformance.
     * @param {ViralDraftPerformanceCreateArgs} args - Arguments to create a ViralDraftPerformance.
     * @example
     * // Create one ViralDraftPerformance
     * const ViralDraftPerformance = await prisma.viralDraftPerformance.create({
     *   data: {
     *     // ... data to create a ViralDraftPerformance
     *   }
     * })
     * 
     */
    create<T extends ViralDraftPerformanceCreateArgs>(args: SelectSubset<T, ViralDraftPerformanceCreateArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ViralDraftPerformances.
     * @param {ViralDraftPerformanceCreateManyArgs} args - Arguments to create many ViralDraftPerformances.
     * @example
     * // Create many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViralDraftPerformanceCreateManyArgs>(args?: SelectSubset<T, ViralDraftPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViralDraftPerformances and returns the data saved in the database.
     * @param {ViralDraftPerformanceCreateManyAndReturnArgs} args - Arguments to create many ViralDraftPerformances.
     * @example
     * // Create many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViralDraftPerformances and only return the `id`
     * const viralDraftPerformanceWithIdOnly = await prisma.viralDraftPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViralDraftPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, ViralDraftPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ViralDraftPerformance.
     * @param {ViralDraftPerformanceDeleteArgs} args - Arguments to delete one ViralDraftPerformance.
     * @example
     * // Delete one ViralDraftPerformance
     * const ViralDraftPerformance = await prisma.viralDraftPerformance.delete({
     *   where: {
     *     // ... filter to delete one ViralDraftPerformance
     *   }
     * })
     * 
     */
    delete<T extends ViralDraftPerformanceDeleteArgs>(args: SelectSubset<T, ViralDraftPerformanceDeleteArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ViralDraftPerformance.
     * @param {ViralDraftPerformanceUpdateArgs} args - Arguments to update one ViralDraftPerformance.
     * @example
     * // Update one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViralDraftPerformanceUpdateArgs>(args: SelectSubset<T, ViralDraftPerformanceUpdateArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ViralDraftPerformances.
     * @param {ViralDraftPerformanceDeleteManyArgs} args - Arguments to filter ViralDraftPerformances to delete.
     * @example
     * // Delete a few ViralDraftPerformances
     * const { count } = await prisma.viralDraftPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViralDraftPerformanceDeleteManyArgs>(args?: SelectSubset<T, ViralDraftPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViralDraftPerformanceUpdateManyArgs>(args: SelectSubset<T, ViralDraftPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViralDraftPerformance.
     * @param {ViralDraftPerformanceUpsertArgs} args - Arguments to update or create a ViralDraftPerformance.
     * @example
     * // Update or create a ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.upsert({
     *   create: {
     *     // ... data to create a ViralDraftPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViralDraftPerformance we want to update
     *   }
     * })
     */
    upsert<T extends ViralDraftPerformanceUpsertArgs>(args: SelectSubset<T, ViralDraftPerformanceUpsertArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ViralDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceCountArgs} args - Arguments to filter ViralDraftPerformances to count.
     * @example
     * // Count the number of ViralDraftPerformances
     * const count = await prisma.viralDraftPerformance.count({
     *   where: {
     *     // ... the filter for the ViralDraftPerformances we want to count
     *   }
     * })
    **/
    count<T extends ViralDraftPerformanceCountArgs>(
      args?: Subset<T, ViralDraftPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViralDraftPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViralDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViralDraftPerformanceAggregateArgs>(args: Subset<T, ViralDraftPerformanceAggregateArgs>): Prisma.PrismaPromise<GetViralDraftPerformanceAggregateType<T>>

    /**
     * Group by ViralDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViralDraftPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViralDraftPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: ViralDraftPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViralDraftPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViralDraftPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViralDraftPerformance model
   */
  readonly fields: ViralDraftPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViralDraftPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViralDraftPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends ViralDraftV2DefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViralDraftV2DefaultArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViralDraftPerformance model
   */ 
  interface ViralDraftPerformanceFieldRefs {
    readonly id: FieldRef<"ViralDraftPerformance", 'String'>
    readonly draftId: FieldRef<"ViralDraftPerformance", 'String'>
    readonly likes30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly retweets30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly replies30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly impressions30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly likes1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly retweets1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly replies1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly impressions1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly likes24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly retweets24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly replies24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly impressions24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly engagementRate: FieldRef<"ViralDraftPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"ViralDraftPerformance", 'Float'>
    readonly collectedAt: FieldRef<"ViralDraftPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"ViralDraftPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViralDraftPerformance findUnique
   */
  export type ViralDraftPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance findUniqueOrThrow
   */
  export type ViralDraftPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance findFirst
   */
  export type ViralDraftPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftPerformances.
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftPerformances.
     */
    distinct?: ViralDraftPerformanceScalarFieldEnum | ViralDraftPerformanceScalarFieldEnum[]
  }

  /**
   * ViralDraftPerformance findFirstOrThrow
   */
  export type ViralDraftPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftPerformances.
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftPerformances.
     */
    distinct?: ViralDraftPerformanceScalarFieldEnum | ViralDraftPerformanceScalarFieldEnum[]
  }

  /**
   * ViralDraftPerformance findMany
   */
  export type ViralDraftPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformances to fetch.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViralDraftPerformances.
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    distinct?: ViralDraftPerformanceScalarFieldEnum | ViralDraftPerformanceScalarFieldEnum[]
  }

  /**
   * ViralDraftPerformance create
   */
  export type ViralDraftPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a ViralDraftPerformance.
     */
    data: XOR<ViralDraftPerformanceCreateInput, ViralDraftPerformanceUncheckedCreateInput>
  }

  /**
   * ViralDraftPerformance createMany
   */
  export type ViralDraftPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViralDraftPerformances.
     */
    data: ViralDraftPerformanceCreateManyInput | ViralDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralDraftPerformance createManyAndReturn
   */
  export type ViralDraftPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ViralDraftPerformances.
     */
    data: ViralDraftPerformanceCreateManyInput | ViralDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralDraftPerformance update
   */
  export type ViralDraftPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a ViralDraftPerformance.
     */
    data: XOR<ViralDraftPerformanceUpdateInput, ViralDraftPerformanceUncheckedUpdateInput>
    /**
     * Choose, which ViralDraftPerformance to update.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance updateMany
   */
  export type ViralDraftPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViralDraftPerformances.
     */
    data: XOR<ViralDraftPerformanceUpdateManyMutationInput, ViralDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which ViralDraftPerformances to update
     */
    where?: ViralDraftPerformanceWhereInput
  }

  /**
   * ViralDraftPerformance upsert
   */
  export type ViralDraftPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the ViralDraftPerformance to update in case it exists.
     */
    where: ViralDraftPerformanceWhereUniqueInput
    /**
     * In case the ViralDraftPerformance found by the `where` argument doesn't exist, create a new ViralDraftPerformance with this data.
     */
    create: XOR<ViralDraftPerformanceCreateInput, ViralDraftPerformanceUncheckedCreateInput>
    /**
     * In case the ViralDraftPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViralDraftPerformanceUpdateInput, ViralDraftPerformanceUncheckedUpdateInput>
  }

  /**
   * ViralDraftPerformance delete
   */
  export type ViralDraftPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter which ViralDraftPerformance to delete.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance deleteMany
   */
  export type ViralDraftPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftPerformances to delete
     */
    where?: ViralDraftPerformanceWhereInput
  }

  /**
   * ViralDraftPerformance without action
   */
  export type ViralDraftPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model CharacterProfile
   */

  export type AggregateCharacterProfile = {
    _count: CharacterProfileCountAggregateOutputType | null
    _avg: CharacterProfileAvgAggregateOutputType | null
    _sum: CharacterProfileSumAggregateOutputType | null
    _min: CharacterProfileMinAggregateOutputType | null
    _max: CharacterProfileMaxAggregateOutputType | null
  }

  export type CharacterProfileAvgAggregateOutputType = {
    age: number | null
  }

  export type CharacterProfileSumAggregateOutputType = {
    age: number | null
  }

  export type CharacterProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    gender: string | null
    tone: string | null
    catchphrase: string | null
    philosophy: string | null
    isDefault: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    gender: string | null
    tone: string | null
    catchphrase: string | null
    philosophy: string | null
    isDefault: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterProfileCountAggregateOutputType = {
    id: number
    name: number
    age: number
    gender: number
    tone: number
    catchphrase: number
    philosophy: number
    voiceStyle: number
    topics: number
    visual: number
    isDefault: number
    userId: number
    createdAt: number
    updatedAt: number
    preferredNewsCategories: number
    newsCommentStyle: number
    topicExpertise: number
    _all: number
  }


  export type CharacterProfileAvgAggregateInputType = {
    age?: true
  }

  export type CharacterProfileSumAggregateInputType = {
    age?: true
  }

  export type CharacterProfileMinAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    tone?: true
    catchphrase?: true
    philosophy?: true
    isDefault?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterProfileMaxAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    tone?: true
    catchphrase?: true
    philosophy?: true
    isDefault?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterProfileCountAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    tone?: true
    catchphrase?: true
    philosophy?: true
    voiceStyle?: true
    topics?: true
    visual?: true
    isDefault?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    preferredNewsCategories?: true
    newsCommentStyle?: true
    topicExpertise?: true
    _all?: true
  }

  export type CharacterProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterProfile to aggregate.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterProfiles
    **/
    _count?: true | CharacterProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterProfileMaxAggregateInputType
  }

  export type GetCharacterProfileAggregateType<T extends CharacterProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterProfile[P]>
      : GetScalarType<T[P], AggregateCharacterProfile[P]>
  }




  export type CharacterProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterProfileWhereInput
    orderBy?: CharacterProfileOrderByWithAggregationInput | CharacterProfileOrderByWithAggregationInput[]
    by: CharacterProfileScalarFieldEnum[] | CharacterProfileScalarFieldEnum
    having?: CharacterProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterProfileCountAggregateInputType | true
    _avg?: CharacterProfileAvgAggregateInputType
    _sum?: CharacterProfileSumAggregateInputType
    _min?: CharacterProfileMinAggregateInputType
    _max?: CharacterProfileMaxAggregateInputType
  }

  export type CharacterProfileGroupByOutputType = {
    id: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy: string | null
    voiceStyle: JsonValue
    topics: JsonValue
    visual: JsonValue | null
    isDefault: boolean
    userId: string | null
    createdAt: Date
    updatedAt: Date
    preferredNewsCategories: string[]
    newsCommentStyle: JsonValue | null
    topicExpertise: JsonValue | null
    _count: CharacterProfileCountAggregateOutputType | null
    _avg: CharacterProfileAvgAggregateOutputType | null
    _sum: CharacterProfileSumAggregateOutputType | null
    _min: CharacterProfileMinAggregateOutputType | null
    _max: CharacterProfileMaxAggregateOutputType | null
  }

  type GetCharacterProfileGroupByPayload<T extends CharacterProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterProfileGroupByOutputType[P]>
        }
      >
    >


  export type CharacterProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    tone?: boolean
    catchphrase?: boolean
    philosophy?: boolean
    voiceStyle?: boolean
    topics?: boolean
    visual?: boolean
    isDefault?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
    user?: boolean | CharacterProfile$userArgs<ExtArgs>
    sessions?: boolean | CharacterProfile$sessionsArgs<ExtArgs>
    _count?: boolean | CharacterProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterProfile"]>

  export type CharacterProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    tone?: boolean
    catchphrase?: boolean
    philosophy?: boolean
    voiceStyle?: boolean
    topics?: boolean
    visual?: boolean
    isDefault?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
    user?: boolean | CharacterProfile$userArgs<ExtArgs>
  }, ExtArgs["result"]["characterProfile"]>

  export type CharacterProfileSelectScalar = {
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    tone?: boolean
    catchphrase?: boolean
    philosophy?: boolean
    voiceStyle?: boolean
    topics?: boolean
    visual?: boolean
    isDefault?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
  }

  export type CharacterProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CharacterProfile$userArgs<ExtArgs>
    sessions?: boolean | CharacterProfile$sessionsArgs<ExtArgs>
    _count?: boolean | CharacterProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CharacterProfile$userArgs<ExtArgs>
  }

  export type $CharacterProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      sessions: Prisma.$ViralSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      age: number
      gender: string
      tone: string
      catchphrase: string
      philosophy: string | null
      voiceStyle: Prisma.JsonValue
      topics: Prisma.JsonValue
      visual: Prisma.JsonValue | null
      isDefault: boolean
      userId: string | null
      createdAt: Date
      updatedAt: Date
      preferredNewsCategories: string[]
      newsCommentStyle: Prisma.JsonValue | null
      topicExpertise: Prisma.JsonValue | null
    }, ExtArgs["result"]["characterProfile"]>
    composites: {}
  }

  type CharacterProfileGetPayload<S extends boolean | null | undefined | CharacterProfileDefaultArgs> = $Result.GetResult<Prisma.$CharacterProfilePayload, S>

  type CharacterProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterProfileCountAggregateInputType | true
    }

  export interface CharacterProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterProfile'], meta: { name: 'CharacterProfile' } }
    /**
     * Find zero or one CharacterProfile that matches the filter.
     * @param {CharacterProfileFindUniqueArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterProfileFindUniqueArgs>(args: SelectSubset<T, CharacterProfileFindUniqueArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CharacterProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterProfileFindUniqueOrThrowArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CharacterProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileFindFirstArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterProfileFindFirstArgs>(args?: SelectSubset<T, CharacterProfileFindFirstArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CharacterProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileFindFirstOrThrowArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CharacterProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterProfiles
     * const characterProfiles = await prisma.characterProfile.findMany()
     * 
     * // Get first 10 CharacterProfiles
     * const characterProfiles = await prisma.characterProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterProfileWithIdOnly = await prisma.characterProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterProfileFindManyArgs>(args?: SelectSubset<T, CharacterProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CharacterProfile.
     * @param {CharacterProfileCreateArgs} args - Arguments to create a CharacterProfile.
     * @example
     * // Create one CharacterProfile
     * const CharacterProfile = await prisma.characterProfile.create({
     *   data: {
     *     // ... data to create a CharacterProfile
     *   }
     * })
     * 
     */
    create<T extends CharacterProfileCreateArgs>(args: SelectSubset<T, CharacterProfileCreateArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CharacterProfiles.
     * @param {CharacterProfileCreateManyArgs} args - Arguments to create many CharacterProfiles.
     * @example
     * // Create many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterProfileCreateManyArgs>(args?: SelectSubset<T, CharacterProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterProfiles and returns the data saved in the database.
     * @param {CharacterProfileCreateManyAndReturnArgs} args - Arguments to create many CharacterProfiles.
     * @example
     * // Create many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterProfiles and only return the `id`
     * const characterProfileWithIdOnly = await prisma.characterProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CharacterProfile.
     * @param {CharacterProfileDeleteArgs} args - Arguments to delete one CharacterProfile.
     * @example
     * // Delete one CharacterProfile
     * const CharacterProfile = await prisma.characterProfile.delete({
     *   where: {
     *     // ... filter to delete one CharacterProfile
     *   }
     * })
     * 
     */
    delete<T extends CharacterProfileDeleteArgs>(args: SelectSubset<T, CharacterProfileDeleteArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CharacterProfile.
     * @param {CharacterProfileUpdateArgs} args - Arguments to update one CharacterProfile.
     * @example
     * // Update one CharacterProfile
     * const characterProfile = await prisma.characterProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterProfileUpdateArgs>(args: SelectSubset<T, CharacterProfileUpdateArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CharacterProfiles.
     * @param {CharacterProfileDeleteManyArgs} args - Arguments to filter CharacterProfiles to delete.
     * @example
     * // Delete a few CharacterProfiles
     * const { count } = await prisma.characterProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterProfileDeleteManyArgs>(args?: SelectSubset<T, CharacterProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterProfileUpdateManyArgs>(args: SelectSubset<T, CharacterProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterProfile.
     * @param {CharacterProfileUpsertArgs} args - Arguments to update or create a CharacterProfile.
     * @example
     * // Update or create a CharacterProfile
     * const characterProfile = await prisma.characterProfile.upsert({
     *   create: {
     *     // ... data to create a CharacterProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterProfile we want to update
     *   }
     * })
     */
    upsert<T extends CharacterProfileUpsertArgs>(args: SelectSubset<T, CharacterProfileUpsertArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CharacterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileCountArgs} args - Arguments to filter CharacterProfiles to count.
     * @example
     * // Count the number of CharacterProfiles
     * const count = await prisma.characterProfile.count({
     *   where: {
     *     // ... the filter for the CharacterProfiles we want to count
     *   }
     * })
    **/
    count<T extends CharacterProfileCountArgs>(
      args?: Subset<T, CharacterProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterProfileAggregateArgs>(args: Subset<T, CharacterProfileAggregateArgs>): Prisma.PrismaPromise<GetCharacterProfileAggregateType<T>>

    /**
     * Group by CharacterProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterProfileGroupByArgs['orderBy'] }
        : { orderBy?: CharacterProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterProfile model
   */
  readonly fields: CharacterProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CharacterProfile$userArgs<ExtArgs> = {}>(args?: Subset<T, CharacterProfile$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends CharacterProfile$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, CharacterProfile$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterProfile model
   */ 
  interface CharacterProfileFieldRefs {
    readonly id: FieldRef<"CharacterProfile", 'String'>
    readonly name: FieldRef<"CharacterProfile", 'String'>
    readonly age: FieldRef<"CharacterProfile", 'Int'>
    readonly gender: FieldRef<"CharacterProfile", 'String'>
    readonly tone: FieldRef<"CharacterProfile", 'String'>
    readonly catchphrase: FieldRef<"CharacterProfile", 'String'>
    readonly philosophy: FieldRef<"CharacterProfile", 'String'>
    readonly voiceStyle: FieldRef<"CharacterProfile", 'Json'>
    readonly topics: FieldRef<"CharacterProfile", 'Json'>
    readonly visual: FieldRef<"CharacterProfile", 'Json'>
    readonly isDefault: FieldRef<"CharacterProfile", 'Boolean'>
    readonly userId: FieldRef<"CharacterProfile", 'String'>
    readonly createdAt: FieldRef<"CharacterProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterProfile", 'DateTime'>
    readonly preferredNewsCategories: FieldRef<"CharacterProfile", 'String[]'>
    readonly newsCommentStyle: FieldRef<"CharacterProfile", 'Json'>
    readonly topicExpertise: FieldRef<"CharacterProfile", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CharacterProfile findUnique
   */
  export type CharacterProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile findUniqueOrThrow
   */
  export type CharacterProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile findFirst
   */
  export type CharacterProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterProfiles.
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterProfiles.
     */
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * CharacterProfile findFirstOrThrow
   */
  export type CharacterProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterProfiles.
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterProfiles.
     */
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * CharacterProfile findMany
   */
  export type CharacterProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * Filter, which CharacterProfiles to fetch.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterProfiles.
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * CharacterProfile create
   */
  export type CharacterProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterProfile.
     */
    data: XOR<CharacterProfileCreateInput, CharacterProfileUncheckedCreateInput>
  }

  /**
   * CharacterProfile createMany
   */
  export type CharacterProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterProfiles.
     */
    data: CharacterProfileCreateManyInput | CharacterProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterProfile createManyAndReturn
   */
  export type CharacterProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CharacterProfiles.
     */
    data: CharacterProfileCreateManyInput | CharacterProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterProfile update
   */
  export type CharacterProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterProfile.
     */
    data: XOR<CharacterProfileUpdateInput, CharacterProfileUncheckedUpdateInput>
    /**
     * Choose, which CharacterProfile to update.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile updateMany
   */
  export type CharacterProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterProfiles.
     */
    data: XOR<CharacterProfileUpdateManyMutationInput, CharacterProfileUncheckedUpdateManyInput>
    /**
     * Filter which CharacterProfiles to update
     */
    where?: CharacterProfileWhereInput
  }

  /**
   * CharacterProfile upsert
   */
  export type CharacterProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterProfile to update in case it exists.
     */
    where: CharacterProfileWhereUniqueInput
    /**
     * In case the CharacterProfile found by the `where` argument doesn't exist, create a new CharacterProfile with this data.
     */
    create: XOR<CharacterProfileCreateInput, CharacterProfileUncheckedCreateInput>
    /**
     * In case the CharacterProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterProfileUpdateInput, CharacterProfileUncheckedUpdateInput>
  }

  /**
   * CharacterProfile delete
   */
  export type CharacterProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
    /**
     * Filter which CharacterProfile to delete.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile deleteMany
   */
  export type CharacterProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterProfiles to delete
     */
    where?: CharacterProfileWhereInput
  }

  /**
   * CharacterProfile.user
   */
  export type CharacterProfile$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CharacterProfile.sessions
   */
  export type CharacterProfile$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    where?: ViralSessionWhereInput
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    cursor?: ViralSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * CharacterProfile without action
   */
  export type CharacterProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterProfileInclude<ExtArgs> | null
  }


  /**
   * Model BuzzInfluencer
   */

  export type AggregateBuzzInfluencer = {
    _count: BuzzInfluencerCountAggregateOutputType | null
    _avg: BuzzInfluencerAvgAggregateOutputType | null
    _sum: BuzzInfluencerSumAggregateOutputType | null
    _min: BuzzInfluencerMinAggregateOutputType | null
    _max: BuzzInfluencerMaxAggregateOutputType | null
  }

  export type BuzzInfluencerAvgAggregateOutputType = {
    followers: number | null
    following: number | null
    engagementRate: number | null
    viralScore: number | null
    consistencyScore: number | null
  }

  export type BuzzInfluencerSumAggregateOutputType = {
    followers: number | null
    following: number | null
    engagementRate: number | null
    viralScore: number | null
    consistencyScore: number | null
  }

  export type BuzzInfluencerMinAggregateOutputType = {
    id: string | null
    username: string | null
    userId: string | null
    followers: number | null
    following: number | null
    verified: boolean | null
    profileImage: string | null
    bio: string | null
    primaryCategory: string | null
    engagementRate: number | null
    viralScore: number | null
    consistencyScore: number | null
    lastActiveAt: Date | null
    lastAnalyzedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuzzInfluencerMaxAggregateOutputType = {
    id: string | null
    username: string | null
    userId: string | null
    followers: number | null
    following: number | null
    verified: boolean | null
    profileImage: string | null
    bio: string | null
    primaryCategory: string | null
    engagementRate: number | null
    viralScore: number | null
    consistencyScore: number | null
    lastActiveAt: Date | null
    lastAnalyzedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuzzInfluencerCountAggregateOutputType = {
    id: number
    username: number
    userId: number
    followers: number
    following: number
    verified: number
    profileImage: number
    bio: number
    metrics7d: number
    metrics30d: number
    metricsAllTime: number
    categoryScores: number
    primaryCategory: number
    engagementRate: number
    viralScore: number
    consistencyScore: number
    bestPostingHours: number
    postingFrequency: number
    lastActiveAt: number
    lastAnalyzedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuzzInfluencerAvgAggregateInputType = {
    followers?: true
    following?: true
    engagementRate?: true
    viralScore?: true
    consistencyScore?: true
  }

  export type BuzzInfluencerSumAggregateInputType = {
    followers?: true
    following?: true
    engagementRate?: true
    viralScore?: true
    consistencyScore?: true
  }

  export type BuzzInfluencerMinAggregateInputType = {
    id?: true
    username?: true
    userId?: true
    followers?: true
    following?: true
    verified?: true
    profileImage?: true
    bio?: true
    primaryCategory?: true
    engagementRate?: true
    viralScore?: true
    consistencyScore?: true
    lastActiveAt?: true
    lastAnalyzedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuzzInfluencerMaxAggregateInputType = {
    id?: true
    username?: true
    userId?: true
    followers?: true
    following?: true
    verified?: true
    profileImage?: true
    bio?: true
    primaryCategory?: true
    engagementRate?: true
    viralScore?: true
    consistencyScore?: true
    lastActiveAt?: true
    lastAnalyzedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuzzInfluencerCountAggregateInputType = {
    id?: true
    username?: true
    userId?: true
    followers?: true
    following?: true
    verified?: true
    profileImage?: true
    bio?: true
    metrics7d?: true
    metrics30d?: true
    metricsAllTime?: true
    categoryScores?: true
    primaryCategory?: true
    engagementRate?: true
    viralScore?: true
    consistencyScore?: true
    bestPostingHours?: true
    postingFrequency?: true
    lastActiveAt?: true
    lastAnalyzedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuzzInfluencerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzInfluencer to aggregate.
     */
    where?: BuzzInfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzInfluencers to fetch.
     */
    orderBy?: BuzzInfluencerOrderByWithRelationInput | BuzzInfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzInfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzInfluencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzInfluencers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzInfluencers
    **/
    _count?: true | BuzzInfluencerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzInfluencerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzInfluencerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzInfluencerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzInfluencerMaxAggregateInputType
  }

  export type GetBuzzInfluencerAggregateType<T extends BuzzInfluencerAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzInfluencer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzInfluencer[P]>
      : GetScalarType<T[P], AggregateBuzzInfluencer[P]>
  }




  export type BuzzInfluencerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzInfluencerWhereInput
    orderBy?: BuzzInfluencerOrderByWithAggregationInput | BuzzInfluencerOrderByWithAggregationInput[]
    by: BuzzInfluencerScalarFieldEnum[] | BuzzInfluencerScalarFieldEnum
    having?: BuzzInfluencerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzInfluencerCountAggregateInputType | true
    _avg?: BuzzInfluencerAvgAggregateInputType
    _sum?: BuzzInfluencerSumAggregateInputType
    _min?: BuzzInfluencerMinAggregateInputType
    _max?: BuzzInfluencerMaxAggregateInputType
  }

  export type BuzzInfluencerGroupByOutputType = {
    id: string
    username: string
    userId: string
    followers: number
    following: number
    verified: boolean
    profileImage: string | null
    bio: string | null
    metrics7d: JsonValue | null
    metrics30d: JsonValue | null
    metricsAllTime: JsonValue | null
    categoryScores: JsonValue
    primaryCategory: string | null
    engagementRate: number
    viralScore: number
    consistencyScore: number
    bestPostingHours: JsonValue | null
    postingFrequency: JsonValue | null
    lastActiveAt: Date | null
    lastAnalyzedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BuzzInfluencerCountAggregateOutputType | null
    _avg: BuzzInfluencerAvgAggregateOutputType | null
    _sum: BuzzInfluencerSumAggregateOutputType | null
    _min: BuzzInfluencerMinAggregateOutputType | null
    _max: BuzzInfluencerMaxAggregateOutputType | null
  }

  type GetBuzzInfluencerGroupByPayload<T extends BuzzInfluencerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzInfluencerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzInfluencerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzInfluencerGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzInfluencerGroupByOutputType[P]>
        }
      >
    >


  export type BuzzInfluencerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    userId?: boolean
    followers?: boolean
    following?: boolean
    verified?: boolean
    profileImage?: boolean
    bio?: boolean
    metrics7d?: boolean
    metrics30d?: boolean
    metricsAllTime?: boolean
    categoryScores?: boolean
    primaryCategory?: boolean
    engagementRate?: boolean
    viralScore?: boolean
    consistencyScore?: boolean
    bestPostingHours?: boolean
    postingFrequency?: boolean
    lastActiveAt?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzInfluencer"]>

  export type BuzzInfluencerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    userId?: boolean
    followers?: boolean
    following?: boolean
    verified?: boolean
    profileImage?: boolean
    bio?: boolean
    metrics7d?: boolean
    metrics30d?: boolean
    metricsAllTime?: boolean
    categoryScores?: boolean
    primaryCategory?: boolean
    engagementRate?: boolean
    viralScore?: boolean
    consistencyScore?: boolean
    bestPostingHours?: boolean
    postingFrequency?: boolean
    lastActiveAt?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzInfluencer"]>

  export type BuzzInfluencerSelectScalar = {
    id?: boolean
    username?: boolean
    userId?: boolean
    followers?: boolean
    following?: boolean
    verified?: boolean
    profileImage?: boolean
    bio?: boolean
    metrics7d?: boolean
    metrics30d?: boolean
    metricsAllTime?: boolean
    categoryScores?: boolean
    primaryCategory?: boolean
    engagementRate?: boolean
    viralScore?: boolean
    consistencyScore?: boolean
    bestPostingHours?: boolean
    postingFrequency?: boolean
    lastActiveAt?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BuzzInfluencerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzInfluencer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      userId: string
      followers: number
      following: number
      verified: boolean
      profileImage: string | null
      bio: string | null
      metrics7d: Prisma.JsonValue | null
      metrics30d: Prisma.JsonValue | null
      metricsAllTime: Prisma.JsonValue | null
      categoryScores: Prisma.JsonValue
      primaryCategory: string | null
      engagementRate: number
      viralScore: number
      consistencyScore: number
      bestPostingHours: Prisma.JsonValue | null
      postingFrequency: Prisma.JsonValue | null
      lastActiveAt: Date | null
      lastAnalyzedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buzzInfluencer"]>
    composites: {}
  }

  type BuzzInfluencerGetPayload<S extends boolean | null | undefined | BuzzInfluencerDefaultArgs> = $Result.GetResult<Prisma.$BuzzInfluencerPayload, S>

  type BuzzInfluencerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuzzInfluencerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuzzInfluencerCountAggregateInputType | true
    }

  export interface BuzzInfluencerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzInfluencer'], meta: { name: 'BuzzInfluencer' } }
    /**
     * Find zero or one BuzzInfluencer that matches the filter.
     * @param {BuzzInfluencerFindUniqueArgs} args - Arguments to find a BuzzInfluencer
     * @example
     * // Get one BuzzInfluencer
     * const buzzInfluencer = await prisma.buzzInfluencer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzInfluencerFindUniqueArgs>(args: SelectSubset<T, BuzzInfluencerFindUniqueArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuzzInfluencer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuzzInfluencerFindUniqueOrThrowArgs} args - Arguments to find a BuzzInfluencer
     * @example
     * // Get one BuzzInfluencer
     * const buzzInfluencer = await prisma.buzzInfluencer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzInfluencerFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzInfluencerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuzzInfluencer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerFindFirstArgs} args - Arguments to find a BuzzInfluencer
     * @example
     * // Get one BuzzInfluencer
     * const buzzInfluencer = await prisma.buzzInfluencer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzInfluencerFindFirstArgs>(args?: SelectSubset<T, BuzzInfluencerFindFirstArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuzzInfluencer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerFindFirstOrThrowArgs} args - Arguments to find a BuzzInfluencer
     * @example
     * // Get one BuzzInfluencer
     * const buzzInfluencer = await prisma.buzzInfluencer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzInfluencerFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzInfluencerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuzzInfluencers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzInfluencers
     * const buzzInfluencers = await prisma.buzzInfluencer.findMany()
     * 
     * // Get first 10 BuzzInfluencers
     * const buzzInfluencers = await prisma.buzzInfluencer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzInfluencerWithIdOnly = await prisma.buzzInfluencer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzInfluencerFindManyArgs>(args?: SelectSubset<T, BuzzInfluencerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuzzInfluencer.
     * @param {BuzzInfluencerCreateArgs} args - Arguments to create a BuzzInfluencer.
     * @example
     * // Create one BuzzInfluencer
     * const BuzzInfluencer = await prisma.buzzInfluencer.create({
     *   data: {
     *     // ... data to create a BuzzInfluencer
     *   }
     * })
     * 
     */
    create<T extends BuzzInfluencerCreateArgs>(args: SelectSubset<T, BuzzInfluencerCreateArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuzzInfluencers.
     * @param {BuzzInfluencerCreateManyArgs} args - Arguments to create many BuzzInfluencers.
     * @example
     * // Create many BuzzInfluencers
     * const buzzInfluencer = await prisma.buzzInfluencer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzInfluencerCreateManyArgs>(args?: SelectSubset<T, BuzzInfluencerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuzzInfluencers and returns the data saved in the database.
     * @param {BuzzInfluencerCreateManyAndReturnArgs} args - Arguments to create many BuzzInfluencers.
     * @example
     * // Create many BuzzInfluencers
     * const buzzInfluencer = await prisma.buzzInfluencer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuzzInfluencers and only return the `id`
     * const buzzInfluencerWithIdOnly = await prisma.buzzInfluencer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuzzInfluencerCreateManyAndReturnArgs>(args?: SelectSubset<T, BuzzInfluencerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuzzInfluencer.
     * @param {BuzzInfluencerDeleteArgs} args - Arguments to delete one BuzzInfluencer.
     * @example
     * // Delete one BuzzInfluencer
     * const BuzzInfluencer = await prisma.buzzInfluencer.delete({
     *   where: {
     *     // ... filter to delete one BuzzInfluencer
     *   }
     * })
     * 
     */
    delete<T extends BuzzInfluencerDeleteArgs>(args: SelectSubset<T, BuzzInfluencerDeleteArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuzzInfluencer.
     * @param {BuzzInfluencerUpdateArgs} args - Arguments to update one BuzzInfluencer.
     * @example
     * // Update one BuzzInfluencer
     * const buzzInfluencer = await prisma.buzzInfluencer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzInfluencerUpdateArgs>(args: SelectSubset<T, BuzzInfluencerUpdateArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuzzInfluencers.
     * @param {BuzzInfluencerDeleteManyArgs} args - Arguments to filter BuzzInfluencers to delete.
     * @example
     * // Delete a few BuzzInfluencers
     * const { count } = await prisma.buzzInfluencer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzInfluencerDeleteManyArgs>(args?: SelectSubset<T, BuzzInfluencerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzInfluencers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzInfluencers
     * const buzzInfluencer = await prisma.buzzInfluencer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzInfluencerUpdateManyArgs>(args: SelectSubset<T, BuzzInfluencerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuzzInfluencer.
     * @param {BuzzInfluencerUpsertArgs} args - Arguments to update or create a BuzzInfluencer.
     * @example
     * // Update or create a BuzzInfluencer
     * const buzzInfluencer = await prisma.buzzInfluencer.upsert({
     *   create: {
     *     // ... data to create a BuzzInfluencer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzInfluencer we want to update
     *   }
     * })
     */
    upsert<T extends BuzzInfluencerUpsertArgs>(args: SelectSubset<T, BuzzInfluencerUpsertArgs<ExtArgs>>): Prisma__BuzzInfluencerClient<$Result.GetResult<Prisma.$BuzzInfluencerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuzzInfluencers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerCountArgs} args - Arguments to filter BuzzInfluencers to count.
     * @example
     * // Count the number of BuzzInfluencers
     * const count = await prisma.buzzInfluencer.count({
     *   where: {
     *     // ... the filter for the BuzzInfluencers we want to count
     *   }
     * })
    **/
    count<T extends BuzzInfluencerCountArgs>(
      args?: Subset<T, BuzzInfluencerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzInfluencerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzInfluencer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzInfluencerAggregateArgs>(args: Subset<T, BuzzInfluencerAggregateArgs>): Prisma.PrismaPromise<GetBuzzInfluencerAggregateType<T>>

    /**
     * Group by BuzzInfluencer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzInfluencerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzInfluencerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzInfluencerGroupByArgs['orderBy'] }
        : { orderBy?: BuzzInfluencerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzInfluencerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzInfluencerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzInfluencer model
   */
  readonly fields: BuzzInfluencerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzInfluencer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzInfluencerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzInfluencer model
   */ 
  interface BuzzInfluencerFieldRefs {
    readonly id: FieldRef<"BuzzInfluencer", 'String'>
    readonly username: FieldRef<"BuzzInfluencer", 'String'>
    readonly userId: FieldRef<"BuzzInfluencer", 'String'>
    readonly followers: FieldRef<"BuzzInfluencer", 'Int'>
    readonly following: FieldRef<"BuzzInfluencer", 'Int'>
    readonly verified: FieldRef<"BuzzInfluencer", 'Boolean'>
    readonly profileImage: FieldRef<"BuzzInfluencer", 'String'>
    readonly bio: FieldRef<"BuzzInfluencer", 'String'>
    readonly metrics7d: FieldRef<"BuzzInfluencer", 'Json'>
    readonly metrics30d: FieldRef<"BuzzInfluencer", 'Json'>
    readonly metricsAllTime: FieldRef<"BuzzInfluencer", 'Json'>
    readonly categoryScores: FieldRef<"BuzzInfluencer", 'Json'>
    readonly primaryCategory: FieldRef<"BuzzInfluencer", 'String'>
    readonly engagementRate: FieldRef<"BuzzInfluencer", 'Float'>
    readonly viralScore: FieldRef<"BuzzInfluencer", 'Float'>
    readonly consistencyScore: FieldRef<"BuzzInfluencer", 'Float'>
    readonly bestPostingHours: FieldRef<"BuzzInfluencer", 'Json'>
    readonly postingFrequency: FieldRef<"BuzzInfluencer", 'Json'>
    readonly lastActiveAt: FieldRef<"BuzzInfluencer", 'DateTime'>
    readonly lastAnalyzedAt: FieldRef<"BuzzInfluencer", 'DateTime'>
    readonly createdAt: FieldRef<"BuzzInfluencer", 'DateTime'>
    readonly updatedAt: FieldRef<"BuzzInfluencer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuzzInfluencer findUnique
   */
  export type BuzzInfluencerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * Filter, which BuzzInfluencer to fetch.
     */
    where: BuzzInfluencerWhereUniqueInput
  }

  /**
   * BuzzInfluencer findUniqueOrThrow
   */
  export type BuzzInfluencerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * Filter, which BuzzInfluencer to fetch.
     */
    where: BuzzInfluencerWhereUniqueInput
  }

  /**
   * BuzzInfluencer findFirst
   */
  export type BuzzInfluencerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * Filter, which BuzzInfluencer to fetch.
     */
    where?: BuzzInfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzInfluencers to fetch.
     */
    orderBy?: BuzzInfluencerOrderByWithRelationInput | BuzzInfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzInfluencers.
     */
    cursor?: BuzzInfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzInfluencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzInfluencers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzInfluencers.
     */
    distinct?: BuzzInfluencerScalarFieldEnum | BuzzInfluencerScalarFieldEnum[]
  }

  /**
   * BuzzInfluencer findFirstOrThrow
   */
  export type BuzzInfluencerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * Filter, which BuzzInfluencer to fetch.
     */
    where?: BuzzInfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzInfluencers to fetch.
     */
    orderBy?: BuzzInfluencerOrderByWithRelationInput | BuzzInfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzInfluencers.
     */
    cursor?: BuzzInfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzInfluencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzInfluencers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzInfluencers.
     */
    distinct?: BuzzInfluencerScalarFieldEnum | BuzzInfluencerScalarFieldEnum[]
  }

  /**
   * BuzzInfluencer findMany
   */
  export type BuzzInfluencerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * Filter, which BuzzInfluencers to fetch.
     */
    where?: BuzzInfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzInfluencers to fetch.
     */
    orderBy?: BuzzInfluencerOrderByWithRelationInput | BuzzInfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzInfluencers.
     */
    cursor?: BuzzInfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzInfluencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzInfluencers.
     */
    skip?: number
    distinct?: BuzzInfluencerScalarFieldEnum | BuzzInfluencerScalarFieldEnum[]
  }

  /**
   * BuzzInfluencer create
   */
  export type BuzzInfluencerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * The data needed to create a BuzzInfluencer.
     */
    data: XOR<BuzzInfluencerCreateInput, BuzzInfluencerUncheckedCreateInput>
  }

  /**
   * BuzzInfluencer createMany
   */
  export type BuzzInfluencerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzInfluencers.
     */
    data: BuzzInfluencerCreateManyInput | BuzzInfluencerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzInfluencer createManyAndReturn
   */
  export type BuzzInfluencerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuzzInfluencers.
     */
    data: BuzzInfluencerCreateManyInput | BuzzInfluencerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzInfluencer update
   */
  export type BuzzInfluencerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * The data needed to update a BuzzInfluencer.
     */
    data: XOR<BuzzInfluencerUpdateInput, BuzzInfluencerUncheckedUpdateInput>
    /**
     * Choose, which BuzzInfluencer to update.
     */
    where: BuzzInfluencerWhereUniqueInput
  }

  /**
   * BuzzInfluencer updateMany
   */
  export type BuzzInfluencerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzInfluencers.
     */
    data: XOR<BuzzInfluencerUpdateManyMutationInput, BuzzInfluencerUncheckedUpdateManyInput>
    /**
     * Filter which BuzzInfluencers to update
     */
    where?: BuzzInfluencerWhereInput
  }

  /**
   * BuzzInfluencer upsert
   */
  export type BuzzInfluencerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * The filter to search for the BuzzInfluencer to update in case it exists.
     */
    where: BuzzInfluencerWhereUniqueInput
    /**
     * In case the BuzzInfluencer found by the `where` argument doesn't exist, create a new BuzzInfluencer with this data.
     */
    create: XOR<BuzzInfluencerCreateInput, BuzzInfluencerUncheckedCreateInput>
    /**
     * In case the BuzzInfluencer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzInfluencerUpdateInput, BuzzInfluencerUncheckedUpdateInput>
  }

  /**
   * BuzzInfluencer delete
   */
  export type BuzzInfluencerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
    /**
     * Filter which BuzzInfluencer to delete.
     */
    where: BuzzInfluencerWhereUniqueInput
  }

  /**
   * BuzzInfluencer deleteMany
   */
  export type BuzzInfluencerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzInfluencers to delete
     */
    where?: BuzzInfluencerWhereInput
  }

  /**
   * BuzzInfluencer without action
   */
  export type BuzzInfluencerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzInfluencer
     */
    select?: BuzzInfluencerSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BuzzPostScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    content: 'content',
    authorUsername: 'authorUsername',
    authorId: 'authorId',
    likesCount: 'likesCount',
    retweetsCount: 'retweetsCount',
    repliesCount: 'repliesCount',
    impressionsCount: 'impressionsCount',
    postedAt: 'postedAt',
    collectedAt: 'collectedAt',
    url: 'url',
    theme: 'theme',
    language: 'language',
    mediaUrls: 'mediaUrls',
    hashtags: 'hashtags',
    chromaId: 'chromaId',
    authorFollowers: 'authorFollowers',
    authorFollowing: 'authorFollowing',
    authorVerified: 'authorVerified'
  };

  export type BuzzPostScalarFieldEnum = (typeof BuzzPostScalarFieldEnum)[keyof typeof BuzzPostScalarFieldEnum]


  export const BuzzConfigScalarFieldEnum: {
    id: 'id',
    keywords: 'keywords',
    accounts: 'accounts',
    minEngagement: 'minEngagement',
    minImpressions: 'minImpressions',
    collectInterval: 'collectInterval',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuzzConfigScalarFieldEnum = (typeof BuzzConfigScalarFieldEnum)[keyof typeof BuzzConfigScalarFieldEnum]


  export const ScheduledPostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    scheduledTime: 'scheduledTime',
    status: 'status',
    postType: 'postType',
    refPostId: 'refPostId',
    templateType: 'templateType',
    aiGenerated: 'aiGenerated',
    aiPrompt: 'aiPrompt',
    editedContent: 'editedContent',
    postedAt: 'postedAt',
    postResult: 'postResult',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledPostScalarFieldEnum = (typeof ScheduledPostScalarFieldEnum)[keyof typeof ScheduledPostScalarFieldEnum]


  export const PostAnalyticsScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    impressions: 'impressions',
    engagements: 'engagements',
    likes: 'likes',
    retweets: 'retweets',
    replies: 'replies',
    profileClicks: 'profileClicks',
    urlClicks: 'urlClicks',
    detailExpands: 'detailExpands',
    engagementRate: 'engagementRate',
    collectedAt: 'collectedAt'
  };

  export type PostAnalyticsScalarFieldEnum = (typeof PostAnalyticsScalarFieldEnum)[keyof typeof PostAnalyticsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    twitterId: 'twitterId',
    username: 'username',
    name: 'name',
    email: 'email',
    image: 'image',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenSecret: 'tokenSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NewsSourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    rssUrl: 'rssUrl',
    category: 'category',
    language: 'language',
    isActive: 'isActive',
    lastFetched: 'lastFetched',
    createdAt: 'createdAt'
  };

  export type NewsSourceScalarFieldEnum = (typeof NewsSourceScalarFieldEnum)[keyof typeof NewsSourceScalarFieldEnum]


  export const NewsArticleScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    title: 'title',
    description: 'description',
    url: 'url',
    publishedAt: 'publishedAt',
    category: 'category',
    tags: 'tags',
    importance: 'importance',
    processed: 'processed',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type NewsArticleScalarFieldEnum = (typeof NewsArticleScalarFieldEnum)[keyof typeof NewsArticleScalarFieldEnum]


  export const NewsThreadScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    metadata: 'metadata',
    scheduledAt: 'scheduledAt',
    title: 'title',
    postedAt: 'postedAt'
  };

  export type NewsThreadScalarFieldEnum = (typeof NewsThreadScalarFieldEnum)[keyof typeof NewsThreadScalarFieldEnum]


  export const NewsThreadItemScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    articleId: 'articleId',
    order: 'order',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type NewsThreadItemScalarFieldEnum = (typeof NewsThreadItemScalarFieldEnum)[keyof typeof NewsThreadItemScalarFieldEnum]


  export const NewsAnalysisScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    summary: 'summary',
    sentiment: 'sentiment',
    keywords: 'keywords',
    topics: 'topics',
    createdAt: 'createdAt'
  };

  export type NewsAnalysisScalarFieldEnum = (typeof NewsAnalysisScalarFieldEnum)[keyof typeof NewsAnalysisScalarFieldEnum]


  export const JobQueueScalarFieldEnum: {
    id: 'id',
    type: 'type',
    payload: 'payload',
    status: 'status',
    priority: 'priority',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    runAt: 'runAt',
    completedAt: 'completedAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobQueueScalarFieldEnum = (typeof JobQueueScalarFieldEnum)[keyof typeof JobQueueScalarFieldEnum]


  export const CollectionPresetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    settings: 'settings',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionPresetScalarFieldEnum = (typeof CollectionPresetScalarFieldEnum)[keyof typeof CollectionPresetScalarFieldEnum]


  export const WatchlistUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    twitterId: 'twitterId',
    username: 'username',
    displayName: 'displayName',
    followers: 'followers',
    following: 'following',
    isActive: 'isActive',
    lastChecked: 'lastChecked',
    createdAt: 'createdAt'
  };

  export type WatchlistUserScalarFieldEnum = (typeof WatchlistUserScalarFieldEnum)[keyof typeof WatchlistUserScalarFieldEnum]


  export const WatchlistTweetScalarFieldEnum: {
    id: 'id',
    watchlistUserId: 'watchlistUserId',
    tweetId: 'tweetId',
    content: 'content',
    createdAt: 'createdAt',
    retweetCount: 'retweetCount',
    likeCount: 'likeCount',
    replyCount: 'replyCount',
    collectedAt: 'collectedAt'
  };

  export type WatchlistTweetScalarFieldEnum = (typeof WatchlistTweetScalarFieldEnum)[keyof typeof WatchlistTweetScalarFieldEnum]


  export const InteractionHistoryScalarFieldEnum: {
    id: 'id',
    watchlistUserId: 'watchlistUserId',
    interactionType: 'interactionType',
    tweetId: 'tweetId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type InteractionHistoryScalarFieldEnum = (typeof InteractionHistoryScalarFieldEnum)[keyof typeof InteractionHistoryScalarFieldEnum]


  export const PerplexityReportScalarFieldEnum: {
    id: 'id',
    query: 'query',
    focus: 'focus',
    rawAnalysis: 'rawAnalysis',
    trends: 'trends',
    insights: 'insights',
    contentAngles: 'contentAngles',
    marketContext: 'marketContext',
    competitorActivity: 'competitorActivity',
    riskFactors: 'riskFactors',
    createdAt: 'createdAt'
  };

  export type PerplexityReportScalarFieldEnum = (typeof PerplexityReportScalarFieldEnum)[keyof typeof PerplexityReportScalarFieldEnum]


  export const CotSessionScalarFieldEnum: {
    id: 'id',
    theme: 'theme',
    style: 'style',
    platform: 'platform',
    status: 'status',
    currentPhase: 'currentPhase',
    currentStep: 'currentStep',
    lastError: 'lastError',
    retryCount: 'retryCount',
    nextRetryAt: 'nextRetryAt',
    totalTokens: 'totalTokens',
    totalDuration: 'totalDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type CotSessionScalarFieldEnum = (typeof CotSessionScalarFieldEnum)[keyof typeof CotSessionScalarFieldEnum]


  export const CotPhaseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    phaseNumber: 'phaseNumber',
    thinkPrompt: 'thinkPrompt',
    thinkResult: 'thinkResult',
    thinkTokens: 'thinkTokens',
    thinkAt: 'thinkAt',
    executeResult: 'executeResult',
    executeDuration: 'executeDuration',
    executeAt: 'executeAt',
    integratePrompt: 'integratePrompt',
    integrateResult: 'integrateResult',
    integrateTokens: 'integrateTokens',
    integrateAt: 'integrateAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CotPhaseScalarFieldEnum = (typeof CotPhaseScalarFieldEnum)[keyof typeof CotPhaseScalarFieldEnum]


  export const CotDraftScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    conceptNumber: 'conceptNumber',
    title: 'title',
    hook: 'hook',
    angle: 'angle',
    format: 'format',
    content: 'content',
    visualGuide: 'visualGuide',
    timing: 'timing',
    hashtags: 'hashtags',
    newsSource: 'newsSource',
    sourceUrl: 'sourceUrl',
    kpis: 'kpis',
    riskAssessment: 'riskAssessment',
    optimizationTips: 'optimizationTips',
    status: 'status',
    editedContent: 'editedContent',
    scheduledAt: 'scheduledAt',
    postedAt: 'postedAt',
    postId: 'postId',
    viralScore: 'viralScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CotDraftScalarFieldEnum = (typeof CotDraftScalarFieldEnum)[keyof typeof CotDraftScalarFieldEnum]


  export const CotDraftPerformanceScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    likes30m: 'likes30m',
    retweets30m: 'retweets30m',
    replies30m: 'replies30m',
    impressions30m: 'impressions30m',
    likes1h: 'likes1h',
    retweets1h: 'retweets1h',
    replies1h: 'replies1h',
    impressions1h: 'impressions1h',
    likes24h: 'likes24h',
    retweets24h: 'retweets24h',
    replies24h: 'replies24h',
    impressions24h: 'impressions24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    lastUpdateAt: 'lastUpdateAt'
  };

  export type CotDraftPerformanceScalarFieldEnum = (typeof CotDraftPerformanceScalarFieldEnum)[keyof typeof CotDraftPerformanceScalarFieldEnum]


  export const UnifiedContentSourceScalarFieldEnum: {
    id: 'id',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    contentSummary: 'contentSummary',
    importanceScore: 'importanceScore',
    viralPotential: 'viralPotential',
    keywords: 'keywords',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnifiedContentSourceScalarFieldEnum = (typeof UnifiedContentSourceScalarFieldEnum)[keyof typeof UnifiedContentSourceScalarFieldEnum]


  export const IntegratedSessionScalarFieldEnum: {
    id: 'id',
    sessionType: 'sessionType',
    v2SessionId: 'v2SessionId',
    newsArticleIds: 'newsArticleIds',
    buzzPostIds: 'buzzPostIds',
    generationContext: 'generationContext',
    performanceMetrics: 'performanceMetrics',
    status: 'status',
    currentStep: 'currentStep',
    theme: 'theme',
    character: 'character',
    platform: 'platform',
    strategy: 'strategy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type IntegratedSessionScalarFieldEnum = (typeof IntegratedSessionScalarFieldEnum)[keyof typeof IntegratedSessionScalarFieldEnum]


  export const IntegratedSessionSourceScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    sourceId: 'sourceId',
    relevanceScore: 'relevanceScore',
    usageType: 'usageType'
  };

  export type IntegratedSessionSourceScalarFieldEnum = (typeof IntegratedSessionSourceScalarFieldEnum)[keyof typeof IntegratedSessionSourceScalarFieldEnum]


  export const IntegratedDraftScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    title: 'title',
    content: 'content',
    contentType: 'contentType',
    sourcesSummary: 'sourcesSummary',
    newsContext: 'newsContext',
    buzzContext: 'buzzContext',
    conceptId: 'conceptId',
    hook: 'hook',
    angle: 'angle',
    sourceNewsIds: 'sourceNewsIds',
    sourceBuzzIds: 'sourceBuzzIds',
    generationStrategy: 'generationStrategy',
    generationData: 'generationData',
    hashtags: 'hashtags',
    visualGuide: 'visualGuide',
    status: 'status',
    scheduledAt: 'scheduledAt',
    postedAt: 'postedAt',
    postId: 'postId',
    viralScore: 'viralScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegratedDraftScalarFieldEnum = (typeof IntegratedDraftScalarFieldEnum)[keyof typeof IntegratedDraftScalarFieldEnum]


  export const IntegratedDraftPerformanceScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    likes30m: 'likes30m',
    retweets30m: 'retweets30m',
    replies30m: 'replies30m',
    impressions30m: 'impressions30m',
    likes1h: 'likes1h',
    retweets1h: 'retweets1h',
    replies1h: 'replies1h',
    impressions1h: 'impressions1h',
    likes24h: 'likes24h',
    retweets24h: 'retweets24h',
    replies24h: 'replies24h',
    impressions24h: 'impressions24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    predictionAccuracy: 'predictionAccuracy',
    collectedAt: 'collectedAt',
    updatedAt: 'updatedAt'
  };

  export type IntegratedDraftPerformanceScalarFieldEnum = (typeof IntegratedDraftPerformanceScalarFieldEnum)[keyof typeof IntegratedDraftPerformanceScalarFieldEnum]


  export const ScheduledRetweetScalarFieldEnum: {
    id: 'id',
    originalPostId: 'originalPostId',
    originalContent: 'originalContent',
    scheduledAt: 'scheduledAt',
    status: 'status',
    rtStrategy: 'rtStrategy',
    addComment: 'addComment',
    commentText: 'commentText',
    viralDraftId: 'viralDraftId',
    cotDraftId: 'cotDraftId',
    executedAt: 'executedAt',
    rtPostId: 'rtPostId',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledRetweetScalarFieldEnum = (typeof ScheduledRetweetScalarFieldEnum)[keyof typeof ScheduledRetweetScalarFieldEnum]


  export const UnifiedPerformanceScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    contentType: 'contentType',
    metrics30m: 'metrics30m',
    metrics1h: 'metrics1h',
    metrics24h: 'metrics24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    updatedAt: 'updatedAt'
  };

  export type UnifiedPerformanceScalarFieldEnum = (typeof UnifiedPerformanceScalarFieldEnum)[keyof typeof UnifiedPerformanceScalarFieldEnum]


  export const NewsViralRelationScalarFieldEnum: {
    id: 'id',
    newsId: 'newsId',
    sessionId: 'sessionId',
    relevanceScore: 'relevanceScore',
    usedInContent: 'usedInContent',
    createdAt: 'createdAt'
  };

  export type NewsViralRelationScalarFieldEnum = (typeof NewsViralRelationScalarFieldEnum)[keyof typeof NewsViralRelationScalarFieldEnum]


  export const SessionActivityLogScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    sessionType: 'sessionType',
    activityType: 'activityType',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type SessionActivityLogScalarFieldEnum = (typeof SessionActivityLogScalarFieldEnum)[keyof typeof SessionActivityLogScalarFieldEnum]


  export const ApiErrorLogScalarFieldEnum: {
    id: 'id',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    errorMessage: 'errorMessage',
    stackTrace: 'stackTrace',
    requestBody: 'requestBody',
    requestHeaders: 'requestHeaders',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type ApiErrorLogScalarFieldEnum = (typeof ApiErrorLogScalarFieldEnum)[keyof typeof ApiErrorLogScalarFieldEnum]


  export const ViralSessionScalarFieldEnum: {
    id: 'id',
    theme: 'theme',
    platform: 'platform',
    style: 'style',
    status: 'status',
    createdAt: 'createdAt',
    characterProfileId: 'characterProfileId',
    voiceStyleMode: 'voiceStyleMode',
    topics: 'topics',
    concepts: 'concepts',
    selectedIds: 'selectedIds',
    contents: 'contents'
  };

  export type ViralSessionScalarFieldEnum = (typeof ViralSessionScalarFieldEnum)[keyof typeof ViralSessionScalarFieldEnum]


  export const ViralDraftV2ScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    conceptId: 'conceptId',
    title: 'title',
    content: 'content',
    hashtags: 'hashtags',
    visualNote: 'visualNote',
    sourceUrl: 'sourceUrl',
    characterId: 'characterId',
    characterNote: 'characterNote',
    status: 'status',
    scheduledAt: 'scheduledAt',
    postedAt: 'postedAt',
    tweetId: 'tweetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ViralDraftV2ScalarFieldEnum = (typeof ViralDraftV2ScalarFieldEnum)[keyof typeof ViralDraftV2ScalarFieldEnum]


  export const ViralDraftPerformanceScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    likes30m: 'likes30m',
    retweets30m: 'retweets30m',
    replies30m: 'replies30m',
    impressions30m: 'impressions30m',
    likes1h: 'likes1h',
    retweets1h: 'retweets1h',
    replies1h: 'replies1h',
    impressions1h: 'impressions1h',
    likes24h: 'likes24h',
    retweets24h: 'retweets24h',
    replies24h: 'replies24h',
    impressions24h: 'impressions24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    updatedAt: 'updatedAt'
  };

  export type ViralDraftPerformanceScalarFieldEnum = (typeof ViralDraftPerformanceScalarFieldEnum)[keyof typeof ViralDraftPerformanceScalarFieldEnum]


  export const CharacterProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    age: 'age',
    gender: 'gender',
    tone: 'tone',
    catchphrase: 'catchphrase',
    philosophy: 'philosophy',
    voiceStyle: 'voiceStyle',
    topics: 'topics',
    visual: 'visual',
    isDefault: 'isDefault',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    preferredNewsCategories: 'preferredNewsCategories',
    newsCommentStyle: 'newsCommentStyle',
    topicExpertise: 'topicExpertise'
  };

  export type CharacterProfileScalarFieldEnum = (typeof CharacterProfileScalarFieldEnum)[keyof typeof CharacterProfileScalarFieldEnum]


  export const BuzzInfluencerScalarFieldEnum: {
    id: 'id',
    username: 'username',
    userId: 'userId',
    followers: 'followers',
    following: 'following',
    verified: 'verified',
    profileImage: 'profileImage',
    bio: 'bio',
    metrics7d: 'metrics7d',
    metrics30d: 'metrics30d',
    metricsAllTime: 'metricsAllTime',
    categoryScores: 'categoryScores',
    primaryCategory: 'primaryCategory',
    engagementRate: 'engagementRate',
    viralScore: 'viralScore',
    consistencyScore: 'consistencyScore',
    bestPostingHours: 'bestPostingHours',
    postingFrequency: 'postingFrequency',
    lastActiveAt: 'lastActiveAt',
    lastAnalyzedAt: 'lastAnalyzedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuzzInfluencerScalarFieldEnum = (typeof BuzzInfluencerScalarFieldEnum)[keyof typeof BuzzInfluencerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CotSessionStatus'
   */
  export type EnumCotSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotSessionStatus'>
    


  /**
   * Reference to a field of type 'CotSessionStatus[]'
   */
  export type ListEnumCotSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotSessionStatus[]'>
    


  /**
   * Reference to a field of type 'CotPhaseStep'
   */
  export type EnumCotPhaseStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStep'>
    


  /**
   * Reference to a field of type 'CotPhaseStep[]'
   */
  export type ListEnumCotPhaseStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStep[]'>
    


  /**
   * Reference to a field of type 'CotPhaseStatus'
   */
  export type EnumCotPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStatus'>
    


  /**
   * Reference to a field of type 'CotPhaseStatus[]'
   */
  export type ListEnumCotPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStatus[]'>
    


  /**
   * Reference to a field of type 'CotDraftStatus'
   */
  export type EnumCotDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotDraftStatus'>
    


  /**
   * Reference to a field of type 'CotDraftStatus[]'
   */
  export type ListEnumCotDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotDraftStatus[]'>
    


  /**
   * Reference to a field of type 'RTStatus'
   */
  export type EnumRTStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RTStatus'>
    


  /**
   * Reference to a field of type 'RTStatus[]'
   */
  export type ListEnumRTStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RTStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BuzzPostWhereInput = {
    AND?: BuzzPostWhereInput | BuzzPostWhereInput[]
    OR?: BuzzPostWhereInput[]
    NOT?: BuzzPostWhereInput | BuzzPostWhereInput[]
    id?: StringFilter<"BuzzPost"> | string
    postId?: StringFilter<"BuzzPost"> | string
    content?: StringFilter<"BuzzPost"> | string
    authorUsername?: StringFilter<"BuzzPost"> | string
    authorId?: StringFilter<"BuzzPost"> | string
    likesCount?: IntFilter<"BuzzPost"> | number
    retweetsCount?: IntFilter<"BuzzPost"> | number
    repliesCount?: IntFilter<"BuzzPost"> | number
    impressionsCount?: IntFilter<"BuzzPost"> | number
    postedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    url?: StringFilter<"BuzzPost"> | string
    theme?: StringFilter<"BuzzPost"> | string
    language?: StringFilter<"BuzzPost"> | string
    mediaUrls?: JsonFilter<"BuzzPost">
    hashtags?: JsonFilter<"BuzzPost">
    chromaId?: StringNullableFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableFilter<"BuzzPost"> | boolean | null
    scheduledPosts?: ScheduledPostListRelationFilter
  }

  export type BuzzPostOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrderInput | SortOrder
    authorFollowers?: SortOrderInput | SortOrder
    authorFollowing?: SortOrderInput | SortOrder
    authorVerified?: SortOrderInput | SortOrder
    scheduledPosts?: ScheduledPostOrderByRelationAggregateInput
  }

  export type BuzzPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId?: string
    AND?: BuzzPostWhereInput | BuzzPostWhereInput[]
    OR?: BuzzPostWhereInput[]
    NOT?: BuzzPostWhereInput | BuzzPostWhereInput[]
    content?: StringFilter<"BuzzPost"> | string
    authorUsername?: StringFilter<"BuzzPost"> | string
    authorId?: StringFilter<"BuzzPost"> | string
    likesCount?: IntFilter<"BuzzPost"> | number
    retweetsCount?: IntFilter<"BuzzPost"> | number
    repliesCount?: IntFilter<"BuzzPost"> | number
    impressionsCount?: IntFilter<"BuzzPost"> | number
    postedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    url?: StringFilter<"BuzzPost"> | string
    theme?: StringFilter<"BuzzPost"> | string
    language?: StringFilter<"BuzzPost"> | string
    mediaUrls?: JsonFilter<"BuzzPost">
    hashtags?: JsonFilter<"BuzzPost">
    chromaId?: StringNullableFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableFilter<"BuzzPost"> | boolean | null
    scheduledPosts?: ScheduledPostListRelationFilter
  }, "id" | "postId">

  export type BuzzPostOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrderInput | SortOrder
    authorFollowers?: SortOrderInput | SortOrder
    authorFollowing?: SortOrderInput | SortOrder
    authorVerified?: SortOrderInput | SortOrder
    _count?: BuzzPostCountOrderByAggregateInput
    _avg?: BuzzPostAvgOrderByAggregateInput
    _max?: BuzzPostMaxOrderByAggregateInput
    _min?: BuzzPostMinOrderByAggregateInput
    _sum?: BuzzPostSumOrderByAggregateInput
  }

  export type BuzzPostScalarWhereWithAggregatesInput = {
    AND?: BuzzPostScalarWhereWithAggregatesInput | BuzzPostScalarWhereWithAggregatesInput[]
    OR?: BuzzPostScalarWhereWithAggregatesInput[]
    NOT?: BuzzPostScalarWhereWithAggregatesInput | BuzzPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuzzPost"> | string
    postId?: StringWithAggregatesFilter<"BuzzPost"> | string
    content?: StringWithAggregatesFilter<"BuzzPost"> | string
    authorUsername?: StringWithAggregatesFilter<"BuzzPost"> | string
    authorId?: StringWithAggregatesFilter<"BuzzPost"> | string
    likesCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    retweetsCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    repliesCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    impressionsCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    postedAt?: DateTimeWithAggregatesFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeWithAggregatesFilter<"BuzzPost"> | Date | string
    url?: StringWithAggregatesFilter<"BuzzPost"> | string
    theme?: StringWithAggregatesFilter<"BuzzPost"> | string
    language?: StringWithAggregatesFilter<"BuzzPost"> | string
    mediaUrls?: JsonWithAggregatesFilter<"BuzzPost">
    hashtags?: JsonWithAggregatesFilter<"BuzzPost">
    chromaId?: StringNullableWithAggregatesFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableWithAggregatesFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableWithAggregatesFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableWithAggregatesFilter<"BuzzPost"> | boolean | null
  }

  export type BuzzConfigWhereInput = {
    AND?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    OR?: BuzzConfigWhereInput[]
    NOT?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    id?: StringFilter<"BuzzConfig"> | string
    keywords?: StringNullableListFilter<"BuzzConfig">
    accounts?: StringNullableListFilter<"BuzzConfig">
    minEngagement?: IntFilter<"BuzzConfig"> | number
    minImpressions?: IntFilter<"BuzzConfig"> | number
    collectInterval?: IntFilter<"BuzzConfig"> | number
    enabled?: BoolFilter<"BuzzConfig"> | boolean
    createdAt?: DateTimeFilter<"BuzzConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BuzzConfig"> | Date | string
  }

  export type BuzzConfigOrderByWithRelationInput = {
    id?: SortOrder
    keywords?: SortOrder
    accounts?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    OR?: BuzzConfigWhereInput[]
    NOT?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    keywords?: StringNullableListFilter<"BuzzConfig">
    accounts?: StringNullableListFilter<"BuzzConfig">
    minEngagement?: IntFilter<"BuzzConfig"> | number
    minImpressions?: IntFilter<"BuzzConfig"> | number
    collectInterval?: IntFilter<"BuzzConfig"> | number
    enabled?: BoolFilter<"BuzzConfig"> | boolean
    createdAt?: DateTimeFilter<"BuzzConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BuzzConfig"> | Date | string
  }, "id">

  export type BuzzConfigOrderByWithAggregationInput = {
    id?: SortOrder
    keywords?: SortOrder
    accounts?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuzzConfigCountOrderByAggregateInput
    _avg?: BuzzConfigAvgOrderByAggregateInput
    _max?: BuzzConfigMaxOrderByAggregateInput
    _min?: BuzzConfigMinOrderByAggregateInput
    _sum?: BuzzConfigSumOrderByAggregateInput
  }

  export type BuzzConfigScalarWhereWithAggregatesInput = {
    AND?: BuzzConfigScalarWhereWithAggregatesInput | BuzzConfigScalarWhereWithAggregatesInput[]
    OR?: BuzzConfigScalarWhereWithAggregatesInput[]
    NOT?: BuzzConfigScalarWhereWithAggregatesInput | BuzzConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuzzConfig"> | string
    keywords?: StringNullableListFilter<"BuzzConfig">
    accounts?: StringNullableListFilter<"BuzzConfig">
    minEngagement?: IntWithAggregatesFilter<"BuzzConfig"> | number
    minImpressions?: IntWithAggregatesFilter<"BuzzConfig"> | number
    collectInterval?: IntWithAggregatesFilter<"BuzzConfig"> | number
    enabled?: BoolWithAggregatesFilter<"BuzzConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BuzzConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuzzConfig"> | Date | string
  }

  export type ScheduledPostWhereInput = {
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    refPost?: XOR<BuzzPostNullableRelationFilter, BuzzPostWhereInput> | null
  }

  export type ScheduledPostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrderInput | SortOrder
    templateType?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refPost?: BuzzPostOrderByWithRelationInput
  }

  export type ScheduledPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    refPost?: XOR<BuzzPostNullableRelationFilter, BuzzPostWhereInput> | null
  }, "id">

  export type ScheduledPostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrderInput | SortOrder
    templateType?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledPostCountOrderByAggregateInput
    _max?: ScheduledPostMaxOrderByAggregateInput
    _min?: ScheduledPostMinOrderByAggregateInput
  }

  export type ScheduledPostScalarWhereWithAggregatesInput = {
    AND?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    OR?: ScheduledPostScalarWhereWithAggregatesInput[]
    NOT?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledPost"> | string
    content?: StringWithAggregatesFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusWithAggregatesFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeWithAggregatesFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolWithAggregatesFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableWithAggregatesFilter<"ScheduledPost">
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
  }

  export type PostAnalyticsWhereInput = {
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    id?: StringFilter<"PostAnalytics"> | string
    postId?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    engagements?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    urlClicks?: IntFilter<"PostAnalytics"> | number
    detailExpands?: IntFilter<"PostAnalytics"> | number
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    collectedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
  }

  export type PostAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    postId?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    engagements?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    urlClicks?: IntFilter<"PostAnalytics"> | number
    detailExpands?: IntFilter<"PostAnalytics"> | number
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    collectedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
  }, "id">

  export type PostAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
    _count?: PostAnalyticsCountOrderByAggregateInput
    _avg?: PostAnalyticsAvgOrderByAggregateInput
    _max?: PostAnalyticsMaxOrderByAggregateInput
    _min?: PostAnalyticsMinOrderByAggregateInput
    _sum?: PostAnalyticsSumOrderByAggregateInput
  }

  export type PostAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PostAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostAnalytics"> | string
    postId?: StringWithAggregatesFilter<"PostAnalytics"> | string
    impressions?: IntWithAggregatesFilter<"PostAnalytics"> | number
    engagements?: IntWithAggregatesFilter<"PostAnalytics"> | number
    likes?: IntWithAggregatesFilter<"PostAnalytics"> | number
    retweets?: IntWithAggregatesFilter<"PostAnalytics"> | number
    replies?: IntWithAggregatesFilter<"PostAnalytics"> | number
    profileClicks?: IntWithAggregatesFilter<"PostAnalytics"> | number
    urlClicks?: IntWithAggregatesFilter<"PostAnalytics"> | number
    detailExpands?: IntWithAggregatesFilter<"PostAnalytics"> | number
    engagementRate?: FloatWithAggregatesFilter<"PostAnalytics"> | number
    collectedAt?: DateTimeWithAggregatesFilter<"PostAnalytics"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    twitterId?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    accessToken?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    tokenSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    watchlistUsers?: WatchlistUserListRelationFilter
    characterProfiles?: CharacterProfileListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    watchlistUsers?: WatchlistUserOrderByRelationAggregateInput
    characterProfiles?: CharacterProfileOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    twitterId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    accessToken?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    tokenSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    watchlistUsers?: WatchlistUserListRelationFilter
    characterProfiles?: CharacterProfileListRelationFilter
  }, "id" | "twitterId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    twitterId?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    accessToken?: StringWithAggregatesFilter<"User"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    tokenSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NewsSourceWhereInput = {
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    id?: StringFilter<"NewsSource"> | string
    name?: StringFilter<"NewsSource"> | string
    url?: StringFilter<"NewsSource"> | string
    rssUrl?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    language?: StringFilter<"NewsSource"> | string
    isActive?: BoolFilter<"NewsSource"> | boolean
    lastFetched?: DateTimeNullableFilter<"NewsSource"> | Date | string | null
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    articles?: NewsArticleListRelationFilter
  }

  export type NewsSourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    articles?: NewsArticleOrderByRelationAggregateInput
  }

  export type NewsSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    name?: StringFilter<"NewsSource"> | string
    url?: StringFilter<"NewsSource"> | string
    rssUrl?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    language?: StringFilter<"NewsSource"> | string
    isActive?: BoolFilter<"NewsSource"> | boolean
    lastFetched?: DateTimeNullableFilter<"NewsSource"> | Date | string | null
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    articles?: NewsArticleListRelationFilter
  }, "id">

  export type NewsSourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NewsSourceCountOrderByAggregateInput
    _max?: NewsSourceMaxOrderByAggregateInput
    _min?: NewsSourceMinOrderByAggregateInput
  }

  export type NewsSourceScalarWhereWithAggregatesInput = {
    AND?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    OR?: NewsSourceScalarWhereWithAggregatesInput[]
    NOT?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsSource"> | string
    name?: StringWithAggregatesFilter<"NewsSource"> | string
    url?: StringWithAggregatesFilter<"NewsSource"> | string
    rssUrl?: StringWithAggregatesFilter<"NewsSource"> | string
    category?: StringWithAggregatesFilter<"NewsSource"> | string
    language?: StringWithAggregatesFilter<"NewsSource"> | string
    isActive?: BoolWithAggregatesFilter<"NewsSource"> | boolean
    lastFetched?: DateTimeNullableWithAggregatesFilter<"NewsSource"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NewsSource"> | Date | string
  }

  export type NewsArticleWhereInput = {
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    description?: StringNullableFilter<"NewsArticle"> | string | null
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
    analysis?: XOR<NewsAnalysisNullableRelationFilter, NewsAnalysisWhereInput> | null
    source?: XOR<NewsSourceRelationFilter, NewsSourceWhereInput>
    newsThreadItems?: NewsThreadItemListRelationFilter
    viralRelations?: NewsViralRelationListRelationFilter
  }

  export type NewsArticleOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    importance?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    analysis?: NewsAnalysisOrderByWithRelationInput
    source?: NewsSourceOrderByWithRelationInput
    newsThreadItems?: NewsThreadItemOrderByRelationAggregateInput
    viralRelations?: NewsViralRelationOrderByRelationAggregateInput
  }

  export type NewsArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    description?: StringNullableFilter<"NewsArticle"> | string | null
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
    analysis?: XOR<NewsAnalysisNullableRelationFilter, NewsAnalysisWhereInput> | null
    source?: XOR<NewsSourceRelationFilter, NewsSourceWhereInput>
    newsThreadItems?: NewsThreadItemListRelationFilter
    viralRelations?: NewsViralRelationListRelationFilter
  }, "id" | "url">

  export type NewsArticleOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    importance?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NewsArticleCountOrderByAggregateInput
    _avg?: NewsArticleAvgOrderByAggregateInput
    _max?: NewsArticleMaxOrderByAggregateInput
    _min?: NewsArticleMinOrderByAggregateInput
    _sum?: NewsArticleSumOrderByAggregateInput
  }

  export type NewsArticleScalarWhereWithAggregatesInput = {
    AND?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    OR?: NewsArticleScalarWhereWithAggregatesInput[]
    NOT?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsArticle"> | string
    sourceId?: StringWithAggregatesFilter<"NewsArticle"> | string
    title?: StringWithAggregatesFilter<"NewsArticle"> | string
    description?: StringNullableWithAggregatesFilter<"NewsArticle"> | string | null
    url?: StringWithAggregatesFilter<"NewsArticle"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    category?: StringNullableWithAggregatesFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableWithAggregatesFilter<"NewsArticle"> | number | null
    processed?: BoolWithAggregatesFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsArticle">
  }

  export type NewsThreadWhereInput = {
    AND?: NewsThreadWhereInput | NewsThreadWhereInput[]
    OR?: NewsThreadWhereInput[]
    NOT?: NewsThreadWhereInput | NewsThreadWhereInput[]
    id?: StringFilter<"NewsThread"> | string
    status?: StringFilter<"NewsThread"> | string
    createdAt?: DateTimeFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableFilter<"NewsThread">
    scheduledAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    title?: StringFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    items?: NewsThreadItemListRelationFilter
  }

  export type NewsThreadOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    title?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    items?: NewsThreadItemOrderByRelationAggregateInput
  }

  export type NewsThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsThreadWhereInput | NewsThreadWhereInput[]
    OR?: NewsThreadWhereInput[]
    NOT?: NewsThreadWhereInput | NewsThreadWhereInput[]
    status?: StringFilter<"NewsThread"> | string
    createdAt?: DateTimeFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableFilter<"NewsThread">
    scheduledAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    title?: StringFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    items?: NewsThreadItemListRelationFilter
  }, "id">

  export type NewsThreadOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    title?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    _count?: NewsThreadCountOrderByAggregateInput
    _max?: NewsThreadMaxOrderByAggregateInput
    _min?: NewsThreadMinOrderByAggregateInput
  }

  export type NewsThreadScalarWhereWithAggregatesInput = {
    AND?: NewsThreadScalarWhereWithAggregatesInput | NewsThreadScalarWhereWithAggregatesInput[]
    OR?: NewsThreadScalarWhereWithAggregatesInput[]
    NOT?: NewsThreadScalarWhereWithAggregatesInput | NewsThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsThread"> | string
    status?: StringWithAggregatesFilter<"NewsThread"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsThread">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"NewsThread"> | Date | string | null
    title?: StringWithAggregatesFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableWithAggregatesFilter<"NewsThread"> | Date | string | null
  }

  export type NewsThreadItemWhereInput = {
    AND?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    OR?: NewsThreadItemWhereInput[]
    NOT?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    id?: StringFilter<"NewsThreadItem"> | string
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringFilter<"NewsThreadItem"> | string
    order?: IntFilter<"NewsThreadItem"> | number
    content?: StringNullableFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeFilter<"NewsThreadItem"> | Date | string
    thread?: XOR<NewsThreadRelationFilter, NewsThreadWhereInput>
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }

  export type NewsThreadItemOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    thread?: NewsThreadOrderByWithRelationInput
    article?: NewsArticleOrderByWithRelationInput
  }

  export type NewsThreadItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    OR?: NewsThreadItemWhereInput[]
    NOT?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringFilter<"NewsThreadItem"> | string
    order?: IntFilter<"NewsThreadItem"> | number
    content?: StringNullableFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeFilter<"NewsThreadItem"> | Date | string
    thread?: XOR<NewsThreadRelationFilter, NewsThreadWhereInput>
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }, "id">

  export type NewsThreadItemOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NewsThreadItemCountOrderByAggregateInput
    _avg?: NewsThreadItemAvgOrderByAggregateInput
    _max?: NewsThreadItemMaxOrderByAggregateInput
    _min?: NewsThreadItemMinOrderByAggregateInput
    _sum?: NewsThreadItemSumOrderByAggregateInput
  }

  export type NewsThreadItemScalarWhereWithAggregatesInput = {
    AND?: NewsThreadItemScalarWhereWithAggregatesInput | NewsThreadItemScalarWhereWithAggregatesInput[]
    OR?: NewsThreadItemScalarWhereWithAggregatesInput[]
    NOT?: NewsThreadItemScalarWhereWithAggregatesInput | NewsThreadItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    threadId?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    articleId?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    order?: IntWithAggregatesFilter<"NewsThreadItem"> | number
    content?: StringNullableWithAggregatesFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NewsThreadItem"> | Date | string
  }

  export type NewsAnalysisWhereInput = {
    AND?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    OR?: NewsAnalysisWhereInput[]
    NOT?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    id?: StringFilter<"NewsAnalysis"> | string
    articleId?: StringFilter<"NewsAnalysis"> | string
    summary?: StringFilter<"NewsAnalysis"> | string
    sentiment?: StringFilter<"NewsAnalysis"> | string
    keywords?: StringNullableListFilter<"NewsAnalysis">
    topics?: StringNullableListFilter<"NewsAnalysis">
    createdAt?: DateTimeFilter<"NewsAnalysis"> | Date | string
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }

  export type NewsAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    keywords?: SortOrder
    topics?: SortOrder
    createdAt?: SortOrder
    article?: NewsArticleOrderByWithRelationInput
  }

  export type NewsAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    articleId?: string
    AND?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    OR?: NewsAnalysisWhereInput[]
    NOT?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    summary?: StringFilter<"NewsAnalysis"> | string
    sentiment?: StringFilter<"NewsAnalysis"> | string
    keywords?: StringNullableListFilter<"NewsAnalysis">
    topics?: StringNullableListFilter<"NewsAnalysis">
    createdAt?: DateTimeFilter<"NewsAnalysis"> | Date | string
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }, "id" | "articleId">

  export type NewsAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    keywords?: SortOrder
    topics?: SortOrder
    createdAt?: SortOrder
    _count?: NewsAnalysisCountOrderByAggregateInput
    _max?: NewsAnalysisMaxOrderByAggregateInput
    _min?: NewsAnalysisMinOrderByAggregateInput
  }

  export type NewsAnalysisScalarWhereWithAggregatesInput = {
    AND?: NewsAnalysisScalarWhereWithAggregatesInput | NewsAnalysisScalarWhereWithAggregatesInput[]
    OR?: NewsAnalysisScalarWhereWithAggregatesInput[]
    NOT?: NewsAnalysisScalarWhereWithAggregatesInput | NewsAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    articleId?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    summary?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    sentiment?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    keywords?: StringNullableListFilter<"NewsAnalysis">
    topics?: StringNullableListFilter<"NewsAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"NewsAnalysis"> | Date | string
  }

  export type JobQueueWhereInput = {
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    id?: StringFilter<"JobQueue"> | string
    type?: StringFilter<"JobQueue"> | string
    payload?: JsonFilter<"JobQueue">
    status?: StringFilter<"JobQueue"> | string
    priority?: IntFilter<"JobQueue"> | number
    attempts?: IntFilter<"JobQueue"> | number
    maxAttempts?: IntFilter<"JobQueue"> | number
    runAt?: DateTimeFilter<"JobQueue"> | Date | string
    completedAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    error?: StringNullableFilter<"JobQueue"> | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeFilter<"JobQueue"> | Date | string
  }

  export type JobQueueOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    type?: StringFilter<"JobQueue"> | string
    payload?: JsonFilter<"JobQueue">
    status?: StringFilter<"JobQueue"> | string
    priority?: IntFilter<"JobQueue"> | number
    attempts?: IntFilter<"JobQueue"> | number
    maxAttempts?: IntFilter<"JobQueue"> | number
    runAt?: DateTimeFilter<"JobQueue"> | Date | string
    completedAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    error?: StringNullableFilter<"JobQueue"> | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeFilter<"JobQueue"> | Date | string
  }, "id">

  export type JobQueueOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobQueueCountOrderByAggregateInput
    _avg?: JobQueueAvgOrderByAggregateInput
    _max?: JobQueueMaxOrderByAggregateInput
    _min?: JobQueueMinOrderByAggregateInput
    _sum?: JobQueueSumOrderByAggregateInput
  }

  export type JobQueueScalarWhereWithAggregatesInput = {
    AND?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    OR?: JobQueueScalarWhereWithAggregatesInput[]
    NOT?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobQueue"> | string
    type?: StringWithAggregatesFilter<"JobQueue"> | string
    payload?: JsonWithAggregatesFilter<"JobQueue">
    status?: StringWithAggregatesFilter<"JobQueue"> | string
    priority?: IntWithAggregatesFilter<"JobQueue"> | number
    attempts?: IntWithAggregatesFilter<"JobQueue"> | number
    maxAttempts?: IntWithAggregatesFilter<"JobQueue"> | number
    runAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"JobQueue"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"JobQueue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
  }

  export type CollectionPresetWhereInput = {
    AND?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    OR?: CollectionPresetWhereInput[]
    NOT?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    id?: StringFilter<"CollectionPreset"> | string
    name?: StringFilter<"CollectionPreset"> | string
    description?: StringNullableFilter<"CollectionPreset"> | string | null
    settings?: JsonFilter<"CollectionPreset">
    isActive?: BoolFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionPreset"> | Date | string
  }

  export type CollectionPresetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    OR?: CollectionPresetWhereInput[]
    NOT?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    name?: StringFilter<"CollectionPreset"> | string
    description?: StringNullableFilter<"CollectionPreset"> | string | null
    settings?: JsonFilter<"CollectionPreset">
    isActive?: BoolFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionPreset"> | Date | string
  }, "id">

  export type CollectionPresetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionPresetCountOrderByAggregateInput
    _max?: CollectionPresetMaxOrderByAggregateInput
    _min?: CollectionPresetMinOrderByAggregateInput
  }

  export type CollectionPresetScalarWhereWithAggregatesInput = {
    AND?: CollectionPresetScalarWhereWithAggregatesInput | CollectionPresetScalarWhereWithAggregatesInput[]
    OR?: CollectionPresetScalarWhereWithAggregatesInput[]
    NOT?: CollectionPresetScalarWhereWithAggregatesInput | CollectionPresetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionPreset"> | string
    name?: StringWithAggregatesFilter<"CollectionPreset"> | string
    description?: StringNullableWithAggregatesFilter<"CollectionPreset"> | string | null
    settings?: JsonWithAggregatesFilter<"CollectionPreset">
    isActive?: BoolWithAggregatesFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionPreset"> | Date | string
  }

  export type WatchlistUserWhereInput = {
    AND?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    OR?: WatchlistUserWhereInput[]
    NOT?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    id?: StringFilter<"WatchlistUser"> | string
    userId?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    followers?: IntNullableFilter<"WatchlistUser"> | number | null
    following?: IntNullableFilter<"WatchlistUser"> | number | null
    isActive?: BoolFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchlistUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tweets?: WatchlistTweetListRelationFilter
    interactions?: InteractionHistoryListRelationFilter
  }

  export type WatchlistUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrderInput | SortOrder
    following?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tweets?: WatchlistTweetOrderByRelationAggregateInput
    interactions?: InteractionHistoryOrderByRelationAggregateInput
  }

  export type WatchlistUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_twitterId?: WatchlistUserUserIdTwitterIdCompoundUniqueInput
    AND?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    OR?: WatchlistUserWhereInput[]
    NOT?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    userId?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    followers?: IntNullableFilter<"WatchlistUser"> | number | null
    following?: IntNullableFilter<"WatchlistUser"> | number | null
    isActive?: BoolFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchlistUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tweets?: WatchlistTweetListRelationFilter
    interactions?: InteractionHistoryListRelationFilter
  }, "id" | "userId_twitterId">

  export type WatchlistUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrderInput | SortOrder
    following?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WatchlistUserCountOrderByAggregateInput
    _avg?: WatchlistUserAvgOrderByAggregateInput
    _max?: WatchlistUserMaxOrderByAggregateInput
    _min?: WatchlistUserMinOrderByAggregateInput
    _sum?: WatchlistUserSumOrderByAggregateInput
  }

  export type WatchlistUserScalarWhereWithAggregatesInput = {
    AND?: WatchlistUserScalarWhereWithAggregatesInput | WatchlistUserScalarWhereWithAggregatesInput[]
    OR?: WatchlistUserScalarWhereWithAggregatesInput[]
    NOT?: WatchlistUserScalarWhereWithAggregatesInput | WatchlistUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistUser"> | string
    userId?: StringWithAggregatesFilter<"WatchlistUser"> | string
    twitterId?: StringWithAggregatesFilter<"WatchlistUser"> | string
    username?: StringWithAggregatesFilter<"WatchlistUser"> | string
    displayName?: StringWithAggregatesFilter<"WatchlistUser"> | string
    followers?: IntNullableWithAggregatesFilter<"WatchlistUser"> | number | null
    following?: IntNullableWithAggregatesFilter<"WatchlistUser"> | number | null
    isActive?: BoolWithAggregatesFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableWithAggregatesFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WatchlistUser"> | Date | string
  }

  export type WatchlistTweetWhereInput = {
    AND?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    OR?: WatchlistTweetWhereInput[]
    NOT?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    id?: StringFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    tweetId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntFilter<"WatchlistTweet"> | number
    likeCount?: IntFilter<"WatchlistTweet"> | number
    replyCount?: IntFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }

  export type WatchlistTweetOrderByWithRelationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
    watchlistUser?: WatchlistUserOrderByWithRelationInput
  }

  export type WatchlistTweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tweetId?: string
    AND?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    OR?: WatchlistTweetWhereInput[]
    NOT?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntFilter<"WatchlistTweet"> | number
    likeCount?: IntFilter<"WatchlistTweet"> | number
    replyCount?: IntFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }, "id" | "tweetId">

  export type WatchlistTweetOrderByWithAggregationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
    _count?: WatchlistTweetCountOrderByAggregateInput
    _avg?: WatchlistTweetAvgOrderByAggregateInput
    _max?: WatchlistTweetMaxOrderByAggregateInput
    _min?: WatchlistTweetMinOrderByAggregateInput
    _sum?: WatchlistTweetSumOrderByAggregateInput
  }

  export type WatchlistTweetScalarWhereWithAggregatesInput = {
    AND?: WatchlistTweetScalarWhereWithAggregatesInput | WatchlistTweetScalarWhereWithAggregatesInput[]
    OR?: WatchlistTweetScalarWhereWithAggregatesInput[]
    NOT?: WatchlistTweetScalarWhereWithAggregatesInput | WatchlistTweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    tweetId?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    content?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    likeCount?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    replyCount?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeWithAggregatesFilter<"WatchlistTweet"> | Date | string
  }

  export type InteractionHistoryWhereInput = {
    AND?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    OR?: InteractionHistoryWhereInput[]
    NOT?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    id?: StringFilter<"InteractionHistory"> | string
    watchlistUserId?: StringFilter<"InteractionHistory"> | string
    interactionType?: StringFilter<"InteractionHistory"> | string
    tweetId?: StringNullableFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableFilter<"InteractionHistory">
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }

  export type InteractionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    watchlistUser?: WatchlistUserOrderByWithRelationInput
  }

  export type InteractionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    OR?: InteractionHistoryWhereInput[]
    NOT?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    watchlistUserId?: StringFilter<"InteractionHistory"> | string
    interactionType?: StringFilter<"InteractionHistory"> | string
    tweetId?: StringNullableFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableFilter<"InteractionHistory">
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }, "id">

  export type InteractionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InteractionHistoryCountOrderByAggregateInput
    _max?: InteractionHistoryMaxOrderByAggregateInput
    _min?: InteractionHistoryMinOrderByAggregateInput
  }

  export type InteractionHistoryScalarWhereWithAggregatesInput = {
    AND?: InteractionHistoryScalarWhereWithAggregatesInput | InteractionHistoryScalarWhereWithAggregatesInput[]
    OR?: InteractionHistoryScalarWhereWithAggregatesInput[]
    NOT?: InteractionHistoryScalarWhereWithAggregatesInput | InteractionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InteractionHistory"> | string
    watchlistUserId?: StringWithAggregatesFilter<"InteractionHistory"> | string
    interactionType?: StringWithAggregatesFilter<"InteractionHistory"> | string
    tweetId?: StringNullableWithAggregatesFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"InteractionHistory">
    createdAt?: DateTimeWithAggregatesFilter<"InteractionHistory"> | Date | string
  }

  export type PerplexityReportWhereInput = {
    AND?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    OR?: PerplexityReportWhereInput[]
    NOT?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    id?: StringFilter<"PerplexityReport"> | string
    query?: StringFilter<"PerplexityReport"> | string
    focus?: StringFilter<"PerplexityReport"> | string
    rawAnalysis?: StringFilter<"PerplexityReport"> | string
    trends?: JsonFilter<"PerplexityReport">
    insights?: JsonFilter<"PerplexityReport">
    contentAngles?: JsonFilter<"PerplexityReport">
    marketContext?: JsonFilter<"PerplexityReport">
    competitorActivity?: JsonFilter<"PerplexityReport">
    riskFactors?: JsonFilter<"PerplexityReport">
    createdAt?: DateTimeFilter<"PerplexityReport"> | Date | string
  }

  export type PerplexityReportOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    contentAngles?: SortOrder
    marketContext?: SortOrder
    competitorActivity?: SortOrder
    riskFactors?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    OR?: PerplexityReportWhereInput[]
    NOT?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    query?: StringFilter<"PerplexityReport"> | string
    focus?: StringFilter<"PerplexityReport"> | string
    rawAnalysis?: StringFilter<"PerplexityReport"> | string
    trends?: JsonFilter<"PerplexityReport">
    insights?: JsonFilter<"PerplexityReport">
    contentAngles?: JsonFilter<"PerplexityReport">
    marketContext?: JsonFilter<"PerplexityReport">
    competitorActivity?: JsonFilter<"PerplexityReport">
    riskFactors?: JsonFilter<"PerplexityReport">
    createdAt?: DateTimeFilter<"PerplexityReport"> | Date | string
  }, "id">

  export type PerplexityReportOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    contentAngles?: SortOrder
    marketContext?: SortOrder
    competitorActivity?: SortOrder
    riskFactors?: SortOrder
    createdAt?: SortOrder
    _count?: PerplexityReportCountOrderByAggregateInput
    _max?: PerplexityReportMaxOrderByAggregateInput
    _min?: PerplexityReportMinOrderByAggregateInput
  }

  export type PerplexityReportScalarWhereWithAggregatesInput = {
    AND?: PerplexityReportScalarWhereWithAggregatesInput | PerplexityReportScalarWhereWithAggregatesInput[]
    OR?: PerplexityReportScalarWhereWithAggregatesInput[]
    NOT?: PerplexityReportScalarWhereWithAggregatesInput | PerplexityReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerplexityReport"> | string
    query?: StringWithAggregatesFilter<"PerplexityReport"> | string
    focus?: StringWithAggregatesFilter<"PerplexityReport"> | string
    rawAnalysis?: StringWithAggregatesFilter<"PerplexityReport"> | string
    trends?: JsonWithAggregatesFilter<"PerplexityReport">
    insights?: JsonWithAggregatesFilter<"PerplexityReport">
    contentAngles?: JsonWithAggregatesFilter<"PerplexityReport">
    marketContext?: JsonWithAggregatesFilter<"PerplexityReport">
    competitorActivity?: JsonWithAggregatesFilter<"PerplexityReport">
    riskFactors?: JsonWithAggregatesFilter<"PerplexityReport">
    createdAt?: DateTimeWithAggregatesFilter<"PerplexityReport"> | Date | string
  }

  export type CotSessionWhereInput = {
    AND?: CotSessionWhereInput | CotSessionWhereInput[]
    OR?: CotSessionWhereInput[]
    NOT?: CotSessionWhereInput | CotSessionWhereInput[]
    id?: StringFilter<"CotSession"> | string
    theme?: StringFilter<"CotSession"> | string
    style?: StringFilter<"CotSession"> | string
    platform?: StringFilter<"CotSession"> | string
    status?: EnumCotSessionStatusFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableFilter<"CotSession"> | string | null
    retryCount?: IntFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    totalTokens?: IntFilter<"CotSession"> | number
    totalDuration?: IntFilter<"CotSession"> | number
    createdAt?: DateTimeFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    phases?: CotPhaseListRelationFilter
    drafts?: CotDraftListRelationFilter
  }

  export type CotSessionOrderByWithRelationInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    phases?: CotPhaseOrderByRelationAggregateInput
    drafts?: CotDraftOrderByRelationAggregateInput
  }

  export type CotSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CotSessionWhereInput | CotSessionWhereInput[]
    OR?: CotSessionWhereInput[]
    NOT?: CotSessionWhereInput | CotSessionWhereInput[]
    theme?: StringFilter<"CotSession"> | string
    style?: StringFilter<"CotSession"> | string
    platform?: StringFilter<"CotSession"> | string
    status?: EnumCotSessionStatusFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableFilter<"CotSession"> | string | null
    retryCount?: IntFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    totalTokens?: IntFilter<"CotSession"> | number
    totalDuration?: IntFilter<"CotSession"> | number
    createdAt?: DateTimeFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    phases?: CotPhaseListRelationFilter
    drafts?: CotDraftListRelationFilter
  }, "id">

  export type CotSessionOrderByWithAggregationInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CotSessionCountOrderByAggregateInput
    _avg?: CotSessionAvgOrderByAggregateInput
    _max?: CotSessionMaxOrderByAggregateInput
    _min?: CotSessionMinOrderByAggregateInput
    _sum?: CotSessionSumOrderByAggregateInput
  }

  export type CotSessionScalarWhereWithAggregatesInput = {
    AND?: CotSessionScalarWhereWithAggregatesInput | CotSessionScalarWhereWithAggregatesInput[]
    OR?: CotSessionScalarWhereWithAggregatesInput[]
    NOT?: CotSessionScalarWhereWithAggregatesInput | CotSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotSession"> | string
    theme?: StringWithAggregatesFilter<"CotSession"> | string
    style?: StringWithAggregatesFilter<"CotSession"> | string
    platform?: StringWithAggregatesFilter<"CotSession"> | string
    status?: EnumCotSessionStatusWithAggregatesFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntWithAggregatesFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepWithAggregatesFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableWithAggregatesFilter<"CotSession"> | string | null
    retryCount?: IntWithAggregatesFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"CotSession"> | Date | string | null
    totalTokens?: IntWithAggregatesFilter<"CotSession"> | number
    totalDuration?: IntWithAggregatesFilter<"CotSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CotSession"> | Date | string | null
  }

  export type CotPhaseWhereInput = {
    AND?: CotPhaseWhereInput | CotPhaseWhereInput[]
    OR?: CotPhaseWhereInput[]
    NOT?: CotPhaseWhereInput | CotPhaseWhereInput[]
    id?: StringFilter<"CotPhase"> | string
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
  }

  export type CotPhaseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrderInput | SortOrder
    thinkResult?: SortOrderInput | SortOrder
    thinkTokens?: SortOrderInput | SortOrder
    thinkAt?: SortOrderInput | SortOrder
    executeResult?: SortOrderInput | SortOrder
    executeDuration?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    integratePrompt?: SortOrderInput | SortOrder
    integrateResult?: SortOrderInput | SortOrder
    integrateTokens?: SortOrderInput | SortOrder
    integrateAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: CotSessionOrderByWithRelationInput
  }

  export type CotPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_phaseNumber?: CotPhaseSessionIdPhaseNumberCompoundUniqueInput
    AND?: CotPhaseWhereInput | CotPhaseWhereInput[]
    OR?: CotPhaseWhereInput[]
    NOT?: CotPhaseWhereInput | CotPhaseWhereInput[]
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
  }, "id" | "sessionId_phaseNumber">

  export type CotPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrderInput | SortOrder
    thinkResult?: SortOrderInput | SortOrder
    thinkTokens?: SortOrderInput | SortOrder
    thinkAt?: SortOrderInput | SortOrder
    executeResult?: SortOrderInput | SortOrder
    executeDuration?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    integratePrompt?: SortOrderInput | SortOrder
    integrateResult?: SortOrderInput | SortOrder
    integrateTokens?: SortOrderInput | SortOrder
    integrateAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CotPhaseCountOrderByAggregateInput
    _avg?: CotPhaseAvgOrderByAggregateInput
    _max?: CotPhaseMaxOrderByAggregateInput
    _min?: CotPhaseMinOrderByAggregateInput
    _sum?: CotPhaseSumOrderByAggregateInput
  }

  export type CotPhaseScalarWhereWithAggregatesInput = {
    AND?: CotPhaseScalarWhereWithAggregatesInput | CotPhaseScalarWhereWithAggregatesInput[]
    OR?: CotPhaseScalarWhereWithAggregatesInput[]
    NOT?: CotPhaseScalarWhereWithAggregatesInput | CotPhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotPhase"> | string
    sessionId?: StringWithAggregatesFilter<"CotPhase"> | string
    phaseNumber?: IntWithAggregatesFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableWithAggregatesFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    thinkTokens?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    executeDuration?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableWithAggregatesFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    integrateTokens?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusWithAggregatesFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotPhase"> | Date | string
  }

  export type CotDraftWhereInput = {
    AND?: CotDraftWhereInput | CotDraftWhereInput[]
    OR?: CotDraftWhereInput[]
    NOT?: CotDraftWhereInput | CotDraftWhereInput[]
    id?: StringFilter<"CotDraft"> | string
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
    performance?: XOR<CotDraftPerformanceNullableRelationFilter, CotDraftPerformanceWhereInput> | null
    scheduledRTs?: ScheduledRetweetListRelationFilter
  }

  export type CotDraftOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    visualGuide?: SortOrderInput | SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    kpis?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    optimizationTips?: SortOrderInput | SortOrder
    status?: SortOrder
    editedContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: CotSessionOrderByWithRelationInput
    performance?: CotDraftPerformanceOrderByWithRelationInput
    scheduledRTs?: ScheduledRetweetOrderByRelationAggregateInput
  }

  export type CotDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_conceptNumber?: CotDraftSessionIdConceptNumberCompoundUniqueInput
    AND?: CotDraftWhereInput | CotDraftWhereInput[]
    OR?: CotDraftWhereInput[]
    NOT?: CotDraftWhereInput | CotDraftWhereInput[]
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
    performance?: XOR<CotDraftPerformanceNullableRelationFilter, CotDraftPerformanceWhereInput> | null
    scheduledRTs?: ScheduledRetweetListRelationFilter
  }, "id" | "sessionId_conceptNumber">

  export type CotDraftOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    visualGuide?: SortOrderInput | SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    kpis?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    optimizationTips?: SortOrderInput | SortOrder
    status?: SortOrder
    editedContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CotDraftCountOrderByAggregateInput
    _avg?: CotDraftAvgOrderByAggregateInput
    _max?: CotDraftMaxOrderByAggregateInput
    _min?: CotDraftMinOrderByAggregateInput
    _sum?: CotDraftSumOrderByAggregateInput
  }

  export type CotDraftScalarWhereWithAggregatesInput = {
    AND?: CotDraftScalarWhereWithAggregatesInput | CotDraftScalarWhereWithAggregatesInput[]
    OR?: CotDraftScalarWhereWithAggregatesInput[]
    NOT?: CotDraftScalarWhereWithAggregatesInput | CotDraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotDraft"> | string
    sessionId?: StringWithAggregatesFilter<"CotDraft"> | string
    conceptNumber?: IntWithAggregatesFilter<"CotDraft"> | number
    title?: StringWithAggregatesFilter<"CotDraft"> | string
    hook?: StringWithAggregatesFilter<"CotDraft"> | string
    angle?: StringWithAggregatesFilter<"CotDraft"> | string
    format?: StringWithAggregatesFilter<"CotDraft"> | string
    content?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    timing?: StringWithAggregatesFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    kpis?: JsonNullableWithAggregatesFilter<"CotDraft">
    riskAssessment?: JsonNullableWithAggregatesFilter<"CotDraft">
    optimizationTips?: JsonNullableWithAggregatesFilter<"CotDraft">
    status?: EnumCotDraftStatusWithAggregatesFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableWithAggregatesFilter<"CotDraft"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotDraft"> | Date | string
  }

  export type CotDraftPerformanceWhereInput = {
    AND?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    OR?: CotDraftPerformanceWhereInput[]
    NOT?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    id?: StringFilter<"CotDraftPerformance"> | string
    draftId?: StringFilter<"CotDraftPerformance"> | string
    likes30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    draft?: XOR<CotDraftRelationFilter, CotDraftWhereInput>
  }

  export type CotDraftPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
    draft?: CotDraftOrderByWithRelationInput
  }

  export type CotDraftPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId?: string
    AND?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    OR?: CotDraftPerformanceWhereInput[]
    NOT?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    likes30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    draft?: XOR<CotDraftRelationFilter, CotDraftWhereInput>
  }, "id" | "draftId">

  export type CotDraftPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
    _count?: CotDraftPerformanceCountOrderByAggregateInput
    _avg?: CotDraftPerformanceAvgOrderByAggregateInput
    _max?: CotDraftPerformanceMaxOrderByAggregateInput
    _min?: CotDraftPerformanceMinOrderByAggregateInput
    _sum?: CotDraftPerformanceSumOrderByAggregateInput
  }

  export type CotDraftPerformanceScalarWhereWithAggregatesInput = {
    AND?: CotDraftPerformanceScalarWhereWithAggregatesInput | CotDraftPerformanceScalarWhereWithAggregatesInput[]
    OR?: CotDraftPerformanceScalarWhereWithAggregatesInput[]
    NOT?: CotDraftPerformanceScalarWhereWithAggregatesInput | CotDraftPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotDraftPerformance"> | string
    draftId?: StringWithAggregatesFilter<"CotDraftPerformance"> | string
    likes30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeWithAggregatesFilter<"CotDraftPerformance"> | Date | string
  }

  export type UnifiedContentSourceWhereInput = {
    AND?: UnifiedContentSourceWhereInput | UnifiedContentSourceWhereInput[]
    OR?: UnifiedContentSourceWhereInput[]
    NOT?: UnifiedContentSourceWhereInput | UnifiedContentSourceWhereInput[]
    id?: StringFilter<"UnifiedContentSource"> | string
    sourceType?: StringFilter<"UnifiedContentSource"> | string
    sourceId?: StringFilter<"UnifiedContentSource"> | string
    contentSummary?: StringNullableFilter<"UnifiedContentSource"> | string | null
    importanceScore?: FloatNullableFilter<"UnifiedContentSource"> | number | null
    viralPotential?: FloatNullableFilter<"UnifiedContentSource"> | number | null
    keywords?: StringNullableListFilter<"UnifiedContentSource">
    metadata?: JsonNullableFilter<"UnifiedContentSource">
    createdAt?: DateTimeFilter<"UnifiedContentSource"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedContentSource"> | Date | string
    integratedSessions?: IntegratedSessionSourceListRelationFilter
  }

  export type UnifiedContentSourceOrderByWithRelationInput = {
    id?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    contentSummary?: SortOrderInput | SortOrder
    importanceScore?: SortOrderInput | SortOrder
    viralPotential?: SortOrderInput | SortOrder
    keywords?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    integratedSessions?: IntegratedSessionSourceOrderByRelationAggregateInput
  }

  export type UnifiedContentSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnifiedContentSourceWhereInput | UnifiedContentSourceWhereInput[]
    OR?: UnifiedContentSourceWhereInput[]
    NOT?: UnifiedContentSourceWhereInput | UnifiedContentSourceWhereInput[]
    sourceType?: StringFilter<"UnifiedContentSource"> | string
    sourceId?: StringFilter<"UnifiedContentSource"> | string
    contentSummary?: StringNullableFilter<"UnifiedContentSource"> | string | null
    importanceScore?: FloatNullableFilter<"UnifiedContentSource"> | number | null
    viralPotential?: FloatNullableFilter<"UnifiedContentSource"> | number | null
    keywords?: StringNullableListFilter<"UnifiedContentSource">
    metadata?: JsonNullableFilter<"UnifiedContentSource">
    createdAt?: DateTimeFilter<"UnifiedContentSource"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedContentSource"> | Date | string
    integratedSessions?: IntegratedSessionSourceListRelationFilter
  }, "id">

  export type UnifiedContentSourceOrderByWithAggregationInput = {
    id?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    contentSummary?: SortOrderInput | SortOrder
    importanceScore?: SortOrderInput | SortOrder
    viralPotential?: SortOrderInput | SortOrder
    keywords?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnifiedContentSourceCountOrderByAggregateInput
    _avg?: UnifiedContentSourceAvgOrderByAggregateInput
    _max?: UnifiedContentSourceMaxOrderByAggregateInput
    _min?: UnifiedContentSourceMinOrderByAggregateInput
    _sum?: UnifiedContentSourceSumOrderByAggregateInput
  }

  export type UnifiedContentSourceScalarWhereWithAggregatesInput = {
    AND?: UnifiedContentSourceScalarWhereWithAggregatesInput | UnifiedContentSourceScalarWhereWithAggregatesInput[]
    OR?: UnifiedContentSourceScalarWhereWithAggregatesInput[]
    NOT?: UnifiedContentSourceScalarWhereWithAggregatesInput | UnifiedContentSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnifiedContentSource"> | string
    sourceType?: StringWithAggregatesFilter<"UnifiedContentSource"> | string
    sourceId?: StringWithAggregatesFilter<"UnifiedContentSource"> | string
    contentSummary?: StringNullableWithAggregatesFilter<"UnifiedContentSource"> | string | null
    importanceScore?: FloatNullableWithAggregatesFilter<"UnifiedContentSource"> | number | null
    viralPotential?: FloatNullableWithAggregatesFilter<"UnifiedContentSource"> | number | null
    keywords?: StringNullableListFilter<"UnifiedContentSource">
    metadata?: JsonNullableWithAggregatesFilter<"UnifiedContentSource">
    createdAt?: DateTimeWithAggregatesFilter<"UnifiedContentSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnifiedContentSource"> | Date | string
  }

  export type IntegratedSessionWhereInput = {
    AND?: IntegratedSessionWhereInput | IntegratedSessionWhereInput[]
    OR?: IntegratedSessionWhereInput[]
    NOT?: IntegratedSessionWhereInput | IntegratedSessionWhereInput[]
    id?: StringFilter<"IntegratedSession"> | string
    sessionType?: StringFilter<"IntegratedSession"> | string
    v2SessionId?: StringNullableFilter<"IntegratedSession"> | string | null
    newsArticleIds?: StringNullableListFilter<"IntegratedSession">
    buzzPostIds?: StringNullableListFilter<"IntegratedSession">
    generationContext?: JsonNullableFilter<"IntegratedSession">
    performanceMetrics?: JsonNullableFilter<"IntegratedSession">
    status?: StringFilter<"IntegratedSession"> | string
    currentStep?: StringNullableFilter<"IntegratedSession"> | string | null
    theme?: StringNullableFilter<"IntegratedSession"> | string | null
    character?: StringNullableFilter<"IntegratedSession"> | string | null
    platform?: StringNullableFilter<"IntegratedSession"> | string | null
    strategy?: StringNullableFilter<"IntegratedSession"> | string | null
    createdAt?: DateTimeFilter<"IntegratedSession"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"IntegratedSession"> | Date | string | null
    v2Session?: XOR<ViralSessionNullableRelationFilter, ViralSessionWhereInput> | null
    sources?: IntegratedSessionSourceListRelationFilter
    drafts?: IntegratedDraftListRelationFilter
  }

  export type IntegratedSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionType?: SortOrder
    v2SessionId?: SortOrderInput | SortOrder
    newsArticleIds?: SortOrder
    buzzPostIds?: SortOrder
    generationContext?: SortOrderInput | SortOrder
    performanceMetrics?: SortOrderInput | SortOrder
    status?: SortOrder
    currentStep?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    character?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    strategy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    v2Session?: ViralSessionOrderByWithRelationInput
    sources?: IntegratedSessionSourceOrderByRelationAggregateInput
    drafts?: IntegratedDraftOrderByRelationAggregateInput
  }

  export type IntegratedSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegratedSessionWhereInput | IntegratedSessionWhereInput[]
    OR?: IntegratedSessionWhereInput[]
    NOT?: IntegratedSessionWhereInput | IntegratedSessionWhereInput[]
    sessionType?: StringFilter<"IntegratedSession"> | string
    v2SessionId?: StringNullableFilter<"IntegratedSession"> | string | null
    newsArticleIds?: StringNullableListFilter<"IntegratedSession">
    buzzPostIds?: StringNullableListFilter<"IntegratedSession">
    generationContext?: JsonNullableFilter<"IntegratedSession">
    performanceMetrics?: JsonNullableFilter<"IntegratedSession">
    status?: StringFilter<"IntegratedSession"> | string
    currentStep?: StringNullableFilter<"IntegratedSession"> | string | null
    theme?: StringNullableFilter<"IntegratedSession"> | string | null
    character?: StringNullableFilter<"IntegratedSession"> | string | null
    platform?: StringNullableFilter<"IntegratedSession"> | string | null
    strategy?: StringNullableFilter<"IntegratedSession"> | string | null
    createdAt?: DateTimeFilter<"IntegratedSession"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"IntegratedSession"> | Date | string | null
    v2Session?: XOR<ViralSessionNullableRelationFilter, ViralSessionWhereInput> | null
    sources?: IntegratedSessionSourceListRelationFilter
    drafts?: IntegratedDraftListRelationFilter
  }, "id">

  export type IntegratedSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionType?: SortOrder
    v2SessionId?: SortOrderInput | SortOrder
    newsArticleIds?: SortOrder
    buzzPostIds?: SortOrder
    generationContext?: SortOrderInput | SortOrder
    performanceMetrics?: SortOrderInput | SortOrder
    status?: SortOrder
    currentStep?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    character?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    strategy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: IntegratedSessionCountOrderByAggregateInput
    _max?: IntegratedSessionMaxOrderByAggregateInput
    _min?: IntegratedSessionMinOrderByAggregateInput
  }

  export type IntegratedSessionScalarWhereWithAggregatesInput = {
    AND?: IntegratedSessionScalarWhereWithAggregatesInput | IntegratedSessionScalarWhereWithAggregatesInput[]
    OR?: IntegratedSessionScalarWhereWithAggregatesInput[]
    NOT?: IntegratedSessionScalarWhereWithAggregatesInput | IntegratedSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegratedSession"> | string
    sessionType?: StringWithAggregatesFilter<"IntegratedSession"> | string
    v2SessionId?: StringNullableWithAggregatesFilter<"IntegratedSession"> | string | null
    newsArticleIds?: StringNullableListFilter<"IntegratedSession">
    buzzPostIds?: StringNullableListFilter<"IntegratedSession">
    generationContext?: JsonNullableWithAggregatesFilter<"IntegratedSession">
    performanceMetrics?: JsonNullableWithAggregatesFilter<"IntegratedSession">
    status?: StringWithAggregatesFilter<"IntegratedSession"> | string
    currentStep?: StringNullableWithAggregatesFilter<"IntegratedSession"> | string | null
    theme?: StringNullableWithAggregatesFilter<"IntegratedSession"> | string | null
    character?: StringNullableWithAggregatesFilter<"IntegratedSession"> | string | null
    platform?: StringNullableWithAggregatesFilter<"IntegratedSession"> | string | null
    strategy?: StringNullableWithAggregatesFilter<"IntegratedSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IntegratedSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntegratedSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"IntegratedSession"> | Date | string | null
  }

  export type IntegratedSessionSourceWhereInput = {
    AND?: IntegratedSessionSourceWhereInput | IntegratedSessionSourceWhereInput[]
    OR?: IntegratedSessionSourceWhereInput[]
    NOT?: IntegratedSessionSourceWhereInput | IntegratedSessionSourceWhereInput[]
    id?: StringFilter<"IntegratedSessionSource"> | string
    sessionId?: StringFilter<"IntegratedSessionSource"> | string
    sourceId?: StringFilter<"IntegratedSessionSource"> | string
    relevanceScore?: FloatNullableFilter<"IntegratedSessionSource"> | number | null
    usageType?: StringFilter<"IntegratedSessionSource"> | string
    session?: XOR<IntegratedSessionRelationFilter, IntegratedSessionWhereInput>
    source?: XOR<UnifiedContentSourceRelationFilter, UnifiedContentSourceWhereInput>
  }

  export type IntegratedSessionSourceOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sourceId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    usageType?: SortOrder
    session?: IntegratedSessionOrderByWithRelationInput
    source?: UnifiedContentSourceOrderByWithRelationInput
  }

  export type IntegratedSessionSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_sourceId?: IntegratedSessionSourceSessionIdSourceIdCompoundUniqueInput
    AND?: IntegratedSessionSourceWhereInput | IntegratedSessionSourceWhereInput[]
    OR?: IntegratedSessionSourceWhereInput[]
    NOT?: IntegratedSessionSourceWhereInput | IntegratedSessionSourceWhereInput[]
    sessionId?: StringFilter<"IntegratedSessionSource"> | string
    sourceId?: StringFilter<"IntegratedSessionSource"> | string
    relevanceScore?: FloatNullableFilter<"IntegratedSessionSource"> | number | null
    usageType?: StringFilter<"IntegratedSessionSource"> | string
    session?: XOR<IntegratedSessionRelationFilter, IntegratedSessionWhereInput>
    source?: XOR<UnifiedContentSourceRelationFilter, UnifiedContentSourceWhereInput>
  }, "id" | "sessionId_sourceId">

  export type IntegratedSessionSourceOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sourceId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    usageType?: SortOrder
    _count?: IntegratedSessionSourceCountOrderByAggregateInput
    _avg?: IntegratedSessionSourceAvgOrderByAggregateInput
    _max?: IntegratedSessionSourceMaxOrderByAggregateInput
    _min?: IntegratedSessionSourceMinOrderByAggregateInput
    _sum?: IntegratedSessionSourceSumOrderByAggregateInput
  }

  export type IntegratedSessionSourceScalarWhereWithAggregatesInput = {
    AND?: IntegratedSessionSourceScalarWhereWithAggregatesInput | IntegratedSessionSourceScalarWhereWithAggregatesInput[]
    OR?: IntegratedSessionSourceScalarWhereWithAggregatesInput[]
    NOT?: IntegratedSessionSourceScalarWhereWithAggregatesInput | IntegratedSessionSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegratedSessionSource"> | string
    sessionId?: StringWithAggregatesFilter<"IntegratedSessionSource"> | string
    sourceId?: StringWithAggregatesFilter<"IntegratedSessionSource"> | string
    relevanceScore?: FloatNullableWithAggregatesFilter<"IntegratedSessionSource"> | number | null
    usageType?: StringWithAggregatesFilter<"IntegratedSessionSource"> | string
  }

  export type IntegratedDraftWhereInput = {
    AND?: IntegratedDraftWhereInput | IntegratedDraftWhereInput[]
    OR?: IntegratedDraftWhereInput[]
    NOT?: IntegratedDraftWhereInput | IntegratedDraftWhereInput[]
    id?: StringFilter<"IntegratedDraft"> | string
    sessionId?: StringFilter<"IntegratedDraft"> | string
    title?: StringFilter<"IntegratedDraft"> | string
    content?: StringFilter<"IntegratedDraft"> | string
    contentType?: StringFilter<"IntegratedDraft"> | string
    sourcesSummary?: StringNullableFilter<"IntegratedDraft"> | string | null
    newsContext?: StringNullableFilter<"IntegratedDraft"> | string | null
    buzzContext?: StringNullableFilter<"IntegratedDraft"> | string | null
    conceptId?: StringNullableFilter<"IntegratedDraft"> | string | null
    hook?: StringNullableFilter<"IntegratedDraft"> | string | null
    angle?: StringNullableFilter<"IntegratedDraft"> | string | null
    sourceNewsIds?: StringNullableListFilter<"IntegratedDraft">
    sourceBuzzIds?: StringNullableListFilter<"IntegratedDraft">
    generationStrategy?: StringNullableFilter<"IntegratedDraft"> | string | null
    generationData?: JsonNullableFilter<"IntegratedDraft">
    hashtags?: StringNullableListFilter<"IntegratedDraft">
    visualGuide?: StringNullableFilter<"IntegratedDraft"> | string | null
    status?: StringFilter<"IntegratedDraft"> | string
    scheduledAt?: DateTimeNullableFilter<"IntegratedDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"IntegratedDraft"> | Date | string | null
    postId?: StringNullableFilter<"IntegratedDraft"> | string | null
    viralScore?: FloatNullableFilter<"IntegratedDraft"> | number | null
    createdAt?: DateTimeFilter<"IntegratedDraft"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedDraft"> | Date | string
    session?: XOR<IntegratedSessionRelationFilter, IntegratedSessionWhereInput>
    performance?: XOR<IntegratedDraftPerformanceNullableRelationFilter, IntegratedDraftPerformanceWhereInput> | null
  }

  export type IntegratedDraftOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourcesSummary?: SortOrderInput | SortOrder
    newsContext?: SortOrderInput | SortOrder
    buzzContext?: SortOrderInput | SortOrder
    conceptId?: SortOrderInput | SortOrder
    hook?: SortOrderInput | SortOrder
    angle?: SortOrderInput | SortOrder
    sourceNewsIds?: SortOrder
    sourceBuzzIds?: SortOrder
    generationStrategy?: SortOrderInput | SortOrder
    generationData?: SortOrderInput | SortOrder
    hashtags?: SortOrder
    visualGuide?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: IntegratedSessionOrderByWithRelationInput
    performance?: IntegratedDraftPerformanceOrderByWithRelationInput
  }

  export type IntegratedDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegratedDraftWhereInput | IntegratedDraftWhereInput[]
    OR?: IntegratedDraftWhereInput[]
    NOT?: IntegratedDraftWhereInput | IntegratedDraftWhereInput[]
    sessionId?: StringFilter<"IntegratedDraft"> | string
    title?: StringFilter<"IntegratedDraft"> | string
    content?: StringFilter<"IntegratedDraft"> | string
    contentType?: StringFilter<"IntegratedDraft"> | string
    sourcesSummary?: StringNullableFilter<"IntegratedDraft"> | string | null
    newsContext?: StringNullableFilter<"IntegratedDraft"> | string | null
    buzzContext?: StringNullableFilter<"IntegratedDraft"> | string | null
    conceptId?: StringNullableFilter<"IntegratedDraft"> | string | null
    hook?: StringNullableFilter<"IntegratedDraft"> | string | null
    angle?: StringNullableFilter<"IntegratedDraft"> | string | null
    sourceNewsIds?: StringNullableListFilter<"IntegratedDraft">
    sourceBuzzIds?: StringNullableListFilter<"IntegratedDraft">
    generationStrategy?: StringNullableFilter<"IntegratedDraft"> | string | null
    generationData?: JsonNullableFilter<"IntegratedDraft">
    hashtags?: StringNullableListFilter<"IntegratedDraft">
    visualGuide?: StringNullableFilter<"IntegratedDraft"> | string | null
    status?: StringFilter<"IntegratedDraft"> | string
    scheduledAt?: DateTimeNullableFilter<"IntegratedDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"IntegratedDraft"> | Date | string | null
    postId?: StringNullableFilter<"IntegratedDraft"> | string | null
    viralScore?: FloatNullableFilter<"IntegratedDraft"> | number | null
    createdAt?: DateTimeFilter<"IntegratedDraft"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedDraft"> | Date | string
    session?: XOR<IntegratedSessionRelationFilter, IntegratedSessionWhereInput>
    performance?: XOR<IntegratedDraftPerformanceNullableRelationFilter, IntegratedDraftPerformanceWhereInput> | null
  }, "id">

  export type IntegratedDraftOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourcesSummary?: SortOrderInput | SortOrder
    newsContext?: SortOrderInput | SortOrder
    buzzContext?: SortOrderInput | SortOrder
    conceptId?: SortOrderInput | SortOrder
    hook?: SortOrderInput | SortOrder
    angle?: SortOrderInput | SortOrder
    sourceNewsIds?: SortOrder
    sourceBuzzIds?: SortOrder
    generationStrategy?: SortOrderInput | SortOrder
    generationData?: SortOrderInput | SortOrder
    hashtags?: SortOrder
    visualGuide?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegratedDraftCountOrderByAggregateInput
    _avg?: IntegratedDraftAvgOrderByAggregateInput
    _max?: IntegratedDraftMaxOrderByAggregateInput
    _min?: IntegratedDraftMinOrderByAggregateInput
    _sum?: IntegratedDraftSumOrderByAggregateInput
  }

  export type IntegratedDraftScalarWhereWithAggregatesInput = {
    AND?: IntegratedDraftScalarWhereWithAggregatesInput | IntegratedDraftScalarWhereWithAggregatesInput[]
    OR?: IntegratedDraftScalarWhereWithAggregatesInput[]
    NOT?: IntegratedDraftScalarWhereWithAggregatesInput | IntegratedDraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegratedDraft"> | string
    sessionId?: StringWithAggregatesFilter<"IntegratedDraft"> | string
    title?: StringWithAggregatesFilter<"IntegratedDraft"> | string
    content?: StringWithAggregatesFilter<"IntegratedDraft"> | string
    contentType?: StringWithAggregatesFilter<"IntegratedDraft"> | string
    sourcesSummary?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    newsContext?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    buzzContext?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    conceptId?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    hook?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    angle?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    sourceNewsIds?: StringNullableListFilter<"IntegratedDraft">
    sourceBuzzIds?: StringNullableListFilter<"IntegratedDraft">
    generationStrategy?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    generationData?: JsonNullableWithAggregatesFilter<"IntegratedDraft">
    hashtags?: StringNullableListFilter<"IntegratedDraft">
    visualGuide?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    status?: StringWithAggregatesFilter<"IntegratedDraft"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"IntegratedDraft"> | Date | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"IntegratedDraft"> | Date | string | null
    postId?: StringNullableWithAggregatesFilter<"IntegratedDraft"> | string | null
    viralScore?: FloatNullableWithAggregatesFilter<"IntegratedDraft"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"IntegratedDraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntegratedDraft"> | Date | string
  }

  export type IntegratedDraftPerformanceWhereInput = {
    AND?: IntegratedDraftPerformanceWhereInput | IntegratedDraftPerformanceWhereInput[]
    OR?: IntegratedDraftPerformanceWhereInput[]
    NOT?: IntegratedDraftPerformanceWhereInput | IntegratedDraftPerformanceWhereInput[]
    id?: StringFilter<"IntegratedDraftPerformance"> | string
    draftId?: StringFilter<"IntegratedDraftPerformance"> | string
    likes30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"IntegratedDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"IntegratedDraftPerformance"> | number | null
    predictionAccuracy?: FloatNullableFilter<"IntegratedDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"IntegratedDraftPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedDraftPerformance"> | Date | string
    draft?: XOR<IntegratedDraftRelationFilter, IntegratedDraftWhereInput>
  }

  export type IntegratedDraftPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    predictionAccuracy?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    draft?: IntegratedDraftOrderByWithRelationInput
  }

  export type IntegratedDraftPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId?: string
    AND?: IntegratedDraftPerformanceWhereInput | IntegratedDraftPerformanceWhereInput[]
    OR?: IntegratedDraftPerformanceWhereInput[]
    NOT?: IntegratedDraftPerformanceWhereInput | IntegratedDraftPerformanceWhereInput[]
    likes30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"IntegratedDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"IntegratedDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"IntegratedDraftPerformance"> | number | null
    predictionAccuracy?: FloatNullableFilter<"IntegratedDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"IntegratedDraftPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedDraftPerformance"> | Date | string
    draft?: XOR<IntegratedDraftRelationFilter, IntegratedDraftWhereInput>
  }, "id" | "draftId">

  export type IntegratedDraftPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    predictionAccuracy?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegratedDraftPerformanceCountOrderByAggregateInput
    _avg?: IntegratedDraftPerformanceAvgOrderByAggregateInput
    _max?: IntegratedDraftPerformanceMaxOrderByAggregateInput
    _min?: IntegratedDraftPerformanceMinOrderByAggregateInput
    _sum?: IntegratedDraftPerformanceSumOrderByAggregateInput
  }

  export type IntegratedDraftPerformanceScalarWhereWithAggregatesInput = {
    AND?: IntegratedDraftPerformanceScalarWhereWithAggregatesInput | IntegratedDraftPerformanceScalarWhereWithAggregatesInput[]
    OR?: IntegratedDraftPerformanceScalarWhereWithAggregatesInput[]
    NOT?: IntegratedDraftPerformanceScalarWhereWithAggregatesInput | IntegratedDraftPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegratedDraftPerformance"> | string
    draftId?: StringWithAggregatesFilter<"IntegratedDraftPerformance"> | string
    likes30m?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    retweets30m?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    replies30m?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    impressions30m?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    likes1h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    retweets1h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    replies1h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    impressions1h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    likes24h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    retweets24h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    replies24h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    impressions24h?: IntNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    engagementRate?: FloatNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    predictionAccuracy?: FloatNullableWithAggregatesFilter<"IntegratedDraftPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"IntegratedDraftPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntegratedDraftPerformance"> | Date | string
  }

  export type ScheduledRetweetWhereInput = {
    AND?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    OR?: ScheduledRetweetWhereInput[]
    NOT?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    id?: StringFilter<"ScheduledRetweet"> | string
    originalPostId?: StringFilter<"ScheduledRetweet"> | string
    originalContent?: StringFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringFilter<"ScheduledRetweet"> | string
    addComment?: BoolFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    viralDraft?: XOR<ViralDraftV2NullableRelationFilter, ViralDraftV2WhereInput> | null
    cotDraft?: XOR<CotDraftNullableRelationFilter, CotDraftWhereInput> | null
  }

  export type ScheduledRetweetOrderByWithRelationInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrderInput | SortOrder
    viralDraftId?: SortOrderInput | SortOrder
    cotDraftId?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    rtPostId?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    viralDraft?: ViralDraftV2OrderByWithRelationInput
    cotDraft?: CotDraftOrderByWithRelationInput
  }

  export type ScheduledRetweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    OR?: ScheduledRetweetWhereInput[]
    NOT?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    originalPostId?: StringFilter<"ScheduledRetweet"> | string
    originalContent?: StringFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringFilter<"ScheduledRetweet"> | string
    addComment?: BoolFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    viralDraft?: XOR<ViralDraftV2NullableRelationFilter, ViralDraftV2WhereInput> | null
    cotDraft?: XOR<CotDraftNullableRelationFilter, CotDraftWhereInput> | null
  }, "id">

  export type ScheduledRetweetOrderByWithAggregationInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrderInput | SortOrder
    viralDraftId?: SortOrderInput | SortOrder
    cotDraftId?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    rtPostId?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledRetweetCountOrderByAggregateInput
    _max?: ScheduledRetweetMaxOrderByAggregateInput
    _min?: ScheduledRetweetMinOrderByAggregateInput
  }

  export type ScheduledRetweetScalarWhereWithAggregatesInput = {
    AND?: ScheduledRetweetScalarWhereWithAggregatesInput | ScheduledRetweetScalarWhereWithAggregatesInput[]
    OR?: ScheduledRetweetScalarWhereWithAggregatesInput[]
    NOT?: ScheduledRetweetScalarWhereWithAggregatesInput | ScheduledRetweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    originalPostId?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    originalContent?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusWithAggregatesFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    addComment?: BoolWithAggregatesFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledRetweet"> | Date | string
  }

  export type UnifiedPerformanceWhereInput = {
    AND?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    OR?: UnifiedPerformanceWhereInput[]
    NOT?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    id?: StringFilter<"UnifiedPerformance"> | string
    contentId?: StringFilter<"UnifiedPerformance"> | string
    contentType?: StringFilter<"UnifiedPerformance"> | string
    metrics30m?: JsonNullableFilter<"UnifiedPerformance">
    metrics1h?: JsonNullableFilter<"UnifiedPerformance">
    metrics24h?: JsonNullableFilter<"UnifiedPerformance">
    engagementRate?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    collectedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
  }

  export type UnifiedPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    metrics30m?: SortOrderInput | SortOrder
    metrics1h?: SortOrderInput | SortOrder
    metrics24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId?: string
    AND?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    OR?: UnifiedPerformanceWhereInput[]
    NOT?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    contentType?: StringFilter<"UnifiedPerformance"> | string
    metrics30m?: JsonNullableFilter<"UnifiedPerformance">
    metrics1h?: JsonNullableFilter<"UnifiedPerformance">
    metrics24h?: JsonNullableFilter<"UnifiedPerformance">
    engagementRate?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    collectedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
  }, "id" | "contentId">

  export type UnifiedPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    metrics30m?: SortOrderInput | SortOrder
    metrics1h?: SortOrderInput | SortOrder
    metrics24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnifiedPerformanceCountOrderByAggregateInput
    _avg?: UnifiedPerformanceAvgOrderByAggregateInput
    _max?: UnifiedPerformanceMaxOrderByAggregateInput
    _min?: UnifiedPerformanceMinOrderByAggregateInput
    _sum?: UnifiedPerformanceSumOrderByAggregateInput
  }

  export type UnifiedPerformanceScalarWhereWithAggregatesInput = {
    AND?: UnifiedPerformanceScalarWhereWithAggregatesInput | UnifiedPerformanceScalarWhereWithAggregatesInput[]
    OR?: UnifiedPerformanceScalarWhereWithAggregatesInput[]
    NOT?: UnifiedPerformanceScalarWhereWithAggregatesInput | UnifiedPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnifiedPerformance"> | string
    contentId?: StringWithAggregatesFilter<"UnifiedPerformance"> | string
    contentType?: StringWithAggregatesFilter<"UnifiedPerformance"> | string
    metrics30m?: JsonNullableWithAggregatesFilter<"UnifiedPerformance">
    metrics1h?: JsonNullableWithAggregatesFilter<"UnifiedPerformance">
    metrics24h?: JsonNullableWithAggregatesFilter<"UnifiedPerformance">
    engagementRate?: FloatNullableWithAggregatesFilter<"UnifiedPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"UnifiedPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"UnifiedPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnifiedPerformance"> | Date | string
  }

  export type NewsViralRelationWhereInput = {
    AND?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    OR?: NewsViralRelationWhereInput[]
    NOT?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    id?: StringFilter<"NewsViralRelation"> | string
    newsId?: StringFilter<"NewsViralRelation"> | string
    sessionId?: StringFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeFilter<"NewsViralRelation"> | Date | string
    newsArticle?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
    session?: XOR<ViralSessionRelationFilter, ViralSessionWhereInput>
  }

  export type NewsViralRelationOrderByWithRelationInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
    newsArticle?: NewsArticleOrderByWithRelationInput
    session?: ViralSessionOrderByWithRelationInput
  }

  export type NewsViralRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    newsId_sessionId?: NewsViralRelationNewsIdSessionIdCompoundUniqueInput
    AND?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    OR?: NewsViralRelationWhereInput[]
    NOT?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    newsId?: StringFilter<"NewsViralRelation"> | string
    sessionId?: StringFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeFilter<"NewsViralRelation"> | Date | string
    newsArticle?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
    session?: XOR<ViralSessionRelationFilter, ViralSessionWhereInput>
  }, "id" | "newsId_sessionId">

  export type NewsViralRelationOrderByWithAggregationInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
    _count?: NewsViralRelationCountOrderByAggregateInput
    _avg?: NewsViralRelationAvgOrderByAggregateInput
    _max?: NewsViralRelationMaxOrderByAggregateInput
    _min?: NewsViralRelationMinOrderByAggregateInput
    _sum?: NewsViralRelationSumOrderByAggregateInput
  }

  export type NewsViralRelationScalarWhereWithAggregatesInput = {
    AND?: NewsViralRelationScalarWhereWithAggregatesInput | NewsViralRelationScalarWhereWithAggregatesInput[]
    OR?: NewsViralRelationScalarWhereWithAggregatesInput[]
    NOT?: NewsViralRelationScalarWhereWithAggregatesInput | NewsViralRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsViralRelation"> | string
    newsId?: StringWithAggregatesFilter<"NewsViralRelation"> | string
    sessionId?: StringWithAggregatesFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableWithAggregatesFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolWithAggregatesFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsViralRelation"> | Date | string
  }

  export type SessionActivityLogWhereInput = {
    AND?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    OR?: SessionActivityLogWhereInput[]
    NOT?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    id?: StringFilter<"SessionActivityLog"> | string
    sessionId?: StringFilter<"SessionActivityLog"> | string
    sessionType?: StringFilter<"SessionActivityLog"> | string
    activityType?: StringFilter<"SessionActivityLog"> | string
    details?: JsonNullableFilter<"SessionActivityLog">
    createdAt?: DateTimeFilter<"SessionActivityLog"> | Date | string
  }

  export type SessionActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SessionActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    OR?: SessionActivityLogWhereInput[]
    NOT?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    sessionId?: StringFilter<"SessionActivityLog"> | string
    sessionType?: StringFilter<"SessionActivityLog"> | string
    activityType?: StringFilter<"SessionActivityLog"> | string
    details?: JsonNullableFilter<"SessionActivityLog">
    createdAt?: DateTimeFilter<"SessionActivityLog"> | Date | string
  }, "id">

  export type SessionActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionActivityLogCountOrderByAggregateInput
    _max?: SessionActivityLogMaxOrderByAggregateInput
    _min?: SessionActivityLogMinOrderByAggregateInput
  }

  export type SessionActivityLogScalarWhereWithAggregatesInput = {
    AND?: SessionActivityLogScalarWhereWithAggregatesInput | SessionActivityLogScalarWhereWithAggregatesInput[]
    OR?: SessionActivityLogScalarWhereWithAggregatesInput[]
    NOT?: SessionActivityLogScalarWhereWithAggregatesInput | SessionActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    sessionId?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    sessionType?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    activityType?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    details?: JsonNullableWithAggregatesFilter<"SessionActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"SessionActivityLog"> | Date | string
  }

  export type ApiErrorLogWhereInput = {
    AND?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    OR?: ApiErrorLogWhereInput[]
    NOT?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    id?: StringFilter<"ApiErrorLog"> | string
    endpoint?: StringFilter<"ApiErrorLog"> | string
    method?: StringFilter<"ApiErrorLog"> | string
    statusCode?: IntFilter<"ApiErrorLog"> | number
    errorMessage?: StringNullableFilter<"ApiErrorLog"> | string | null
    stackTrace?: StringNullableFilter<"ApiErrorLog"> | string | null
    requestBody?: JsonNullableFilter<"ApiErrorLog">
    requestHeaders?: JsonNullableFilter<"ApiErrorLog">
    userAgent?: StringNullableFilter<"ApiErrorLog"> | string | null
    ipAddress?: StringNullableFilter<"ApiErrorLog"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorLog"> | Date | string
  }

  export type ApiErrorLogOrderByWithRelationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    stackTrace?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    OR?: ApiErrorLogWhereInput[]
    NOT?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    endpoint?: StringFilter<"ApiErrorLog"> | string
    method?: StringFilter<"ApiErrorLog"> | string
    statusCode?: IntFilter<"ApiErrorLog"> | number
    errorMessage?: StringNullableFilter<"ApiErrorLog"> | string | null
    stackTrace?: StringNullableFilter<"ApiErrorLog"> | string | null
    requestBody?: JsonNullableFilter<"ApiErrorLog">
    requestHeaders?: JsonNullableFilter<"ApiErrorLog">
    userAgent?: StringNullableFilter<"ApiErrorLog"> | string | null
    ipAddress?: StringNullableFilter<"ApiErrorLog"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorLog"> | Date | string
  }, "id">

  export type ApiErrorLogOrderByWithAggregationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    stackTrace?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiErrorLogCountOrderByAggregateInput
    _avg?: ApiErrorLogAvgOrderByAggregateInput
    _max?: ApiErrorLogMaxOrderByAggregateInput
    _min?: ApiErrorLogMinOrderByAggregateInput
    _sum?: ApiErrorLogSumOrderByAggregateInput
  }

  export type ApiErrorLogScalarWhereWithAggregatesInput = {
    AND?: ApiErrorLogScalarWhereWithAggregatesInput | ApiErrorLogScalarWhereWithAggregatesInput[]
    OR?: ApiErrorLogScalarWhereWithAggregatesInput[]
    NOT?: ApiErrorLogScalarWhereWithAggregatesInput | ApiErrorLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiErrorLog"> | string
    endpoint?: StringWithAggregatesFilter<"ApiErrorLog"> | string
    method?: StringWithAggregatesFilter<"ApiErrorLog"> | string
    statusCode?: IntWithAggregatesFilter<"ApiErrorLog"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    stackTrace?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    requestBody?: JsonNullableWithAggregatesFilter<"ApiErrorLog">
    requestHeaders?: JsonNullableWithAggregatesFilter<"ApiErrorLog">
    userAgent?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiErrorLog"> | Date | string
  }

  export type ViralSessionWhereInput = {
    AND?: ViralSessionWhereInput | ViralSessionWhereInput[]
    OR?: ViralSessionWhereInput[]
    NOT?: ViralSessionWhereInput | ViralSessionWhereInput[]
    id?: StringFilter<"ViralSession"> | string
    theme?: StringFilter<"ViralSession"> | string
    platform?: StringFilter<"ViralSession"> | string
    style?: StringFilter<"ViralSession"> | string
    status?: StringFilter<"ViralSession"> | string
    createdAt?: DateTimeFilter<"ViralSession"> | Date | string
    characterProfileId?: StringNullableFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableFilter<"ViralSession"> | string | null
    topics?: JsonNullableFilter<"ViralSession">
    concepts?: JsonNullableFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableFilter<"ViralSession">
    drafts?: ViralDraftV2ListRelationFilter
    characterProfile?: XOR<CharacterProfileNullableRelationFilter, CharacterProfileWhereInput> | null
    newsRelations?: NewsViralRelationListRelationFilter
    integratedSessions?: IntegratedSessionListRelationFilter
  }

  export type ViralSessionOrderByWithRelationInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrderInput | SortOrder
    voiceStyleMode?: SortOrderInput | SortOrder
    topics?: SortOrderInput | SortOrder
    concepts?: SortOrderInput | SortOrder
    selectedIds?: SortOrder
    contents?: SortOrderInput | SortOrder
    drafts?: ViralDraftV2OrderByRelationAggregateInput
    characterProfile?: CharacterProfileOrderByWithRelationInput
    newsRelations?: NewsViralRelationOrderByRelationAggregateInput
    integratedSessions?: IntegratedSessionOrderByRelationAggregateInput
  }

  export type ViralSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViralSessionWhereInput | ViralSessionWhereInput[]
    OR?: ViralSessionWhereInput[]
    NOT?: ViralSessionWhereInput | ViralSessionWhereInput[]
    theme?: StringFilter<"ViralSession"> | string
    platform?: StringFilter<"ViralSession"> | string
    style?: StringFilter<"ViralSession"> | string
    status?: StringFilter<"ViralSession"> | string
    createdAt?: DateTimeFilter<"ViralSession"> | Date | string
    characterProfileId?: StringNullableFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableFilter<"ViralSession"> | string | null
    topics?: JsonNullableFilter<"ViralSession">
    concepts?: JsonNullableFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableFilter<"ViralSession">
    drafts?: ViralDraftV2ListRelationFilter
    characterProfile?: XOR<CharacterProfileNullableRelationFilter, CharacterProfileWhereInput> | null
    newsRelations?: NewsViralRelationListRelationFilter
    integratedSessions?: IntegratedSessionListRelationFilter
  }, "id">

  export type ViralSessionOrderByWithAggregationInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrderInput | SortOrder
    voiceStyleMode?: SortOrderInput | SortOrder
    topics?: SortOrderInput | SortOrder
    concepts?: SortOrderInput | SortOrder
    selectedIds?: SortOrder
    contents?: SortOrderInput | SortOrder
    _count?: ViralSessionCountOrderByAggregateInput
    _max?: ViralSessionMaxOrderByAggregateInput
    _min?: ViralSessionMinOrderByAggregateInput
  }

  export type ViralSessionScalarWhereWithAggregatesInput = {
    AND?: ViralSessionScalarWhereWithAggregatesInput | ViralSessionScalarWhereWithAggregatesInput[]
    OR?: ViralSessionScalarWhereWithAggregatesInput[]
    NOT?: ViralSessionScalarWhereWithAggregatesInput | ViralSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViralSession"> | string
    theme?: StringWithAggregatesFilter<"ViralSession"> | string
    platform?: StringWithAggregatesFilter<"ViralSession"> | string
    style?: StringWithAggregatesFilter<"ViralSession"> | string
    status?: StringWithAggregatesFilter<"ViralSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ViralSession"> | Date | string
    characterProfileId?: StringNullableWithAggregatesFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableWithAggregatesFilter<"ViralSession"> | string | null
    topics?: JsonNullableWithAggregatesFilter<"ViralSession">
    concepts?: JsonNullableWithAggregatesFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableWithAggregatesFilter<"ViralSession">
  }

  export type ViralDraftV2WhereInput = {
    AND?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    OR?: ViralDraftV2WhereInput[]
    NOT?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    id?: StringFilter<"ViralDraftV2"> | string
    sessionId?: StringFilter<"ViralDraftV2"> | string
    conceptId?: StringFilter<"ViralDraftV2"> | string
    title?: StringFilter<"ViralDraftV2"> | string
    content?: StringFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterId?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    status?: StringFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    session?: XOR<ViralSessionRelationFilter, ViralSessionWhereInput>
    performance?: XOR<ViralDraftPerformanceNullableRelationFilter, ViralDraftPerformanceWhereInput> | null
    scheduledRTs?: ScheduledRetweetListRelationFilter
  }

  export type ViralDraftV2OrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    hashtags?: SortOrder
    visualNote?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    characterId?: SortOrderInput | SortOrder
    characterNote?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    tweetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: ViralSessionOrderByWithRelationInput
    performance?: ViralDraftPerformanceOrderByWithRelationInput
    scheduledRTs?: ScheduledRetweetOrderByRelationAggregateInput
  }

  export type ViralDraftV2WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    OR?: ViralDraftV2WhereInput[]
    NOT?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    sessionId?: StringFilter<"ViralDraftV2"> | string
    conceptId?: StringFilter<"ViralDraftV2"> | string
    title?: StringFilter<"ViralDraftV2"> | string
    content?: StringFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterId?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    status?: StringFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    session?: XOR<ViralSessionRelationFilter, ViralSessionWhereInput>
    performance?: XOR<ViralDraftPerformanceNullableRelationFilter, ViralDraftPerformanceWhereInput> | null
    scheduledRTs?: ScheduledRetweetListRelationFilter
  }, "id">

  export type ViralDraftV2OrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    hashtags?: SortOrder
    visualNote?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    characterId?: SortOrderInput | SortOrder
    characterNote?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    tweetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ViralDraftV2CountOrderByAggregateInput
    _max?: ViralDraftV2MaxOrderByAggregateInput
    _min?: ViralDraftV2MinOrderByAggregateInput
  }

  export type ViralDraftV2ScalarWhereWithAggregatesInput = {
    AND?: ViralDraftV2ScalarWhereWithAggregatesInput | ViralDraftV2ScalarWhereWithAggregatesInput[]
    OR?: ViralDraftV2ScalarWhereWithAggregatesInput[]
    NOT?: ViralDraftV2ScalarWhereWithAggregatesInput | ViralDraftV2ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    sessionId?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    conceptId?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    title?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    content?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    characterId?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    status?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViralDraftV2"> | Date | string
  }

  export type ViralDraftPerformanceWhereInput = {
    AND?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    OR?: ViralDraftPerformanceWhereInput[]
    NOT?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    id?: StringFilter<"ViralDraftPerformance"> | string
    draftId?: StringFilter<"ViralDraftPerformance"> | string
    likes30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    draft?: XOR<ViralDraftV2RelationFilter, ViralDraftV2WhereInput>
  }

  export type ViralDraftPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    draft?: ViralDraftV2OrderByWithRelationInput
  }

  export type ViralDraftPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId?: string
    AND?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    OR?: ViralDraftPerformanceWhereInput[]
    NOT?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    likes30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    draft?: XOR<ViralDraftV2RelationFilter, ViralDraftV2WhereInput>
  }, "id" | "draftId">

  export type ViralDraftPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ViralDraftPerformanceCountOrderByAggregateInput
    _avg?: ViralDraftPerformanceAvgOrderByAggregateInput
    _max?: ViralDraftPerformanceMaxOrderByAggregateInput
    _min?: ViralDraftPerformanceMinOrderByAggregateInput
    _sum?: ViralDraftPerformanceSumOrderByAggregateInput
  }

  export type ViralDraftPerformanceScalarWhereWithAggregatesInput = {
    AND?: ViralDraftPerformanceScalarWhereWithAggregatesInput | ViralDraftPerformanceScalarWhereWithAggregatesInput[]
    OR?: ViralDraftPerformanceScalarWhereWithAggregatesInput[]
    NOT?: ViralDraftPerformanceScalarWhereWithAggregatesInput | ViralDraftPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViralDraftPerformance"> | string
    draftId?: StringWithAggregatesFilter<"ViralDraftPerformance"> | string
    likes30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    retweets30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    replies30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    impressions30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    likes1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    retweets1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    replies1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    impressions1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    likes24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    retweets24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    replies24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    impressions24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    engagementRate?: FloatNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"ViralDraftPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViralDraftPerformance"> | Date | string
  }

  export type CharacterProfileWhereInput = {
    AND?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    OR?: CharacterProfileWhereInput[]
    NOT?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    id?: StringFilter<"CharacterProfile"> | string
    name?: StringFilter<"CharacterProfile"> | string
    age?: IntFilter<"CharacterProfile"> | number
    gender?: StringFilter<"CharacterProfile"> | string
    tone?: StringFilter<"CharacterProfile"> | string
    catchphrase?: StringFilter<"CharacterProfile"> | string
    philosophy?: StringNullableFilter<"CharacterProfile"> | string | null
    voiceStyle?: JsonFilter<"CharacterProfile">
    topics?: JsonFilter<"CharacterProfile">
    visual?: JsonNullableFilter<"CharacterProfile">
    isDefault?: BoolFilter<"CharacterProfile"> | boolean
    userId?: StringNullableFilter<"CharacterProfile"> | string | null
    createdAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableFilter<"CharacterProfile">
    topicExpertise?: JsonNullableFilter<"CharacterProfile">
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    sessions?: ViralSessionListRelationFilter
  }

  export type CharacterProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    tone?: SortOrder
    catchphrase?: SortOrder
    philosophy?: SortOrderInput | SortOrder
    voiceStyle?: SortOrder
    topics?: SortOrder
    visual?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredNewsCategories?: SortOrder
    newsCommentStyle?: SortOrderInput | SortOrder
    topicExpertise?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    sessions?: ViralSessionOrderByRelationAggregateInput
  }

  export type CharacterProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    OR?: CharacterProfileWhereInput[]
    NOT?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    name?: StringFilter<"CharacterProfile"> | string
    age?: IntFilter<"CharacterProfile"> | number
    gender?: StringFilter<"CharacterProfile"> | string
    tone?: StringFilter<"CharacterProfile"> | string
    catchphrase?: StringFilter<"CharacterProfile"> | string
    philosophy?: StringNullableFilter<"CharacterProfile"> | string | null
    voiceStyle?: JsonFilter<"CharacterProfile">
    topics?: JsonFilter<"CharacterProfile">
    visual?: JsonNullableFilter<"CharacterProfile">
    isDefault?: BoolFilter<"CharacterProfile"> | boolean
    userId?: StringNullableFilter<"CharacterProfile"> | string | null
    createdAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableFilter<"CharacterProfile">
    topicExpertise?: JsonNullableFilter<"CharacterProfile">
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    sessions?: ViralSessionListRelationFilter
  }, "id">

  export type CharacterProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    tone?: SortOrder
    catchphrase?: SortOrder
    philosophy?: SortOrderInput | SortOrder
    voiceStyle?: SortOrder
    topics?: SortOrder
    visual?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredNewsCategories?: SortOrder
    newsCommentStyle?: SortOrderInput | SortOrder
    topicExpertise?: SortOrderInput | SortOrder
    _count?: CharacterProfileCountOrderByAggregateInput
    _avg?: CharacterProfileAvgOrderByAggregateInput
    _max?: CharacterProfileMaxOrderByAggregateInput
    _min?: CharacterProfileMinOrderByAggregateInput
    _sum?: CharacterProfileSumOrderByAggregateInput
  }

  export type CharacterProfileScalarWhereWithAggregatesInput = {
    AND?: CharacterProfileScalarWhereWithAggregatesInput | CharacterProfileScalarWhereWithAggregatesInput[]
    OR?: CharacterProfileScalarWhereWithAggregatesInput[]
    NOT?: CharacterProfileScalarWhereWithAggregatesInput | CharacterProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterProfile"> | string
    name?: StringWithAggregatesFilter<"CharacterProfile"> | string
    age?: IntWithAggregatesFilter<"CharacterProfile"> | number
    gender?: StringWithAggregatesFilter<"CharacterProfile"> | string
    tone?: StringWithAggregatesFilter<"CharacterProfile"> | string
    catchphrase?: StringWithAggregatesFilter<"CharacterProfile"> | string
    philosophy?: StringNullableWithAggregatesFilter<"CharacterProfile"> | string | null
    voiceStyle?: JsonWithAggregatesFilter<"CharacterProfile">
    topics?: JsonWithAggregatesFilter<"CharacterProfile">
    visual?: JsonNullableWithAggregatesFilter<"CharacterProfile">
    isDefault?: BoolWithAggregatesFilter<"CharacterProfile"> | boolean
    userId?: StringNullableWithAggregatesFilter<"CharacterProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableWithAggregatesFilter<"CharacterProfile">
    topicExpertise?: JsonNullableWithAggregatesFilter<"CharacterProfile">
  }

  export type BuzzInfluencerWhereInput = {
    AND?: BuzzInfluencerWhereInput | BuzzInfluencerWhereInput[]
    OR?: BuzzInfluencerWhereInput[]
    NOT?: BuzzInfluencerWhereInput | BuzzInfluencerWhereInput[]
    id?: StringFilter<"BuzzInfluencer"> | string
    username?: StringFilter<"BuzzInfluencer"> | string
    userId?: StringFilter<"BuzzInfluencer"> | string
    followers?: IntFilter<"BuzzInfluencer"> | number
    following?: IntFilter<"BuzzInfluencer"> | number
    verified?: BoolFilter<"BuzzInfluencer"> | boolean
    profileImage?: StringNullableFilter<"BuzzInfluencer"> | string | null
    bio?: StringNullableFilter<"BuzzInfluencer"> | string | null
    metrics7d?: JsonNullableFilter<"BuzzInfluencer">
    metrics30d?: JsonNullableFilter<"BuzzInfluencer">
    metricsAllTime?: JsonNullableFilter<"BuzzInfluencer">
    categoryScores?: JsonFilter<"BuzzInfluencer">
    primaryCategory?: StringNullableFilter<"BuzzInfluencer"> | string | null
    engagementRate?: FloatFilter<"BuzzInfluencer"> | number
    viralScore?: FloatFilter<"BuzzInfluencer"> | number
    consistencyScore?: FloatFilter<"BuzzInfluencer"> | number
    bestPostingHours?: JsonNullableFilter<"BuzzInfluencer">
    postingFrequency?: JsonNullableFilter<"BuzzInfluencer">
    lastActiveAt?: DateTimeNullableFilter<"BuzzInfluencer"> | Date | string | null
    lastAnalyzedAt?: DateTimeNullableFilter<"BuzzInfluencer"> | Date | string | null
    createdAt?: DateTimeFilter<"BuzzInfluencer"> | Date | string
    updatedAt?: DateTimeFilter<"BuzzInfluencer"> | Date | string
  }

  export type BuzzInfluencerOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    verified?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    metrics7d?: SortOrderInput | SortOrder
    metrics30d?: SortOrderInput | SortOrder
    metricsAllTime?: SortOrderInput | SortOrder
    categoryScores?: SortOrder
    primaryCategory?: SortOrderInput | SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
    bestPostingHours?: SortOrderInput | SortOrder
    postingFrequency?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    lastAnalyzedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzInfluencerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: BuzzInfluencerWhereInput | BuzzInfluencerWhereInput[]
    OR?: BuzzInfluencerWhereInput[]
    NOT?: BuzzInfluencerWhereInput | BuzzInfluencerWhereInput[]
    userId?: StringFilter<"BuzzInfluencer"> | string
    followers?: IntFilter<"BuzzInfluencer"> | number
    following?: IntFilter<"BuzzInfluencer"> | number
    verified?: BoolFilter<"BuzzInfluencer"> | boolean
    profileImage?: StringNullableFilter<"BuzzInfluencer"> | string | null
    bio?: StringNullableFilter<"BuzzInfluencer"> | string | null
    metrics7d?: JsonNullableFilter<"BuzzInfluencer">
    metrics30d?: JsonNullableFilter<"BuzzInfluencer">
    metricsAllTime?: JsonNullableFilter<"BuzzInfluencer">
    categoryScores?: JsonFilter<"BuzzInfluencer">
    primaryCategory?: StringNullableFilter<"BuzzInfluencer"> | string | null
    engagementRate?: FloatFilter<"BuzzInfluencer"> | number
    viralScore?: FloatFilter<"BuzzInfluencer"> | number
    consistencyScore?: FloatFilter<"BuzzInfluencer"> | number
    bestPostingHours?: JsonNullableFilter<"BuzzInfluencer">
    postingFrequency?: JsonNullableFilter<"BuzzInfluencer">
    lastActiveAt?: DateTimeNullableFilter<"BuzzInfluencer"> | Date | string | null
    lastAnalyzedAt?: DateTimeNullableFilter<"BuzzInfluencer"> | Date | string | null
    createdAt?: DateTimeFilter<"BuzzInfluencer"> | Date | string
    updatedAt?: DateTimeFilter<"BuzzInfluencer"> | Date | string
  }, "id" | "username">

  export type BuzzInfluencerOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    verified?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    metrics7d?: SortOrderInput | SortOrder
    metrics30d?: SortOrderInput | SortOrder
    metricsAllTime?: SortOrderInput | SortOrder
    categoryScores?: SortOrder
    primaryCategory?: SortOrderInput | SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
    bestPostingHours?: SortOrderInput | SortOrder
    postingFrequency?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    lastAnalyzedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuzzInfluencerCountOrderByAggregateInput
    _avg?: BuzzInfluencerAvgOrderByAggregateInput
    _max?: BuzzInfluencerMaxOrderByAggregateInput
    _min?: BuzzInfluencerMinOrderByAggregateInput
    _sum?: BuzzInfluencerSumOrderByAggregateInput
  }

  export type BuzzInfluencerScalarWhereWithAggregatesInput = {
    AND?: BuzzInfluencerScalarWhereWithAggregatesInput | BuzzInfluencerScalarWhereWithAggregatesInput[]
    OR?: BuzzInfluencerScalarWhereWithAggregatesInput[]
    NOT?: BuzzInfluencerScalarWhereWithAggregatesInput | BuzzInfluencerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuzzInfluencer"> | string
    username?: StringWithAggregatesFilter<"BuzzInfluencer"> | string
    userId?: StringWithAggregatesFilter<"BuzzInfluencer"> | string
    followers?: IntWithAggregatesFilter<"BuzzInfluencer"> | number
    following?: IntWithAggregatesFilter<"BuzzInfluencer"> | number
    verified?: BoolWithAggregatesFilter<"BuzzInfluencer"> | boolean
    profileImage?: StringNullableWithAggregatesFilter<"BuzzInfluencer"> | string | null
    bio?: StringNullableWithAggregatesFilter<"BuzzInfluencer"> | string | null
    metrics7d?: JsonNullableWithAggregatesFilter<"BuzzInfluencer">
    metrics30d?: JsonNullableWithAggregatesFilter<"BuzzInfluencer">
    metricsAllTime?: JsonNullableWithAggregatesFilter<"BuzzInfluencer">
    categoryScores?: JsonWithAggregatesFilter<"BuzzInfluencer">
    primaryCategory?: StringNullableWithAggregatesFilter<"BuzzInfluencer"> | string | null
    engagementRate?: FloatWithAggregatesFilter<"BuzzInfluencer"> | number
    viralScore?: FloatWithAggregatesFilter<"BuzzInfluencer"> | number
    consistencyScore?: FloatWithAggregatesFilter<"BuzzInfluencer"> | number
    bestPostingHours?: JsonNullableWithAggregatesFilter<"BuzzInfluencer">
    postingFrequency?: JsonNullableWithAggregatesFilter<"BuzzInfluencer">
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"BuzzInfluencer"> | Date | string | null
    lastAnalyzedAt?: DateTimeNullableWithAggregatesFilter<"BuzzInfluencer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BuzzInfluencer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuzzInfluencer"> | Date | string
  }

  export type BuzzPostCreateInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
    scheduledPosts?: ScheduledPostCreateNestedManyWithoutRefPostInput
  }

  export type BuzzPostUncheckedCreateInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
    scheduledPosts?: ScheduledPostUncheckedCreateNestedManyWithoutRefPostInput
  }

  export type BuzzPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduledPosts?: ScheduledPostUpdateManyWithoutRefPostNestedInput
  }

  export type BuzzPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduledPosts?: ScheduledPostUncheckedUpdateManyWithoutRefPostNestedInput
  }

  export type BuzzPostCreateManyInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzConfigCreateInput = {
    id: string
    keywords?: BuzzConfigCreatekeywordsInput | string[]
    accounts?: BuzzConfigCreateaccountsInput | string[]
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzConfigUncheckedCreateInput = {
    id: string
    keywords?: BuzzConfigCreatekeywordsInput | string[]
    accounts?: BuzzConfigCreateaccountsInput | string[]
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzConfigCreateManyInput = {
    id: string
    keywords?: BuzzConfigCreatekeywordsInput | string[]
    accounts?: BuzzConfigCreateaccountsInput | string[]
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostCreateInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    refPost?: BuzzPostCreateNestedOneWithoutScheduledPostsInput
  }

  export type ScheduledPostUncheckedCreateInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refPost?: BuzzPostUpdateOneWithoutScheduledPostsNestedInput
  }

  export type ScheduledPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostCreateManyInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateInput = {
    id?: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt?: Date | string
  }

  export type PostAnalyticsUncheckedCreateInput = {
    id?: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt?: Date | string
  }

  export type PostAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateManyInput = {
    id?: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt?: Date | string
  }

  export type PostAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
    characterProfiles?: CharacterProfileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
    characterProfiles?: CharacterProfileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
    characterProfiles?: CharacterProfileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
    characterProfiles?: CharacterProfileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceCreateInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
    articles?: NewsArticleCreateNestedManyWithoutSourceInput
  }

  export type NewsSourceUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
    articles?: NewsArticleUncheckedCreateNestedManyWithoutSourceInput
  }

  export type NewsSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: NewsArticleUpdateManyWithoutSourceNestedInput
  }

  export type NewsSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: NewsArticleUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type NewsSourceCreateManyInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
  }

  export type NewsSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleCreateInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
    viralRelations?: NewsViralRelationCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleUncheckedCreateInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
    viralRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUncheckedUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleCreateManyInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsThreadCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
    items?: NewsThreadItemCreateNestedManyWithoutThreadInput
  }

  export type NewsThreadUncheckedCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
    items?: NewsThreadItemUncheckedCreateNestedManyWithoutThreadInput
  }

  export type NewsThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: NewsThreadItemUpdateManyWithoutThreadNestedInput
  }

  export type NewsThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: NewsThreadItemUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type NewsThreadCreateManyInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadItemCreateInput = {
    id?: string
    order: number
    content?: string | null
    createdAt?: Date | string
    thread: NewsThreadCreateNestedOneWithoutItemsInput
    article: NewsArticleCreateNestedOneWithoutNewsThreadItemsInput
  }

  export type NewsThreadItemUncheckedCreateInput = {
    id?: string
    threadId: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: NewsThreadUpdateOneRequiredWithoutItemsNestedInput
    article?: NewsArticleUpdateOneRequiredWithoutNewsThreadItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemCreateManyInput = {
    id?: string
    threadId: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisCreateInput = {
    id?: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
    article: NewsArticleCreateNestedOneWithoutAnalysisInput
  }

  export type NewsAnalysisUncheckedCreateInput = {
    id?: string
    articleId: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: NewsArticleUpdateOneRequiredWithoutAnalysisNestedInput
  }

  export type NewsAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisCreateManyInput = {
    id?: string
    articleId: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    runAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUncheckedCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    runAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueCreateManyInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    runAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetCreateInput = {
    id?: string
    name: string
    description?: string | null
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserCreateInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistUsersInput
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserCreateManyInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
  }

  export type WatchlistUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetCreateInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
    watchlistUser: WatchlistUserCreateNestedOneWithoutTweetsInput
  }

  export type WatchlistTweetUncheckedCreateInput = {
    id?: string
    watchlistUserId: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUser?: WatchlistUserUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type WatchlistTweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetCreateManyInput = {
    id?: string
    watchlistUserId: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryCreateInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    watchlistUser: WatchlistUserCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionHistoryUncheckedCreateInput = {
    id?: string
    watchlistUserId: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUser?: WatchlistUserUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryCreateManyInput = {
    id?: string
    watchlistUserId: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportCreateInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    contentAngles: JsonNullValueInput | InputJsonValue
    marketContext: JsonNullValueInput | InputJsonValue
    competitorActivity: JsonNullValueInput | InputJsonValue
    riskFactors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUncheckedCreateInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    contentAngles: JsonNullValueInput | InputJsonValue
    marketContext: JsonNullValueInput | InputJsonValue
    competitorActivity: JsonNullValueInput | InputJsonValue
    riskFactors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportCreateManyInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    contentAngles: JsonNullValueInput | InputJsonValue
    marketContext: JsonNullValueInput | InputJsonValue
    competitorActivity: JsonNullValueInput | InputJsonValue
    riskFactors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotSessionCreateInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseCreateNestedManyWithoutSessionInput
    drafts?: CotDraftCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseUncheckedCreateNestedManyWithoutSessionInput
    drafts?: CotDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUpdateManyWithoutSessionNestedInput
    drafts?: CotDraftUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUncheckedUpdateManyWithoutSessionNestedInput
    drafts?: CotDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionCreateManyInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CotSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CotSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CotPhaseCreateInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutPhasesInput
  }

  export type CotPhaseUncheckedCreateInput = {
    id?: string
    sessionId: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type CotPhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseCreateManyInput = {
    id?: string
    sessionId: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftCreateInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutDraftsInput
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetCreateNestedManyWithoutCotDraftInput
  }

  export type CotDraftUncheckedCreateInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetUncheckedCreateNestedManyWithoutCotDraftInput
  }

  export type CotDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUpdateManyWithoutCotDraftNestedInput
  }

  export type CotDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUncheckedUpdateManyWithoutCotDraftNestedInput
  }

  export type CotDraftCreateManyInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceCreateInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
    draft: CotDraftCreateNestedOneWithoutPerformanceInput
  }

  export type CotDraftPerformanceUncheckedCreateInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: CotDraftUpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type CotDraftPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceCreateManyInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedContentSourceCreateInput = {
    id?: string
    sourceType: string
    sourceId: string
    contentSummary?: string | null
    importanceScore?: number | null
    viralPotential?: number | null
    keywords?: UnifiedContentSourceCreatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    integratedSessions?: IntegratedSessionSourceCreateNestedManyWithoutSourceInput
  }

  export type UnifiedContentSourceUncheckedCreateInput = {
    id?: string
    sourceType: string
    sourceId: string
    contentSummary?: string | null
    importanceScore?: number | null
    viralPotential?: number | null
    keywords?: UnifiedContentSourceCreatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    integratedSessions?: IntegratedSessionSourceUncheckedCreateNestedManyWithoutSourceInput
  }

  export type UnifiedContentSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    contentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    importanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    viralPotential?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: UnifiedContentSourceUpdatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integratedSessions?: IntegratedSessionSourceUpdateManyWithoutSourceNestedInput
  }

  export type UnifiedContentSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    contentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    importanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    viralPotential?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: UnifiedContentSourceUpdatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integratedSessions?: IntegratedSessionSourceUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type UnifiedContentSourceCreateManyInput = {
    id?: string
    sourceType: string
    sourceId: string
    contentSummary?: string | null
    importanceScore?: number | null
    viralPotential?: number | null
    keywords?: UnifiedContentSourceCreatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedContentSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    contentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    importanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    viralPotential?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: UnifiedContentSourceUpdatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedContentSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    contentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    importanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    viralPotential?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: UnifiedContentSourceUpdatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedSessionCreateInput = {
    id?: string
    sessionType: string
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    v2Session?: ViralSessionCreateNestedOneWithoutIntegratedSessionsInput
    sources?: IntegratedSessionSourceCreateNestedManyWithoutSessionInput
    drafts?: IntegratedDraftCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionUncheckedCreateInput = {
    id?: string
    sessionType: string
    v2SessionId?: string | null
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sources?: IntegratedSessionSourceUncheckedCreateNestedManyWithoutSessionInput
    drafts?: IntegratedDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    v2Session?: ViralSessionUpdateOneWithoutIntegratedSessionsNestedInput
    sources?: IntegratedSessionSourceUpdateManyWithoutSessionNestedInput
    drafts?: IntegratedDraftUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    v2SessionId?: NullableStringFieldUpdateOperationsInput | string | null
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sources?: IntegratedSessionSourceUncheckedUpdateManyWithoutSessionNestedInput
    drafts?: IntegratedDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionCreateManyInput = {
    id?: string
    sessionType: string
    v2SessionId?: string | null
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type IntegratedSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegratedSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    v2SessionId?: NullableStringFieldUpdateOperationsInput | string | null
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegratedSessionSourceCreateInput = {
    id?: string
    relevanceScore?: number | null
    usageType: string
    session: IntegratedSessionCreateNestedOneWithoutSourcesInput
    source: UnifiedContentSourceCreateNestedOneWithoutIntegratedSessionsInput
  }

  export type IntegratedSessionSourceUncheckedCreateInput = {
    id?: string
    sessionId: string
    sourceId: string
    relevanceScore?: number | null
    usageType: string
  }

  export type IntegratedSessionSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
    session?: IntegratedSessionUpdateOneRequiredWithoutSourcesNestedInput
    source?: UnifiedContentSourceUpdateOneRequiredWithoutIntegratedSessionsNestedInput
  }

  export type IntegratedSessionSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedSessionSourceCreateManyInput = {
    id?: string
    sessionId: string
    sourceId: string
    relevanceScore?: number | null
    usageType: string
  }

  export type IntegratedSessionSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedSessionSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedDraftCreateInput = {
    id?: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: IntegratedSessionCreateNestedOneWithoutDraftsInput
    performance?: IntegratedDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type IntegratedDraftUncheckedCreateInput = {
    id?: string
    sessionId: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: IntegratedDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type IntegratedDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntegratedSessionUpdateOneRequiredWithoutDraftsNestedInput
    performance?: IntegratedDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type IntegratedDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: IntegratedDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type IntegratedDraftCreateManyInput = {
    id?: string
    sessionId: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedDraftPerformanceCreateInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    predictionAccuracy?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
    draft: IntegratedDraftCreateNestedOneWithoutPerformanceInput
  }

  export type IntegratedDraftPerformanceUncheckedCreateInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    predictionAccuracy?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedDraftPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    predictionAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: IntegratedDraftUpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type IntegratedDraftPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    predictionAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedDraftPerformanceCreateManyInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    predictionAccuracy?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedDraftPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    predictionAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedDraftPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    predictionAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetCreateInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viralDraft?: ViralDraftV2CreateNestedOneWithoutScheduledRTsInput
    cotDraft?: CotDraftCreateNestedOneWithoutScheduledRTsInput
  }

  export type ScheduledRetweetUncheckedCreateInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viralDraft?: ViralDraftV2UpdateOneWithoutScheduledRTsNestedInput
    cotDraft?: CotDraftUpdateOneWithoutScheduledRTsNestedInput
  }

  export type ScheduledRetweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetCreateManyInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceCreateInput = {
    id?: string
    contentId: string
    contentType: string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedPerformanceUncheckedCreateInput = {
    id?: string
    contentId: string
    contentType: string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceCreateManyInput = {
    id?: string
    contentId: string
    contentType: string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationCreateInput = {
    id?: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
    newsArticle: NewsArticleCreateNestedOneWithoutViralRelationsInput
    session: ViralSessionCreateNestedOneWithoutNewsRelationsInput
  }

  export type NewsViralRelationUncheckedCreateInput = {
    id?: string
    newsId: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsArticle?: NewsArticleUpdateOneRequiredWithoutViralRelationsNestedInput
    session?: ViralSessionUpdateOneRequiredWithoutNewsRelationsNestedInput
  }

  export type NewsViralRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationCreateManyInput = {
    id?: string
    newsId: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogCreateInput = {
    id?: string
    sessionId: string
    sessionType: string
    activityType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionActivityLogUncheckedCreateInput = {
    id?: string
    sessionId: string
    sessionType: string
    activityType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogCreateManyInput = {
    id?: string
    sessionId: string
    sessionType: string
    activityType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage?: string | null
    stackTrace?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApiErrorLogUncheckedCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage?: string | null
    stackTrace?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApiErrorLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogCreateManyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage?: string | null
    stackTrace?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApiErrorLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralSessionCreateInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2CreateNestedManyWithoutSessionInput
    characterProfile?: CharacterProfileCreateNestedOneWithoutSessionsInput
    newsRelations?: NewsViralRelationCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionUncheckedCreateInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput
    newsRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionUncheckedCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UpdateManyWithoutSessionNestedInput
    characterProfile?: CharacterProfileUpdateOneWithoutSessionsNestedInput
    newsRelations?: NewsViralRelationUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput
    newsRelations?: NewsViralRelationUncheckedUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUncheckedUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralSessionCreateManyInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ViralSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ViralSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ViralDraftV2CreateInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: ViralSessionCreateNestedOneWithoutDraftsInput
    performance?: ViralDraftPerformanceCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetCreateNestedManyWithoutViralDraftInput
  }

  export type ViralDraftV2UncheckedCreateInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetUncheckedCreateNestedManyWithoutViralDraftInput
  }

  export type ViralDraftV2UpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ViralSessionUpdateOneRequiredWithoutDraftsNestedInput
    performance?: ViralDraftPerformanceUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUpdateManyWithoutViralDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUncheckedUpdateManyWithoutViralDraftNestedInput
  }

  export type ViralDraftV2CreateManyInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftV2UpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftV2UncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceCreateInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
    draft: ViralDraftV2CreateNestedOneWithoutPerformanceInput
  }

  export type ViralDraftPerformanceUncheckedCreateInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: ViralDraftV2UpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type ViralDraftPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceCreateManyInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterProfileCreateInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutCharacterProfilesInput
    sessions?: ViralSessionCreateNestedManyWithoutCharacterProfileInput
  }

  export type CharacterProfileUncheckedCreateInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    sessions?: ViralSessionUncheckedCreateNestedManyWithoutCharacterProfileInput
  }

  export type CharacterProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutCharacterProfilesNestedInput
    sessions?: ViralSessionUpdateManyWithoutCharacterProfileNestedInput
  }

  export type CharacterProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    sessions?: ViralSessionUncheckedUpdateManyWithoutCharacterProfileNestedInput
  }

  export type CharacterProfileCreateManyInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BuzzInfluencerCreateInput = {
    id?: string
    username: string
    userId: string
    followers?: number
    following?: number
    verified?: boolean
    profileImage?: string | null
    bio?: string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores: JsonNullValueInput | InputJsonValue
    primaryCategory?: string | null
    engagementRate?: number
    viralScore?: number
    consistencyScore?: number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
    lastAnalyzedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzInfluencerUncheckedCreateInput = {
    id?: string
    username: string
    userId: string
    followers?: number
    following?: number
    verified?: boolean
    profileImage?: string | null
    bio?: string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores: JsonNullValueInput | InputJsonValue
    primaryCategory?: string | null
    engagementRate?: number
    viralScore?: number
    consistencyScore?: number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
    lastAnalyzedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzInfluencerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores?: JsonNullValueInput | InputJsonValue
    primaryCategory?: NullableStringFieldUpdateOperationsInput | string | null
    engagementRate?: FloatFieldUpdateOperationsInput | number
    viralScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzInfluencerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores?: JsonNullValueInput | InputJsonValue
    primaryCategory?: NullableStringFieldUpdateOperationsInput | string | null
    engagementRate?: FloatFieldUpdateOperationsInput | number
    viralScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzInfluencerCreateManyInput = {
    id?: string
    username: string
    userId: string
    followers?: number
    following?: number
    verified?: boolean
    profileImage?: string | null
    bio?: string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores: JsonNullValueInput | InputJsonValue
    primaryCategory?: string | null
    engagementRate?: number
    viralScore?: number
    consistencyScore?: number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
    lastAnalyzedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzInfluencerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores?: JsonNullValueInput | InputJsonValue
    primaryCategory?: NullableStringFieldUpdateOperationsInput | string | null
    engagementRate?: FloatFieldUpdateOperationsInput | number
    viralScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzInfluencerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    metrics7d?: NullableJsonNullValueInput | InputJsonValue
    metrics30d?: NullableJsonNullValueInput | InputJsonValue
    metricsAllTime?: NullableJsonNullValueInput | InputJsonValue
    categoryScores?: JsonNullValueInput | InputJsonValue
    primaryCategory?: NullableStringFieldUpdateOperationsInput | string | null
    engagementRate?: FloatFieldUpdateOperationsInput | number
    viralScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    bestPostingHours?: NullableJsonNullValueInput | InputJsonValue
    postingFrequency?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ScheduledPostListRelationFilter = {
    every?: ScheduledPostWhereInput
    some?: ScheduledPostWhereInput
    none?: ScheduledPostWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ScheduledPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuzzPostCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostAvgOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
  }

  export type BuzzPostMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostSumOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BuzzConfigCountOrderByAggregateInput = {
    id?: SortOrder
    keywords?: SortOrder
    accounts?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigAvgOrderByAggregateInput = {
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
  }

  export type BuzzConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigMinOrderByAggregateInput = {
    id?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigSumOrderByAggregateInput = {
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BuzzPostNullableRelationFilter = {
    is?: BuzzPostWhereInput | null
    isNot?: BuzzPostWhereInput | null
  }

  export type ScheduledPostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    postResult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PostAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsAvgOrderByAggregateInput = {
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
  }

  export type PostAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsSumOrderByAggregateInput = {
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type WatchlistUserListRelationFilter = {
    every?: WatchlistUserWhereInput
    some?: WatchlistUserWhereInput
    none?: WatchlistUserWhereInput
  }

  export type CharacterProfileListRelationFilter = {
    every?: CharacterProfileWhereInput
    some?: CharacterProfileWhereInput
    none?: CharacterProfileWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type NewsArticleListRelationFilter = {
    every?: NewsArticleWhereInput
    some?: NewsArticleWhereInput
    none?: NewsArticleWhereInput
  }

  export type NewsArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsSourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NewsAnalysisNullableRelationFilter = {
    is?: NewsAnalysisWhereInput | null
    isNot?: NewsAnalysisWhereInput | null
  }

  export type NewsSourceRelationFilter = {
    is?: NewsSourceWhereInput
    isNot?: NewsSourceWhereInput
  }

  export type NewsThreadItemListRelationFilter = {
    every?: NewsThreadItemWhereInput
    some?: NewsThreadItemWhereInput
    none?: NewsThreadItemWhereInput
  }

  export type NewsViralRelationListRelationFilter = {
    every?: NewsViralRelationWhereInput
    some?: NewsViralRelationWhereInput
    none?: NewsViralRelationWhereInput
  }

  export type NewsThreadItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsViralRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsArticleCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type NewsArticleAvgOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type NewsArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleSumOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NewsThreadCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadRelationFilter = {
    is?: NewsThreadWhereInput
    isNot?: NewsThreadWhereInput
  }

  export type NewsArticleRelationFilter = {
    is?: NewsArticleWhereInput
    isNot?: NewsArticleWhereInput
  }

  export type NewsThreadItemCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsThreadItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NewsThreadItemMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsThreadItemMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsThreadItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NewsAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    keywords?: SortOrder
    topics?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
  }

  export type JobQueueCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueAvgOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type JobQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueSumOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CollectionPresetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchlistTweetListRelationFilter = {
    every?: WatchlistTweetWhereInput
    some?: WatchlistTweetWhereInput
    none?: WatchlistTweetWhereInput
  }

  export type InteractionHistoryListRelationFilter = {
    every?: InteractionHistoryWhereInput
    some?: InteractionHistoryWhereInput
    none?: InteractionHistoryWhereInput
  }

  export type WatchlistTweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistUserUserIdTwitterIdCompoundUniqueInput = {
    userId: string
    twitterId: string
  }

  export type WatchlistUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchlistUserAvgOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
  }

  export type WatchlistUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchlistUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchlistUserSumOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
  }

  export type WatchlistUserRelationFilter = {
    is?: WatchlistUserWhereInput
    isNot?: WatchlistUserWhereInput
  }

  export type WatchlistTweetCountOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
  }

  export type WatchlistTweetAvgOrderByAggregateInput = {
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
  }

  export type WatchlistTweetMaxOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
  }

  export type WatchlistTweetMinOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
  }

  export type WatchlistTweetSumOrderByAggregateInput = {
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
  }

  export type InteractionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    contentAngles?: SortOrder
    marketContext?: SortOrder
    competitorActivity?: SortOrder
    riskFactors?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCotSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusFilter<$PrismaModel> | $Enums.CotSessionStatus
  }

  export type EnumCotPhaseStepFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepFilter<$PrismaModel> | $Enums.CotPhaseStep
  }

  export type CotPhaseListRelationFilter = {
    every?: CotPhaseWhereInput
    some?: CotPhaseWhereInput
    none?: CotPhaseWhereInput
  }

  export type CotDraftListRelationFilter = {
    every?: CotDraftWhereInput
    some?: CotDraftWhereInput
    none?: CotDraftWhereInput
  }

  export type CotPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotDraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotSessionCountOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionAvgOrderByAggregateInput = {
    currentPhase?: SortOrder
    retryCount?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
  }

  export type CotSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionMinOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionSumOrderByAggregateInput = {
    currentPhase?: SortOrder
    retryCount?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
  }

  export type EnumCotSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCotSessionStatusFilter<$PrismaModel>
  }

  export type EnumCotPhaseStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStepFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStepFilter<$PrismaModel>
  }

  export type EnumCotPhaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusFilter<$PrismaModel> | $Enums.CotPhaseStatus
  }

  export type CotSessionRelationFilter = {
    is?: CotSessionWhereInput
    isNot?: CotSessionWhereInput
  }

  export type CotPhaseSessionIdPhaseNumberCompoundUniqueInput = {
    sessionId: string
    phaseNumber: number
  }

  export type CotPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkResult?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeResult?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateResult?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseAvgOrderByAggregateInput = {
    phaseNumber?: SortOrder
    thinkTokens?: SortOrder
    executeDuration?: SortOrder
    integrateTokens?: SortOrder
  }

  export type CotPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseSumOrderByAggregateInput = {
    phaseNumber?: SortOrder
    thinkTokens?: SortOrder
    executeDuration?: SortOrder
    integrateTokens?: SortOrder
  }

  export type EnumCotPhaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
  }

  export type EnumCotDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusFilter<$PrismaModel> | $Enums.CotDraftStatus
  }

  export type CotDraftPerformanceNullableRelationFilter = {
    is?: CotDraftPerformanceWhereInput | null
    isNot?: CotDraftPerformanceWhereInput | null
  }

  export type ScheduledRetweetListRelationFilter = {
    every?: ScheduledRetweetWhereInput
    some?: ScheduledRetweetWhereInput
    none?: ScheduledRetweetWhereInput
  }

  export type ScheduledRetweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotDraftSessionIdConceptNumberCompoundUniqueInput = {
    sessionId: string
    conceptNumber: number
  }

  export type CotDraftCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    kpis?: SortOrder
    riskAssessment?: SortOrder
    optimizationTips?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftAvgOrderByAggregateInput = {
    conceptNumber?: SortOrder
    viralScore?: SortOrder
  }

  export type CotDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftSumOrderByAggregateInput = {
    conceptNumber?: SortOrder
    viralScore?: SortOrder
  }

  export type EnumCotDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotDraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumCotDraftStatusFilter<$PrismaModel>
  }

  export type CotDraftRelationFilter = {
    is?: CotDraftWhereInput
    isNot?: CotDraftWhereInput
  }

  export type CotDraftPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceAvgOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type CotDraftPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceSumOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type IntegratedSessionSourceListRelationFilter = {
    every?: IntegratedSessionSourceWhereInput
    some?: IntegratedSessionSourceWhereInput
    none?: IntegratedSessionSourceWhereInput
  }

  export type IntegratedSessionSourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnifiedContentSourceCountOrderByAggregateInput = {
    id?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    contentSummary?: SortOrder
    importanceScore?: SortOrder
    viralPotential?: SortOrder
    keywords?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedContentSourceAvgOrderByAggregateInput = {
    importanceScore?: SortOrder
    viralPotential?: SortOrder
  }

  export type UnifiedContentSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    contentSummary?: SortOrder
    importanceScore?: SortOrder
    viralPotential?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedContentSourceMinOrderByAggregateInput = {
    id?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    contentSummary?: SortOrder
    importanceScore?: SortOrder
    viralPotential?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedContentSourceSumOrderByAggregateInput = {
    importanceScore?: SortOrder
    viralPotential?: SortOrder
  }

  export type ViralSessionNullableRelationFilter = {
    is?: ViralSessionWhereInput | null
    isNot?: ViralSessionWhereInput | null
  }

  export type IntegratedDraftListRelationFilter = {
    every?: IntegratedDraftWhereInput
    some?: IntegratedDraftWhereInput
    none?: IntegratedDraftWhereInput
  }

  export type IntegratedDraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegratedSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionType?: SortOrder
    v2SessionId?: SortOrder
    newsArticleIds?: SortOrder
    buzzPostIds?: SortOrder
    generationContext?: SortOrder
    performanceMetrics?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    theme?: SortOrder
    character?: SortOrder
    platform?: SortOrder
    strategy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IntegratedSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionType?: SortOrder
    v2SessionId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    theme?: SortOrder
    character?: SortOrder
    platform?: SortOrder
    strategy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IntegratedSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionType?: SortOrder
    v2SessionId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    theme?: SortOrder
    character?: SortOrder
    platform?: SortOrder
    strategy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IntegratedSessionRelationFilter = {
    is?: IntegratedSessionWhereInput
    isNot?: IntegratedSessionWhereInput
  }

  export type UnifiedContentSourceRelationFilter = {
    is?: UnifiedContentSourceWhereInput
    isNot?: UnifiedContentSourceWhereInput
  }

  export type IntegratedSessionSourceSessionIdSourceIdCompoundUniqueInput = {
    sessionId: string
    sourceId: string
  }

  export type IntegratedSessionSourceCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sourceId?: SortOrder
    relevanceScore?: SortOrder
    usageType?: SortOrder
  }

  export type IntegratedSessionSourceAvgOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type IntegratedSessionSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sourceId?: SortOrder
    relevanceScore?: SortOrder
    usageType?: SortOrder
  }

  export type IntegratedSessionSourceMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sourceId?: SortOrder
    relevanceScore?: SortOrder
    usageType?: SortOrder
  }

  export type IntegratedSessionSourceSumOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type IntegratedDraftPerformanceNullableRelationFilter = {
    is?: IntegratedDraftPerformanceWhereInput | null
    isNot?: IntegratedDraftPerformanceWhereInput | null
  }

  export type IntegratedDraftCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourcesSummary?: SortOrder
    newsContext?: SortOrder
    buzzContext?: SortOrder
    conceptId?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    sourceNewsIds?: SortOrder
    sourceBuzzIds?: SortOrder
    generationStrategy?: SortOrder
    generationData?: SortOrder
    hashtags?: SortOrder
    visualGuide?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegratedDraftAvgOrderByAggregateInput = {
    viralScore?: SortOrder
  }

  export type IntegratedDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourcesSummary?: SortOrder
    newsContext?: SortOrder
    buzzContext?: SortOrder
    conceptId?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    generationStrategy?: SortOrder
    visualGuide?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegratedDraftMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourcesSummary?: SortOrder
    newsContext?: SortOrder
    buzzContext?: SortOrder
    conceptId?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    generationStrategy?: SortOrder
    visualGuide?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegratedDraftSumOrderByAggregateInput = {
    viralScore?: SortOrder
  }

  export type IntegratedDraftRelationFilter = {
    is?: IntegratedDraftWhereInput
    isNot?: IntegratedDraftWhereInput
  }

  export type IntegratedDraftPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    predictionAccuracy?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegratedDraftPerformanceAvgOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    predictionAccuracy?: SortOrder
  }

  export type IntegratedDraftPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    predictionAccuracy?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegratedDraftPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    predictionAccuracy?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegratedDraftPerformanceSumOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    predictionAccuracy?: SortOrder
  }

  export type EnumRTStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusFilter<$PrismaModel> | $Enums.RTStatus
  }

  export type ViralDraftV2NullableRelationFilter = {
    is?: ViralDraftV2WhereInput | null
    isNot?: ViralDraftV2WhereInput | null
  }

  export type CotDraftNullableRelationFilter = {
    is?: CotDraftWhereInput | null
    isNot?: CotDraftWhereInput | null
  }

  export type ScheduledRetweetCountOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrder
    viralDraftId?: SortOrder
    cotDraftId?: SortOrder
    executedAt?: SortOrder
    rtPostId?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledRetweetMaxOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrder
    viralDraftId?: SortOrder
    cotDraftId?: SortOrder
    executedAt?: SortOrder
    rtPostId?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledRetweetMinOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrder
    viralDraftId?: SortOrder
    cotDraftId?: SortOrder
    executedAt?: SortOrder
    rtPostId?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRTStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusWithAggregatesFilter<$PrismaModel> | $Enums.RTStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRTStatusFilter<$PrismaModel>
    _max?: NestedEnumRTStatusFilter<$PrismaModel>
  }

  export type UnifiedPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    metrics30m?: SortOrder
    metrics1h?: SortOrder
    metrics24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceAvgOrderByAggregateInput = {
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type UnifiedPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceSumOrderByAggregateInput = {
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type ViralSessionRelationFilter = {
    is?: ViralSessionWhereInput
    isNot?: ViralSessionWhereInput
  }

  export type NewsViralRelationNewsIdSessionIdCompoundUniqueInput = {
    newsId: string
    sessionId: string
  }

  export type NewsViralRelationCountOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationAvgOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type NewsViralRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationMinOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationSumOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type SessionActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogCountOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrder
    stackTrace?: SortOrder
    requestBody?: SortOrder
    requestHeaders?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type ApiErrorLogMaxOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrder
    stackTrace?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogMinOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrder
    stackTrace?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type ViralDraftV2ListRelationFilter = {
    every?: ViralDraftV2WhereInput
    some?: ViralDraftV2WhereInput
    none?: ViralDraftV2WhereInput
  }

  export type CharacterProfileNullableRelationFilter = {
    is?: CharacterProfileWhereInput | null
    isNot?: CharacterProfileWhereInput | null
  }

  export type IntegratedSessionListRelationFilter = {
    every?: IntegratedSessionWhereInput
    some?: IntegratedSessionWhereInput
    none?: IntegratedSessionWhereInput
  }

  export type ViralDraftV2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegratedSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViralSessionCountOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrder
    voiceStyleMode?: SortOrder
    topics?: SortOrder
    concepts?: SortOrder
    selectedIds?: SortOrder
    contents?: SortOrder
  }

  export type ViralSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrder
    voiceStyleMode?: SortOrder
  }

  export type ViralSessionMinOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrder
    voiceStyleMode?: SortOrder
  }

  export type ViralDraftPerformanceNullableRelationFilter = {
    is?: ViralDraftPerformanceWhereInput | null
    isNot?: ViralDraftPerformanceWhereInput | null
  }

  export type ViralDraftV2CountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    hashtags?: SortOrder
    visualNote?: SortOrder
    sourceUrl?: SortOrder
    characterId?: SortOrder
    characterNote?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftV2MaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    visualNote?: SortOrder
    sourceUrl?: SortOrder
    characterId?: SortOrder
    characterNote?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftV2MinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    visualNote?: SortOrder
    sourceUrl?: SortOrder
    characterId?: SortOrder
    characterNote?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftV2RelationFilter = {
    is?: ViralDraftV2WhereInput
    isNot?: ViralDraftV2WhereInput
  }

  export type ViralDraftPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftPerformanceAvgOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type ViralDraftPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftPerformanceSumOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ViralSessionListRelationFilter = {
    every?: ViralSessionWhereInput
    some?: ViralSessionWhereInput
    none?: ViralSessionWhereInput
  }

  export type ViralSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    tone?: SortOrder
    catchphrase?: SortOrder
    philosophy?: SortOrder
    voiceStyle?: SortOrder
    topics?: SortOrder
    visual?: SortOrder
    isDefault?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredNewsCategories?: SortOrder
    newsCommentStyle?: SortOrder
    topicExpertise?: SortOrder
  }

  export type CharacterProfileAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type CharacterProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    tone?: SortOrder
    catchphrase?: SortOrder
    philosophy?: SortOrder
    isDefault?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    tone?: SortOrder
    catchphrase?: SortOrder
    philosophy?: SortOrder
    isDefault?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterProfileSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type BuzzInfluencerCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    verified?: SortOrder
    profileImage?: SortOrder
    bio?: SortOrder
    metrics7d?: SortOrder
    metrics30d?: SortOrder
    metricsAllTime?: SortOrder
    categoryScores?: SortOrder
    primaryCategory?: SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
    bestPostingHours?: SortOrder
    postingFrequency?: SortOrder
    lastActiveAt?: SortOrder
    lastAnalyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzInfluencerAvgOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
  }

  export type BuzzInfluencerMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    verified?: SortOrder
    profileImage?: SortOrder
    bio?: SortOrder
    primaryCategory?: SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
    lastActiveAt?: SortOrder
    lastAnalyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzInfluencerMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    verified?: SortOrder
    profileImage?: SortOrder
    bio?: SortOrder
    primaryCategory?: SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
    lastActiveAt?: SortOrder
    lastAnalyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzInfluencerSumOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
    engagementRate?: SortOrder
    viralScore?: SortOrder
    consistencyScore?: SortOrder
  }

  export type ScheduledPostCreateNestedManyWithoutRefPostInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
  }

  export type ScheduledPostUncheckedCreateNestedManyWithoutRefPostInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ScheduledPostUpdateManyWithoutRefPostNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    upsert?: ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput | ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    set?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    disconnect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    delete?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    update?: ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput | ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput[]
    updateMany?: ScheduledPostUpdateManyWithWhereWithoutRefPostInput | ScheduledPostUpdateManyWithWhereWithoutRefPostInput[]
    deleteMany?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
  }

  export type ScheduledPostUncheckedUpdateManyWithoutRefPostNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    upsert?: ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput | ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    set?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    disconnect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    delete?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    update?: ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput | ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput[]
    updateMany?: ScheduledPostUpdateManyWithWhereWithoutRefPostInput | ScheduledPostUpdateManyWithWhereWithoutRefPostInput[]
    deleteMany?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
  }

  export type BuzzConfigCreatekeywordsInput = {
    set: string[]
  }

  export type BuzzConfigCreateaccountsInput = {
    set: string[]
  }

  export type BuzzConfigUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BuzzConfigUpdateaccountsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BuzzPostCreateNestedOneWithoutScheduledPostsInput = {
    create?: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    connectOrCreate?: BuzzPostCreateOrConnectWithoutScheduledPostsInput
    connect?: BuzzPostWhereUniqueInput
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BuzzPostUpdateOneWithoutScheduledPostsNestedInput = {
    create?: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    connectOrCreate?: BuzzPostCreateOrConnectWithoutScheduledPostsInput
    upsert?: BuzzPostUpsertWithoutScheduledPostsInput
    disconnect?: BuzzPostWhereInput | boolean
    delete?: BuzzPostWhereInput | boolean
    connect?: BuzzPostWhereUniqueInput
    update?: XOR<XOR<BuzzPostUpdateToOneWithWhereWithoutScheduledPostsInput, BuzzPostUpdateWithoutScheduledPostsInput>, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WatchlistUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
  }

  export type CharacterProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<CharacterProfileCreateWithoutUserInput, CharacterProfileUncheckedCreateWithoutUserInput> | CharacterProfileCreateWithoutUserInput[] | CharacterProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterProfileCreateOrConnectWithoutUserInput | CharacterProfileCreateOrConnectWithoutUserInput[]
    createMany?: CharacterProfileCreateManyUserInputEnvelope
    connect?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WatchlistUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
  }

  export type CharacterProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CharacterProfileCreateWithoutUserInput, CharacterProfileUncheckedCreateWithoutUserInput> | CharacterProfileCreateWithoutUserInput[] | CharacterProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterProfileCreateOrConnectWithoutUserInput | CharacterProfileCreateOrConnectWithoutUserInput[]
    createMany?: CharacterProfileCreateManyUserInputEnvelope
    connect?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WatchlistUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUserUpsertWithWhereUniqueWithoutUserInput | WatchlistUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    set?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    disconnect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    delete?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    update?: WatchlistUserUpdateWithWhereUniqueWithoutUserInput | WatchlistUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUserUpdateManyWithWhereWithoutUserInput | WatchlistUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
  }

  export type CharacterProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<CharacterProfileCreateWithoutUserInput, CharacterProfileUncheckedCreateWithoutUserInput> | CharacterProfileCreateWithoutUserInput[] | CharacterProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterProfileCreateOrConnectWithoutUserInput | CharacterProfileCreateOrConnectWithoutUserInput[]
    upsert?: CharacterProfileUpsertWithWhereUniqueWithoutUserInput | CharacterProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CharacterProfileCreateManyUserInputEnvelope
    set?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    disconnect?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    delete?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    connect?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    update?: CharacterProfileUpdateWithWhereUniqueWithoutUserInput | CharacterProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CharacterProfileUpdateManyWithWhereWithoutUserInput | CharacterProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CharacterProfileScalarWhereInput | CharacterProfileScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WatchlistUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUserUpsertWithWhereUniqueWithoutUserInput | WatchlistUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    set?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    disconnect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    delete?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    update?: WatchlistUserUpdateWithWhereUniqueWithoutUserInput | WatchlistUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUserUpdateManyWithWhereWithoutUserInput | WatchlistUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
  }

  export type CharacterProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CharacterProfileCreateWithoutUserInput, CharacterProfileUncheckedCreateWithoutUserInput> | CharacterProfileCreateWithoutUserInput[] | CharacterProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterProfileCreateOrConnectWithoutUserInput | CharacterProfileCreateOrConnectWithoutUserInput[]
    upsert?: CharacterProfileUpsertWithWhereUniqueWithoutUserInput | CharacterProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CharacterProfileCreateManyUserInputEnvelope
    set?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    disconnect?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    delete?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    connect?: CharacterProfileWhereUniqueInput | CharacterProfileWhereUniqueInput[]
    update?: CharacterProfileUpdateWithWhereUniqueWithoutUserInput | CharacterProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CharacterProfileUpdateManyWithWhereWithoutUserInput | CharacterProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CharacterProfileScalarWhereInput | CharacterProfileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NewsArticleCreateNestedManyWithoutSourceInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
  }

  export type NewsArticleUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
  }

  export type NewsArticleUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    upsert?: NewsArticleUpsertWithWhereUniqueWithoutSourceInput | NewsArticleUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    set?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    disconnect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    delete?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    update?: NewsArticleUpdateWithWhereUniqueWithoutSourceInput | NewsArticleUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NewsArticleUpdateManyWithWhereWithoutSourceInput | NewsArticleUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
  }

  export type NewsArticleUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    upsert?: NewsArticleUpsertWithWhereUniqueWithoutSourceInput | NewsArticleUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    set?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    disconnect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    delete?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    update?: NewsArticleUpdateWithWhereUniqueWithoutSourceInput | NewsArticleUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NewsArticleUpdateManyWithWhereWithoutSourceInput | NewsArticleUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
  }

  export type NewsArticleCreatetagsInput = {
    set: string[]
  }

  export type NewsAnalysisCreateNestedOneWithoutArticleInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    connect?: NewsAnalysisWhereUniqueInput
  }

  export type NewsSourceCreateNestedOneWithoutArticlesInput = {
    create?: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: NewsSourceCreateOrConnectWithoutArticlesInput
    connect?: NewsSourceWhereUniqueInput
  }

  export type NewsThreadItemCreateNestedManyWithoutArticleInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsViralRelationCreateNestedManyWithoutNewsArticleInput = {
    create?: XOR<NewsViralRelationCreateWithoutNewsArticleInput, NewsViralRelationUncheckedCreateWithoutNewsArticleInput> | NewsViralRelationCreateWithoutNewsArticleInput[] | NewsViralRelationUncheckedCreateWithoutNewsArticleInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutNewsArticleInput | NewsViralRelationCreateOrConnectWithoutNewsArticleInput[]
    createMany?: NewsViralRelationCreateManyNewsArticleInputEnvelope
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
  }

  export type NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    connect?: NewsAnalysisWhereUniqueInput
  }

  export type NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsViralRelationUncheckedCreateNestedManyWithoutNewsArticleInput = {
    create?: XOR<NewsViralRelationCreateWithoutNewsArticleInput, NewsViralRelationUncheckedCreateWithoutNewsArticleInput> | NewsViralRelationCreateWithoutNewsArticleInput[] | NewsViralRelationUncheckedCreateWithoutNewsArticleInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutNewsArticleInput | NewsViralRelationCreateOrConnectWithoutNewsArticleInput[]
    createMany?: NewsViralRelationCreateManyNewsArticleInputEnvelope
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
  }

  export type NewsArticleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NewsAnalysisUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    upsert?: NewsAnalysisUpsertWithoutArticleInput
    disconnect?: NewsAnalysisWhereInput | boolean
    delete?: NewsAnalysisWhereInput | boolean
    connect?: NewsAnalysisWhereUniqueInput
    update?: XOR<XOR<NewsAnalysisUpdateToOneWithWhereWithoutArticleInput, NewsAnalysisUpdateWithoutArticleInput>, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsSourceUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: NewsSourceCreateOrConnectWithoutArticlesInput
    upsert?: NewsSourceUpsertWithoutArticlesInput
    connect?: NewsSourceWhereUniqueInput
    update?: XOR<XOR<NewsSourceUpdateToOneWithWhereWithoutArticlesInput, NewsSourceUpdateWithoutArticlesInput>, NewsSourceUncheckedUpdateWithoutArticlesInput>
  }

  export type NewsThreadItemUpdateManyWithoutArticleNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput | NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput | NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutArticleInput | NewsThreadItemUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsViralRelationUpdateManyWithoutNewsArticleNestedInput = {
    create?: XOR<NewsViralRelationCreateWithoutNewsArticleInput, NewsViralRelationUncheckedCreateWithoutNewsArticleInput> | NewsViralRelationCreateWithoutNewsArticleInput[] | NewsViralRelationUncheckedCreateWithoutNewsArticleInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutNewsArticleInput | NewsViralRelationCreateOrConnectWithoutNewsArticleInput[]
    upsert?: NewsViralRelationUpsertWithWhereUniqueWithoutNewsArticleInput | NewsViralRelationUpsertWithWhereUniqueWithoutNewsArticleInput[]
    createMany?: NewsViralRelationCreateManyNewsArticleInputEnvelope
    set?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    disconnect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    delete?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    update?: NewsViralRelationUpdateWithWhereUniqueWithoutNewsArticleInput | NewsViralRelationUpdateWithWhereUniqueWithoutNewsArticleInput[]
    updateMany?: NewsViralRelationUpdateManyWithWhereWithoutNewsArticleInput | NewsViralRelationUpdateManyWithWhereWithoutNewsArticleInput[]
    deleteMany?: NewsViralRelationScalarWhereInput | NewsViralRelationScalarWhereInput[]
  }

  export type NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    upsert?: NewsAnalysisUpsertWithoutArticleInput
    disconnect?: NewsAnalysisWhereInput | boolean
    delete?: NewsAnalysisWhereInput | boolean
    connect?: NewsAnalysisWhereUniqueInput
    update?: XOR<XOR<NewsAnalysisUpdateToOneWithWhereWithoutArticleInput, NewsAnalysisUpdateWithoutArticleInput>, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput | NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput | NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutArticleInput | NewsThreadItemUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsViralRelationUncheckedUpdateManyWithoutNewsArticleNestedInput = {
    create?: XOR<NewsViralRelationCreateWithoutNewsArticleInput, NewsViralRelationUncheckedCreateWithoutNewsArticleInput> | NewsViralRelationCreateWithoutNewsArticleInput[] | NewsViralRelationUncheckedCreateWithoutNewsArticleInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutNewsArticleInput | NewsViralRelationCreateOrConnectWithoutNewsArticleInput[]
    upsert?: NewsViralRelationUpsertWithWhereUniqueWithoutNewsArticleInput | NewsViralRelationUpsertWithWhereUniqueWithoutNewsArticleInput[]
    createMany?: NewsViralRelationCreateManyNewsArticleInputEnvelope
    set?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    disconnect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    delete?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    update?: NewsViralRelationUpdateWithWhereUniqueWithoutNewsArticleInput | NewsViralRelationUpdateWithWhereUniqueWithoutNewsArticleInput[]
    updateMany?: NewsViralRelationUpdateManyWithWhereWithoutNewsArticleInput | NewsViralRelationUpdateManyWithWhereWithoutNewsArticleInput[]
    deleteMany?: NewsViralRelationScalarWhereInput | NewsViralRelationScalarWhereInput[]
  }

  export type NewsThreadItemCreateNestedManyWithoutThreadInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsThreadItemUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsThreadItemUpdateManyWithoutThreadNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput | NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput | NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutThreadInput | NewsThreadItemUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput | NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput | NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutThreadInput | NewsThreadItemUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadCreateNestedOneWithoutItemsInput = {
    create?: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NewsThreadCreateOrConnectWithoutItemsInput
    connect?: NewsThreadWhereUniqueInput
  }

  export type NewsArticleCreateNestedOneWithoutNewsThreadItemsInput = {
    create?: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNewsThreadItemsInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type NewsThreadUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NewsThreadCreateOrConnectWithoutItemsInput
    upsert?: NewsThreadUpsertWithoutItemsInput
    connect?: NewsThreadWhereUniqueInput
    update?: XOR<XOR<NewsThreadUpdateToOneWithWhereWithoutItemsInput, NewsThreadUpdateWithoutItemsInput>, NewsThreadUncheckedUpdateWithoutItemsInput>
  }

  export type NewsArticleUpdateOneRequiredWithoutNewsThreadItemsNestedInput = {
    create?: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNewsThreadItemsInput
    upsert?: NewsArticleUpsertWithoutNewsThreadItemsInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutNewsThreadItemsInput, NewsArticleUpdateWithoutNewsThreadItemsInput>, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
  }

  export type NewsAnalysisCreatekeywordsInput = {
    set: string[]
  }

  export type NewsAnalysisCreatetopicsInput = {
    set: string[]
  }

  export type NewsArticleCreateNestedOneWithoutAnalysisInput = {
    create?: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutAnalysisInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type NewsAnalysisUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NewsAnalysisUpdatetopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NewsArticleUpdateOneRequiredWithoutAnalysisNestedInput = {
    create?: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutAnalysisInput
    upsert?: NewsArticleUpsertWithoutAnalysisInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutAnalysisInput, NewsArticleUpdateWithoutAnalysisInput>, NewsArticleUncheckedUpdateWithoutAnalysisInput>
  }

  export type UserCreateNestedOneWithoutWatchlistUsersInput = {
    create?: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistUsersInput
    connect?: UserWhereUniqueInput
  }

  export type WatchlistTweetCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
  }

  export type InteractionHistoryCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
  }

  export type WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
  }

  export type InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWatchlistUsersNestedInput = {
    create?: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistUsersInput
    upsert?: UserUpsertWithoutWatchlistUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchlistUsersInput, UserUpdateWithoutWatchlistUsersInput>, UserUncheckedUpdateWithoutWatchlistUsersInput>
  }

  export type WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    set?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    disconnect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    delete?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    update?: WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput | WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
  }

  export type InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    set?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    disconnect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    delete?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    update?: InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput | InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
  }

  export type WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    set?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    disconnect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    delete?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    update?: WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput | WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
  }

  export type InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    set?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    disconnect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    delete?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    update?: InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput | InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
  }

  export type WatchlistUserCreateNestedOneWithoutTweetsInput = {
    create?: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutTweetsInput
    connect?: WatchlistUserWhereUniqueInput
  }

  export type WatchlistUserUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutTweetsInput
    upsert?: WatchlistUserUpsertWithoutTweetsInput
    connect?: WatchlistUserWhereUniqueInput
    update?: XOR<XOR<WatchlistUserUpdateToOneWithWhereWithoutTweetsInput, WatchlistUserUpdateWithoutTweetsInput>, WatchlistUserUncheckedUpdateWithoutTweetsInput>
  }

  export type WatchlistUserCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutInteractionsInput
    connect?: WatchlistUserWhereUniqueInput
  }

  export type WatchlistUserUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutInteractionsInput
    upsert?: WatchlistUserUpsertWithoutInteractionsInput
    connect?: WatchlistUserWhereUniqueInput
    update?: XOR<XOR<WatchlistUserUpdateToOneWithWhereWithoutInteractionsInput, WatchlistUserUpdateWithoutInteractionsInput>, WatchlistUserUncheckedUpdateWithoutInteractionsInput>
  }

  export type CotPhaseCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
  }

  export type CotDraftCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
  }

  export type CotPhaseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
  }

  export type CotDraftUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
  }

  export type EnumCotSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotSessionStatus
  }

  export type EnumCotPhaseStepFieldUpdateOperationsInput = {
    set?: $Enums.CotPhaseStep
  }

  export type CotPhaseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    upsert?: CotPhaseUpsertWithWhereUniqueWithoutSessionInput | CotPhaseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    set?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    disconnect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    delete?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    update?: CotPhaseUpdateWithWhereUniqueWithoutSessionInput | CotPhaseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotPhaseUpdateManyWithWhereWithoutSessionInput | CotPhaseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
  }

  export type CotDraftUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    upsert?: CotDraftUpsertWithWhereUniqueWithoutSessionInput | CotDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    set?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    disconnect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    delete?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    update?: CotDraftUpdateWithWhereUniqueWithoutSessionInput | CotDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotDraftUpdateManyWithWhereWithoutSessionInput | CotDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
  }

  export type CotPhaseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    upsert?: CotPhaseUpsertWithWhereUniqueWithoutSessionInput | CotPhaseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    set?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    disconnect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    delete?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    update?: CotPhaseUpdateWithWhereUniqueWithoutSessionInput | CotPhaseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotPhaseUpdateManyWithWhereWithoutSessionInput | CotPhaseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
  }

  export type CotDraftUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    upsert?: CotDraftUpsertWithWhereUniqueWithoutSessionInput | CotDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    set?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    disconnect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    delete?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    update?: CotDraftUpdateWithWhereUniqueWithoutSessionInput | CotDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotDraftUpdateManyWithWhereWithoutSessionInput | CotDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
  }

  export type CotSessionCreateNestedOneWithoutPhasesInput = {
    create?: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutPhasesInput
    connect?: CotSessionWhereUniqueInput
  }

  export type EnumCotPhaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotPhaseStatus
  }

  export type CotSessionUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutPhasesInput
    upsert?: CotSessionUpsertWithoutPhasesInput
    connect?: CotSessionWhereUniqueInput
    update?: XOR<XOR<CotSessionUpdateToOneWithWhereWithoutPhasesInput, CotSessionUpdateWithoutPhasesInput>, CotSessionUncheckedUpdateWithoutPhasesInput>
  }

  export type CotDraftCreatehashtagsInput = {
    set: string[]
  }

  export type CotSessionCreateNestedOneWithoutDraftsInput = {
    create?: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutDraftsInput
    connect?: CotSessionWhereUniqueInput
  }

  export type CotDraftPerformanceCreateNestedOneWithoutDraftInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: CotDraftPerformanceWhereUniqueInput
  }

  export type ScheduledRetweetCreateNestedManyWithoutCotDraftInput = {
    create?: XOR<ScheduledRetweetCreateWithoutCotDraftInput, ScheduledRetweetUncheckedCreateWithoutCotDraftInput> | ScheduledRetweetCreateWithoutCotDraftInput[] | ScheduledRetweetUncheckedCreateWithoutCotDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutCotDraftInput | ScheduledRetweetCreateOrConnectWithoutCotDraftInput[]
    createMany?: ScheduledRetweetCreateManyCotDraftInputEnvelope
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
  }

  export type CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: CotDraftPerformanceWhereUniqueInput
  }

  export type ScheduledRetweetUncheckedCreateNestedManyWithoutCotDraftInput = {
    create?: XOR<ScheduledRetweetCreateWithoutCotDraftInput, ScheduledRetweetUncheckedCreateWithoutCotDraftInput> | ScheduledRetweetCreateWithoutCotDraftInput[] | ScheduledRetweetUncheckedCreateWithoutCotDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutCotDraftInput | ScheduledRetweetCreateOrConnectWithoutCotDraftInput[]
    createMany?: ScheduledRetweetCreateManyCotDraftInputEnvelope
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
  }

  export type CotDraftUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCotDraftStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotDraftStatus
  }

  export type CotSessionUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutDraftsInput
    upsert?: CotSessionUpsertWithoutDraftsInput
    connect?: CotSessionWhereUniqueInput
    update?: XOR<XOR<CotSessionUpdateToOneWithWhereWithoutDraftsInput, CotSessionUpdateWithoutDraftsInput>, CotSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type CotDraftPerformanceUpdateOneWithoutDraftNestedInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: CotDraftPerformanceUpsertWithoutDraftInput
    disconnect?: CotDraftPerformanceWhereInput | boolean
    delete?: CotDraftPerformanceWhereInput | boolean
    connect?: CotDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, CotDraftPerformanceUpdateWithoutDraftInput>, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ScheduledRetweetUpdateManyWithoutCotDraftNestedInput = {
    create?: XOR<ScheduledRetweetCreateWithoutCotDraftInput, ScheduledRetweetUncheckedCreateWithoutCotDraftInput> | ScheduledRetweetCreateWithoutCotDraftInput[] | ScheduledRetweetUncheckedCreateWithoutCotDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutCotDraftInput | ScheduledRetweetCreateOrConnectWithoutCotDraftInput[]
    upsert?: ScheduledRetweetUpsertWithWhereUniqueWithoutCotDraftInput | ScheduledRetweetUpsertWithWhereUniqueWithoutCotDraftInput[]
    createMany?: ScheduledRetweetCreateManyCotDraftInputEnvelope
    set?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    disconnect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    delete?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    update?: ScheduledRetweetUpdateWithWhereUniqueWithoutCotDraftInput | ScheduledRetweetUpdateWithWhereUniqueWithoutCotDraftInput[]
    updateMany?: ScheduledRetweetUpdateManyWithWhereWithoutCotDraftInput | ScheduledRetweetUpdateManyWithWhereWithoutCotDraftInput[]
    deleteMany?: ScheduledRetweetScalarWhereInput | ScheduledRetweetScalarWhereInput[]
  }

  export type CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: CotDraftPerformanceUpsertWithoutDraftInput
    disconnect?: CotDraftPerformanceWhereInput | boolean
    delete?: CotDraftPerformanceWhereInput | boolean
    connect?: CotDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, CotDraftPerformanceUpdateWithoutDraftInput>, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ScheduledRetweetUncheckedUpdateManyWithoutCotDraftNestedInput = {
    create?: XOR<ScheduledRetweetCreateWithoutCotDraftInput, ScheduledRetweetUncheckedCreateWithoutCotDraftInput> | ScheduledRetweetCreateWithoutCotDraftInput[] | ScheduledRetweetUncheckedCreateWithoutCotDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutCotDraftInput | ScheduledRetweetCreateOrConnectWithoutCotDraftInput[]
    upsert?: ScheduledRetweetUpsertWithWhereUniqueWithoutCotDraftInput | ScheduledRetweetUpsertWithWhereUniqueWithoutCotDraftInput[]
    createMany?: ScheduledRetweetCreateManyCotDraftInputEnvelope
    set?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    disconnect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    delete?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    update?: ScheduledRetweetUpdateWithWhereUniqueWithoutCotDraftInput | ScheduledRetweetUpdateWithWhereUniqueWithoutCotDraftInput[]
    updateMany?: ScheduledRetweetUpdateManyWithWhereWithoutCotDraftInput | ScheduledRetweetUpdateManyWithWhereWithoutCotDraftInput[]
    deleteMany?: ScheduledRetweetScalarWhereInput | ScheduledRetweetScalarWhereInput[]
  }

  export type CotDraftCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutPerformanceInput
    connect?: CotDraftWhereUniqueInput
  }

  export type CotDraftUpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutPerformanceInput
    upsert?: CotDraftUpsertWithoutPerformanceInput
    connect?: CotDraftWhereUniqueInput
    update?: XOR<XOR<CotDraftUpdateToOneWithWhereWithoutPerformanceInput, CotDraftUpdateWithoutPerformanceInput>, CotDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type UnifiedContentSourceCreatekeywordsInput = {
    set: string[]
  }

  export type IntegratedSessionSourceCreateNestedManyWithoutSourceInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSourceInput, IntegratedSessionSourceUncheckedCreateWithoutSourceInput> | IntegratedSessionSourceCreateWithoutSourceInput[] | IntegratedSessionSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSourceInput | IntegratedSessionSourceCreateOrConnectWithoutSourceInput[]
    createMany?: IntegratedSessionSourceCreateManySourceInputEnvelope
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
  }

  export type IntegratedSessionSourceUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSourceInput, IntegratedSessionSourceUncheckedCreateWithoutSourceInput> | IntegratedSessionSourceCreateWithoutSourceInput[] | IntegratedSessionSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSourceInput | IntegratedSessionSourceCreateOrConnectWithoutSourceInput[]
    createMany?: IntegratedSessionSourceCreateManySourceInputEnvelope
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
  }

  export type UnifiedContentSourceUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntegratedSessionSourceUpdateManyWithoutSourceNestedInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSourceInput, IntegratedSessionSourceUncheckedCreateWithoutSourceInput> | IntegratedSessionSourceCreateWithoutSourceInput[] | IntegratedSessionSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSourceInput | IntegratedSessionSourceCreateOrConnectWithoutSourceInput[]
    upsert?: IntegratedSessionSourceUpsertWithWhereUniqueWithoutSourceInput | IntegratedSessionSourceUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: IntegratedSessionSourceCreateManySourceInputEnvelope
    set?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    disconnect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    delete?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    update?: IntegratedSessionSourceUpdateWithWhereUniqueWithoutSourceInput | IntegratedSessionSourceUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: IntegratedSessionSourceUpdateManyWithWhereWithoutSourceInput | IntegratedSessionSourceUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: IntegratedSessionSourceScalarWhereInput | IntegratedSessionSourceScalarWhereInput[]
  }

  export type IntegratedSessionSourceUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSourceInput, IntegratedSessionSourceUncheckedCreateWithoutSourceInput> | IntegratedSessionSourceCreateWithoutSourceInput[] | IntegratedSessionSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSourceInput | IntegratedSessionSourceCreateOrConnectWithoutSourceInput[]
    upsert?: IntegratedSessionSourceUpsertWithWhereUniqueWithoutSourceInput | IntegratedSessionSourceUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: IntegratedSessionSourceCreateManySourceInputEnvelope
    set?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    disconnect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    delete?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    update?: IntegratedSessionSourceUpdateWithWhereUniqueWithoutSourceInput | IntegratedSessionSourceUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: IntegratedSessionSourceUpdateManyWithWhereWithoutSourceInput | IntegratedSessionSourceUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: IntegratedSessionSourceScalarWhereInput | IntegratedSessionSourceScalarWhereInput[]
  }

  export type IntegratedSessionCreatenewsArticleIdsInput = {
    set: string[]
  }

  export type IntegratedSessionCreatebuzzPostIdsInput = {
    set: string[]
  }

  export type ViralSessionCreateNestedOneWithoutIntegratedSessionsInput = {
    create?: XOR<ViralSessionCreateWithoutIntegratedSessionsInput, ViralSessionUncheckedCreateWithoutIntegratedSessionsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutIntegratedSessionsInput
    connect?: ViralSessionWhereUniqueInput
  }

  export type IntegratedSessionSourceCreateNestedManyWithoutSessionInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSessionInput, IntegratedSessionSourceUncheckedCreateWithoutSessionInput> | IntegratedSessionSourceCreateWithoutSessionInput[] | IntegratedSessionSourceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSessionInput | IntegratedSessionSourceCreateOrConnectWithoutSessionInput[]
    createMany?: IntegratedSessionSourceCreateManySessionInputEnvelope
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
  }

  export type IntegratedDraftCreateNestedManyWithoutSessionInput = {
    create?: XOR<IntegratedDraftCreateWithoutSessionInput, IntegratedDraftUncheckedCreateWithoutSessionInput> | IntegratedDraftCreateWithoutSessionInput[] | IntegratedDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedDraftCreateOrConnectWithoutSessionInput | IntegratedDraftCreateOrConnectWithoutSessionInput[]
    createMany?: IntegratedDraftCreateManySessionInputEnvelope
    connect?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
  }

  export type IntegratedSessionSourceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSessionInput, IntegratedSessionSourceUncheckedCreateWithoutSessionInput> | IntegratedSessionSourceCreateWithoutSessionInput[] | IntegratedSessionSourceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSessionInput | IntegratedSessionSourceCreateOrConnectWithoutSessionInput[]
    createMany?: IntegratedSessionSourceCreateManySessionInputEnvelope
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
  }

  export type IntegratedDraftUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<IntegratedDraftCreateWithoutSessionInput, IntegratedDraftUncheckedCreateWithoutSessionInput> | IntegratedDraftCreateWithoutSessionInput[] | IntegratedDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedDraftCreateOrConnectWithoutSessionInput | IntegratedDraftCreateOrConnectWithoutSessionInput[]
    createMany?: IntegratedDraftCreateManySessionInputEnvelope
    connect?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
  }

  export type IntegratedSessionUpdatenewsArticleIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntegratedSessionUpdatebuzzPostIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ViralSessionUpdateOneWithoutIntegratedSessionsNestedInput = {
    create?: XOR<ViralSessionCreateWithoutIntegratedSessionsInput, ViralSessionUncheckedCreateWithoutIntegratedSessionsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutIntegratedSessionsInput
    upsert?: ViralSessionUpsertWithoutIntegratedSessionsInput
    disconnect?: ViralSessionWhereInput | boolean
    delete?: ViralSessionWhereInput | boolean
    connect?: ViralSessionWhereUniqueInput
    update?: XOR<XOR<ViralSessionUpdateToOneWithWhereWithoutIntegratedSessionsInput, ViralSessionUpdateWithoutIntegratedSessionsInput>, ViralSessionUncheckedUpdateWithoutIntegratedSessionsInput>
  }

  export type IntegratedSessionSourceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSessionInput, IntegratedSessionSourceUncheckedCreateWithoutSessionInput> | IntegratedSessionSourceCreateWithoutSessionInput[] | IntegratedSessionSourceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSessionInput | IntegratedSessionSourceCreateOrConnectWithoutSessionInput[]
    upsert?: IntegratedSessionSourceUpsertWithWhereUniqueWithoutSessionInput | IntegratedSessionSourceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: IntegratedSessionSourceCreateManySessionInputEnvelope
    set?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    disconnect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    delete?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    update?: IntegratedSessionSourceUpdateWithWhereUniqueWithoutSessionInput | IntegratedSessionSourceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: IntegratedSessionSourceUpdateManyWithWhereWithoutSessionInput | IntegratedSessionSourceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: IntegratedSessionSourceScalarWhereInput | IntegratedSessionSourceScalarWhereInput[]
  }

  export type IntegratedDraftUpdateManyWithoutSessionNestedInput = {
    create?: XOR<IntegratedDraftCreateWithoutSessionInput, IntegratedDraftUncheckedCreateWithoutSessionInput> | IntegratedDraftCreateWithoutSessionInput[] | IntegratedDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedDraftCreateOrConnectWithoutSessionInput | IntegratedDraftCreateOrConnectWithoutSessionInput[]
    upsert?: IntegratedDraftUpsertWithWhereUniqueWithoutSessionInput | IntegratedDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: IntegratedDraftCreateManySessionInputEnvelope
    set?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    disconnect?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    delete?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    connect?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    update?: IntegratedDraftUpdateWithWhereUniqueWithoutSessionInput | IntegratedDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: IntegratedDraftUpdateManyWithWhereWithoutSessionInput | IntegratedDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: IntegratedDraftScalarWhereInput | IntegratedDraftScalarWhereInput[]
  }

  export type IntegratedSessionSourceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<IntegratedSessionSourceCreateWithoutSessionInput, IntegratedSessionSourceUncheckedCreateWithoutSessionInput> | IntegratedSessionSourceCreateWithoutSessionInput[] | IntegratedSessionSourceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedSessionSourceCreateOrConnectWithoutSessionInput | IntegratedSessionSourceCreateOrConnectWithoutSessionInput[]
    upsert?: IntegratedSessionSourceUpsertWithWhereUniqueWithoutSessionInput | IntegratedSessionSourceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: IntegratedSessionSourceCreateManySessionInputEnvelope
    set?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    disconnect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    delete?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    connect?: IntegratedSessionSourceWhereUniqueInput | IntegratedSessionSourceWhereUniqueInput[]
    update?: IntegratedSessionSourceUpdateWithWhereUniqueWithoutSessionInput | IntegratedSessionSourceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: IntegratedSessionSourceUpdateManyWithWhereWithoutSessionInput | IntegratedSessionSourceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: IntegratedSessionSourceScalarWhereInput | IntegratedSessionSourceScalarWhereInput[]
  }

  export type IntegratedDraftUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<IntegratedDraftCreateWithoutSessionInput, IntegratedDraftUncheckedCreateWithoutSessionInput> | IntegratedDraftCreateWithoutSessionInput[] | IntegratedDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: IntegratedDraftCreateOrConnectWithoutSessionInput | IntegratedDraftCreateOrConnectWithoutSessionInput[]
    upsert?: IntegratedDraftUpsertWithWhereUniqueWithoutSessionInput | IntegratedDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: IntegratedDraftCreateManySessionInputEnvelope
    set?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    disconnect?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    delete?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    connect?: IntegratedDraftWhereUniqueInput | IntegratedDraftWhereUniqueInput[]
    update?: IntegratedDraftUpdateWithWhereUniqueWithoutSessionInput | IntegratedDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: IntegratedDraftUpdateManyWithWhereWithoutSessionInput | IntegratedDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: IntegratedDraftScalarWhereInput | IntegratedDraftScalarWhereInput[]
  }

  export type IntegratedSessionCreateNestedOneWithoutSourcesInput = {
    create?: XOR<IntegratedSessionCreateWithoutSourcesInput, IntegratedSessionUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutSourcesInput
    connect?: IntegratedSessionWhereUniqueInput
  }

  export type UnifiedContentSourceCreateNestedOneWithoutIntegratedSessionsInput = {
    create?: XOR<UnifiedContentSourceCreateWithoutIntegratedSessionsInput, UnifiedContentSourceUncheckedCreateWithoutIntegratedSessionsInput>
    connectOrCreate?: UnifiedContentSourceCreateOrConnectWithoutIntegratedSessionsInput
    connect?: UnifiedContentSourceWhereUniqueInput
  }

  export type IntegratedSessionUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<IntegratedSessionCreateWithoutSourcesInput, IntegratedSessionUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutSourcesInput
    upsert?: IntegratedSessionUpsertWithoutSourcesInput
    connect?: IntegratedSessionWhereUniqueInput
    update?: XOR<XOR<IntegratedSessionUpdateToOneWithWhereWithoutSourcesInput, IntegratedSessionUpdateWithoutSourcesInput>, IntegratedSessionUncheckedUpdateWithoutSourcesInput>
  }

  export type UnifiedContentSourceUpdateOneRequiredWithoutIntegratedSessionsNestedInput = {
    create?: XOR<UnifiedContentSourceCreateWithoutIntegratedSessionsInput, UnifiedContentSourceUncheckedCreateWithoutIntegratedSessionsInput>
    connectOrCreate?: UnifiedContentSourceCreateOrConnectWithoutIntegratedSessionsInput
    upsert?: UnifiedContentSourceUpsertWithoutIntegratedSessionsInput
    connect?: UnifiedContentSourceWhereUniqueInput
    update?: XOR<XOR<UnifiedContentSourceUpdateToOneWithWhereWithoutIntegratedSessionsInput, UnifiedContentSourceUpdateWithoutIntegratedSessionsInput>, UnifiedContentSourceUncheckedUpdateWithoutIntegratedSessionsInput>
  }

  export type IntegratedDraftCreatesourceNewsIdsInput = {
    set: string[]
  }

  export type IntegratedDraftCreatesourceBuzzIdsInput = {
    set: string[]
  }

  export type IntegratedDraftCreatehashtagsInput = {
    set: string[]
  }

  export type IntegratedSessionCreateNestedOneWithoutDraftsInput = {
    create?: XOR<IntegratedSessionCreateWithoutDraftsInput, IntegratedSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutDraftsInput
    connect?: IntegratedSessionWhereUniqueInput
  }

  export type IntegratedDraftPerformanceCreateNestedOneWithoutDraftInput = {
    create?: XOR<IntegratedDraftPerformanceCreateWithoutDraftInput, IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: IntegratedDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: IntegratedDraftPerformanceWhereUniqueInput
  }

  export type IntegratedDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput = {
    create?: XOR<IntegratedDraftPerformanceCreateWithoutDraftInput, IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: IntegratedDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: IntegratedDraftPerformanceWhereUniqueInput
  }

  export type IntegratedDraftUpdatesourceNewsIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntegratedDraftUpdatesourceBuzzIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntegratedDraftUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntegratedSessionUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<IntegratedSessionCreateWithoutDraftsInput, IntegratedSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutDraftsInput
    upsert?: IntegratedSessionUpsertWithoutDraftsInput
    connect?: IntegratedSessionWhereUniqueInput
    update?: XOR<XOR<IntegratedSessionUpdateToOneWithWhereWithoutDraftsInput, IntegratedSessionUpdateWithoutDraftsInput>, IntegratedSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type IntegratedDraftPerformanceUpdateOneWithoutDraftNestedInput = {
    create?: XOR<IntegratedDraftPerformanceCreateWithoutDraftInput, IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: IntegratedDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: IntegratedDraftPerformanceUpsertWithoutDraftInput
    disconnect?: IntegratedDraftPerformanceWhereInput | boolean
    delete?: IntegratedDraftPerformanceWhereInput | boolean
    connect?: IntegratedDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<IntegratedDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, IntegratedDraftPerformanceUpdateWithoutDraftInput>, IntegratedDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type IntegratedDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput = {
    create?: XOR<IntegratedDraftPerformanceCreateWithoutDraftInput, IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: IntegratedDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: IntegratedDraftPerformanceUpsertWithoutDraftInput
    disconnect?: IntegratedDraftPerformanceWhereInput | boolean
    delete?: IntegratedDraftPerformanceWhereInput | boolean
    connect?: IntegratedDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<IntegratedDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, IntegratedDraftPerformanceUpdateWithoutDraftInput>, IntegratedDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type IntegratedDraftCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<IntegratedDraftCreateWithoutPerformanceInput, IntegratedDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: IntegratedDraftCreateOrConnectWithoutPerformanceInput
    connect?: IntegratedDraftWhereUniqueInput
  }

  export type IntegratedDraftUpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<IntegratedDraftCreateWithoutPerformanceInput, IntegratedDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: IntegratedDraftCreateOrConnectWithoutPerformanceInput
    upsert?: IntegratedDraftUpsertWithoutPerformanceInput
    connect?: IntegratedDraftWhereUniqueInput
    update?: XOR<XOR<IntegratedDraftUpdateToOneWithWhereWithoutPerformanceInput, IntegratedDraftUpdateWithoutPerformanceInput>, IntegratedDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type ViralDraftV2CreateNestedOneWithoutScheduledRTsInput = {
    create?: XOR<ViralDraftV2CreateWithoutScheduledRTsInput, ViralDraftV2UncheckedCreateWithoutScheduledRTsInput>
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutScheduledRTsInput
    connect?: ViralDraftV2WhereUniqueInput
  }

  export type CotDraftCreateNestedOneWithoutScheduledRTsInput = {
    create?: XOR<CotDraftCreateWithoutScheduledRTsInput, CotDraftUncheckedCreateWithoutScheduledRTsInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutScheduledRTsInput
    connect?: CotDraftWhereUniqueInput
  }

  export type EnumRTStatusFieldUpdateOperationsInput = {
    set?: $Enums.RTStatus
  }

  export type ViralDraftV2UpdateOneWithoutScheduledRTsNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutScheduledRTsInput, ViralDraftV2UncheckedCreateWithoutScheduledRTsInput>
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutScheduledRTsInput
    upsert?: ViralDraftV2UpsertWithoutScheduledRTsInput
    disconnect?: ViralDraftV2WhereInput | boolean
    delete?: ViralDraftV2WhereInput | boolean
    connect?: ViralDraftV2WhereUniqueInput
    update?: XOR<XOR<ViralDraftV2UpdateToOneWithWhereWithoutScheduledRTsInput, ViralDraftV2UpdateWithoutScheduledRTsInput>, ViralDraftV2UncheckedUpdateWithoutScheduledRTsInput>
  }

  export type CotDraftUpdateOneWithoutScheduledRTsNestedInput = {
    create?: XOR<CotDraftCreateWithoutScheduledRTsInput, CotDraftUncheckedCreateWithoutScheduledRTsInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutScheduledRTsInput
    upsert?: CotDraftUpsertWithoutScheduledRTsInput
    disconnect?: CotDraftWhereInput | boolean
    delete?: CotDraftWhereInput | boolean
    connect?: CotDraftWhereUniqueInput
    update?: XOR<XOR<CotDraftUpdateToOneWithWhereWithoutScheduledRTsInput, CotDraftUpdateWithoutScheduledRTsInput>, CotDraftUncheckedUpdateWithoutScheduledRTsInput>
  }

  export type NewsArticleCreateNestedOneWithoutViralRelationsInput = {
    create?: XOR<NewsArticleCreateWithoutViralRelationsInput, NewsArticleUncheckedCreateWithoutViralRelationsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutViralRelationsInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type ViralSessionCreateNestedOneWithoutNewsRelationsInput = {
    create?: XOR<ViralSessionCreateWithoutNewsRelationsInput, ViralSessionUncheckedCreateWithoutNewsRelationsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutNewsRelationsInput
    connect?: ViralSessionWhereUniqueInput
  }

  export type NewsArticleUpdateOneRequiredWithoutViralRelationsNestedInput = {
    create?: XOR<NewsArticleCreateWithoutViralRelationsInput, NewsArticleUncheckedCreateWithoutViralRelationsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutViralRelationsInput
    upsert?: NewsArticleUpsertWithoutViralRelationsInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutViralRelationsInput, NewsArticleUpdateWithoutViralRelationsInput>, NewsArticleUncheckedUpdateWithoutViralRelationsInput>
  }

  export type ViralSessionUpdateOneRequiredWithoutNewsRelationsNestedInput = {
    create?: XOR<ViralSessionCreateWithoutNewsRelationsInput, ViralSessionUncheckedCreateWithoutNewsRelationsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutNewsRelationsInput
    upsert?: ViralSessionUpsertWithoutNewsRelationsInput
    connect?: ViralSessionWhereUniqueInput
    update?: XOR<XOR<ViralSessionUpdateToOneWithWhereWithoutNewsRelationsInput, ViralSessionUpdateWithoutNewsRelationsInput>, ViralSessionUncheckedUpdateWithoutNewsRelationsInput>
  }

  export type ViralSessionCreateselectedIdsInput = {
    set: string[]
  }

  export type ViralDraftV2CreateNestedManyWithoutSessionInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
  }

  export type CharacterProfileCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CharacterProfileCreateWithoutSessionsInput, CharacterProfileUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CharacterProfileCreateOrConnectWithoutSessionsInput
    connect?: CharacterProfileWhereUniqueInput
  }

  export type NewsViralRelationCreateNestedManyWithoutSessionInput = {
    create?: XOR<NewsViralRelationCreateWithoutSessionInput, NewsViralRelationUncheckedCreateWithoutSessionInput> | NewsViralRelationCreateWithoutSessionInput[] | NewsViralRelationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutSessionInput | NewsViralRelationCreateOrConnectWithoutSessionInput[]
    createMany?: NewsViralRelationCreateManySessionInputEnvelope
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
  }

  export type IntegratedSessionCreateNestedManyWithoutV2SessionInput = {
    create?: XOR<IntegratedSessionCreateWithoutV2SessionInput, IntegratedSessionUncheckedCreateWithoutV2SessionInput> | IntegratedSessionCreateWithoutV2SessionInput[] | IntegratedSessionUncheckedCreateWithoutV2SessionInput[]
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutV2SessionInput | IntegratedSessionCreateOrConnectWithoutV2SessionInput[]
    createMany?: IntegratedSessionCreateManyV2SessionInputEnvelope
    connect?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
  }

  export type ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
  }

  export type NewsViralRelationUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<NewsViralRelationCreateWithoutSessionInput, NewsViralRelationUncheckedCreateWithoutSessionInput> | NewsViralRelationCreateWithoutSessionInput[] | NewsViralRelationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutSessionInput | NewsViralRelationCreateOrConnectWithoutSessionInput[]
    createMany?: NewsViralRelationCreateManySessionInputEnvelope
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
  }

  export type IntegratedSessionUncheckedCreateNestedManyWithoutV2SessionInput = {
    create?: XOR<IntegratedSessionCreateWithoutV2SessionInput, IntegratedSessionUncheckedCreateWithoutV2SessionInput> | IntegratedSessionCreateWithoutV2SessionInput[] | IntegratedSessionUncheckedCreateWithoutV2SessionInput[]
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutV2SessionInput | IntegratedSessionCreateOrConnectWithoutV2SessionInput[]
    createMany?: IntegratedSessionCreateManyV2SessionInputEnvelope
    connect?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
  }

  export type ViralSessionUpdateselectedIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ViralDraftV2UpdateManyWithoutSessionNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    upsert?: ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput | ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    set?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    disconnect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    delete?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    update?: ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput | ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ViralDraftV2UpdateManyWithWhereWithoutSessionInput | ViralDraftV2UpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
  }

  export type CharacterProfileUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<CharacterProfileCreateWithoutSessionsInput, CharacterProfileUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CharacterProfileCreateOrConnectWithoutSessionsInput
    upsert?: CharacterProfileUpsertWithoutSessionsInput
    disconnect?: CharacterProfileWhereInput | boolean
    delete?: CharacterProfileWhereInput | boolean
    connect?: CharacterProfileWhereUniqueInput
    update?: XOR<XOR<CharacterProfileUpdateToOneWithWhereWithoutSessionsInput, CharacterProfileUpdateWithoutSessionsInput>, CharacterProfileUncheckedUpdateWithoutSessionsInput>
  }

  export type NewsViralRelationUpdateManyWithoutSessionNestedInput = {
    create?: XOR<NewsViralRelationCreateWithoutSessionInput, NewsViralRelationUncheckedCreateWithoutSessionInput> | NewsViralRelationCreateWithoutSessionInput[] | NewsViralRelationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutSessionInput | NewsViralRelationCreateOrConnectWithoutSessionInput[]
    upsert?: NewsViralRelationUpsertWithWhereUniqueWithoutSessionInput | NewsViralRelationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: NewsViralRelationCreateManySessionInputEnvelope
    set?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    disconnect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    delete?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    update?: NewsViralRelationUpdateWithWhereUniqueWithoutSessionInput | NewsViralRelationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: NewsViralRelationUpdateManyWithWhereWithoutSessionInput | NewsViralRelationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: NewsViralRelationScalarWhereInput | NewsViralRelationScalarWhereInput[]
  }

  export type IntegratedSessionUpdateManyWithoutV2SessionNestedInput = {
    create?: XOR<IntegratedSessionCreateWithoutV2SessionInput, IntegratedSessionUncheckedCreateWithoutV2SessionInput> | IntegratedSessionCreateWithoutV2SessionInput[] | IntegratedSessionUncheckedCreateWithoutV2SessionInput[]
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutV2SessionInput | IntegratedSessionCreateOrConnectWithoutV2SessionInput[]
    upsert?: IntegratedSessionUpsertWithWhereUniqueWithoutV2SessionInput | IntegratedSessionUpsertWithWhereUniqueWithoutV2SessionInput[]
    createMany?: IntegratedSessionCreateManyV2SessionInputEnvelope
    set?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    disconnect?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    delete?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    connect?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    update?: IntegratedSessionUpdateWithWhereUniqueWithoutV2SessionInput | IntegratedSessionUpdateWithWhereUniqueWithoutV2SessionInput[]
    updateMany?: IntegratedSessionUpdateManyWithWhereWithoutV2SessionInput | IntegratedSessionUpdateManyWithWhereWithoutV2SessionInput[]
    deleteMany?: IntegratedSessionScalarWhereInput | IntegratedSessionScalarWhereInput[]
  }

  export type ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    upsert?: ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput | ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    set?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    disconnect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    delete?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    update?: ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput | ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ViralDraftV2UpdateManyWithWhereWithoutSessionInput | ViralDraftV2UpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
  }

  export type NewsViralRelationUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<NewsViralRelationCreateWithoutSessionInput, NewsViralRelationUncheckedCreateWithoutSessionInput> | NewsViralRelationCreateWithoutSessionInput[] | NewsViralRelationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: NewsViralRelationCreateOrConnectWithoutSessionInput | NewsViralRelationCreateOrConnectWithoutSessionInput[]
    upsert?: NewsViralRelationUpsertWithWhereUniqueWithoutSessionInput | NewsViralRelationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: NewsViralRelationCreateManySessionInputEnvelope
    set?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    disconnect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    delete?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    connect?: NewsViralRelationWhereUniqueInput | NewsViralRelationWhereUniqueInput[]
    update?: NewsViralRelationUpdateWithWhereUniqueWithoutSessionInput | NewsViralRelationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: NewsViralRelationUpdateManyWithWhereWithoutSessionInput | NewsViralRelationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: NewsViralRelationScalarWhereInput | NewsViralRelationScalarWhereInput[]
  }

  export type IntegratedSessionUncheckedUpdateManyWithoutV2SessionNestedInput = {
    create?: XOR<IntegratedSessionCreateWithoutV2SessionInput, IntegratedSessionUncheckedCreateWithoutV2SessionInput> | IntegratedSessionCreateWithoutV2SessionInput[] | IntegratedSessionUncheckedCreateWithoutV2SessionInput[]
    connectOrCreate?: IntegratedSessionCreateOrConnectWithoutV2SessionInput | IntegratedSessionCreateOrConnectWithoutV2SessionInput[]
    upsert?: IntegratedSessionUpsertWithWhereUniqueWithoutV2SessionInput | IntegratedSessionUpsertWithWhereUniqueWithoutV2SessionInput[]
    createMany?: IntegratedSessionCreateManyV2SessionInputEnvelope
    set?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    disconnect?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    delete?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    connect?: IntegratedSessionWhereUniqueInput | IntegratedSessionWhereUniqueInput[]
    update?: IntegratedSessionUpdateWithWhereUniqueWithoutV2SessionInput | IntegratedSessionUpdateWithWhereUniqueWithoutV2SessionInput[]
    updateMany?: IntegratedSessionUpdateManyWithWhereWithoutV2SessionInput | IntegratedSessionUpdateManyWithWhereWithoutV2SessionInput[]
    deleteMany?: IntegratedSessionScalarWhereInput | IntegratedSessionScalarWhereInput[]
  }

  export type ViralDraftV2CreatehashtagsInput = {
    set: string[]
  }

  export type ViralSessionCreateNestedOneWithoutDraftsInput = {
    create?: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutDraftsInput
    connect?: ViralSessionWhereUniqueInput
  }

  export type ViralDraftPerformanceCreateNestedOneWithoutDraftInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: ViralDraftPerformanceWhereUniqueInput
  }

  export type ScheduledRetweetCreateNestedManyWithoutViralDraftInput = {
    create?: XOR<ScheduledRetweetCreateWithoutViralDraftInput, ScheduledRetweetUncheckedCreateWithoutViralDraftInput> | ScheduledRetweetCreateWithoutViralDraftInput[] | ScheduledRetweetUncheckedCreateWithoutViralDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutViralDraftInput | ScheduledRetweetCreateOrConnectWithoutViralDraftInput[]
    createMany?: ScheduledRetweetCreateManyViralDraftInputEnvelope
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
  }

  export type ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: ViralDraftPerformanceWhereUniqueInput
  }

  export type ScheduledRetweetUncheckedCreateNestedManyWithoutViralDraftInput = {
    create?: XOR<ScheduledRetweetCreateWithoutViralDraftInput, ScheduledRetweetUncheckedCreateWithoutViralDraftInput> | ScheduledRetweetCreateWithoutViralDraftInput[] | ScheduledRetweetUncheckedCreateWithoutViralDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutViralDraftInput | ScheduledRetweetCreateOrConnectWithoutViralDraftInput[]
    createMany?: ScheduledRetweetCreateManyViralDraftInputEnvelope
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
  }

  export type ViralDraftV2UpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ViralSessionUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutDraftsInput
    upsert?: ViralSessionUpsertWithoutDraftsInput
    connect?: ViralSessionWhereUniqueInput
    update?: XOR<XOR<ViralSessionUpdateToOneWithWhereWithoutDraftsInput, ViralSessionUpdateWithoutDraftsInput>, ViralSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type ViralDraftPerformanceUpdateOneWithoutDraftNestedInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: ViralDraftPerformanceUpsertWithoutDraftInput
    disconnect?: ViralDraftPerformanceWhereInput | boolean
    delete?: ViralDraftPerformanceWhereInput | boolean
    connect?: ViralDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<ViralDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, ViralDraftPerformanceUpdateWithoutDraftInput>, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ScheduledRetweetUpdateManyWithoutViralDraftNestedInput = {
    create?: XOR<ScheduledRetweetCreateWithoutViralDraftInput, ScheduledRetweetUncheckedCreateWithoutViralDraftInput> | ScheduledRetweetCreateWithoutViralDraftInput[] | ScheduledRetweetUncheckedCreateWithoutViralDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutViralDraftInput | ScheduledRetweetCreateOrConnectWithoutViralDraftInput[]
    upsert?: ScheduledRetweetUpsertWithWhereUniqueWithoutViralDraftInput | ScheduledRetweetUpsertWithWhereUniqueWithoutViralDraftInput[]
    createMany?: ScheduledRetweetCreateManyViralDraftInputEnvelope
    set?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    disconnect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    delete?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    update?: ScheduledRetweetUpdateWithWhereUniqueWithoutViralDraftInput | ScheduledRetweetUpdateWithWhereUniqueWithoutViralDraftInput[]
    updateMany?: ScheduledRetweetUpdateManyWithWhereWithoutViralDraftInput | ScheduledRetweetUpdateManyWithWhereWithoutViralDraftInput[]
    deleteMany?: ScheduledRetweetScalarWhereInput | ScheduledRetweetScalarWhereInput[]
  }

  export type ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: ViralDraftPerformanceUpsertWithoutDraftInput
    disconnect?: ViralDraftPerformanceWhereInput | boolean
    delete?: ViralDraftPerformanceWhereInput | boolean
    connect?: ViralDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<ViralDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, ViralDraftPerformanceUpdateWithoutDraftInput>, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ScheduledRetweetUncheckedUpdateManyWithoutViralDraftNestedInput = {
    create?: XOR<ScheduledRetweetCreateWithoutViralDraftInput, ScheduledRetweetUncheckedCreateWithoutViralDraftInput> | ScheduledRetweetCreateWithoutViralDraftInput[] | ScheduledRetweetUncheckedCreateWithoutViralDraftInput[]
    connectOrCreate?: ScheduledRetweetCreateOrConnectWithoutViralDraftInput | ScheduledRetweetCreateOrConnectWithoutViralDraftInput[]
    upsert?: ScheduledRetweetUpsertWithWhereUniqueWithoutViralDraftInput | ScheduledRetweetUpsertWithWhereUniqueWithoutViralDraftInput[]
    createMany?: ScheduledRetweetCreateManyViralDraftInputEnvelope
    set?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    disconnect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    delete?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    connect?: ScheduledRetweetWhereUniqueInput | ScheduledRetweetWhereUniqueInput[]
    update?: ScheduledRetweetUpdateWithWhereUniqueWithoutViralDraftInput | ScheduledRetweetUpdateWithWhereUniqueWithoutViralDraftInput[]
    updateMany?: ScheduledRetweetUpdateManyWithWhereWithoutViralDraftInput | ScheduledRetweetUpdateManyWithWhereWithoutViralDraftInput[]
    deleteMany?: ScheduledRetweetScalarWhereInput | ScheduledRetweetScalarWhereInput[]
  }

  export type ViralDraftV2CreateNestedOneWithoutPerformanceInput = {
    create?: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutPerformanceInput
    connect?: ViralDraftV2WhereUniqueInput
  }

  export type ViralDraftV2UpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutPerformanceInput
    upsert?: ViralDraftV2UpsertWithoutPerformanceInput
    connect?: ViralDraftV2WhereUniqueInput
    update?: XOR<XOR<ViralDraftV2UpdateToOneWithWhereWithoutPerformanceInput, ViralDraftV2UpdateWithoutPerformanceInput>, ViralDraftV2UncheckedUpdateWithoutPerformanceInput>
  }

  export type CharacterProfileCreatepreferredNewsCategoriesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCharacterProfilesInput = {
    create?: XOR<UserCreateWithoutCharacterProfilesInput, UserUncheckedCreateWithoutCharacterProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharacterProfilesInput
    connect?: UserWhereUniqueInput
  }

  export type ViralSessionCreateNestedManyWithoutCharacterProfileInput = {
    create?: XOR<ViralSessionCreateWithoutCharacterProfileInput, ViralSessionUncheckedCreateWithoutCharacterProfileInput> | ViralSessionCreateWithoutCharacterProfileInput[] | ViralSessionUncheckedCreateWithoutCharacterProfileInput[]
    connectOrCreate?: ViralSessionCreateOrConnectWithoutCharacterProfileInput | ViralSessionCreateOrConnectWithoutCharacterProfileInput[]
    createMany?: ViralSessionCreateManyCharacterProfileInputEnvelope
    connect?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
  }

  export type ViralSessionUncheckedCreateNestedManyWithoutCharacterProfileInput = {
    create?: XOR<ViralSessionCreateWithoutCharacterProfileInput, ViralSessionUncheckedCreateWithoutCharacterProfileInput> | ViralSessionCreateWithoutCharacterProfileInput[] | ViralSessionUncheckedCreateWithoutCharacterProfileInput[]
    connectOrCreate?: ViralSessionCreateOrConnectWithoutCharacterProfileInput | ViralSessionCreateOrConnectWithoutCharacterProfileInput[]
    createMany?: ViralSessionCreateManyCharacterProfileInputEnvelope
    connect?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
  }

  export type CharacterProfileUpdatepreferredNewsCategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutCharacterProfilesNestedInput = {
    create?: XOR<UserCreateWithoutCharacterProfilesInput, UserUncheckedCreateWithoutCharacterProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharacterProfilesInput
    upsert?: UserUpsertWithoutCharacterProfilesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharacterProfilesInput, UserUpdateWithoutCharacterProfilesInput>, UserUncheckedUpdateWithoutCharacterProfilesInput>
  }

  export type ViralSessionUpdateManyWithoutCharacterProfileNestedInput = {
    create?: XOR<ViralSessionCreateWithoutCharacterProfileInput, ViralSessionUncheckedCreateWithoutCharacterProfileInput> | ViralSessionCreateWithoutCharacterProfileInput[] | ViralSessionUncheckedCreateWithoutCharacterProfileInput[]
    connectOrCreate?: ViralSessionCreateOrConnectWithoutCharacterProfileInput | ViralSessionCreateOrConnectWithoutCharacterProfileInput[]
    upsert?: ViralSessionUpsertWithWhereUniqueWithoutCharacterProfileInput | ViralSessionUpsertWithWhereUniqueWithoutCharacterProfileInput[]
    createMany?: ViralSessionCreateManyCharacterProfileInputEnvelope
    set?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    disconnect?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    delete?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    connect?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    update?: ViralSessionUpdateWithWhereUniqueWithoutCharacterProfileInput | ViralSessionUpdateWithWhereUniqueWithoutCharacterProfileInput[]
    updateMany?: ViralSessionUpdateManyWithWhereWithoutCharacterProfileInput | ViralSessionUpdateManyWithWhereWithoutCharacterProfileInput[]
    deleteMany?: ViralSessionScalarWhereInput | ViralSessionScalarWhereInput[]
  }

  export type ViralSessionUncheckedUpdateManyWithoutCharacterProfileNestedInput = {
    create?: XOR<ViralSessionCreateWithoutCharacterProfileInput, ViralSessionUncheckedCreateWithoutCharacterProfileInput> | ViralSessionCreateWithoutCharacterProfileInput[] | ViralSessionUncheckedCreateWithoutCharacterProfileInput[]
    connectOrCreate?: ViralSessionCreateOrConnectWithoutCharacterProfileInput | ViralSessionCreateOrConnectWithoutCharacterProfileInput[]
    upsert?: ViralSessionUpsertWithWhereUniqueWithoutCharacterProfileInput | ViralSessionUpsertWithWhereUniqueWithoutCharacterProfileInput[]
    createMany?: ViralSessionCreateManyCharacterProfileInputEnvelope
    set?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    disconnect?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    delete?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    connect?: ViralSessionWhereUniqueInput | ViralSessionWhereUniqueInput[]
    update?: ViralSessionUpdateWithWhereUniqueWithoutCharacterProfileInput | ViralSessionUpdateWithWhereUniqueWithoutCharacterProfileInput[]
    updateMany?: ViralSessionUpdateManyWithWhereWithoutCharacterProfileInput | ViralSessionUpdateManyWithWhereWithoutCharacterProfileInput[]
    deleteMany?: ViralSessionScalarWhereInput | ViralSessionScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCotSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusFilter<$PrismaModel> | $Enums.CotSessionStatus
  }

  export type NestedEnumCotPhaseStepFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepFilter<$PrismaModel> | $Enums.CotPhaseStep
  }

  export type NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCotSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStepFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStepFilter<$PrismaModel>
  }

  export type NestedEnumCotPhaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusFilter<$PrismaModel> | $Enums.CotPhaseStatus
  }

  export type NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumCotDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusFilter<$PrismaModel> | $Enums.CotDraftStatus
  }

  export type NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotDraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumCotDraftStatusFilter<$PrismaModel>
  }

  export type NestedEnumRTStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusFilter<$PrismaModel> | $Enums.RTStatus
  }

  export type NestedEnumRTStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusWithAggregatesFilter<$PrismaModel> | $Enums.RTStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRTStatusFilter<$PrismaModel>
    _max?: NestedEnumRTStatusFilter<$PrismaModel>
  }

  export type ScheduledPostCreateWithoutRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUncheckedCreateWithoutRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostCreateOrConnectWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    create: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput>
  }

  export type ScheduledPostCreateManyRefPostInputEnvelope = {
    data: ScheduledPostCreateManyRefPostInput | ScheduledPostCreateManyRefPostInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    update: XOR<ScheduledPostUpdateWithoutRefPostInput, ScheduledPostUncheckedUpdateWithoutRefPostInput>
    create: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput>
  }

  export type ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    data: XOR<ScheduledPostUpdateWithoutRefPostInput, ScheduledPostUncheckedUpdateWithoutRefPostInput>
  }

  export type ScheduledPostUpdateManyWithWhereWithoutRefPostInput = {
    where: ScheduledPostScalarWhereInput
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyWithoutRefPostInput>
  }

  export type ScheduledPostScalarWhereInput = {
    AND?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
    OR?: ScheduledPostScalarWhereInput[]
    NOT?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
  }

  export type BuzzPostCreateWithoutScheduledPostsInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostUncheckedCreateWithoutScheduledPostsInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostCreateOrConnectWithoutScheduledPostsInput = {
    where: BuzzPostWhereUniqueInput
    create: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
  }

  export type BuzzPostUpsertWithoutScheduledPostsInput = {
    update: XOR<BuzzPostUpdateWithoutScheduledPostsInput, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
    create: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    where?: BuzzPostWhereInput
  }

  export type BuzzPostUpdateToOneWithWhereWithoutScheduledPostsInput = {
    where?: BuzzPostWhereInput
    data: XOR<BuzzPostUpdateWithoutScheduledPostsInput, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
  }

  export type BuzzPostUpdateWithoutScheduledPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzPostUncheckedUpdateWithoutScheduledPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WatchlistUserCreateWithoutUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUserCreateManyUserInputEnvelope = {
    data: WatchlistUserCreateManyUserInput | WatchlistUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CharacterProfileCreateWithoutUserInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    sessions?: ViralSessionCreateNestedManyWithoutCharacterProfileInput
  }

  export type CharacterProfileUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    sessions?: ViralSessionUncheckedCreateNestedManyWithoutCharacterProfileInput
  }

  export type CharacterProfileCreateOrConnectWithoutUserInput = {
    where: CharacterProfileWhereUniqueInput
    create: XOR<CharacterProfileCreateWithoutUserInput, CharacterProfileUncheckedCreateWithoutUserInput>
  }

  export type CharacterProfileCreateManyUserInputEnvelope = {
    data: CharacterProfileCreateManyUserInput | CharacterProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type WatchlistUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    update: XOR<WatchlistUserUpdateWithoutUserInput, WatchlistUserUncheckedUpdateWithoutUserInput>
    create: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    data: XOR<WatchlistUserUpdateWithoutUserInput, WatchlistUserUncheckedUpdateWithoutUserInput>
  }

  export type WatchlistUserUpdateManyWithWhereWithoutUserInput = {
    where: WatchlistUserScalarWhereInput
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WatchlistUserScalarWhereInput = {
    AND?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
    OR?: WatchlistUserScalarWhereInput[]
    NOT?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
    id?: StringFilter<"WatchlistUser"> | string
    userId?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    followers?: IntNullableFilter<"WatchlistUser"> | number | null
    following?: IntNullableFilter<"WatchlistUser"> | number | null
    isActive?: BoolFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchlistUser"> | Date | string
  }

  export type CharacterProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: CharacterProfileWhereUniqueInput
    update: XOR<CharacterProfileUpdateWithoutUserInput, CharacterProfileUncheckedUpdateWithoutUserInput>
    create: XOR<CharacterProfileCreateWithoutUserInput, CharacterProfileUncheckedCreateWithoutUserInput>
  }

  export type CharacterProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: CharacterProfileWhereUniqueInput
    data: XOR<CharacterProfileUpdateWithoutUserInput, CharacterProfileUncheckedUpdateWithoutUserInput>
  }

  export type CharacterProfileUpdateManyWithWhereWithoutUserInput = {
    where: CharacterProfileScalarWhereInput
    data: XOR<CharacterProfileUpdateManyMutationInput, CharacterProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type CharacterProfileScalarWhereInput = {
    AND?: CharacterProfileScalarWhereInput | CharacterProfileScalarWhereInput[]
    OR?: CharacterProfileScalarWhereInput[]
    NOT?: CharacterProfileScalarWhereInput | CharacterProfileScalarWhereInput[]
    id?: StringFilter<"CharacterProfile"> | string
    name?: StringFilter<"CharacterProfile"> | string
    age?: IntFilter<"CharacterProfile"> | number
    gender?: StringFilter<"CharacterProfile"> | string
    tone?: StringFilter<"CharacterProfile"> | string
    catchphrase?: StringFilter<"CharacterProfile"> | string
    philosophy?: StringNullableFilter<"CharacterProfile"> | string | null
    voiceStyle?: JsonFilter<"CharacterProfile">
    topics?: JsonFilter<"CharacterProfile">
    visual?: JsonNullableFilter<"CharacterProfile">
    isDefault?: BoolFilter<"CharacterProfile"> | boolean
    userId?: StringNullableFilter<"CharacterProfile"> | string | null
    createdAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableFilter<"CharacterProfile">
    topicExpertise?: JsonNullableFilter<"CharacterProfile">
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
    characterProfiles?: CharacterProfileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
    characterProfiles?: CharacterProfileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
    characterProfiles?: CharacterProfileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
    characterProfiles?: CharacterProfileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NewsArticleCreateWithoutSourceInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
    viralRelations?: NewsViralRelationCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutSourceInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
    viralRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput>
  }

  export type NewsArticleCreateManySourceInputEnvelope = {
    data: NewsArticleCreateManySourceInput | NewsArticleCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type NewsArticleUpsertWithWhereUniqueWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    update: XOR<NewsArticleUpdateWithoutSourceInput, NewsArticleUncheckedUpdateWithoutSourceInput>
    create: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput>
  }

  export type NewsArticleUpdateWithWhereUniqueWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    data: XOR<NewsArticleUpdateWithoutSourceInput, NewsArticleUncheckedUpdateWithoutSourceInput>
  }

  export type NewsArticleUpdateManyWithWhereWithoutSourceInput = {
    where: NewsArticleScalarWhereInput
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyWithoutSourceInput>
  }

  export type NewsArticleScalarWhereInput = {
    AND?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
    OR?: NewsArticleScalarWhereInput[]
    NOT?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    description?: StringNullableFilter<"NewsArticle"> | string | null
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
  }

  export type NewsAnalysisCreateWithoutArticleInput = {
    id?: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisUncheckedCreateWithoutArticleInput = {
    id?: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisCreateOrConnectWithoutArticleInput = {
    where: NewsAnalysisWhereUniqueInput
    create: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
  }

  export type NewsSourceCreateWithoutArticlesInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
  }

  export type NewsSourceUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
  }

  export type NewsSourceCreateOrConnectWithoutArticlesInput = {
    where: NewsSourceWhereUniqueInput
    create: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
  }

  export type NewsThreadItemCreateWithoutArticleInput = {
    id?: string
    order: number
    content?: string | null
    createdAt?: Date | string
    thread: NewsThreadCreateNestedOneWithoutItemsInput
  }

  export type NewsThreadItemUncheckedCreateWithoutArticleInput = {
    id?: string
    threadId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemCreateOrConnectWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    create: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput>
  }

  export type NewsThreadItemCreateManyArticleInputEnvelope = {
    data: NewsThreadItemCreateManyArticleInput | NewsThreadItemCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type NewsViralRelationCreateWithoutNewsArticleInput = {
    id?: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
    session: ViralSessionCreateNestedOneWithoutNewsRelationsInput
  }

  export type NewsViralRelationUncheckedCreateWithoutNewsArticleInput = {
    id?: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationCreateOrConnectWithoutNewsArticleInput = {
    where: NewsViralRelationWhereUniqueInput
    create: XOR<NewsViralRelationCreateWithoutNewsArticleInput, NewsViralRelationUncheckedCreateWithoutNewsArticleInput>
  }

  export type NewsViralRelationCreateManyNewsArticleInputEnvelope = {
    data: NewsViralRelationCreateManyNewsArticleInput | NewsViralRelationCreateManyNewsArticleInput[]
    skipDuplicates?: boolean
  }

  export type NewsAnalysisUpsertWithoutArticleInput = {
    update: XOR<NewsAnalysisUpdateWithoutArticleInput, NewsAnalysisUncheckedUpdateWithoutArticleInput>
    create: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    where?: NewsAnalysisWhereInput
  }

  export type NewsAnalysisUpdateToOneWithWhereWithoutArticleInput = {
    where?: NewsAnalysisWhereInput
    data: XOR<NewsAnalysisUpdateWithoutArticleInput, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsAnalysisUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUpsertWithoutArticlesInput = {
    update: XOR<NewsSourceUpdateWithoutArticlesInput, NewsSourceUncheckedUpdateWithoutArticlesInput>
    create: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    where?: NewsSourceWhereInput
  }

  export type NewsSourceUpdateToOneWithWhereWithoutArticlesInput = {
    where?: NewsSourceWhereInput
    data: XOR<NewsSourceUpdateWithoutArticlesInput, NewsSourceUncheckedUpdateWithoutArticlesInput>
  }

  export type NewsSourceUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    update: XOR<NewsThreadItemUpdateWithoutArticleInput, NewsThreadItemUncheckedUpdateWithoutArticleInput>
    create: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput>
  }

  export type NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    data: XOR<NewsThreadItemUpdateWithoutArticleInput, NewsThreadItemUncheckedUpdateWithoutArticleInput>
  }

  export type NewsThreadItemUpdateManyWithWhereWithoutArticleInput = {
    where: NewsThreadItemScalarWhereInput
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyWithoutArticleInput>
  }

  export type NewsThreadItemScalarWhereInput = {
    AND?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
    OR?: NewsThreadItemScalarWhereInput[]
    NOT?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
    id?: StringFilter<"NewsThreadItem"> | string
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringFilter<"NewsThreadItem"> | string
    order?: IntFilter<"NewsThreadItem"> | number
    content?: StringNullableFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeFilter<"NewsThreadItem"> | Date | string
  }

  export type NewsViralRelationUpsertWithWhereUniqueWithoutNewsArticleInput = {
    where: NewsViralRelationWhereUniqueInput
    update: XOR<NewsViralRelationUpdateWithoutNewsArticleInput, NewsViralRelationUncheckedUpdateWithoutNewsArticleInput>
    create: XOR<NewsViralRelationCreateWithoutNewsArticleInput, NewsViralRelationUncheckedCreateWithoutNewsArticleInput>
  }

  export type NewsViralRelationUpdateWithWhereUniqueWithoutNewsArticleInput = {
    where: NewsViralRelationWhereUniqueInput
    data: XOR<NewsViralRelationUpdateWithoutNewsArticleInput, NewsViralRelationUncheckedUpdateWithoutNewsArticleInput>
  }

  export type NewsViralRelationUpdateManyWithWhereWithoutNewsArticleInput = {
    where: NewsViralRelationScalarWhereInput
    data: XOR<NewsViralRelationUpdateManyMutationInput, NewsViralRelationUncheckedUpdateManyWithoutNewsArticleInput>
  }

  export type NewsViralRelationScalarWhereInput = {
    AND?: NewsViralRelationScalarWhereInput | NewsViralRelationScalarWhereInput[]
    OR?: NewsViralRelationScalarWhereInput[]
    NOT?: NewsViralRelationScalarWhereInput | NewsViralRelationScalarWhereInput[]
    id?: StringFilter<"NewsViralRelation"> | string
    newsId?: StringFilter<"NewsViralRelation"> | string
    sessionId?: StringFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeFilter<"NewsViralRelation"> | Date | string
  }

  export type NewsThreadItemCreateWithoutThreadInput = {
    id?: string
    order: number
    content?: string | null
    createdAt?: Date | string
    article: NewsArticleCreateNestedOneWithoutNewsThreadItemsInput
  }

  export type NewsThreadItemUncheckedCreateWithoutThreadInput = {
    id?: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemCreateOrConnectWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    create: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput>
  }

  export type NewsThreadItemCreateManyThreadInputEnvelope = {
    data: NewsThreadItemCreateManyThreadInput | NewsThreadItemCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    update: XOR<NewsThreadItemUpdateWithoutThreadInput, NewsThreadItemUncheckedUpdateWithoutThreadInput>
    create: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput>
  }

  export type NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    data: XOR<NewsThreadItemUpdateWithoutThreadInput, NewsThreadItemUncheckedUpdateWithoutThreadInput>
  }

  export type NewsThreadItemUpdateManyWithWhereWithoutThreadInput = {
    where: NewsThreadItemScalarWhereInput
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyWithoutThreadInput>
  }

  export type NewsThreadCreateWithoutItemsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadUncheckedCreateWithoutItemsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadCreateOrConnectWithoutItemsInput = {
    where: NewsThreadWhereUniqueInput
    create: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
  }

  export type NewsArticleCreateWithoutNewsThreadItemsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    viralRelations?: NewsViralRelationCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutNewsThreadItemsInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    viralRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutNewsThreadItemsInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
  }

  export type NewsThreadUpsertWithoutItemsInput = {
    update: XOR<NewsThreadUpdateWithoutItemsInput, NewsThreadUncheckedUpdateWithoutItemsInput>
    create: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    where?: NewsThreadWhereInput
  }

  export type NewsThreadUpdateToOneWithWhereWithoutItemsInput = {
    where?: NewsThreadWhereInput
    data: XOR<NewsThreadUpdateWithoutItemsInput, NewsThreadUncheckedUpdateWithoutItemsInput>
  }

  export type NewsThreadUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsArticleUpsertWithoutNewsThreadItemsInput = {
    update: XOR<NewsArticleUpdateWithoutNewsThreadItemsInput, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
    create: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutNewsThreadItemsInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutNewsThreadItemsInput, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
  }

  export type NewsArticleUpdateWithoutNewsThreadItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    viralRelations?: NewsViralRelationUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUncheckedUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleCreateWithoutAnalysisInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
    viralRelations?: NewsViralRelationCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutAnalysisInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
    viralRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutNewsArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutAnalysisInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
  }

  export type NewsArticleUpsertWithoutAnalysisInput = {
    update: XOR<NewsArticleUpdateWithoutAnalysisInput, NewsArticleUncheckedUpdateWithoutAnalysisInput>
    create: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutAnalysisInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutAnalysisInput, NewsArticleUncheckedUpdateWithoutAnalysisInput>
  }

  export type NewsArticleUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUncheckedUpdateManyWithoutNewsArticleNestedInput
  }

  export type UserCreateWithoutWatchlistUsersInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    characterProfiles?: CharacterProfileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchlistUsersInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    characterProfiles?: CharacterProfileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchlistUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
  }

  export type WatchlistTweetCreateWithoutWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetUncheckedCreateWithoutWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetCreateOrConnectWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    create: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetCreateManyWatchlistUserInputEnvelope = {
    data: WatchlistTweetCreateManyWatchlistUserInput | WatchlistTweetCreateManyWatchlistUserInput[]
    skipDuplicates?: boolean
  }

  export type InteractionHistoryCreateWithoutWatchlistUserInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryUncheckedCreateWithoutWatchlistUserInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryCreateOrConnectWithoutWatchlistUserInput = {
    where: InteractionHistoryWhereUniqueInput
    create: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput>
  }

  export type InteractionHistoryCreateManyWatchlistUserInputEnvelope = {
    data: InteractionHistoryCreateManyWatchlistUserInput | InteractionHistoryCreateManyWatchlistUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWatchlistUsersInput = {
    update: XOR<UserUpdateWithoutWatchlistUsersInput, UserUncheckedUpdateWithoutWatchlistUsersInput>
    create: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchlistUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchlistUsersInput, UserUncheckedUpdateWithoutWatchlistUsersInput>
  }

  export type UserUpdateWithoutWatchlistUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    characterProfiles?: CharacterProfileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchlistUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    characterProfiles?: CharacterProfileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    update: XOR<WatchlistTweetUpdateWithoutWatchlistUserInput, WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput>
    create: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    data: XOR<WatchlistTweetUpdateWithoutWatchlistUserInput, WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput = {
    where: WatchlistTweetScalarWhereInput
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserInput>
  }

  export type WatchlistTweetScalarWhereInput = {
    AND?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
    OR?: WatchlistTweetScalarWhereInput[]
    NOT?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
    id?: StringFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    tweetId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntFilter<"WatchlistTweet"> | number
    likeCount?: IntFilter<"WatchlistTweet"> | number
    replyCount?: IntFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
  }

  export type InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput = {
    where: InteractionHistoryWhereUniqueInput
    update: XOR<InteractionHistoryUpdateWithoutWatchlistUserInput, InteractionHistoryUncheckedUpdateWithoutWatchlistUserInput>
    create: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput>
  }

  export type InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput = {
    where: InteractionHistoryWhereUniqueInput
    data: XOR<InteractionHistoryUpdateWithoutWatchlistUserInput, InteractionHistoryUncheckedUpdateWithoutWatchlistUserInput>
  }

  export type InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput = {
    where: InteractionHistoryScalarWhereInput
    data: XOR<InteractionHistoryUpdateManyMutationInput, InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserInput>
  }

  export type InteractionHistoryScalarWhereInput = {
    AND?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
    OR?: InteractionHistoryScalarWhereInput[]
    NOT?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
    id?: StringFilter<"InteractionHistory"> | string
    watchlistUserId?: StringFilter<"InteractionHistory"> | string
    interactionType?: StringFilter<"InteractionHistory"> | string
    tweetId?: StringNullableFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableFilter<"InteractionHistory">
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
  }

  export type WatchlistUserCreateWithoutTweetsInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistUsersInput
    interactions?: InteractionHistoryCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutTweetsInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    interactions?: InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutTweetsInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
  }

  export type WatchlistUserUpsertWithoutTweetsInput = {
    update: XOR<WatchlistUserUpdateWithoutTweetsInput, WatchlistUserUncheckedUpdateWithoutTweetsInput>
    create: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    where?: WatchlistUserWhereInput
  }

  export type WatchlistUserUpdateToOneWithWhereWithoutTweetsInput = {
    where?: WatchlistUserWhereInput
    data: XOR<WatchlistUserUpdateWithoutTweetsInput, WatchlistUserUncheckedUpdateWithoutTweetsInput>
  }

  export type WatchlistUserUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
    interactions?: InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserCreateWithoutInteractionsInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistUsersInput
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutInteractionsInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutInteractionsInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
  }

  export type WatchlistUserUpsertWithoutInteractionsInput = {
    update: XOR<WatchlistUserUpdateWithoutInteractionsInput, WatchlistUserUncheckedUpdateWithoutInteractionsInput>
    create: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
    where?: WatchlistUserWhereInput
  }

  export type WatchlistUserUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: WatchlistUserWhereInput
    data: XOR<WatchlistUserUpdateWithoutInteractionsInput, WatchlistUserUncheckedUpdateWithoutInteractionsInput>
  }

  export type WatchlistUserUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type CotPhaseCreateWithoutSessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUncheckedCreateWithoutSessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseCreateOrConnectWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    create: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput>
  }

  export type CotPhaseCreateManySessionInputEnvelope = {
    data: CotPhaseCreateManySessionInput | CotPhaseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CotDraftCreateWithoutSessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetCreateNestedManyWithoutCotDraftInput
  }

  export type CotDraftUncheckedCreateWithoutSessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetUncheckedCreateNestedManyWithoutCotDraftInput
  }

  export type CotDraftCreateOrConnectWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput>
  }

  export type CotDraftCreateManySessionInputEnvelope = {
    data: CotDraftCreateManySessionInput | CotDraftCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CotPhaseUpsertWithWhereUniqueWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    update: XOR<CotPhaseUpdateWithoutSessionInput, CotPhaseUncheckedUpdateWithoutSessionInput>
    create: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput>
  }

  export type CotPhaseUpdateWithWhereUniqueWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    data: XOR<CotPhaseUpdateWithoutSessionInput, CotPhaseUncheckedUpdateWithoutSessionInput>
  }

  export type CotPhaseUpdateManyWithWhereWithoutSessionInput = {
    where: CotPhaseScalarWhereInput
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyWithoutSessionInput>
  }

  export type CotPhaseScalarWhereInput = {
    AND?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
    OR?: CotPhaseScalarWhereInput[]
    NOT?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
    id?: StringFilter<"CotPhase"> | string
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
  }

  export type CotDraftUpsertWithWhereUniqueWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    update: XOR<CotDraftUpdateWithoutSessionInput, CotDraftUncheckedUpdateWithoutSessionInput>
    create: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput>
  }

  export type CotDraftUpdateWithWhereUniqueWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    data: XOR<CotDraftUpdateWithoutSessionInput, CotDraftUncheckedUpdateWithoutSessionInput>
  }

  export type CotDraftUpdateManyWithWhereWithoutSessionInput = {
    where: CotDraftScalarWhereInput
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyWithoutSessionInput>
  }

  export type CotDraftScalarWhereInput = {
    AND?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
    OR?: CotDraftScalarWhereInput[]
    NOT?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
    id?: StringFilter<"CotDraft"> | string
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
  }

  export type CotSessionCreateWithoutPhasesInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    drafts?: CotDraftCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateWithoutPhasesInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    drafts?: CotDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionCreateOrConnectWithoutPhasesInput = {
    where: CotSessionWhereUniqueInput
    create: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
  }

  export type CotSessionUpsertWithoutPhasesInput = {
    update: XOR<CotSessionUpdateWithoutPhasesInput, CotSessionUncheckedUpdateWithoutPhasesInput>
    create: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    where?: CotSessionWhereInput
  }

  export type CotSessionUpdateToOneWithWhereWithoutPhasesInput = {
    where?: CotSessionWhereInput
    data: XOR<CotSessionUpdateWithoutPhasesInput, CotSessionUncheckedUpdateWithoutPhasesInput>
  }

  export type CotSessionUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drafts?: CotDraftUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drafts?: CotDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionCreateWithoutDraftsInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateWithoutDraftsInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionCreateOrConnectWithoutDraftsInput = {
    where: CotSessionWhereUniqueInput
    create: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
  }

  export type CotDraftPerformanceCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUncheckedCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceCreateOrConnectWithoutDraftInput = {
    where: CotDraftPerformanceWhereUniqueInput
    create: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
  }

  export type ScheduledRetweetCreateWithoutCotDraftInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viralDraft?: ViralDraftV2CreateNestedOneWithoutScheduledRTsInput
  }

  export type ScheduledRetweetUncheckedCreateWithoutCotDraftInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetCreateOrConnectWithoutCotDraftInput = {
    where: ScheduledRetweetWhereUniqueInput
    create: XOR<ScheduledRetweetCreateWithoutCotDraftInput, ScheduledRetweetUncheckedCreateWithoutCotDraftInput>
  }

  export type ScheduledRetweetCreateManyCotDraftInputEnvelope = {
    data: ScheduledRetweetCreateManyCotDraftInput | ScheduledRetweetCreateManyCotDraftInput[]
    skipDuplicates?: boolean
  }

  export type CotSessionUpsertWithoutDraftsInput = {
    update: XOR<CotSessionUpdateWithoutDraftsInput, CotSessionUncheckedUpdateWithoutDraftsInput>
    create: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    where?: CotSessionWhereInput
  }

  export type CotSessionUpdateToOneWithWhereWithoutDraftsInput = {
    where?: CotSessionWhereInput
    data: XOR<CotSessionUpdateWithoutDraftsInput, CotSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type CotSessionUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotDraftPerformanceUpsertWithoutDraftInput = {
    update: XOR<CotDraftPerformanceUpdateWithoutDraftInput, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
    create: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    where?: CotDraftPerformanceWhereInput
  }

  export type CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput = {
    where?: CotDraftPerformanceWhereInput
    data: XOR<CotDraftPerformanceUpdateWithoutDraftInput, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotDraftPerformanceUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUpsertWithWhereUniqueWithoutCotDraftInput = {
    where: ScheduledRetweetWhereUniqueInput
    update: XOR<ScheduledRetweetUpdateWithoutCotDraftInput, ScheduledRetweetUncheckedUpdateWithoutCotDraftInput>
    create: XOR<ScheduledRetweetCreateWithoutCotDraftInput, ScheduledRetweetUncheckedCreateWithoutCotDraftInput>
  }

  export type ScheduledRetweetUpdateWithWhereUniqueWithoutCotDraftInput = {
    where: ScheduledRetweetWhereUniqueInput
    data: XOR<ScheduledRetweetUpdateWithoutCotDraftInput, ScheduledRetweetUncheckedUpdateWithoutCotDraftInput>
  }

  export type ScheduledRetweetUpdateManyWithWhereWithoutCotDraftInput = {
    where: ScheduledRetweetScalarWhereInput
    data: XOR<ScheduledRetweetUpdateManyMutationInput, ScheduledRetweetUncheckedUpdateManyWithoutCotDraftInput>
  }

  export type ScheduledRetweetScalarWhereInput = {
    AND?: ScheduledRetweetScalarWhereInput | ScheduledRetweetScalarWhereInput[]
    OR?: ScheduledRetweetScalarWhereInput[]
    NOT?: ScheduledRetweetScalarWhereInput | ScheduledRetweetScalarWhereInput[]
    id?: StringFilter<"ScheduledRetweet"> | string
    originalPostId?: StringFilter<"ScheduledRetweet"> | string
    originalContent?: StringFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringFilter<"ScheduledRetweet"> | string
    addComment?: BoolFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
  }

  export type CotDraftCreateWithoutPerformanceInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutDraftsInput
    scheduledRTs?: ScheduledRetweetCreateNestedManyWithoutCotDraftInput
  }

  export type CotDraftUncheckedCreateWithoutPerformanceInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduledRTs?: ScheduledRetweetUncheckedCreateNestedManyWithoutCotDraftInput
  }

  export type CotDraftCreateOrConnectWithoutPerformanceInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
  }

  export type CotDraftUpsertWithoutPerformanceInput = {
    update: XOR<CotDraftUpdateWithoutPerformanceInput, CotDraftUncheckedUpdateWithoutPerformanceInput>
    create: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    where?: CotDraftWhereInput
  }

  export type CotDraftUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: CotDraftWhereInput
    data: XOR<CotDraftUpdateWithoutPerformanceInput, CotDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type CotDraftUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
    scheduledRTs?: ScheduledRetweetUpdateManyWithoutCotDraftNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledRTs?: ScheduledRetweetUncheckedUpdateManyWithoutCotDraftNestedInput
  }

  export type IntegratedSessionSourceCreateWithoutSourceInput = {
    id?: string
    relevanceScore?: number | null
    usageType: string
    session: IntegratedSessionCreateNestedOneWithoutSourcesInput
  }

  export type IntegratedSessionSourceUncheckedCreateWithoutSourceInput = {
    id?: string
    sessionId: string
    relevanceScore?: number | null
    usageType: string
  }

  export type IntegratedSessionSourceCreateOrConnectWithoutSourceInput = {
    where: IntegratedSessionSourceWhereUniqueInput
    create: XOR<IntegratedSessionSourceCreateWithoutSourceInput, IntegratedSessionSourceUncheckedCreateWithoutSourceInput>
  }

  export type IntegratedSessionSourceCreateManySourceInputEnvelope = {
    data: IntegratedSessionSourceCreateManySourceInput | IntegratedSessionSourceCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type IntegratedSessionSourceUpsertWithWhereUniqueWithoutSourceInput = {
    where: IntegratedSessionSourceWhereUniqueInput
    update: XOR<IntegratedSessionSourceUpdateWithoutSourceInput, IntegratedSessionSourceUncheckedUpdateWithoutSourceInput>
    create: XOR<IntegratedSessionSourceCreateWithoutSourceInput, IntegratedSessionSourceUncheckedCreateWithoutSourceInput>
  }

  export type IntegratedSessionSourceUpdateWithWhereUniqueWithoutSourceInput = {
    where: IntegratedSessionSourceWhereUniqueInput
    data: XOR<IntegratedSessionSourceUpdateWithoutSourceInput, IntegratedSessionSourceUncheckedUpdateWithoutSourceInput>
  }

  export type IntegratedSessionSourceUpdateManyWithWhereWithoutSourceInput = {
    where: IntegratedSessionSourceScalarWhereInput
    data: XOR<IntegratedSessionSourceUpdateManyMutationInput, IntegratedSessionSourceUncheckedUpdateManyWithoutSourceInput>
  }

  export type IntegratedSessionSourceScalarWhereInput = {
    AND?: IntegratedSessionSourceScalarWhereInput | IntegratedSessionSourceScalarWhereInput[]
    OR?: IntegratedSessionSourceScalarWhereInput[]
    NOT?: IntegratedSessionSourceScalarWhereInput | IntegratedSessionSourceScalarWhereInput[]
    id?: StringFilter<"IntegratedSessionSource"> | string
    sessionId?: StringFilter<"IntegratedSessionSource"> | string
    sourceId?: StringFilter<"IntegratedSessionSource"> | string
    relevanceScore?: FloatNullableFilter<"IntegratedSessionSource"> | number | null
    usageType?: StringFilter<"IntegratedSessionSource"> | string
  }

  export type ViralSessionCreateWithoutIntegratedSessionsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2CreateNestedManyWithoutSessionInput
    characterProfile?: CharacterProfileCreateNestedOneWithoutSessionsInput
    newsRelations?: NewsViralRelationCreateNestedManyWithoutSessionInput
  }

  export type ViralSessionUncheckedCreateWithoutIntegratedSessionsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput
    newsRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ViralSessionCreateOrConnectWithoutIntegratedSessionsInput = {
    where: ViralSessionWhereUniqueInput
    create: XOR<ViralSessionCreateWithoutIntegratedSessionsInput, ViralSessionUncheckedCreateWithoutIntegratedSessionsInput>
  }

  export type IntegratedSessionSourceCreateWithoutSessionInput = {
    id?: string
    relevanceScore?: number | null
    usageType: string
    source: UnifiedContentSourceCreateNestedOneWithoutIntegratedSessionsInput
  }

  export type IntegratedSessionSourceUncheckedCreateWithoutSessionInput = {
    id?: string
    sourceId: string
    relevanceScore?: number | null
    usageType: string
  }

  export type IntegratedSessionSourceCreateOrConnectWithoutSessionInput = {
    where: IntegratedSessionSourceWhereUniqueInput
    create: XOR<IntegratedSessionSourceCreateWithoutSessionInput, IntegratedSessionSourceUncheckedCreateWithoutSessionInput>
  }

  export type IntegratedSessionSourceCreateManySessionInputEnvelope = {
    data: IntegratedSessionSourceCreateManySessionInput | IntegratedSessionSourceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type IntegratedDraftCreateWithoutSessionInput = {
    id?: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: IntegratedDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type IntegratedDraftUncheckedCreateWithoutSessionInput = {
    id?: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: IntegratedDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type IntegratedDraftCreateOrConnectWithoutSessionInput = {
    where: IntegratedDraftWhereUniqueInput
    create: XOR<IntegratedDraftCreateWithoutSessionInput, IntegratedDraftUncheckedCreateWithoutSessionInput>
  }

  export type IntegratedDraftCreateManySessionInputEnvelope = {
    data: IntegratedDraftCreateManySessionInput | IntegratedDraftCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ViralSessionUpsertWithoutIntegratedSessionsInput = {
    update: XOR<ViralSessionUpdateWithoutIntegratedSessionsInput, ViralSessionUncheckedUpdateWithoutIntegratedSessionsInput>
    create: XOR<ViralSessionCreateWithoutIntegratedSessionsInput, ViralSessionUncheckedCreateWithoutIntegratedSessionsInput>
    where?: ViralSessionWhereInput
  }

  export type ViralSessionUpdateToOneWithWhereWithoutIntegratedSessionsInput = {
    where?: ViralSessionWhereInput
    data: XOR<ViralSessionUpdateWithoutIntegratedSessionsInput, ViralSessionUncheckedUpdateWithoutIntegratedSessionsInput>
  }

  export type ViralSessionUpdateWithoutIntegratedSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UpdateManyWithoutSessionNestedInput
    characterProfile?: CharacterProfileUpdateOneWithoutSessionsNestedInput
    newsRelations?: NewsViralRelationUpdateManyWithoutSessionNestedInput
  }

  export type ViralSessionUncheckedUpdateWithoutIntegratedSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput
    newsRelations?: NewsViralRelationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionSourceUpsertWithWhereUniqueWithoutSessionInput = {
    where: IntegratedSessionSourceWhereUniqueInput
    update: XOR<IntegratedSessionSourceUpdateWithoutSessionInput, IntegratedSessionSourceUncheckedUpdateWithoutSessionInput>
    create: XOR<IntegratedSessionSourceCreateWithoutSessionInput, IntegratedSessionSourceUncheckedCreateWithoutSessionInput>
  }

  export type IntegratedSessionSourceUpdateWithWhereUniqueWithoutSessionInput = {
    where: IntegratedSessionSourceWhereUniqueInput
    data: XOR<IntegratedSessionSourceUpdateWithoutSessionInput, IntegratedSessionSourceUncheckedUpdateWithoutSessionInput>
  }

  export type IntegratedSessionSourceUpdateManyWithWhereWithoutSessionInput = {
    where: IntegratedSessionSourceScalarWhereInput
    data: XOR<IntegratedSessionSourceUpdateManyMutationInput, IntegratedSessionSourceUncheckedUpdateManyWithoutSessionInput>
  }

  export type IntegratedDraftUpsertWithWhereUniqueWithoutSessionInput = {
    where: IntegratedDraftWhereUniqueInput
    update: XOR<IntegratedDraftUpdateWithoutSessionInput, IntegratedDraftUncheckedUpdateWithoutSessionInput>
    create: XOR<IntegratedDraftCreateWithoutSessionInput, IntegratedDraftUncheckedCreateWithoutSessionInput>
  }

  export type IntegratedDraftUpdateWithWhereUniqueWithoutSessionInput = {
    where: IntegratedDraftWhereUniqueInput
    data: XOR<IntegratedDraftUpdateWithoutSessionInput, IntegratedDraftUncheckedUpdateWithoutSessionInput>
  }

  export type IntegratedDraftUpdateManyWithWhereWithoutSessionInput = {
    where: IntegratedDraftScalarWhereInput
    data: XOR<IntegratedDraftUpdateManyMutationInput, IntegratedDraftUncheckedUpdateManyWithoutSessionInput>
  }

  export type IntegratedDraftScalarWhereInput = {
    AND?: IntegratedDraftScalarWhereInput | IntegratedDraftScalarWhereInput[]
    OR?: IntegratedDraftScalarWhereInput[]
    NOT?: IntegratedDraftScalarWhereInput | IntegratedDraftScalarWhereInput[]
    id?: StringFilter<"IntegratedDraft"> | string
    sessionId?: StringFilter<"IntegratedDraft"> | string
    title?: StringFilter<"IntegratedDraft"> | string
    content?: StringFilter<"IntegratedDraft"> | string
    contentType?: StringFilter<"IntegratedDraft"> | string
    sourcesSummary?: StringNullableFilter<"IntegratedDraft"> | string | null
    newsContext?: StringNullableFilter<"IntegratedDraft"> | string | null
    buzzContext?: StringNullableFilter<"IntegratedDraft"> | string | null
    conceptId?: StringNullableFilter<"IntegratedDraft"> | string | null
    hook?: StringNullableFilter<"IntegratedDraft"> | string | null
    angle?: StringNullableFilter<"IntegratedDraft"> | string | null
    sourceNewsIds?: StringNullableListFilter<"IntegratedDraft">
    sourceBuzzIds?: StringNullableListFilter<"IntegratedDraft">
    generationStrategy?: StringNullableFilter<"IntegratedDraft"> | string | null
    generationData?: JsonNullableFilter<"IntegratedDraft">
    hashtags?: StringNullableListFilter<"IntegratedDraft">
    visualGuide?: StringNullableFilter<"IntegratedDraft"> | string | null
    status?: StringFilter<"IntegratedDraft"> | string
    scheduledAt?: DateTimeNullableFilter<"IntegratedDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"IntegratedDraft"> | Date | string | null
    postId?: StringNullableFilter<"IntegratedDraft"> | string | null
    viralScore?: FloatNullableFilter<"IntegratedDraft"> | number | null
    createdAt?: DateTimeFilter<"IntegratedDraft"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedDraft"> | Date | string
  }

  export type IntegratedSessionCreateWithoutSourcesInput = {
    id?: string
    sessionType: string
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    v2Session?: ViralSessionCreateNestedOneWithoutIntegratedSessionsInput
    drafts?: IntegratedDraftCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionUncheckedCreateWithoutSourcesInput = {
    id?: string
    sessionType: string
    v2SessionId?: string | null
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    drafts?: IntegratedDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionCreateOrConnectWithoutSourcesInput = {
    where: IntegratedSessionWhereUniqueInput
    create: XOR<IntegratedSessionCreateWithoutSourcesInput, IntegratedSessionUncheckedCreateWithoutSourcesInput>
  }

  export type UnifiedContentSourceCreateWithoutIntegratedSessionsInput = {
    id?: string
    sourceType: string
    sourceId: string
    contentSummary?: string | null
    importanceScore?: number | null
    viralPotential?: number | null
    keywords?: UnifiedContentSourceCreatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedContentSourceUncheckedCreateWithoutIntegratedSessionsInput = {
    id?: string
    sourceType: string
    sourceId: string
    contentSummary?: string | null
    importanceScore?: number | null
    viralPotential?: number | null
    keywords?: UnifiedContentSourceCreatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedContentSourceCreateOrConnectWithoutIntegratedSessionsInput = {
    where: UnifiedContentSourceWhereUniqueInput
    create: XOR<UnifiedContentSourceCreateWithoutIntegratedSessionsInput, UnifiedContentSourceUncheckedCreateWithoutIntegratedSessionsInput>
  }

  export type IntegratedSessionUpsertWithoutSourcesInput = {
    update: XOR<IntegratedSessionUpdateWithoutSourcesInput, IntegratedSessionUncheckedUpdateWithoutSourcesInput>
    create: XOR<IntegratedSessionCreateWithoutSourcesInput, IntegratedSessionUncheckedCreateWithoutSourcesInput>
    where?: IntegratedSessionWhereInput
  }

  export type IntegratedSessionUpdateToOneWithWhereWithoutSourcesInput = {
    where?: IntegratedSessionWhereInput
    data: XOR<IntegratedSessionUpdateWithoutSourcesInput, IntegratedSessionUncheckedUpdateWithoutSourcesInput>
  }

  export type IntegratedSessionUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    v2Session?: ViralSessionUpdateOneWithoutIntegratedSessionsNestedInput
    drafts?: IntegratedDraftUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    v2SessionId?: NullableStringFieldUpdateOperationsInput | string | null
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drafts?: IntegratedDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UnifiedContentSourceUpsertWithoutIntegratedSessionsInput = {
    update: XOR<UnifiedContentSourceUpdateWithoutIntegratedSessionsInput, UnifiedContentSourceUncheckedUpdateWithoutIntegratedSessionsInput>
    create: XOR<UnifiedContentSourceCreateWithoutIntegratedSessionsInput, UnifiedContentSourceUncheckedCreateWithoutIntegratedSessionsInput>
    where?: UnifiedContentSourceWhereInput
  }

  export type UnifiedContentSourceUpdateToOneWithWhereWithoutIntegratedSessionsInput = {
    where?: UnifiedContentSourceWhereInput
    data: XOR<UnifiedContentSourceUpdateWithoutIntegratedSessionsInput, UnifiedContentSourceUncheckedUpdateWithoutIntegratedSessionsInput>
  }

  export type UnifiedContentSourceUpdateWithoutIntegratedSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    contentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    importanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    viralPotential?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: UnifiedContentSourceUpdatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedContentSourceUncheckedUpdateWithoutIntegratedSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    contentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    importanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    viralPotential?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: UnifiedContentSourceUpdatekeywordsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedSessionCreateWithoutDraftsInput = {
    id?: string
    sessionType: string
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    v2Session?: ViralSessionCreateNestedOneWithoutIntegratedSessionsInput
    sources?: IntegratedSessionSourceCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionUncheckedCreateWithoutDraftsInput = {
    id?: string
    sessionType: string
    v2SessionId?: string | null
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sources?: IntegratedSessionSourceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionCreateOrConnectWithoutDraftsInput = {
    where: IntegratedSessionWhereUniqueInput
    create: XOR<IntegratedSessionCreateWithoutDraftsInput, IntegratedSessionUncheckedCreateWithoutDraftsInput>
  }

  export type IntegratedDraftPerformanceCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    predictionAccuracy?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    predictionAccuracy?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedDraftPerformanceCreateOrConnectWithoutDraftInput = {
    where: IntegratedDraftPerformanceWhereUniqueInput
    create: XOR<IntegratedDraftPerformanceCreateWithoutDraftInput, IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput>
  }

  export type IntegratedSessionUpsertWithoutDraftsInput = {
    update: XOR<IntegratedSessionUpdateWithoutDraftsInput, IntegratedSessionUncheckedUpdateWithoutDraftsInput>
    create: XOR<IntegratedSessionCreateWithoutDraftsInput, IntegratedSessionUncheckedCreateWithoutDraftsInput>
    where?: IntegratedSessionWhereInput
  }

  export type IntegratedSessionUpdateToOneWithWhereWithoutDraftsInput = {
    where?: IntegratedSessionWhereInput
    data: XOR<IntegratedSessionUpdateWithoutDraftsInput, IntegratedSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type IntegratedSessionUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    v2Session?: ViralSessionUpdateOneWithoutIntegratedSessionsNestedInput
    sources?: IntegratedSessionSourceUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    v2SessionId?: NullableStringFieldUpdateOperationsInput | string | null
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sources?: IntegratedSessionSourceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedDraftPerformanceUpsertWithoutDraftInput = {
    update: XOR<IntegratedDraftPerformanceUpdateWithoutDraftInput, IntegratedDraftPerformanceUncheckedUpdateWithoutDraftInput>
    create: XOR<IntegratedDraftPerformanceCreateWithoutDraftInput, IntegratedDraftPerformanceUncheckedCreateWithoutDraftInput>
    where?: IntegratedDraftPerformanceWhereInput
  }

  export type IntegratedDraftPerformanceUpdateToOneWithWhereWithoutDraftInput = {
    where?: IntegratedDraftPerformanceWhereInput
    data: XOR<IntegratedDraftPerformanceUpdateWithoutDraftInput, IntegratedDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type IntegratedDraftPerformanceUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    predictionAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedDraftPerformanceUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    predictionAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedDraftCreateWithoutPerformanceInput = {
    id?: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: IntegratedSessionCreateNestedOneWithoutDraftsInput
  }

  export type IntegratedDraftUncheckedCreateWithoutPerformanceInput = {
    id?: string
    sessionId: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedDraftCreateOrConnectWithoutPerformanceInput = {
    where: IntegratedDraftWhereUniqueInput
    create: XOR<IntegratedDraftCreateWithoutPerformanceInput, IntegratedDraftUncheckedCreateWithoutPerformanceInput>
  }

  export type IntegratedDraftUpsertWithoutPerformanceInput = {
    update: XOR<IntegratedDraftUpdateWithoutPerformanceInput, IntegratedDraftUncheckedUpdateWithoutPerformanceInput>
    create: XOR<IntegratedDraftCreateWithoutPerformanceInput, IntegratedDraftUncheckedCreateWithoutPerformanceInput>
    where?: IntegratedDraftWhereInput
  }

  export type IntegratedDraftUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: IntegratedDraftWhereInput
    data: XOR<IntegratedDraftUpdateWithoutPerformanceInput, IntegratedDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type IntegratedDraftUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntegratedSessionUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type IntegratedDraftUncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftV2CreateWithoutScheduledRTsInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: ViralSessionCreateNestedOneWithoutDraftsInput
    performance?: ViralDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type ViralDraftV2UncheckedCreateWithoutScheduledRTsInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type ViralDraftV2CreateOrConnectWithoutScheduledRTsInput = {
    where: ViralDraftV2WhereUniqueInput
    create: XOR<ViralDraftV2CreateWithoutScheduledRTsInput, ViralDraftV2UncheckedCreateWithoutScheduledRTsInput>
  }

  export type CotDraftCreateWithoutScheduledRTsInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutDraftsInput
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type CotDraftUncheckedCreateWithoutScheduledRTsInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type CotDraftCreateOrConnectWithoutScheduledRTsInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutScheduledRTsInput, CotDraftUncheckedCreateWithoutScheduledRTsInput>
  }

  export type ViralDraftV2UpsertWithoutScheduledRTsInput = {
    update: XOR<ViralDraftV2UpdateWithoutScheduledRTsInput, ViralDraftV2UncheckedUpdateWithoutScheduledRTsInput>
    create: XOR<ViralDraftV2CreateWithoutScheduledRTsInput, ViralDraftV2UncheckedCreateWithoutScheduledRTsInput>
    where?: ViralDraftV2WhereInput
  }

  export type ViralDraftV2UpdateToOneWithWhereWithoutScheduledRTsInput = {
    where?: ViralDraftV2WhereInput
    data: XOR<ViralDraftV2UpdateWithoutScheduledRTsInput, ViralDraftV2UncheckedUpdateWithoutScheduledRTsInput>
  }

  export type ViralDraftV2UpdateWithoutScheduledRTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ViralSessionUpdateOneRequiredWithoutDraftsNestedInput
    performance?: ViralDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateWithoutScheduledRTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUpsertWithoutScheduledRTsInput = {
    update: XOR<CotDraftUpdateWithoutScheduledRTsInput, CotDraftUncheckedUpdateWithoutScheduledRTsInput>
    create: XOR<CotDraftCreateWithoutScheduledRTsInput, CotDraftUncheckedCreateWithoutScheduledRTsInput>
    where?: CotDraftWhereInput
  }

  export type CotDraftUpdateToOneWithWhereWithoutScheduledRTsInput = {
    where?: CotDraftWhereInput
    data: XOR<CotDraftUpdateWithoutScheduledRTsInput, CotDraftUncheckedUpdateWithoutScheduledRTsInput>
  }

  export type CotDraftUpdateWithoutScheduledRTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutScheduledRTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type NewsArticleCreateWithoutViralRelationsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutViralRelationsInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutViralRelationsInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutViralRelationsInput, NewsArticleUncheckedCreateWithoutViralRelationsInput>
  }

  export type ViralSessionCreateWithoutNewsRelationsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2CreateNestedManyWithoutSessionInput
    characterProfile?: CharacterProfileCreateNestedOneWithoutSessionsInput
    integratedSessions?: IntegratedSessionCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionUncheckedCreateWithoutNewsRelationsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionUncheckedCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionCreateOrConnectWithoutNewsRelationsInput = {
    where: ViralSessionWhereUniqueInput
    create: XOR<ViralSessionCreateWithoutNewsRelationsInput, ViralSessionUncheckedCreateWithoutNewsRelationsInput>
  }

  export type NewsArticleUpsertWithoutViralRelationsInput = {
    update: XOR<NewsArticleUpdateWithoutViralRelationsInput, NewsArticleUncheckedUpdateWithoutViralRelationsInput>
    create: XOR<NewsArticleCreateWithoutViralRelationsInput, NewsArticleUncheckedCreateWithoutViralRelationsInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutViralRelationsInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutViralRelationsInput, NewsArticleUncheckedUpdateWithoutViralRelationsInput>
  }

  export type NewsArticleUpdateWithoutViralRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutViralRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ViralSessionUpsertWithoutNewsRelationsInput = {
    update: XOR<ViralSessionUpdateWithoutNewsRelationsInput, ViralSessionUncheckedUpdateWithoutNewsRelationsInput>
    create: XOR<ViralSessionCreateWithoutNewsRelationsInput, ViralSessionUncheckedCreateWithoutNewsRelationsInput>
    where?: ViralSessionWhereInput
  }

  export type ViralSessionUpdateToOneWithWhereWithoutNewsRelationsInput = {
    where?: ViralSessionWhereInput
    data: XOR<ViralSessionUpdateWithoutNewsRelationsInput, ViralSessionUncheckedUpdateWithoutNewsRelationsInput>
  }

  export type ViralSessionUpdateWithoutNewsRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UpdateManyWithoutSessionNestedInput
    characterProfile?: CharacterProfileUpdateOneWithoutSessionsNestedInput
    integratedSessions?: IntegratedSessionUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralSessionUncheckedUpdateWithoutNewsRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUncheckedUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralDraftV2CreateWithoutSessionInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: ViralDraftPerformanceCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetCreateNestedManyWithoutViralDraftInput
  }

  export type ViralDraftV2UncheckedCreateWithoutSessionInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
    scheduledRTs?: ScheduledRetweetUncheckedCreateNestedManyWithoutViralDraftInput
  }

  export type ViralDraftV2CreateOrConnectWithoutSessionInput = {
    where: ViralDraftV2WhereUniqueInput
    create: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput>
  }

  export type ViralDraftV2CreateManySessionInputEnvelope = {
    data: ViralDraftV2CreateManySessionInput | ViralDraftV2CreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CharacterProfileCreateWithoutSessionsInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutCharacterProfilesInput
  }

  export type CharacterProfileUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileCreateOrConnectWithoutSessionsInput = {
    where: CharacterProfileWhereUniqueInput
    create: XOR<CharacterProfileCreateWithoutSessionsInput, CharacterProfileUncheckedCreateWithoutSessionsInput>
  }

  export type NewsViralRelationCreateWithoutSessionInput = {
    id?: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
    newsArticle: NewsArticleCreateNestedOneWithoutViralRelationsInput
  }

  export type NewsViralRelationUncheckedCreateWithoutSessionInput = {
    id?: string
    newsId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationCreateOrConnectWithoutSessionInput = {
    where: NewsViralRelationWhereUniqueInput
    create: XOR<NewsViralRelationCreateWithoutSessionInput, NewsViralRelationUncheckedCreateWithoutSessionInput>
  }

  export type NewsViralRelationCreateManySessionInputEnvelope = {
    data: NewsViralRelationCreateManySessionInput | NewsViralRelationCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type IntegratedSessionCreateWithoutV2SessionInput = {
    id?: string
    sessionType: string
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sources?: IntegratedSessionSourceCreateNestedManyWithoutSessionInput
    drafts?: IntegratedDraftCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionUncheckedCreateWithoutV2SessionInput = {
    id?: string
    sessionType: string
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sources?: IntegratedSessionSourceUncheckedCreateNestedManyWithoutSessionInput
    drafts?: IntegratedDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type IntegratedSessionCreateOrConnectWithoutV2SessionInput = {
    where: IntegratedSessionWhereUniqueInput
    create: XOR<IntegratedSessionCreateWithoutV2SessionInput, IntegratedSessionUncheckedCreateWithoutV2SessionInput>
  }

  export type IntegratedSessionCreateManyV2SessionInputEnvelope = {
    data: IntegratedSessionCreateManyV2SessionInput | IntegratedSessionCreateManyV2SessionInput[]
    skipDuplicates?: boolean
  }

  export type ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput = {
    where: ViralDraftV2WhereUniqueInput
    update: XOR<ViralDraftV2UpdateWithoutSessionInput, ViralDraftV2UncheckedUpdateWithoutSessionInput>
    create: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput>
  }

  export type ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput = {
    where: ViralDraftV2WhereUniqueInput
    data: XOR<ViralDraftV2UpdateWithoutSessionInput, ViralDraftV2UncheckedUpdateWithoutSessionInput>
  }

  export type ViralDraftV2UpdateManyWithWhereWithoutSessionInput = {
    where: ViralDraftV2ScalarWhereInput
    data: XOR<ViralDraftV2UpdateManyMutationInput, ViralDraftV2UncheckedUpdateManyWithoutSessionInput>
  }

  export type ViralDraftV2ScalarWhereInput = {
    AND?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
    OR?: ViralDraftV2ScalarWhereInput[]
    NOT?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
    id?: StringFilter<"ViralDraftV2"> | string
    sessionId?: StringFilter<"ViralDraftV2"> | string
    conceptId?: StringFilter<"ViralDraftV2"> | string
    title?: StringFilter<"ViralDraftV2"> | string
    content?: StringFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterId?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    status?: StringFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
  }

  export type CharacterProfileUpsertWithoutSessionsInput = {
    update: XOR<CharacterProfileUpdateWithoutSessionsInput, CharacterProfileUncheckedUpdateWithoutSessionsInput>
    create: XOR<CharacterProfileCreateWithoutSessionsInput, CharacterProfileUncheckedCreateWithoutSessionsInput>
    where?: CharacterProfileWhereInput
  }

  export type CharacterProfileUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CharacterProfileWhereInput
    data: XOR<CharacterProfileUpdateWithoutSessionsInput, CharacterProfileUncheckedUpdateWithoutSessionsInput>
  }

  export type CharacterProfileUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutCharacterProfilesNestedInput
  }

  export type CharacterProfileUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsViralRelationUpsertWithWhereUniqueWithoutSessionInput = {
    where: NewsViralRelationWhereUniqueInput
    update: XOR<NewsViralRelationUpdateWithoutSessionInput, NewsViralRelationUncheckedUpdateWithoutSessionInput>
    create: XOR<NewsViralRelationCreateWithoutSessionInput, NewsViralRelationUncheckedCreateWithoutSessionInput>
  }

  export type NewsViralRelationUpdateWithWhereUniqueWithoutSessionInput = {
    where: NewsViralRelationWhereUniqueInput
    data: XOR<NewsViralRelationUpdateWithoutSessionInput, NewsViralRelationUncheckedUpdateWithoutSessionInput>
  }

  export type NewsViralRelationUpdateManyWithWhereWithoutSessionInput = {
    where: NewsViralRelationScalarWhereInput
    data: XOR<NewsViralRelationUpdateManyMutationInput, NewsViralRelationUncheckedUpdateManyWithoutSessionInput>
  }

  export type IntegratedSessionUpsertWithWhereUniqueWithoutV2SessionInput = {
    where: IntegratedSessionWhereUniqueInput
    update: XOR<IntegratedSessionUpdateWithoutV2SessionInput, IntegratedSessionUncheckedUpdateWithoutV2SessionInput>
    create: XOR<IntegratedSessionCreateWithoutV2SessionInput, IntegratedSessionUncheckedCreateWithoutV2SessionInput>
  }

  export type IntegratedSessionUpdateWithWhereUniqueWithoutV2SessionInput = {
    where: IntegratedSessionWhereUniqueInput
    data: XOR<IntegratedSessionUpdateWithoutV2SessionInput, IntegratedSessionUncheckedUpdateWithoutV2SessionInput>
  }

  export type IntegratedSessionUpdateManyWithWhereWithoutV2SessionInput = {
    where: IntegratedSessionScalarWhereInput
    data: XOR<IntegratedSessionUpdateManyMutationInput, IntegratedSessionUncheckedUpdateManyWithoutV2SessionInput>
  }

  export type IntegratedSessionScalarWhereInput = {
    AND?: IntegratedSessionScalarWhereInput | IntegratedSessionScalarWhereInput[]
    OR?: IntegratedSessionScalarWhereInput[]
    NOT?: IntegratedSessionScalarWhereInput | IntegratedSessionScalarWhereInput[]
    id?: StringFilter<"IntegratedSession"> | string
    sessionType?: StringFilter<"IntegratedSession"> | string
    v2SessionId?: StringNullableFilter<"IntegratedSession"> | string | null
    newsArticleIds?: StringNullableListFilter<"IntegratedSession">
    buzzPostIds?: StringNullableListFilter<"IntegratedSession">
    generationContext?: JsonNullableFilter<"IntegratedSession">
    performanceMetrics?: JsonNullableFilter<"IntegratedSession">
    status?: StringFilter<"IntegratedSession"> | string
    currentStep?: StringNullableFilter<"IntegratedSession"> | string | null
    theme?: StringNullableFilter<"IntegratedSession"> | string | null
    character?: StringNullableFilter<"IntegratedSession"> | string | null
    platform?: StringNullableFilter<"IntegratedSession"> | string | null
    strategy?: StringNullableFilter<"IntegratedSession"> | string | null
    createdAt?: DateTimeFilter<"IntegratedSession"> | Date | string
    updatedAt?: DateTimeFilter<"IntegratedSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"IntegratedSession"> | Date | string | null
  }

  export type ViralSessionCreateWithoutDraftsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfile?: CharacterProfileCreateNestedOneWithoutSessionsInput
    newsRelations?: NewsViralRelationCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionUncheckedCreateWithoutDraftsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    newsRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionUncheckedCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionCreateOrConnectWithoutDraftsInput = {
    where: ViralSessionWhereUniqueInput
    create: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
  }

  export type ViralDraftPerformanceCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceUncheckedCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceCreateOrConnectWithoutDraftInput = {
    where: ViralDraftPerformanceWhereUniqueInput
    create: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
  }

  export type ScheduledRetweetCreateWithoutViralDraftInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cotDraft?: CotDraftCreateNestedOneWithoutScheduledRTsInput
  }

  export type ScheduledRetweetUncheckedCreateWithoutViralDraftInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetCreateOrConnectWithoutViralDraftInput = {
    where: ScheduledRetweetWhereUniqueInput
    create: XOR<ScheduledRetweetCreateWithoutViralDraftInput, ScheduledRetweetUncheckedCreateWithoutViralDraftInput>
  }

  export type ScheduledRetweetCreateManyViralDraftInputEnvelope = {
    data: ScheduledRetweetCreateManyViralDraftInput | ScheduledRetweetCreateManyViralDraftInput[]
    skipDuplicates?: boolean
  }

  export type ViralSessionUpsertWithoutDraftsInput = {
    update: XOR<ViralSessionUpdateWithoutDraftsInput, ViralSessionUncheckedUpdateWithoutDraftsInput>
    create: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
    where?: ViralSessionWhereInput
  }

  export type ViralSessionUpdateToOneWithWhereWithoutDraftsInput = {
    where?: ViralSessionWhereInput
    data: XOR<ViralSessionUpdateWithoutDraftsInput, ViralSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type ViralSessionUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfile?: CharacterProfileUpdateOneWithoutSessionsNestedInput
    newsRelations?: NewsViralRelationUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralSessionUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    newsRelations?: NewsViralRelationUncheckedUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUncheckedUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralDraftPerformanceUpsertWithoutDraftInput = {
    update: XOR<ViralDraftPerformanceUpdateWithoutDraftInput, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
    create: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    where?: ViralDraftPerformanceWhereInput
  }

  export type ViralDraftPerformanceUpdateToOneWithWhereWithoutDraftInput = {
    where?: ViralDraftPerformanceWhereInput
    data: XOR<ViralDraftPerformanceUpdateWithoutDraftInput, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ViralDraftPerformanceUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUpsertWithWhereUniqueWithoutViralDraftInput = {
    where: ScheduledRetweetWhereUniqueInput
    update: XOR<ScheduledRetweetUpdateWithoutViralDraftInput, ScheduledRetweetUncheckedUpdateWithoutViralDraftInput>
    create: XOR<ScheduledRetweetCreateWithoutViralDraftInput, ScheduledRetweetUncheckedCreateWithoutViralDraftInput>
  }

  export type ScheduledRetweetUpdateWithWhereUniqueWithoutViralDraftInput = {
    where: ScheduledRetweetWhereUniqueInput
    data: XOR<ScheduledRetweetUpdateWithoutViralDraftInput, ScheduledRetweetUncheckedUpdateWithoutViralDraftInput>
  }

  export type ScheduledRetweetUpdateManyWithWhereWithoutViralDraftInput = {
    where: ScheduledRetweetScalarWhereInput
    data: XOR<ScheduledRetweetUpdateManyMutationInput, ScheduledRetweetUncheckedUpdateManyWithoutViralDraftInput>
  }

  export type ViralDraftV2CreateWithoutPerformanceInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: ViralSessionCreateNestedOneWithoutDraftsInput
    scheduledRTs?: ScheduledRetweetCreateNestedManyWithoutViralDraftInput
  }

  export type ViralDraftV2UncheckedCreateWithoutPerformanceInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduledRTs?: ScheduledRetweetUncheckedCreateNestedManyWithoutViralDraftInput
  }

  export type ViralDraftV2CreateOrConnectWithoutPerformanceInput = {
    where: ViralDraftV2WhereUniqueInput
    create: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
  }

  export type ViralDraftV2UpsertWithoutPerformanceInput = {
    update: XOR<ViralDraftV2UpdateWithoutPerformanceInput, ViralDraftV2UncheckedUpdateWithoutPerformanceInput>
    create: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
    where?: ViralDraftV2WhereInput
  }

  export type ViralDraftV2UpdateToOneWithWhereWithoutPerformanceInput = {
    where?: ViralDraftV2WhereInput
    data: XOR<ViralDraftV2UpdateWithoutPerformanceInput, ViralDraftV2UncheckedUpdateWithoutPerformanceInput>
  }

  export type ViralDraftV2UpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ViralSessionUpdateOneRequiredWithoutDraftsNestedInput
    scheduledRTs?: ScheduledRetweetUpdateManyWithoutViralDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledRTs?: ScheduledRetweetUncheckedUpdateManyWithoutViralDraftNestedInput
  }

  export type UserCreateWithoutCharacterProfilesInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCharacterProfilesInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCharacterProfilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharacterProfilesInput, UserUncheckedCreateWithoutCharacterProfilesInput>
  }

  export type ViralSessionCreateWithoutCharacterProfileInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2CreateNestedManyWithoutSessionInput
    newsRelations?: NewsViralRelationCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionUncheckedCreateWithoutCharacterProfileInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput
    newsRelations?: NewsViralRelationUncheckedCreateNestedManyWithoutSessionInput
    integratedSessions?: IntegratedSessionUncheckedCreateNestedManyWithoutV2SessionInput
  }

  export type ViralSessionCreateOrConnectWithoutCharacterProfileInput = {
    where: ViralSessionWhereUniqueInput
    create: XOR<ViralSessionCreateWithoutCharacterProfileInput, ViralSessionUncheckedCreateWithoutCharacterProfileInput>
  }

  export type ViralSessionCreateManyCharacterProfileInputEnvelope = {
    data: ViralSessionCreateManyCharacterProfileInput | ViralSessionCreateManyCharacterProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCharacterProfilesInput = {
    update: XOR<UserUpdateWithoutCharacterProfilesInput, UserUncheckedUpdateWithoutCharacterProfilesInput>
    create: XOR<UserCreateWithoutCharacterProfilesInput, UserUncheckedCreateWithoutCharacterProfilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharacterProfilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharacterProfilesInput, UserUncheckedUpdateWithoutCharacterProfilesInput>
  }

  export type UserUpdateWithoutCharacterProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCharacterProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ViralSessionUpsertWithWhereUniqueWithoutCharacterProfileInput = {
    where: ViralSessionWhereUniqueInput
    update: XOR<ViralSessionUpdateWithoutCharacterProfileInput, ViralSessionUncheckedUpdateWithoutCharacterProfileInput>
    create: XOR<ViralSessionCreateWithoutCharacterProfileInput, ViralSessionUncheckedCreateWithoutCharacterProfileInput>
  }

  export type ViralSessionUpdateWithWhereUniqueWithoutCharacterProfileInput = {
    where: ViralSessionWhereUniqueInput
    data: XOR<ViralSessionUpdateWithoutCharacterProfileInput, ViralSessionUncheckedUpdateWithoutCharacterProfileInput>
  }

  export type ViralSessionUpdateManyWithWhereWithoutCharacterProfileInput = {
    where: ViralSessionScalarWhereInput
    data: XOR<ViralSessionUpdateManyMutationInput, ViralSessionUncheckedUpdateManyWithoutCharacterProfileInput>
  }

  export type ViralSessionScalarWhereInput = {
    AND?: ViralSessionScalarWhereInput | ViralSessionScalarWhereInput[]
    OR?: ViralSessionScalarWhereInput[]
    NOT?: ViralSessionScalarWhereInput | ViralSessionScalarWhereInput[]
    id?: StringFilter<"ViralSession"> | string
    theme?: StringFilter<"ViralSession"> | string
    platform?: StringFilter<"ViralSession"> | string
    style?: StringFilter<"ViralSession"> | string
    status?: StringFilter<"ViralSession"> | string
    createdAt?: DateTimeFilter<"ViralSession"> | Date | string
    characterProfileId?: StringNullableFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableFilter<"ViralSession"> | string | null
    topics?: JsonNullableFilter<"ViralSession">
    concepts?: JsonNullableFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableFilter<"ViralSession">
  }

  export type ScheduledPostCreateManyRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateManyWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type WatchlistUserCreateManyUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
  }

  export type CharacterProfileCreateManyUserInput = {
    id?: string
    name: string
    age: number
    gender: string
    tone: string
    catchphrase: string
    philosophy?: string | null
    voiceStyle: JsonNullValueInput | InputJsonValue
    topics: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    sessions?: ViralSessionUpdateManyWithoutCharacterProfileNestedInput
  }

  export type CharacterProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
    sessions?: ViralSessionUncheckedUpdateManyWithoutCharacterProfileNestedInput
  }

  export type CharacterProfileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyle?: JsonNullValueInput | InputJsonValue
    topics?: JsonNullValueInput | InputJsonValue
    visual?: NullableJsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleCreateManySourceInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
    viralRelations?: NewsViralRelationUncheckedUpdateManyWithoutNewsArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsThreadItemCreateManyArticleInput = {
    id?: string
    threadId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsViralRelationCreateManyNewsArticleInput = {
    id?: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: NewsThreadUpdateOneRequiredWithoutItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUpdateWithoutNewsArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ViralSessionUpdateOneRequiredWithoutNewsRelationsNestedInput
  }

  export type NewsViralRelationUncheckedUpdateWithoutNewsArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUncheckedUpdateManyWithoutNewsArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemCreateManyThreadInput = {
    id?: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: NewsArticleUpdateOneRequiredWithoutNewsThreadItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetCreateManyWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type InteractionHistoryCreateManyWatchlistUserInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WatchlistTweetUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseCreateManySessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftCreateManySessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUpdateManyWithoutCotDraftNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUncheckedUpdateManyWithoutCotDraftNestedInput
  }

  export type CotDraftUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetCreateManyCotDraftInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUpdateWithoutCotDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viralDraft?: ViralDraftV2UpdateOneWithoutScheduledRTsNestedInput
  }

  export type ScheduledRetweetUncheckedUpdateWithoutCotDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUncheckedUpdateManyWithoutCotDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedSessionSourceCreateManySourceInput = {
    id?: string
    sessionId: string
    relevanceScore?: number | null
    usageType: string
  }

  export type IntegratedSessionSourceUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
    session?: IntegratedSessionUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type IntegratedSessionSourceUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedSessionSourceUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedSessionSourceCreateManySessionInput = {
    id?: string
    sourceId: string
    relevanceScore?: number | null
    usageType: string
  }

  export type IntegratedDraftCreateManySessionInput = {
    id?: string
    title: string
    content: string
    contentType: string
    sourcesSummary?: string | null
    newsContext?: string | null
    buzzContext?: string | null
    conceptId?: string | null
    hook?: string | null
    angle?: string | null
    sourceNewsIds?: IntegratedDraftCreatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftCreatesourceBuzzIdsInput | string[]
    generationStrategy?: string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftCreatehashtagsInput | string[]
    visualGuide?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegratedSessionSourceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
    source?: UnifiedContentSourceUpdateOneRequiredWithoutIntegratedSessionsNestedInput
  }

  export type IntegratedSessionSourceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedSessionSourceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usageType?: StringFieldUpdateOperationsInput | string
  }

  export type IntegratedDraftUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: IntegratedDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type IntegratedDraftUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: IntegratedDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type IntegratedDraftUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourcesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    newsContext?: NullableStringFieldUpdateOperationsInput | string | null
    buzzContext?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: NullableStringFieldUpdateOperationsInput | string | null
    hook?: NullableStringFieldUpdateOperationsInput | string | null
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNewsIds?: IntegratedDraftUpdatesourceNewsIdsInput | string[]
    sourceBuzzIds?: IntegratedDraftUpdatesourceBuzzIdsInput | string[]
    generationStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    generationData?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: IntegratedDraftUpdatehashtagsInput | string[]
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftV2CreateManySessionInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    sourceUrl?: string | null
    characterId?: string | null
    characterNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsViralRelationCreateManySessionInput = {
    id?: string
    newsId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type IntegratedSessionCreateManyV2SessionInput = {
    id?: string
    sessionType: string
    newsArticleIds?: IntegratedSessionCreatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionCreatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currentStep?: string | null
    theme?: string | null
    character?: string | null
    platform?: string | null
    strategy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ViralDraftV2UpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: ViralDraftPerformanceUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUpdateManyWithoutViralDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
    scheduledRTs?: ScheduledRetweetUncheckedUpdateManyWithoutViralDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsArticle?: NewsArticleUpdateOneRequiredWithoutViralRelationsNestedInput
  }

  export type NewsViralRelationUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegratedSessionUpdateWithoutV2SessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sources?: IntegratedSessionSourceUpdateManyWithoutSessionNestedInput
    drafts?: IntegratedDraftUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionUncheckedUpdateWithoutV2SessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sources?: IntegratedSessionSourceUncheckedUpdateManyWithoutSessionNestedInput
    drafts?: IntegratedDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IntegratedSessionUncheckedUpdateManyWithoutV2SessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    newsArticleIds?: IntegratedSessionUpdatenewsArticleIdsInput | string[]
    buzzPostIds?: IntegratedSessionUpdatebuzzPostIdsInput | string[]
    generationContext?: NullableJsonNullValueInput | InputJsonValue
    performanceMetrics?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    character?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduledRetweetCreateManyViralDraftInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUpdateWithoutViralDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cotDraft?: CotDraftUpdateOneWithoutScheduledRTsNestedInput
  }

  export type ScheduledRetweetUncheckedUpdateWithoutViralDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUncheckedUpdateManyWithoutViralDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralSessionCreateManyCharacterProfileInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    voiceStyleMode?: string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ViralSessionUpdateWithoutCharacterProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UpdateManyWithoutSessionNestedInput
    newsRelations?: NewsViralRelationUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralSessionUncheckedUpdateWithoutCharacterProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    drafts?: ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput
    newsRelations?: NewsViralRelationUncheckedUpdateManyWithoutSessionNestedInput
    integratedSessions?: IntegratedSessionUncheckedUpdateManyWithoutV2SessionNestedInput
  }

  export type ViralSessionUncheckedUpdateManyWithoutCharacterProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BuzzPostCountOutputTypeDefaultArgs instead
     */
    export type BuzzPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsSourceCountOutputTypeDefaultArgs instead
     */
    export type NewsSourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsArticleCountOutputTypeDefaultArgs instead
     */
    export type NewsArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsThreadCountOutputTypeDefaultArgs instead
     */
    export type NewsThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistUserCountOutputTypeDefaultArgs instead
     */
    export type WatchlistUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotSessionCountOutputTypeDefaultArgs instead
     */
    export type CotSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotDraftCountOutputTypeDefaultArgs instead
     */
    export type CotDraftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotDraftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnifiedContentSourceCountOutputTypeDefaultArgs instead
     */
    export type UnifiedContentSourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnifiedContentSourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegratedSessionCountOutputTypeDefaultArgs instead
     */
    export type IntegratedSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegratedSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViralSessionCountOutputTypeDefaultArgs instead
     */
    export type ViralSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViralSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViralDraftV2CountOutputTypeDefaultArgs instead
     */
    export type ViralDraftV2CountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViralDraftV2CountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterProfileCountOutputTypeDefaultArgs instead
     */
    export type CharacterProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuzzPostDefaultArgs instead
     */
    export type BuzzPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuzzPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuzzConfigDefaultArgs instead
     */
    export type BuzzConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuzzConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledPostDefaultArgs instead
     */
    export type ScheduledPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostAnalyticsDefaultArgs instead
     */
    export type PostAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsSourceDefaultArgs instead
     */
    export type NewsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsArticleDefaultArgs instead
     */
    export type NewsArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsThreadDefaultArgs instead
     */
    export type NewsThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsThreadItemDefaultArgs instead
     */
    export type NewsThreadItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsThreadItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsAnalysisDefaultArgs instead
     */
    export type NewsAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobQueueDefaultArgs instead
     */
    export type JobQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollectionPresetDefaultArgs instead
     */
    export type CollectionPresetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionPresetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistUserDefaultArgs instead
     */
    export type WatchlistUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistTweetDefaultArgs instead
     */
    export type WatchlistTweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistTweetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InteractionHistoryDefaultArgs instead
     */
    export type InteractionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InteractionHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerplexityReportDefaultArgs instead
     */
    export type PerplexityReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerplexityReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotSessionDefaultArgs instead
     */
    export type CotSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotPhaseDefaultArgs instead
     */
    export type CotPhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotPhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotDraftDefaultArgs instead
     */
    export type CotDraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotDraftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotDraftPerformanceDefaultArgs instead
     */
    export type CotDraftPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotDraftPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnifiedContentSourceDefaultArgs instead
     */
    export type UnifiedContentSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnifiedContentSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegratedSessionDefaultArgs instead
     */
    export type IntegratedSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegratedSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegratedSessionSourceDefaultArgs instead
     */
    export type IntegratedSessionSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegratedSessionSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegratedDraftDefaultArgs instead
     */
    export type IntegratedDraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegratedDraftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegratedDraftPerformanceDefaultArgs instead
     */
    export type IntegratedDraftPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegratedDraftPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledRetweetDefaultArgs instead
     */
    export type ScheduledRetweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledRetweetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnifiedPerformanceDefaultArgs instead
     */
    export type UnifiedPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnifiedPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsViralRelationDefaultArgs instead
     */
    export type NewsViralRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsViralRelationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionActivityLogDefaultArgs instead
     */
    export type SessionActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiErrorLogDefaultArgs instead
     */
    export type ApiErrorLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiErrorLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViralSessionDefaultArgs instead
     */
    export type ViralSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViralSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViralDraftV2DefaultArgs instead
     */
    export type ViralDraftV2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViralDraftV2DefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViralDraftPerformanceDefaultArgs instead
     */
    export type ViralDraftPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViralDraftPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterProfileDefaultArgs instead
     */
    export type CharacterProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuzzInfluencerDefaultArgs instead
     */
    export type BuzzInfluencerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuzzInfluencerDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}