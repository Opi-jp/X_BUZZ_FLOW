
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BuzzPost
 * 
 */
export type BuzzPost = $Result.DefaultSelection<Prisma.$BuzzPostPayload>
/**
 * Model BuzzConfig
 * 
 */
export type BuzzConfig = $Result.DefaultSelection<Prisma.$BuzzConfigPayload>
/**
 * Model ScheduledPost
 * 
 */
export type ScheduledPost = $Result.DefaultSelection<Prisma.$ScheduledPostPayload>
/**
 * Model PostAnalytics
 * 
 */
export type PostAnalytics = $Result.DefaultSelection<Prisma.$PostAnalyticsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model NewsSource
 * 
 */
export type NewsSource = $Result.DefaultSelection<Prisma.$NewsSourcePayload>
/**
 * Model NewsArticle
 * 
 */
export type NewsArticle = $Result.DefaultSelection<Prisma.$NewsArticlePayload>
/**
 * Model NewsThread
 * 
 */
export type NewsThread = $Result.DefaultSelection<Prisma.$NewsThreadPayload>
/**
 * Model NewsThreadItem
 * 
 */
export type NewsThreadItem = $Result.DefaultSelection<Prisma.$NewsThreadItemPayload>
/**
 * Model NewsAnalysis
 * 
 */
export type NewsAnalysis = $Result.DefaultSelection<Prisma.$NewsAnalysisPayload>
/**
 * Model JobQueue
 * 
 */
export type JobQueue = $Result.DefaultSelection<Prisma.$JobQueuePayload>
/**
 * Model ApiTask
 * 
 */
export type ApiTask = $Result.DefaultSelection<Prisma.$ApiTaskPayload>
/**
 * Model CollectionPreset
 * 
 */
export type CollectionPreset = $Result.DefaultSelection<Prisma.$CollectionPresetPayload>
/**
 * Model WatchlistUser
 * 
 */
export type WatchlistUser = $Result.DefaultSelection<Prisma.$WatchlistUserPayload>
/**
 * Model WatchlistTweet
 * 
 */
export type WatchlistTweet = $Result.DefaultSelection<Prisma.$WatchlistTweetPayload>
/**
 * Model InteractionHistory
 * 
 */
export type InteractionHistory = $Result.DefaultSelection<Prisma.$InteractionHistoryPayload>
/**
 * Model PerplexityReport
 * 
 */
export type PerplexityReport = $Result.DefaultSelection<Prisma.$PerplexityReportPayload>
/**
 * Model CotSession
 * 
 */
export type CotSession = $Result.DefaultSelection<Prisma.$CotSessionPayload>
/**
 * Model CotPhase
 * 
 */
export type CotPhase = $Result.DefaultSelection<Prisma.$CotPhasePayload>
/**
 * Model CotDraft
 * 
 */
export type CotDraft = $Result.DefaultSelection<Prisma.$CotDraftPayload>
/**
 * Model CotDraftPerformance
 * 
 */
export type CotDraftPerformance = $Result.DefaultSelection<Prisma.$CotDraftPerformancePayload>
/**
 * Model ScheduledRetweet
 * 
 */
export type ScheduledRetweet = $Result.DefaultSelection<Prisma.$ScheduledRetweetPayload>
/**
 * Model UnifiedPerformance
 * 
 */
export type UnifiedPerformance = $Result.DefaultSelection<Prisma.$UnifiedPerformancePayload>
/**
 * Model NewsViralRelation
 * 
 */
export type NewsViralRelation = $Result.DefaultSelection<Prisma.$NewsViralRelationPayload>
/**
 * Model SessionActivityLog
 * 
 */
export type SessionActivityLog = $Result.DefaultSelection<Prisma.$SessionActivityLogPayload>
/**
 * Model ApiErrorLog
 * 
 */
export type ApiErrorLog = $Result.DefaultSelection<Prisma.$ApiErrorLogPayload>
/**
 * Model ViralSession
 * 
 */
export type ViralSession = $Result.DefaultSelection<Prisma.$ViralSessionPayload>
/**
 * Model ViralDraftV2
 * 
 */
export type ViralDraftV2 = $Result.DefaultSelection<Prisma.$ViralDraftV2Payload>
/**
 * Model ViralDraftPerformance
 * 
 */
export type ViralDraftPerformance = $Result.DefaultSelection<Prisma.$ViralDraftPerformancePayload>
/**
 * Model CharacterProfile
 * 
 */
export type CharacterProfile = $Result.DefaultSelection<Prisma.$CharacterProfilePayload>
/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model ai_patterns
 * 
 */
export type ai_patterns = $Result.DefaultSelection<Prisma.$ai_patternsPayload>
/**
 * Model content_drafts
 * 
 */
export type content_drafts = $Result.DefaultSelection<Prisma.$content_draftsPayload>
/**
 * Model gpt_analyses
 * 
 */
export type gpt_analyses = $Result.DefaultSelection<Prisma.$gpt_analysesPayload>
/**
 * Model news_analysis_jobs
 * 
 */
export type news_analysis_jobs = $Result.DefaultSelection<Prisma.$news_analysis_jobsPayload>
/**
 * Model news_analysis_results
 * 
 */
export type news_analysis_results = $Result.DefaultSelection<Prisma.$news_analysis_resultsPayload>
/**
 * Model prompt_templates
 * 
 */
export type prompt_templates = $Result.DefaultSelection<Prisma.$prompt_templatesPayload>
/**
 * Model viral_analysis_logs
 * 
 */
export type viral_analysis_logs = $Result.DefaultSelection<Prisma.$viral_analysis_logsPayload>
/**
 * Model viral_config
 * 
 */
export type viral_config = $Result.DefaultSelection<Prisma.$viral_configPayload>
/**
 * Model viral_opportunities
 * 
 */
export type viral_opportunities = $Result.DefaultSelection<Prisma.$viral_opportunitiesPayload>
/**
 * Model viral_post_performance
 * 
 */
export type viral_post_performance = $Result.DefaultSelection<Prisma.$viral_post_performancePayload>
/**
 * Model viral_posts
 * 
 */
export type viral_posts = $Result.DefaultSelection<Prisma.$viral_postsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  FAILED: 'FAILED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const PostType: {
  NEW: 'NEW',
  RETWEET: 'RETWEET',
  QUOTE: 'QUOTE'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const CotSessionStatus: {
  PENDING: 'PENDING',
  THINKING: 'THINKING',
  EXECUTING: 'EXECUTING',
  INTEGRATING: 'INTEGRATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PAUSED: 'PAUSED'
};

export type CotSessionStatus = (typeof CotSessionStatus)[keyof typeof CotSessionStatus]


export const CotPhaseStep: {
  THINK: 'THINK',
  EXECUTE: 'EXECUTE',
  INTEGRATE: 'INTEGRATE'
};

export type CotPhaseStep = (typeof CotPhaseStep)[keyof typeof CotPhaseStep]


export const CotPhaseStatus: {
  PENDING: 'PENDING',
  THINKING: 'THINKING',
  EXECUTING: 'EXECUTING',
  INTEGRATING: 'INTEGRATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type CotPhaseStatus = (typeof CotPhaseStatus)[keyof typeof CotPhaseStatus]


export const CotDraftStatus: {
  DRAFT: 'DRAFT',
  EDITED: 'EDITED',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  ARCHIVED: 'ARCHIVED'
};

export type CotDraftStatus = (typeof CotDraftStatus)[keyof typeof CotDraftStatus]


export const RTStatus: {
  SCHEDULED: 'SCHEDULED',
  EXECUTED: 'EXECUTED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type RTStatus = (typeof RTStatus)[keyof typeof RTStatus]


export const Gender: {
  male: 'male',
  female: 'female',
  other: 'other'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const draft_status: {
  DRAFT: 'DRAFT',
  EDITED: 'EDITED',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  CANCELLED: 'CANCELLED'
};

export type draft_status = (typeof draft_status)[keyof typeof draft_status]

}

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type CotSessionStatus = $Enums.CotSessionStatus

export const CotSessionStatus: typeof $Enums.CotSessionStatus

export type CotPhaseStep = $Enums.CotPhaseStep

export const CotPhaseStep: typeof $Enums.CotPhaseStep

export type CotPhaseStatus = $Enums.CotPhaseStatus

export const CotPhaseStatus: typeof $Enums.CotPhaseStatus

export type CotDraftStatus = $Enums.CotDraftStatus

export const CotDraftStatus: typeof $Enums.CotDraftStatus

export type RTStatus = $Enums.RTStatus

export const RTStatus: typeof $Enums.RTStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type draft_status = $Enums.draft_status

export const draft_status: typeof $Enums.draft_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BuzzPosts
 * const buzzPosts = await prisma.buzzPost.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BuzzPosts
   * const buzzPosts = await prisma.buzzPost.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.buzzPost`: Exposes CRUD operations for the **BuzzPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzPosts
    * const buzzPosts = await prisma.buzzPost.findMany()
    * ```
    */
  get buzzPost(): Prisma.BuzzPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buzzConfig`: Exposes CRUD operations for the **BuzzConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzConfigs
    * const buzzConfigs = await prisma.buzzConfig.findMany()
    * ```
    */
  get buzzConfig(): Prisma.BuzzConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledPost`: Exposes CRUD operations for the **ScheduledPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledPosts
    * const scheduledPosts = await prisma.scheduledPost.findMany()
    * ```
    */
  get scheduledPost(): Prisma.ScheduledPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postAnalytics`: Exposes CRUD operations for the **PostAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAnalytics
    * const postAnalytics = await prisma.postAnalytics.findMany()
    * ```
    */
  get postAnalytics(): Prisma.PostAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsSource`: Exposes CRUD operations for the **NewsSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsSources
    * const newsSources = await prisma.newsSource.findMany()
    * ```
    */
  get newsSource(): Prisma.NewsSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsArticle`: Exposes CRUD operations for the **NewsArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsArticles
    * const newsArticles = await prisma.newsArticle.findMany()
    * ```
    */
  get newsArticle(): Prisma.NewsArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsThread`: Exposes CRUD operations for the **NewsThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsThreads
    * const newsThreads = await prisma.newsThread.findMany()
    * ```
    */
  get newsThread(): Prisma.NewsThreadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsThreadItem`: Exposes CRUD operations for the **NewsThreadItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsThreadItems
    * const newsThreadItems = await prisma.newsThreadItem.findMany()
    * ```
    */
  get newsThreadItem(): Prisma.NewsThreadItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsAnalysis`: Exposes CRUD operations for the **NewsAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsAnalyses
    * const newsAnalyses = await prisma.newsAnalysis.findMany()
    * ```
    */
  get newsAnalysis(): Prisma.NewsAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobQueue`: Exposes CRUD operations for the **JobQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobQueues
    * const jobQueues = await prisma.jobQueue.findMany()
    * ```
    */
  get jobQueue(): Prisma.JobQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiTask`: Exposes CRUD operations for the **ApiTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiTasks
    * const apiTasks = await prisma.apiTask.findMany()
    * ```
    */
  get apiTask(): Prisma.ApiTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionPreset`: Exposes CRUD operations for the **CollectionPreset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionPresets
    * const collectionPresets = await prisma.collectionPreset.findMany()
    * ```
    */
  get collectionPreset(): Prisma.CollectionPresetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchlistUser`: Exposes CRUD operations for the **WatchlistUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistUsers
    * const watchlistUsers = await prisma.watchlistUser.findMany()
    * ```
    */
  get watchlistUser(): Prisma.WatchlistUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchlistTweet`: Exposes CRUD operations for the **WatchlistTweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistTweets
    * const watchlistTweets = await prisma.watchlistTweet.findMany()
    * ```
    */
  get watchlistTweet(): Prisma.WatchlistTweetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interactionHistory`: Exposes CRUD operations for the **InteractionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InteractionHistories
    * const interactionHistories = await prisma.interactionHistory.findMany()
    * ```
    */
  get interactionHistory(): Prisma.InteractionHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.perplexityReport`: Exposes CRUD operations for the **PerplexityReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerplexityReports
    * const perplexityReports = await prisma.perplexityReport.findMany()
    * ```
    */
  get perplexityReport(): Prisma.PerplexityReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cotSession`: Exposes CRUD operations for the **CotSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotSessions
    * const cotSessions = await prisma.cotSession.findMany()
    * ```
    */
  get cotSession(): Prisma.CotSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cotPhase`: Exposes CRUD operations for the **CotPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotPhases
    * const cotPhases = await prisma.cotPhase.findMany()
    * ```
    */
  get cotPhase(): Prisma.CotPhaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cotDraft`: Exposes CRUD operations for the **CotDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotDrafts
    * const cotDrafts = await prisma.cotDraft.findMany()
    * ```
    */
  get cotDraft(): Prisma.CotDraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cotDraftPerformance`: Exposes CRUD operations for the **CotDraftPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotDraftPerformances
    * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany()
    * ```
    */
  get cotDraftPerformance(): Prisma.CotDraftPerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledRetweet`: Exposes CRUD operations for the **ScheduledRetweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledRetweets
    * const scheduledRetweets = await prisma.scheduledRetweet.findMany()
    * ```
    */
  get scheduledRetweet(): Prisma.ScheduledRetweetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unifiedPerformance`: Exposes CRUD operations for the **UnifiedPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnifiedPerformances
    * const unifiedPerformances = await prisma.unifiedPerformance.findMany()
    * ```
    */
  get unifiedPerformance(): Prisma.UnifiedPerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsViralRelation`: Exposes CRUD operations for the **NewsViralRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsViralRelations
    * const newsViralRelations = await prisma.newsViralRelation.findMany()
    * ```
    */
  get newsViralRelation(): Prisma.NewsViralRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionActivityLog`: Exposes CRUD operations for the **SessionActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionActivityLogs
    * const sessionActivityLogs = await prisma.sessionActivityLog.findMany()
    * ```
    */
  get sessionActivityLog(): Prisma.SessionActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiErrorLog`: Exposes CRUD operations for the **ApiErrorLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiErrorLogs
    * const apiErrorLogs = await prisma.apiErrorLog.findMany()
    * ```
    */
  get apiErrorLog(): Prisma.ApiErrorLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viralSession`: Exposes CRUD operations for the **ViralSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViralSessions
    * const viralSessions = await prisma.viralSession.findMany()
    * ```
    */
  get viralSession(): Prisma.ViralSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viralDraftV2`: Exposes CRUD operations for the **ViralDraftV2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViralDraftV2s
    * const viralDraftV2s = await prisma.viralDraftV2.findMany()
    * ```
    */
  get viralDraftV2(): Prisma.ViralDraftV2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viralDraftPerformance`: Exposes CRUD operations for the **ViralDraftPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViralDraftPerformances
    * const viralDraftPerformances = await prisma.viralDraftPerformance.findMany()
    * ```
    */
  get viralDraftPerformance(): Prisma.ViralDraftPerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterProfile`: Exposes CRUD operations for the **CharacterProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterProfiles
    * const characterProfiles = await prisma.characterProfile.findMany()
    * ```
    */
  get characterProfile(): Prisma.CharacterProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_patterns`: Exposes CRUD operations for the **ai_patterns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_patterns
    * const ai_patterns = await prisma.ai_patterns.findMany()
    * ```
    */
  get ai_patterns(): Prisma.ai_patternsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.content_drafts`: Exposes CRUD operations for the **content_drafts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Content_drafts
    * const content_drafts = await prisma.content_drafts.findMany()
    * ```
    */
  get content_drafts(): Prisma.content_draftsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gpt_analyses`: Exposes CRUD operations for the **gpt_analyses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gpt_analyses
    * const gpt_analyses = await prisma.gpt_analyses.findMany()
    * ```
    */
  get gpt_analyses(): Prisma.gpt_analysesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news_analysis_jobs`: Exposes CRUD operations for the **news_analysis_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News_analysis_jobs
    * const news_analysis_jobs = await prisma.news_analysis_jobs.findMany()
    * ```
    */
  get news_analysis_jobs(): Prisma.news_analysis_jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news_analysis_results`: Exposes CRUD operations for the **news_analysis_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News_analysis_results
    * const news_analysis_results = await prisma.news_analysis_results.findMany()
    * ```
    */
  get news_analysis_results(): Prisma.news_analysis_resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prompt_templates`: Exposes CRUD operations for the **prompt_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prompt_templates
    * const prompt_templates = await prisma.prompt_templates.findMany()
    * ```
    */
  get prompt_templates(): Prisma.prompt_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viral_analysis_logs`: Exposes CRUD operations for the **viral_analysis_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viral_analysis_logs
    * const viral_analysis_logs = await prisma.viral_analysis_logs.findMany()
    * ```
    */
  get viral_analysis_logs(): Prisma.viral_analysis_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viral_config`: Exposes CRUD operations for the **viral_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viral_configs
    * const viral_configs = await prisma.viral_config.findMany()
    * ```
    */
  get viral_config(): Prisma.viral_configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viral_opportunities`: Exposes CRUD operations for the **viral_opportunities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viral_opportunities
    * const viral_opportunities = await prisma.viral_opportunities.findMany()
    * ```
    */
  get viral_opportunities(): Prisma.viral_opportunitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viral_post_performance`: Exposes CRUD operations for the **viral_post_performance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viral_post_performances
    * const viral_post_performances = await prisma.viral_post_performance.findMany()
    * ```
    */
  get viral_post_performance(): Prisma.viral_post_performanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viral_posts`: Exposes CRUD operations for the **viral_posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viral_posts
    * const viral_posts = await prisma.viral_posts.findMany()
    * ```
    */
  get viral_posts(): Prisma.viral_postsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BuzzPost: 'BuzzPost',
    BuzzConfig: 'BuzzConfig',
    ScheduledPost: 'ScheduledPost',
    PostAnalytics: 'PostAnalytics',
    User: 'User',
    Session: 'Session',
    NewsSource: 'NewsSource',
    NewsArticle: 'NewsArticle',
    NewsThread: 'NewsThread',
    NewsThreadItem: 'NewsThreadItem',
    NewsAnalysis: 'NewsAnalysis',
    JobQueue: 'JobQueue',
    ApiTask: 'ApiTask',
    CollectionPreset: 'CollectionPreset',
    WatchlistUser: 'WatchlistUser',
    WatchlistTweet: 'WatchlistTweet',
    InteractionHistory: 'InteractionHistory',
    PerplexityReport: 'PerplexityReport',
    CotSession: 'CotSession',
    CotPhase: 'CotPhase',
    CotDraft: 'CotDraft',
    CotDraftPerformance: 'CotDraftPerformance',
    ScheduledRetweet: 'ScheduledRetweet',
    UnifiedPerformance: 'UnifiedPerformance',
    NewsViralRelation: 'NewsViralRelation',
    SessionActivityLog: 'SessionActivityLog',
    ApiErrorLog: 'ApiErrorLog',
    ViralSession: 'ViralSession',
    ViralDraftV2: 'ViralDraftV2',
    ViralDraftPerformance: 'ViralDraftPerformance',
    CharacterProfile: 'CharacterProfile',
    accounts: 'accounts',
    ai_patterns: 'ai_patterns',
    content_drafts: 'content_drafts',
    gpt_analyses: 'gpt_analyses',
    news_analysis_jobs: 'news_analysis_jobs',
    news_analysis_results: 'news_analysis_results',
    prompt_templates: 'prompt_templates',
    viral_analysis_logs: 'viral_analysis_logs',
    viral_config: 'viral_config',
    viral_opportunities: 'viral_opportunities',
    viral_post_performance: 'viral_post_performance',
    viral_posts: 'viral_posts'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "buzzPost" | "buzzConfig" | "scheduledPost" | "postAnalytics" | "user" | "session" | "newsSource" | "newsArticle" | "newsThread" | "newsThreadItem" | "newsAnalysis" | "jobQueue" | "apiTask" | "collectionPreset" | "watchlistUser" | "watchlistTweet" | "interactionHistory" | "perplexityReport" | "cotSession" | "cotPhase" | "cotDraft" | "cotDraftPerformance" | "scheduledRetweet" | "unifiedPerformance" | "newsViralRelation" | "sessionActivityLog" | "apiErrorLog" | "viralSession" | "viralDraftV2" | "viralDraftPerformance" | "characterProfile" | "accounts" | "ai_patterns" | "content_drafts" | "gpt_analyses" | "news_analysis_jobs" | "news_analysis_results" | "prompt_templates" | "viral_analysis_logs" | "viral_config" | "viral_opportunities" | "viral_post_performance" | "viral_posts"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BuzzPost: {
        payload: Prisma.$BuzzPostPayload<ExtArgs>
        fields: Prisma.BuzzPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          findFirst: {
            args: Prisma.BuzzPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          findMany: {
            args: Prisma.BuzzPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          create: {
            args: Prisma.BuzzPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          createMany: {
            args: Prisma.BuzzPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuzzPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          delete: {
            args: Prisma.BuzzPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          update: {
            args: Prisma.BuzzPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          deleteMany: {
            args: Prisma.BuzzPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BuzzPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          upsert: {
            args: Prisma.BuzzPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          aggregate: {
            args: Prisma.BuzzPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzPost>
          }
          groupBy: {
            args: Prisma.BuzzPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzPostCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzPostCountAggregateOutputType> | number
          }
        }
      }
      BuzzConfig: {
        payload: Prisma.$BuzzConfigPayload<ExtArgs>
        fields: Prisma.BuzzConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          findFirst: {
            args: Prisma.BuzzConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          findMany: {
            args: Prisma.BuzzConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>[]
          }
          create: {
            args: Prisma.BuzzConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          createMany: {
            args: Prisma.BuzzConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuzzConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>[]
          }
          delete: {
            args: Prisma.BuzzConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          update: {
            args: Prisma.BuzzConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          deleteMany: {
            args: Prisma.BuzzConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BuzzConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>[]
          }
          upsert: {
            args: Prisma.BuzzConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzConfigPayload>
          }
          aggregate: {
            args: Prisma.BuzzConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzConfig>
          }
          groupBy: {
            args: Prisma.BuzzConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzConfigCountAggregateOutputType> | number
          }
        }
      }
      ScheduledPost: {
        payload: Prisma.$ScheduledPostPayload<ExtArgs>
        fields: Prisma.ScheduledPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findFirst: {
            args: Prisma.ScheduledPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findMany: {
            args: Prisma.ScheduledPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          create: {
            args: Prisma.ScheduledPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          createMany: {
            args: Prisma.ScheduledPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          delete: {
            args: Prisma.ScheduledPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          update: {
            args: Prisma.ScheduledPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          aggregate: {
            args: Prisma.ScheduledPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledPost>
          }
          groupBy: {
            args: Prisma.ScheduledPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledPostCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostCountAggregateOutputType> | number
          }
        }
      }
      PostAnalytics: {
        payload: Prisma.$PostAnalyticsPayload<ExtArgs>
        fields: Prisma.PostAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PostAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PostAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PostAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PostAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.PostAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          update: {
            args: Prisma.PostAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PostAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.PostAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PostAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAnalytics>
          }
          groupBy: {
            args: Prisma.PostAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      NewsSource: {
        payload: Prisma.$NewsSourcePayload<ExtArgs>
        fields: Prisma.NewsSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findFirst: {
            args: Prisma.NewsSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findMany: {
            args: Prisma.NewsSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          create: {
            args: Prisma.NewsSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          createMany: {
            args: Prisma.NewsSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          delete: {
            args: Prisma.NewsSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          update: {
            args: Prisma.NewsSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          deleteMany: {
            args: Prisma.NewsSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          upsert: {
            args: Prisma.NewsSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          aggregate: {
            args: Prisma.NewsSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsSource>
          }
          groupBy: {
            args: Prisma.NewsSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsSourceCountArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceCountAggregateOutputType> | number
          }
        }
      }
      NewsArticle: {
        payload: Prisma.$NewsArticlePayload<ExtArgs>
        fields: Prisma.NewsArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findFirst: {
            args: Prisma.NewsArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findMany: {
            args: Prisma.NewsArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          create: {
            args: Prisma.NewsArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          createMany: {
            args: Prisma.NewsArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          delete: {
            args: Prisma.NewsArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          update: {
            args: Prisma.NewsArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          deleteMany: {
            args: Prisma.NewsArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          upsert: {
            args: Prisma.NewsArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          aggregate: {
            args: Prisma.NewsArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsArticle>
          }
          groupBy: {
            args: Prisma.NewsArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsArticleCountArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleCountAggregateOutputType> | number
          }
        }
      }
      NewsThread: {
        payload: Prisma.$NewsThreadPayload<ExtArgs>
        fields: Prisma.NewsThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          findFirst: {
            args: Prisma.NewsThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          findMany: {
            args: Prisma.NewsThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          create: {
            args: Prisma.NewsThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          createMany: {
            args: Prisma.NewsThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          delete: {
            args: Prisma.NewsThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          update: {
            args: Prisma.NewsThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          deleteMany: {
            args: Prisma.NewsThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsThreadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          upsert: {
            args: Prisma.NewsThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          aggregate: {
            args: Prisma.NewsThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsThread>
          }
          groupBy: {
            args: Prisma.NewsThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsThreadCountArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadCountAggregateOutputType> | number
          }
        }
      }
      NewsThreadItem: {
        payload: Prisma.$NewsThreadItemPayload<ExtArgs>
        fields: Prisma.NewsThreadItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsThreadItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsThreadItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          findFirst: {
            args: Prisma.NewsThreadItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsThreadItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          findMany: {
            args: Prisma.NewsThreadItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          create: {
            args: Prisma.NewsThreadItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          createMany: {
            args: Prisma.NewsThreadItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsThreadItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          delete: {
            args: Prisma.NewsThreadItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          update: {
            args: Prisma.NewsThreadItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          deleteMany: {
            args: Prisma.NewsThreadItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsThreadItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsThreadItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          upsert: {
            args: Prisma.NewsThreadItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          aggregate: {
            args: Prisma.NewsThreadItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsThreadItem>
          }
          groupBy: {
            args: Prisma.NewsThreadItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsThreadItemCountArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadItemCountAggregateOutputType> | number
          }
        }
      }
      NewsAnalysis: {
        payload: Prisma.$NewsAnalysisPayload<ExtArgs>
        fields: Prisma.NewsAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          findFirst: {
            args: Prisma.NewsAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          findMany: {
            args: Prisma.NewsAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          create: {
            args: Prisma.NewsAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          createMany: {
            args: Prisma.NewsAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          delete: {
            args: Prisma.NewsAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          update: {
            args: Prisma.NewsAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.NewsAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.NewsAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          aggregate: {
            args: Prisma.NewsAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsAnalysis>
          }
          groupBy: {
            args: Prisma.NewsAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<NewsAnalysisCountAggregateOutputType> | number
          }
        }
      }
      JobQueue: {
        payload: Prisma.$JobQueuePayload<ExtArgs>
        fields: Prisma.JobQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findFirst: {
            args: Prisma.JobQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findMany: {
            args: Prisma.JobQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          create: {
            args: Prisma.JobQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          createMany: {
            args: Prisma.JobQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          delete: {
            args: Prisma.JobQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          update: {
            args: Prisma.JobQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          deleteMany: {
            args: Prisma.JobQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          upsert: {
            args: Prisma.JobQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          aggregate: {
            args: Prisma.JobQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobQueue>
          }
          groupBy: {
            args: Prisma.JobQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobQueueCountArgs<ExtArgs>
            result: $Utils.Optional<JobQueueCountAggregateOutputType> | number
          }
        }
      }
      ApiTask: {
        payload: Prisma.$ApiTaskPayload<ExtArgs>
        fields: Prisma.ApiTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>
          }
          findFirst: {
            args: Prisma.ApiTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>
          }
          findMany: {
            args: Prisma.ApiTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>[]
          }
          create: {
            args: Prisma.ApiTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>
          }
          createMany: {
            args: Prisma.ApiTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>[]
          }
          delete: {
            args: Prisma.ApiTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>
          }
          update: {
            args: Prisma.ApiTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>
          }
          deleteMany: {
            args: Prisma.ApiTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>[]
          }
          upsert: {
            args: Prisma.ApiTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTaskPayload>
          }
          aggregate: {
            args: Prisma.ApiTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiTask>
          }
          groupBy: {
            args: Prisma.ApiTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ApiTaskCountAggregateOutputType> | number
          }
        }
      }
      CollectionPreset: {
        payload: Prisma.$CollectionPresetPayload<ExtArgs>
        fields: Prisma.CollectionPresetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionPresetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionPresetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          findFirst: {
            args: Prisma.CollectionPresetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionPresetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          findMany: {
            args: Prisma.CollectionPresetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          create: {
            args: Prisma.CollectionPresetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          createMany: {
            args: Prisma.CollectionPresetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionPresetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          delete: {
            args: Prisma.CollectionPresetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          update: {
            args: Prisma.CollectionPresetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          deleteMany: {
            args: Prisma.CollectionPresetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionPresetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionPresetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          upsert: {
            args: Prisma.CollectionPresetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          aggregate: {
            args: Prisma.CollectionPresetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionPreset>
          }
          groupBy: {
            args: Prisma.CollectionPresetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionPresetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionPresetCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionPresetCountAggregateOutputType> | number
          }
        }
      }
      WatchlistUser: {
        payload: Prisma.$WatchlistUserPayload<ExtArgs>
        fields: Prisma.WatchlistUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          findFirst: {
            args: Prisma.WatchlistUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          findMany: {
            args: Prisma.WatchlistUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          create: {
            args: Prisma.WatchlistUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          createMany: {
            args: Prisma.WatchlistUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          delete: {
            args: Prisma.WatchlistUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          update: {
            args: Prisma.WatchlistUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WatchlistUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          upsert: {
            args: Prisma.WatchlistUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          aggregate: {
            args: Prisma.WatchlistUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistUser>
          }
          groupBy: {
            args: Prisma.WatchlistUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistUserCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistUserCountAggregateOutputType> | number
          }
        }
      }
      WatchlistTweet: {
        payload: Prisma.$WatchlistTweetPayload<ExtArgs>
        fields: Prisma.WatchlistTweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistTweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistTweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          findFirst: {
            args: Prisma.WatchlistTweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistTweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          findMany: {
            args: Prisma.WatchlistTweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          create: {
            args: Prisma.WatchlistTweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          createMany: {
            args: Prisma.WatchlistTweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistTweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          delete: {
            args: Prisma.WatchlistTweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          update: {
            args: Prisma.WatchlistTweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistTweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistTweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WatchlistTweetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          upsert: {
            args: Prisma.WatchlistTweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          aggregate: {
            args: Prisma.WatchlistTweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistTweet>
          }
          groupBy: {
            args: Prisma.WatchlistTweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistTweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistTweetCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistTweetCountAggregateOutputType> | number
          }
        }
      }
      InteractionHistory: {
        payload: Prisma.$InteractionHistoryPayload<ExtArgs>
        fields: Prisma.InteractionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          findFirst: {
            args: Prisma.InteractionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          findMany: {
            args: Prisma.InteractionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          create: {
            args: Prisma.InteractionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          createMany: {
            args: Prisma.InteractionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          delete: {
            args: Prisma.InteractionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          update: {
            args: Prisma.InteractionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.InteractionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.InteractionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          aggregate: {
            args: Prisma.InteractionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteractionHistory>
          }
          groupBy: {
            args: Prisma.InteractionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionHistoryCountAggregateOutputType> | number
          }
        }
      }
      PerplexityReport: {
        payload: Prisma.$PerplexityReportPayload<ExtArgs>
        fields: Prisma.PerplexityReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerplexityReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerplexityReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          findFirst: {
            args: Prisma.PerplexityReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerplexityReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          findMany: {
            args: Prisma.PerplexityReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          create: {
            args: Prisma.PerplexityReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          createMany: {
            args: Prisma.PerplexityReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerplexityReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          delete: {
            args: Prisma.PerplexityReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          update: {
            args: Prisma.PerplexityReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          deleteMany: {
            args: Prisma.PerplexityReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerplexityReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerplexityReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          upsert: {
            args: Prisma.PerplexityReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          aggregate: {
            args: Prisma.PerplexityReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerplexityReport>
          }
          groupBy: {
            args: Prisma.PerplexityReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerplexityReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerplexityReportCountArgs<ExtArgs>
            result: $Utils.Optional<PerplexityReportCountAggregateOutputType> | number
          }
        }
      }
      CotSession: {
        payload: Prisma.$CotSessionPayload<ExtArgs>
        fields: Prisma.CotSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          findFirst: {
            args: Prisma.CotSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          findMany: {
            args: Prisma.CotSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          create: {
            args: Prisma.CotSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          createMany: {
            args: Prisma.CotSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          delete: {
            args: Prisma.CotSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          update: {
            args: Prisma.CotSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          deleteMany: {
            args: Prisma.CotSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CotSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          upsert: {
            args: Prisma.CotSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          aggregate: {
            args: Prisma.CotSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotSession>
          }
          groupBy: {
            args: Prisma.CotSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CotSessionCountAggregateOutputType> | number
          }
        }
      }
      CotPhase: {
        payload: Prisma.$CotPhasePayload<ExtArgs>
        fields: Prisma.CotPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          findFirst: {
            args: Prisma.CotPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          findMany: {
            args: Prisma.CotPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          create: {
            args: Prisma.CotPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          createMany: {
            args: Prisma.CotPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotPhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          delete: {
            args: Prisma.CotPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          update: {
            args: Prisma.CotPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          deleteMany: {
            args: Prisma.CotPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CotPhaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          upsert: {
            args: Prisma.CotPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          aggregate: {
            args: Prisma.CotPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotPhase>
          }
          groupBy: {
            args: Prisma.CotPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<CotPhaseCountAggregateOutputType> | number
          }
        }
      }
      CotDraft: {
        payload: Prisma.$CotDraftPayload<ExtArgs>
        fields: Prisma.CotDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotDraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotDraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          findFirst: {
            args: Prisma.CotDraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotDraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          findMany: {
            args: Prisma.CotDraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          create: {
            args: Prisma.CotDraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          createMany: {
            args: Prisma.CotDraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotDraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          delete: {
            args: Prisma.CotDraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          update: {
            args: Prisma.CotDraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          deleteMany: {
            args: Prisma.CotDraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotDraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CotDraftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          upsert: {
            args: Prisma.CotDraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          aggregate: {
            args: Prisma.CotDraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotDraft>
          }
          groupBy: {
            args: Prisma.CotDraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotDraftCountArgs<ExtArgs>
            result: $Utils.Optional<CotDraftCountAggregateOutputType> | number
          }
        }
      }
      CotDraftPerformance: {
        payload: Prisma.$CotDraftPerformancePayload<ExtArgs>
        fields: Prisma.CotDraftPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotDraftPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          findFirst: {
            args: Prisma.CotDraftPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          findMany: {
            args: Prisma.CotDraftPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          create: {
            args: Prisma.CotDraftPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          createMany: {
            args: Prisma.CotDraftPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          delete: {
            args: Prisma.CotDraftPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          update: {
            args: Prisma.CotDraftPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          deleteMany: {
            args: Prisma.CotDraftPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotDraftPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CotDraftPerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          upsert: {
            args: Prisma.CotDraftPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          aggregate: {
            args: Prisma.CotDraftPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotDraftPerformance>
          }
          groupBy: {
            args: Prisma.CotDraftPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotDraftPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotDraftPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<CotDraftPerformanceCountAggregateOutputType> | number
          }
        }
      }
      ScheduledRetweet: {
        payload: Prisma.$ScheduledRetweetPayload<ExtArgs>
        fields: Prisma.ScheduledRetweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledRetweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledRetweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          findFirst: {
            args: Prisma.ScheduledRetweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledRetweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          findMany: {
            args: Prisma.ScheduledRetweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>[]
          }
          create: {
            args: Prisma.ScheduledRetweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          createMany: {
            args: Prisma.ScheduledRetweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledRetweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>[]
          }
          delete: {
            args: Prisma.ScheduledRetweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          update: {
            args: Prisma.ScheduledRetweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledRetweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledRetweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledRetweetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledRetweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRetweetPayload>
          }
          aggregate: {
            args: Prisma.ScheduledRetweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledRetweet>
          }
          groupBy: {
            args: Prisma.ScheduledRetweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledRetweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledRetweetCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledRetweetCountAggregateOutputType> | number
          }
        }
      }
      UnifiedPerformance: {
        payload: Prisma.$UnifiedPerformancePayload<ExtArgs>
        fields: Prisma.UnifiedPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnifiedPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnifiedPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          findFirst: {
            args: Prisma.UnifiedPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnifiedPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          findMany: {
            args: Prisma.UnifiedPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>[]
          }
          create: {
            args: Prisma.UnifiedPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          createMany: {
            args: Prisma.UnifiedPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnifiedPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>[]
          }
          delete: {
            args: Prisma.UnifiedPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          update: {
            args: Prisma.UnifiedPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          deleteMany: {
            args: Prisma.UnifiedPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnifiedPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnifiedPerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>[]
          }
          upsert: {
            args: Prisma.UnifiedPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedPerformancePayload>
          }
          aggregate: {
            args: Prisma.UnifiedPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnifiedPerformance>
          }
          groupBy: {
            args: Prisma.UnifiedPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnifiedPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnifiedPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<UnifiedPerformanceCountAggregateOutputType> | number
          }
        }
      }
      NewsViralRelation: {
        payload: Prisma.$NewsViralRelationPayload<ExtArgs>
        fields: Prisma.NewsViralRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsViralRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsViralRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          findFirst: {
            args: Prisma.NewsViralRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsViralRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          findMany: {
            args: Prisma.NewsViralRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>[]
          }
          create: {
            args: Prisma.NewsViralRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          createMany: {
            args: Prisma.NewsViralRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsViralRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>[]
          }
          delete: {
            args: Prisma.NewsViralRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          update: {
            args: Prisma.NewsViralRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          deleteMany: {
            args: Prisma.NewsViralRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsViralRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsViralRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>[]
          }
          upsert: {
            args: Prisma.NewsViralRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsViralRelationPayload>
          }
          aggregate: {
            args: Prisma.NewsViralRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsViralRelation>
          }
          groupBy: {
            args: Prisma.NewsViralRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsViralRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsViralRelationCountArgs<ExtArgs>
            result: $Utils.Optional<NewsViralRelationCountAggregateOutputType> | number
          }
        }
      }
      SessionActivityLog: {
        payload: Prisma.$SessionActivityLogPayload<ExtArgs>
        fields: Prisma.SessionActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          findFirst: {
            args: Prisma.SessionActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          findMany: {
            args: Prisma.SessionActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>[]
          }
          create: {
            args: Prisma.SessionActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          createMany: {
            args: Prisma.SessionActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>[]
          }
          delete: {
            args: Prisma.SessionActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          update: {
            args: Prisma.SessionActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.SessionActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.SessionActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionActivityLogPayload>
          }
          aggregate: {
            args: Prisma.SessionActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionActivityLog>
          }
          groupBy: {
            args: Prisma.SessionActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<SessionActivityLogCountAggregateOutputType> | number
          }
        }
      }
      ApiErrorLog: {
        payload: Prisma.$ApiErrorLogPayload<ExtArgs>
        fields: Prisma.ApiErrorLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiErrorLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiErrorLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          findFirst: {
            args: Prisma.ApiErrorLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiErrorLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          findMany: {
            args: Prisma.ApiErrorLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>[]
          }
          create: {
            args: Prisma.ApiErrorLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          createMany: {
            args: Prisma.ApiErrorLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiErrorLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>[]
          }
          delete: {
            args: Prisma.ApiErrorLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          update: {
            args: Prisma.ApiErrorLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiErrorLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiErrorLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiErrorLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>[]
          }
          upsert: {
            args: Prisma.ApiErrorLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorLogPayload>
          }
          aggregate: {
            args: Prisma.ApiErrorLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiErrorLog>
          }
          groupBy: {
            args: Prisma.ApiErrorLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiErrorLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiErrorLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiErrorLogCountAggregateOutputType> | number
          }
        }
      }
      ViralSession: {
        payload: Prisma.$ViralSessionPayload<ExtArgs>
        fields: Prisma.ViralSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViralSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViralSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          findFirst: {
            args: Prisma.ViralSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViralSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          findMany: {
            args: Prisma.ViralSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>[]
          }
          create: {
            args: Prisma.ViralSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          createMany: {
            args: Prisma.ViralSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViralSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>[]
          }
          delete: {
            args: Prisma.ViralSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          update: {
            args: Prisma.ViralSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          deleteMany: {
            args: Prisma.ViralSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViralSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViralSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>[]
          }
          upsert: {
            args: Prisma.ViralSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralSessionPayload>
          }
          aggregate: {
            args: Prisma.ViralSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViralSession>
          }
          groupBy: {
            args: Prisma.ViralSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViralSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViralSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ViralSessionCountAggregateOutputType> | number
          }
        }
      }
      ViralDraftV2: {
        payload: Prisma.$ViralDraftV2Payload<ExtArgs>
        fields: Prisma.ViralDraftV2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViralDraftV2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViralDraftV2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          findFirst: {
            args: Prisma.ViralDraftV2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViralDraftV2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          findMany: {
            args: Prisma.ViralDraftV2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>[]
          }
          create: {
            args: Prisma.ViralDraftV2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          createMany: {
            args: Prisma.ViralDraftV2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViralDraftV2CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>[]
          }
          delete: {
            args: Prisma.ViralDraftV2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          update: {
            args: Prisma.ViralDraftV2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          deleteMany: {
            args: Prisma.ViralDraftV2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViralDraftV2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViralDraftV2UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>[]
          }
          upsert: {
            args: Prisma.ViralDraftV2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftV2Payload>
          }
          aggregate: {
            args: Prisma.ViralDraftV2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViralDraftV2>
          }
          groupBy: {
            args: Prisma.ViralDraftV2GroupByArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftV2GroupByOutputType>[]
          }
          count: {
            args: Prisma.ViralDraftV2CountArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftV2CountAggregateOutputType> | number
          }
        }
      }
      ViralDraftPerformance: {
        payload: Prisma.$ViralDraftPerformancePayload<ExtArgs>
        fields: Prisma.ViralDraftPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViralDraftPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViralDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          findFirst: {
            args: Prisma.ViralDraftPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViralDraftPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          findMany: {
            args: Prisma.ViralDraftPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>[]
          }
          create: {
            args: Prisma.ViralDraftPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          createMany: {
            args: Prisma.ViralDraftPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViralDraftPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>[]
          }
          delete: {
            args: Prisma.ViralDraftPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          update: {
            args: Prisma.ViralDraftPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          deleteMany: {
            args: Prisma.ViralDraftPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViralDraftPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViralDraftPerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>[]
          }
          upsert: {
            args: Prisma.ViralDraftPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViralDraftPerformancePayload>
          }
          aggregate: {
            args: Prisma.ViralDraftPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViralDraftPerformance>
          }
          groupBy: {
            args: Prisma.ViralDraftPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViralDraftPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<ViralDraftPerformanceCountAggregateOutputType> | number
          }
        }
      }
      CharacterProfile: {
        payload: Prisma.$CharacterProfilePayload<ExtArgs>
        fields: Prisma.CharacterProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          findFirst: {
            args: Prisma.CharacterProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          findMany: {
            args: Prisma.CharacterProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>[]
          }
          create: {
            args: Prisma.CharacterProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          createMany: {
            args: Prisma.CharacterProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>[]
          }
          delete: {
            args: Prisma.CharacterProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          update: {
            args: Prisma.CharacterProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          deleteMany: {
            args: Prisma.CharacterProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>[]
          }
          upsert: {
            args: Prisma.CharacterProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterProfilePayload>
          }
          aggregate: {
            args: Prisma.CharacterProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterProfile>
          }
          groupBy: {
            args: Prisma.CharacterProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterProfileCountAggregateOutputType> | number
          }
        }
      }
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.accountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      ai_patterns: {
        payload: Prisma.$ai_patternsPayload<ExtArgs>
        fields: Prisma.ai_patternsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_patternsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_patternsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>
          }
          findFirst: {
            args: Prisma.ai_patternsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_patternsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>
          }
          findMany: {
            args: Prisma.ai_patternsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>[]
          }
          create: {
            args: Prisma.ai_patternsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>
          }
          createMany: {
            args: Prisma.ai_patternsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_patternsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>[]
          }
          delete: {
            args: Prisma.ai_patternsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>
          }
          update: {
            args: Prisma.ai_patternsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>
          }
          deleteMany: {
            args: Prisma.ai_patternsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_patternsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_patternsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>[]
          }
          upsert: {
            args: Prisma.ai_patternsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_patternsPayload>
          }
          aggregate: {
            args: Prisma.Ai_patternsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_patterns>
          }
          groupBy: {
            args: Prisma.ai_patternsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_patternsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_patternsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_patternsCountAggregateOutputType> | number
          }
        }
      }
      content_drafts: {
        payload: Prisma.$content_draftsPayload<ExtArgs>
        fields: Prisma.content_draftsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.content_draftsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.content_draftsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>
          }
          findFirst: {
            args: Prisma.content_draftsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.content_draftsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>
          }
          findMany: {
            args: Prisma.content_draftsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>[]
          }
          create: {
            args: Prisma.content_draftsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>
          }
          createMany: {
            args: Prisma.content_draftsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.content_draftsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>[]
          }
          delete: {
            args: Prisma.content_draftsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>
          }
          update: {
            args: Prisma.content_draftsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>
          }
          deleteMany: {
            args: Prisma.content_draftsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.content_draftsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.content_draftsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>[]
          }
          upsert: {
            args: Prisma.content_draftsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$content_draftsPayload>
          }
          aggregate: {
            args: Prisma.Content_draftsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent_drafts>
          }
          groupBy: {
            args: Prisma.content_draftsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Content_draftsGroupByOutputType>[]
          }
          count: {
            args: Prisma.content_draftsCountArgs<ExtArgs>
            result: $Utils.Optional<Content_draftsCountAggregateOutputType> | number
          }
        }
      }
      gpt_analyses: {
        payload: Prisma.$gpt_analysesPayload<ExtArgs>
        fields: Prisma.gpt_analysesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gpt_analysesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gpt_analysesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>
          }
          findFirst: {
            args: Prisma.gpt_analysesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gpt_analysesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>
          }
          findMany: {
            args: Prisma.gpt_analysesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>[]
          }
          create: {
            args: Prisma.gpt_analysesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>
          }
          createMany: {
            args: Prisma.gpt_analysesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gpt_analysesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>[]
          }
          delete: {
            args: Prisma.gpt_analysesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>
          }
          update: {
            args: Prisma.gpt_analysesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>
          }
          deleteMany: {
            args: Prisma.gpt_analysesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gpt_analysesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.gpt_analysesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>[]
          }
          upsert: {
            args: Prisma.gpt_analysesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gpt_analysesPayload>
          }
          aggregate: {
            args: Prisma.Gpt_analysesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGpt_analyses>
          }
          groupBy: {
            args: Prisma.gpt_analysesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gpt_analysesGroupByOutputType>[]
          }
          count: {
            args: Prisma.gpt_analysesCountArgs<ExtArgs>
            result: $Utils.Optional<Gpt_analysesCountAggregateOutputType> | number
          }
        }
      }
      news_analysis_jobs: {
        payload: Prisma.$news_analysis_jobsPayload<ExtArgs>
        fields: Prisma.news_analysis_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.news_analysis_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.news_analysis_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>
          }
          findFirst: {
            args: Prisma.news_analysis_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.news_analysis_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>
          }
          findMany: {
            args: Prisma.news_analysis_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>[]
          }
          create: {
            args: Prisma.news_analysis_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>
          }
          createMany: {
            args: Prisma.news_analysis_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.news_analysis_jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>[]
          }
          delete: {
            args: Prisma.news_analysis_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>
          }
          update: {
            args: Prisma.news_analysis_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>
          }
          deleteMany: {
            args: Prisma.news_analysis_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.news_analysis_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.news_analysis_jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>[]
          }
          upsert: {
            args: Prisma.news_analysis_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_jobsPayload>
          }
          aggregate: {
            args: Prisma.News_analysis_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews_analysis_jobs>
          }
          groupBy: {
            args: Prisma.news_analysis_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<News_analysis_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.news_analysis_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<News_analysis_jobsCountAggregateOutputType> | number
          }
        }
      }
      news_analysis_results: {
        payload: Prisma.$news_analysis_resultsPayload<ExtArgs>
        fields: Prisma.news_analysis_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.news_analysis_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.news_analysis_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>
          }
          findFirst: {
            args: Prisma.news_analysis_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.news_analysis_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>
          }
          findMany: {
            args: Prisma.news_analysis_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>[]
          }
          create: {
            args: Prisma.news_analysis_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>
          }
          createMany: {
            args: Prisma.news_analysis_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.news_analysis_resultsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>[]
          }
          delete: {
            args: Prisma.news_analysis_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>
          }
          update: {
            args: Prisma.news_analysis_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>
          }
          deleteMany: {
            args: Prisma.news_analysis_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.news_analysis_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.news_analysis_resultsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>[]
          }
          upsert: {
            args: Prisma.news_analysis_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$news_analysis_resultsPayload>
          }
          aggregate: {
            args: Prisma.News_analysis_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews_analysis_results>
          }
          groupBy: {
            args: Prisma.news_analysis_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<News_analysis_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.news_analysis_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<News_analysis_resultsCountAggregateOutputType> | number
          }
        }
      }
      prompt_templates: {
        payload: Prisma.$prompt_templatesPayload<ExtArgs>
        fields: Prisma.prompt_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prompt_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prompt_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>
          }
          findFirst: {
            args: Prisma.prompt_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prompt_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>
          }
          findMany: {
            args: Prisma.prompt_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>[]
          }
          create: {
            args: Prisma.prompt_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>
          }
          createMany: {
            args: Prisma.prompt_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prompt_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>[]
          }
          delete: {
            args: Prisma.prompt_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>
          }
          update: {
            args: Prisma.prompt_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>
          }
          deleteMany: {
            args: Prisma.prompt_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prompt_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.prompt_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>[]
          }
          upsert: {
            args: Prisma.prompt_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prompt_templatesPayload>
          }
          aggregate: {
            args: Prisma.Prompt_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrompt_templates>
          }
          groupBy: {
            args: Prisma.prompt_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prompt_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.prompt_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Prompt_templatesCountAggregateOutputType> | number
          }
        }
      }
      viral_analysis_logs: {
        payload: Prisma.$viral_analysis_logsPayload<ExtArgs>
        fields: Prisma.viral_analysis_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viral_analysis_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viral_analysis_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>
          }
          findFirst: {
            args: Prisma.viral_analysis_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viral_analysis_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>
          }
          findMany: {
            args: Prisma.viral_analysis_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>[]
          }
          create: {
            args: Prisma.viral_analysis_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>
          }
          createMany: {
            args: Prisma.viral_analysis_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.viral_analysis_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>[]
          }
          delete: {
            args: Prisma.viral_analysis_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>
          }
          update: {
            args: Prisma.viral_analysis_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>
          }
          deleteMany: {
            args: Prisma.viral_analysis_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viral_analysis_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.viral_analysis_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>[]
          }
          upsert: {
            args: Prisma.viral_analysis_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_analysis_logsPayload>
          }
          aggregate: {
            args: Prisma.Viral_analysis_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViral_analysis_logs>
          }
          groupBy: {
            args: Prisma.viral_analysis_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Viral_analysis_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.viral_analysis_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Viral_analysis_logsCountAggregateOutputType> | number
          }
        }
      }
      viral_config: {
        payload: Prisma.$viral_configPayload<ExtArgs>
        fields: Prisma.viral_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viral_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viral_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>
          }
          findFirst: {
            args: Prisma.viral_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viral_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>
          }
          findMany: {
            args: Prisma.viral_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>[]
          }
          create: {
            args: Prisma.viral_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>
          }
          createMany: {
            args: Prisma.viral_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.viral_configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>[]
          }
          delete: {
            args: Prisma.viral_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>
          }
          update: {
            args: Prisma.viral_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>
          }
          deleteMany: {
            args: Prisma.viral_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viral_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.viral_configUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>[]
          }
          upsert: {
            args: Prisma.viral_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_configPayload>
          }
          aggregate: {
            args: Prisma.Viral_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViral_config>
          }
          groupBy: {
            args: Prisma.viral_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Viral_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.viral_configCountArgs<ExtArgs>
            result: $Utils.Optional<Viral_configCountAggregateOutputType> | number
          }
        }
      }
      viral_opportunities: {
        payload: Prisma.$viral_opportunitiesPayload<ExtArgs>
        fields: Prisma.viral_opportunitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viral_opportunitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viral_opportunitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>
          }
          findFirst: {
            args: Prisma.viral_opportunitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viral_opportunitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>
          }
          findMany: {
            args: Prisma.viral_opportunitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>[]
          }
          create: {
            args: Prisma.viral_opportunitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>
          }
          createMany: {
            args: Prisma.viral_opportunitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.viral_opportunitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>[]
          }
          delete: {
            args: Prisma.viral_opportunitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>
          }
          update: {
            args: Prisma.viral_opportunitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>
          }
          deleteMany: {
            args: Prisma.viral_opportunitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viral_opportunitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.viral_opportunitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>[]
          }
          upsert: {
            args: Prisma.viral_opportunitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_opportunitiesPayload>
          }
          aggregate: {
            args: Prisma.Viral_opportunitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViral_opportunities>
          }
          groupBy: {
            args: Prisma.viral_opportunitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Viral_opportunitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.viral_opportunitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Viral_opportunitiesCountAggregateOutputType> | number
          }
        }
      }
      viral_post_performance: {
        payload: Prisma.$viral_post_performancePayload<ExtArgs>
        fields: Prisma.viral_post_performanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viral_post_performanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viral_post_performanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>
          }
          findFirst: {
            args: Prisma.viral_post_performanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viral_post_performanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>
          }
          findMany: {
            args: Prisma.viral_post_performanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>[]
          }
          create: {
            args: Prisma.viral_post_performanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>
          }
          createMany: {
            args: Prisma.viral_post_performanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.viral_post_performanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>[]
          }
          delete: {
            args: Prisma.viral_post_performanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>
          }
          update: {
            args: Prisma.viral_post_performanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>
          }
          deleteMany: {
            args: Prisma.viral_post_performanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viral_post_performanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.viral_post_performanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>[]
          }
          upsert: {
            args: Prisma.viral_post_performanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_post_performancePayload>
          }
          aggregate: {
            args: Prisma.Viral_post_performanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViral_post_performance>
          }
          groupBy: {
            args: Prisma.viral_post_performanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Viral_post_performanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.viral_post_performanceCountArgs<ExtArgs>
            result: $Utils.Optional<Viral_post_performanceCountAggregateOutputType> | number
          }
        }
      }
      viral_posts: {
        payload: Prisma.$viral_postsPayload<ExtArgs>
        fields: Prisma.viral_postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viral_postsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viral_postsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>
          }
          findFirst: {
            args: Prisma.viral_postsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viral_postsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>
          }
          findMany: {
            args: Prisma.viral_postsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>[]
          }
          create: {
            args: Prisma.viral_postsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>
          }
          createMany: {
            args: Prisma.viral_postsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.viral_postsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>[]
          }
          delete: {
            args: Prisma.viral_postsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>
          }
          update: {
            args: Prisma.viral_postsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>
          }
          deleteMany: {
            args: Prisma.viral_postsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viral_postsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.viral_postsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>[]
          }
          upsert: {
            args: Prisma.viral_postsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viral_postsPayload>
          }
          aggregate: {
            args: Prisma.Viral_postsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViral_posts>
          }
          groupBy: {
            args: Prisma.viral_postsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Viral_postsGroupByOutputType>[]
          }
          count: {
            args: Prisma.viral_postsCountArgs<ExtArgs>
            result: $Utils.Optional<Viral_postsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    buzzPost?: BuzzPostOmit
    buzzConfig?: BuzzConfigOmit
    scheduledPost?: ScheduledPostOmit
    postAnalytics?: PostAnalyticsOmit
    user?: UserOmit
    session?: SessionOmit
    newsSource?: NewsSourceOmit
    newsArticle?: NewsArticleOmit
    newsThread?: NewsThreadOmit
    newsThreadItem?: NewsThreadItemOmit
    newsAnalysis?: NewsAnalysisOmit
    jobQueue?: JobQueueOmit
    apiTask?: ApiTaskOmit
    collectionPreset?: CollectionPresetOmit
    watchlistUser?: WatchlistUserOmit
    watchlistTweet?: WatchlistTweetOmit
    interactionHistory?: InteractionHistoryOmit
    perplexityReport?: PerplexityReportOmit
    cotSession?: CotSessionOmit
    cotPhase?: CotPhaseOmit
    cotDraft?: CotDraftOmit
    cotDraftPerformance?: CotDraftPerformanceOmit
    scheduledRetweet?: ScheduledRetweetOmit
    unifiedPerformance?: UnifiedPerformanceOmit
    newsViralRelation?: NewsViralRelationOmit
    sessionActivityLog?: SessionActivityLogOmit
    apiErrorLog?: ApiErrorLogOmit
    viralSession?: ViralSessionOmit
    viralDraftV2?: ViralDraftV2Omit
    viralDraftPerformance?: ViralDraftPerformanceOmit
    characterProfile?: CharacterProfileOmit
    accounts?: accountsOmit
    ai_patterns?: ai_patternsOmit
    content_drafts?: content_draftsOmit
    gpt_analyses?: gpt_analysesOmit
    news_analysis_jobs?: news_analysis_jobsOmit
    news_analysis_results?: news_analysis_resultsOmit
    prompt_templates?: prompt_templatesOmit
    viral_analysis_logs?: viral_analysis_logsOmit
    viral_config?: viral_configOmit
    viral_opportunities?: viral_opportunitiesOmit
    viral_post_performance?: viral_post_performanceOmit
    viral_posts?: viral_postsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BuzzPostCountOutputType
   */

  export type BuzzPostCountOutputType = {
    scheduledPosts: number
  }

  export type BuzzPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPosts?: boolean | BuzzPostCountOutputTypeCountScheduledPostsArgs
  }

  // Custom InputTypes
  /**
   * BuzzPostCountOutputType without action
   */
  export type BuzzPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPostCountOutputType
     */
    select?: BuzzPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuzzPostCountOutputType without action
   */
  export type BuzzPostCountOutputTypeCountScheduledPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
  }


  /**
   * Count Type ScheduledPostCountOutputType
   */

  export type ScheduledPostCountOutputType = {
    post_analytics: number
  }

  export type ScheduledPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post_analytics?: boolean | ScheduledPostCountOutputTypeCountPost_analyticsArgs
  }

  // Custom InputTypes
  /**
   * ScheduledPostCountOutputType without action
   */
  export type ScheduledPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPostCountOutputType
     */
    select?: ScheduledPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduledPostCountOutputType without action
   */
  export type ScheduledPostCountOutputTypeCountPost_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAnalyticsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    watchlistUsers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    watchlistUsers?: boolean | UserCountOutputTypeCountWatchlistUsersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchlistUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistUserWhereInput
  }


  /**
   * Count Type NewsSourceCountOutputType
   */

  export type NewsSourceCountOutputType = {
    articles: number
  }

  export type NewsSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | NewsSourceCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * NewsSourceCountOutputType without action
   */
  export type NewsSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSourceCountOutputType
     */
    select?: NewsSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsSourceCountOutputType without action
   */
  export type NewsSourceCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
  }


  /**
   * Count Type NewsArticleCountOutputType
   */

  export type NewsArticleCountOutputType = {
    news_analysis_results: number
    newsThreadItems: number
  }

  export type NewsArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news_analysis_results?: boolean | NewsArticleCountOutputTypeCountNews_analysis_resultsArgs
    newsThreadItems?: boolean | NewsArticleCountOutputTypeCountNewsThreadItemsArgs
  }

  // Custom InputTypes
  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticleCountOutputType
     */
    select?: NewsArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeCountNews_analysis_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: news_analysis_resultsWhereInput
  }

  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeCountNewsThreadItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
  }


  /**
   * Count Type NewsThreadCountOutputType
   */

  export type NewsThreadCountOutputType = {
    items: number
  }

  export type NewsThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NewsThreadCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * NewsThreadCountOutputType without action
   */
  export type NewsThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadCountOutputType
     */
    select?: NewsThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsThreadCountOutputType without action
   */
  export type NewsThreadCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
  }


  /**
   * Count Type WatchlistUserCountOutputType
   */

  export type WatchlistUserCountOutputType = {
    tweets: number
  }

  export type WatchlistUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | WatchlistUserCountOutputTypeCountTweetsArgs
  }

  // Custom InputTypes
  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUserCountOutputType
     */
    select?: WatchlistUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistTweetWhereInput
  }


  /**
   * Count Type CotSessionCountOutputType
   */

  export type CotSessionCountOutputType = {
    drafts: number
    phases: number
  }

  export type CotSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | CotSessionCountOutputTypeCountDraftsArgs
    phases?: boolean | CotSessionCountOutputTypeCountPhasesArgs
  }

  // Custom InputTypes
  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSessionCountOutputType
     */
    select?: CotSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftWhereInput
  }

  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotPhaseWhereInput
  }


  /**
   * Count Type ViralSessionCountOutputType
   */

  export type ViralSessionCountOutputType = {
    drafts: number
  }

  export type ViralSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | ViralSessionCountOutputTypeCountDraftsArgs
  }

  // Custom InputTypes
  /**
   * ViralSessionCountOutputType without action
   */
  export type ViralSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSessionCountOutputType
     */
    select?: ViralSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViralSessionCountOutputType without action
   */
  export type ViralSessionCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralDraftV2WhereInput
  }


  /**
   * Count Type Gpt_analysesCountOutputType
   */

  export type Gpt_analysesCountOutputType = {
    content_drafts: number
  }

  export type Gpt_analysesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content_drafts?: boolean | Gpt_analysesCountOutputTypeCountContent_draftsArgs
  }

  // Custom InputTypes
  /**
   * Gpt_analysesCountOutputType without action
   */
  export type Gpt_analysesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gpt_analysesCountOutputType
     */
    select?: Gpt_analysesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Gpt_analysesCountOutputType without action
   */
  export type Gpt_analysesCountOutputTypeCountContent_draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: content_draftsWhereInput
  }


  /**
   * Count Type News_analysis_jobsCountOutputType
   */

  export type News_analysis_jobsCountOutputType = {
    news_analysis_results: number
  }

  export type News_analysis_jobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news_analysis_results?: boolean | News_analysis_jobsCountOutputTypeCountNews_analysis_resultsArgs
  }

  // Custom InputTypes
  /**
   * News_analysis_jobsCountOutputType without action
   */
  export type News_analysis_jobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News_analysis_jobsCountOutputType
     */
    select?: News_analysis_jobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * News_analysis_jobsCountOutputType without action
   */
  export type News_analysis_jobsCountOutputTypeCountNews_analysis_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: news_analysis_resultsWhereInput
  }


  /**
   * Count Type Viral_opportunitiesCountOutputType
   */

  export type Viral_opportunitiesCountOutputType = {
    viral_posts: number
  }

  export type Viral_opportunitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_posts?: boolean | Viral_opportunitiesCountOutputTypeCountViral_postsArgs
  }

  // Custom InputTypes
  /**
   * Viral_opportunitiesCountOutputType without action
   */
  export type Viral_opportunitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viral_opportunitiesCountOutputType
     */
    select?: Viral_opportunitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Viral_opportunitiesCountOutputType without action
   */
  export type Viral_opportunitiesCountOutputTypeCountViral_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viral_postsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BuzzPost
   */

  export type AggregateBuzzPost = {
    _count: BuzzPostCountAggregateOutputType | null
    _avg: BuzzPostAvgAggregateOutputType | null
    _sum: BuzzPostSumAggregateOutputType | null
    _min: BuzzPostMinAggregateOutputType | null
    _max: BuzzPostMaxAggregateOutputType | null
  }

  export type BuzzPostAvgAggregateOutputType = {
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    authorFollowers: number | null
    authorFollowing: number | null
  }

  export type BuzzPostSumAggregateOutputType = {
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    authorFollowers: number | null
    authorFollowing: number | null
  }

  export type BuzzPostMinAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    authorUsername: string | null
    authorId: string | null
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    postedAt: Date | null
    collectedAt: Date | null
    url: string | null
    theme: string | null
    language: string | null
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
  }

  export type BuzzPostMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    authorUsername: string | null
    authorId: string | null
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    postedAt: Date | null
    collectedAt: Date | null
    url: string | null
    theme: string | null
    language: string | null
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
  }

  export type BuzzPostCountAggregateOutputType = {
    id: number
    postId: number
    content: number
    authorUsername: number
    authorId: number
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: number
    collectedAt: number
    url: number
    theme: number
    language: number
    mediaUrls: number
    hashtags: number
    chromaId: number
    authorFollowers: number
    authorFollowing: number
    authorVerified: number
    _all: number
  }


  export type BuzzPostAvgAggregateInputType = {
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    authorFollowers?: true
    authorFollowing?: true
  }

  export type BuzzPostSumAggregateInputType = {
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    authorFollowers?: true
    authorFollowing?: true
  }

  export type BuzzPostMinAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
  }

  export type BuzzPostMaxAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
  }

  export type BuzzPostCountAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    mediaUrls?: true
    hashtags?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
    _all?: true
  }

  export type BuzzPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzPost to aggregate.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzPosts
    **/
    _count?: true | BuzzPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzPostMaxAggregateInputType
  }

  export type GetBuzzPostAggregateType<T extends BuzzPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzPost[P]>
      : GetScalarType<T[P], AggregateBuzzPost[P]>
  }




  export type BuzzPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzPostWhereInput
    orderBy?: BuzzPostOrderByWithAggregationInput | BuzzPostOrderByWithAggregationInput[]
    by: BuzzPostScalarFieldEnum[] | BuzzPostScalarFieldEnum
    having?: BuzzPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzPostCountAggregateInputType | true
    _avg?: BuzzPostAvgAggregateInputType
    _sum?: BuzzPostSumAggregateInputType
    _min?: BuzzPostMinAggregateInputType
    _max?: BuzzPostMaxAggregateInputType
  }

  export type BuzzPostGroupByOutputType = {
    id: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date
    collectedAt: Date
    url: string
    theme: string
    language: string
    mediaUrls: JsonValue
    hashtags: JsonValue
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
    _count: BuzzPostCountAggregateOutputType | null
    _avg: BuzzPostAvgAggregateOutputType | null
    _sum: BuzzPostSumAggregateOutputType | null
    _min: BuzzPostMinAggregateOutputType | null
    _max: BuzzPostMaxAggregateOutputType | null
  }

  type GetBuzzPostGroupByPayload<T extends BuzzPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzPostGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzPostGroupByOutputType[P]>
        }
      >
    >


  export type BuzzPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
    scheduledPosts?: boolean | BuzzPost$scheduledPostsArgs<ExtArgs>
    _count?: boolean | BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectScalar = {
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }

  export type BuzzPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "content" | "authorUsername" | "authorId" | "likesCount" | "retweetsCount" | "repliesCount" | "impressionsCount" | "postedAt" | "collectedAt" | "url" | "theme" | "language" | "mediaUrls" | "hashtags" | "chromaId" | "authorFollowers" | "authorFollowing" | "authorVerified", ExtArgs["result"]["buzzPost"]>
  export type BuzzPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPosts?: boolean | BuzzPost$scheduledPostsArgs<ExtArgs>
    _count?: boolean | BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuzzPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BuzzPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BuzzPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzPost"
    objects: {
      scheduledPosts: Prisma.$ScheduledPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      content: string
      authorUsername: string
      authorId: string
      likesCount: number
      retweetsCount: number
      repliesCount: number
      impressionsCount: number
      postedAt: Date
      collectedAt: Date
      url: string
      theme: string
      language: string
      mediaUrls: Prisma.JsonValue
      hashtags: Prisma.JsonValue
      chromaId: string | null
      authorFollowers: number | null
      authorFollowing: number | null
      authorVerified: boolean | null
    }, ExtArgs["result"]["buzzPost"]>
    composites: {}
  }

  type BuzzPostGetPayload<S extends boolean | null | undefined | BuzzPostDefaultArgs> = $Result.GetResult<Prisma.$BuzzPostPayload, S>

  type BuzzPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuzzPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuzzPostCountAggregateInputType | true
    }

  export interface BuzzPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzPost'], meta: { name: 'BuzzPost' } }
    /**
     * Find zero or one BuzzPost that matches the filter.
     * @param {BuzzPostFindUniqueArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzPostFindUniqueArgs>(args: SelectSubset<T, BuzzPostFindUniqueArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuzzPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuzzPostFindUniqueOrThrowArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuzzPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindFirstArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzPostFindFirstArgs>(args?: SelectSubset<T, BuzzPostFindFirstArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuzzPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindFirstOrThrowArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuzzPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzPosts
     * const buzzPosts = await prisma.buzzPost.findMany()
     * 
     * // Get first 10 BuzzPosts
     * const buzzPosts = await prisma.buzzPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzPostFindManyArgs>(args?: SelectSubset<T, BuzzPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuzzPost.
     * @param {BuzzPostCreateArgs} args - Arguments to create a BuzzPost.
     * @example
     * // Create one BuzzPost
     * const BuzzPost = await prisma.buzzPost.create({
     *   data: {
     *     // ... data to create a BuzzPost
     *   }
     * })
     * 
     */
    create<T extends BuzzPostCreateArgs>(args: SelectSubset<T, BuzzPostCreateArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuzzPosts.
     * @param {BuzzPostCreateManyArgs} args - Arguments to create many BuzzPosts.
     * @example
     * // Create many BuzzPosts
     * const buzzPost = await prisma.buzzPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzPostCreateManyArgs>(args?: SelectSubset<T, BuzzPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuzzPosts and returns the data saved in the database.
     * @param {BuzzPostCreateManyAndReturnArgs} args - Arguments to create many BuzzPosts.
     * @example
     * // Create many BuzzPosts
     * const buzzPost = await prisma.buzzPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuzzPosts and only return the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuzzPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BuzzPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BuzzPost.
     * @param {BuzzPostDeleteArgs} args - Arguments to delete one BuzzPost.
     * @example
     * // Delete one BuzzPost
     * const BuzzPost = await prisma.buzzPost.delete({
     *   where: {
     *     // ... filter to delete one BuzzPost
     *   }
     * })
     * 
     */
    delete<T extends BuzzPostDeleteArgs>(args: SelectSubset<T, BuzzPostDeleteArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuzzPost.
     * @param {BuzzPostUpdateArgs} args - Arguments to update one BuzzPost.
     * @example
     * // Update one BuzzPost
     * const buzzPost = await prisma.buzzPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzPostUpdateArgs>(args: SelectSubset<T, BuzzPostUpdateArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuzzPosts.
     * @param {BuzzPostDeleteManyArgs} args - Arguments to filter BuzzPosts to delete.
     * @example
     * // Delete a few BuzzPosts
     * const { count } = await prisma.buzzPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzPostDeleteManyArgs>(args?: SelectSubset<T, BuzzPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzPosts
     * const buzzPost = await prisma.buzzPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzPostUpdateManyArgs>(args: SelectSubset<T, BuzzPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzPosts and returns the data updated in the database.
     * @param {BuzzPostUpdateManyAndReturnArgs} args - Arguments to update many BuzzPosts.
     * @example
     * // Update many BuzzPosts
     * const buzzPost = await prisma.buzzPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BuzzPosts and only return the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BuzzPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BuzzPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BuzzPost.
     * @param {BuzzPostUpsertArgs} args - Arguments to update or create a BuzzPost.
     * @example
     * // Update or create a BuzzPost
     * const buzzPost = await prisma.buzzPost.upsert({
     *   create: {
     *     // ... data to create a BuzzPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzPost we want to update
     *   }
     * })
     */
    upsert<T extends BuzzPostUpsertArgs>(args: SelectSubset<T, BuzzPostUpsertArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuzzPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostCountArgs} args - Arguments to filter BuzzPosts to count.
     * @example
     * // Count the number of BuzzPosts
     * const count = await prisma.buzzPost.count({
     *   where: {
     *     // ... the filter for the BuzzPosts we want to count
     *   }
     * })
    **/
    count<T extends BuzzPostCountArgs>(
      args?: Subset<T, BuzzPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzPostAggregateArgs>(args: Subset<T, BuzzPostAggregateArgs>): Prisma.PrismaPromise<GetBuzzPostAggregateType<T>>

    /**
     * Group by BuzzPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzPostGroupByArgs['orderBy'] }
        : { orderBy?: BuzzPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzPost model
   */
  readonly fields: BuzzPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scheduledPosts<T extends BuzzPost$scheduledPostsArgs<ExtArgs> = {}>(args?: Subset<T, BuzzPost$scheduledPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzPost model
   */
  interface BuzzPostFieldRefs {
    readonly id: FieldRef<"BuzzPost", 'String'>
    readonly postId: FieldRef<"BuzzPost", 'String'>
    readonly content: FieldRef<"BuzzPost", 'String'>
    readonly authorUsername: FieldRef<"BuzzPost", 'String'>
    readonly authorId: FieldRef<"BuzzPost", 'String'>
    readonly likesCount: FieldRef<"BuzzPost", 'Int'>
    readonly retweetsCount: FieldRef<"BuzzPost", 'Int'>
    readonly repliesCount: FieldRef<"BuzzPost", 'Int'>
    readonly impressionsCount: FieldRef<"BuzzPost", 'Int'>
    readonly postedAt: FieldRef<"BuzzPost", 'DateTime'>
    readonly collectedAt: FieldRef<"BuzzPost", 'DateTime'>
    readonly url: FieldRef<"BuzzPost", 'String'>
    readonly theme: FieldRef<"BuzzPost", 'String'>
    readonly language: FieldRef<"BuzzPost", 'String'>
    readonly mediaUrls: FieldRef<"BuzzPost", 'Json'>
    readonly hashtags: FieldRef<"BuzzPost", 'Json'>
    readonly chromaId: FieldRef<"BuzzPost", 'String'>
    readonly authorFollowers: FieldRef<"BuzzPost", 'Int'>
    readonly authorFollowing: FieldRef<"BuzzPost", 'Int'>
    readonly authorVerified: FieldRef<"BuzzPost", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BuzzPost findUnique
   */
  export type BuzzPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost findUniqueOrThrow
   */
  export type BuzzPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost findFirst
   */
  export type BuzzPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzPosts.
     */
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost findFirstOrThrow
   */
  export type BuzzPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzPosts.
     */
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost findMany
   */
  export type BuzzPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPosts to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost create
   */
  export type BuzzPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BuzzPost.
     */
    data: XOR<BuzzPostCreateInput, BuzzPostUncheckedCreateInput>
  }

  /**
   * BuzzPost createMany
   */
  export type BuzzPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzPosts.
     */
    data: BuzzPostCreateManyInput | BuzzPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzPost createManyAndReturn
   */
  export type BuzzPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * The data used to create many BuzzPosts.
     */
    data: BuzzPostCreateManyInput | BuzzPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzPost update
   */
  export type BuzzPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BuzzPost.
     */
    data: XOR<BuzzPostUpdateInput, BuzzPostUncheckedUpdateInput>
    /**
     * Choose, which BuzzPost to update.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost updateMany
   */
  export type BuzzPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzPosts.
     */
    data: XOR<BuzzPostUpdateManyMutationInput, BuzzPostUncheckedUpdateManyInput>
    /**
     * Filter which BuzzPosts to update
     */
    where?: BuzzPostWhereInput
    /**
     * Limit how many BuzzPosts to update.
     */
    limit?: number
  }

  /**
   * BuzzPost updateManyAndReturn
   */
  export type BuzzPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * The data used to update BuzzPosts.
     */
    data: XOR<BuzzPostUpdateManyMutationInput, BuzzPostUncheckedUpdateManyInput>
    /**
     * Filter which BuzzPosts to update
     */
    where?: BuzzPostWhereInput
    /**
     * Limit how many BuzzPosts to update.
     */
    limit?: number
  }

  /**
   * BuzzPost upsert
   */
  export type BuzzPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BuzzPost to update in case it exists.
     */
    where: BuzzPostWhereUniqueInput
    /**
     * In case the BuzzPost found by the `where` argument doesn't exist, create a new BuzzPost with this data.
     */
    create: XOR<BuzzPostCreateInput, BuzzPostUncheckedCreateInput>
    /**
     * In case the BuzzPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzPostUpdateInput, BuzzPostUncheckedUpdateInput>
  }

  /**
   * BuzzPost delete
   */
  export type BuzzPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter which BuzzPost to delete.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost deleteMany
   */
  export type BuzzPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzPosts to delete
     */
    where?: BuzzPostWhereInput
    /**
     * Limit how many BuzzPosts to delete.
     */
    limit?: number
  }

  /**
   * BuzzPost.scheduledPosts
   */
  export type BuzzPost$scheduledPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    cursor?: ScheduledPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * BuzzPost without action
   */
  export type BuzzPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
  }


  /**
   * Model BuzzConfig
   */

  export type AggregateBuzzConfig = {
    _count: BuzzConfigCountAggregateOutputType | null
    _avg: BuzzConfigAvgAggregateOutputType | null
    _sum: BuzzConfigSumAggregateOutputType | null
    _min: BuzzConfigMinAggregateOutputType | null
    _max: BuzzConfigMaxAggregateOutputType | null
  }

  export type BuzzConfigAvgAggregateOutputType = {
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
  }

  export type BuzzConfigSumAggregateOutputType = {
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
  }

  export type BuzzConfigMinAggregateOutputType = {
    id: string | null
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuzzConfigMaxAggregateOutputType = {
    id: string | null
    minEngagement: number | null
    minImpressions: number | null
    collectInterval: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuzzConfigCountAggregateOutputType = {
    id: number
    keywords: number
    accounts: number
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuzzConfigAvgAggregateInputType = {
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
  }

  export type BuzzConfigSumAggregateInputType = {
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
  }

  export type BuzzConfigMinAggregateInputType = {
    id?: true
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuzzConfigMaxAggregateInputType = {
    id?: true
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuzzConfigCountAggregateInputType = {
    id?: true
    keywords?: true
    accounts?: true
    minEngagement?: true
    minImpressions?: true
    collectInterval?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuzzConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzConfig to aggregate.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzConfigs
    **/
    _count?: true | BuzzConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzConfigMaxAggregateInputType
  }

  export type GetBuzzConfigAggregateType<T extends BuzzConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzConfig[P]>
      : GetScalarType<T[P], AggregateBuzzConfig[P]>
  }




  export type BuzzConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzConfigWhereInput
    orderBy?: BuzzConfigOrderByWithAggregationInput | BuzzConfigOrderByWithAggregationInput[]
    by: BuzzConfigScalarFieldEnum[] | BuzzConfigScalarFieldEnum
    having?: BuzzConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzConfigCountAggregateInputType | true
    _avg?: BuzzConfigAvgAggregateInputType
    _sum?: BuzzConfigSumAggregateInputType
    _min?: BuzzConfigMinAggregateInputType
    _max?: BuzzConfigMaxAggregateInputType
  }

  export type BuzzConfigGroupByOutputType = {
    id: string
    keywords: string[]
    accounts: string[]
    minEngagement: number
    minImpressions: number
    collectInterval: number
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: BuzzConfigCountAggregateOutputType | null
    _avg: BuzzConfigAvgAggregateOutputType | null
    _sum: BuzzConfigSumAggregateOutputType | null
    _min: BuzzConfigMinAggregateOutputType | null
    _max: BuzzConfigMaxAggregateOutputType | null
  }

  type GetBuzzConfigGroupByPayload<T extends BuzzConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzConfigGroupByOutputType[P]>
        }
      >
    >


  export type BuzzConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzConfig"]>

  export type BuzzConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzConfig"]>

  export type BuzzConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buzzConfig"]>

  export type BuzzConfigSelectScalar = {
    id?: boolean
    keywords?: boolean
    accounts?: boolean
    minEngagement?: boolean
    minImpressions?: boolean
    collectInterval?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuzzConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keywords" | "accounts" | "minEngagement" | "minImpressions" | "collectInterval" | "enabled" | "createdAt" | "updatedAt", ExtArgs["result"]["buzzConfig"]>

  export type $BuzzConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keywords: string[]
      accounts: string[]
      minEngagement: number
      minImpressions: number
      collectInterval: number
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buzzConfig"]>
    composites: {}
  }

  type BuzzConfigGetPayload<S extends boolean | null | undefined | BuzzConfigDefaultArgs> = $Result.GetResult<Prisma.$BuzzConfigPayload, S>

  type BuzzConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuzzConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuzzConfigCountAggregateInputType | true
    }

  export interface BuzzConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzConfig'], meta: { name: 'BuzzConfig' } }
    /**
     * Find zero or one BuzzConfig that matches the filter.
     * @param {BuzzConfigFindUniqueArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzConfigFindUniqueArgs>(args: SelectSubset<T, BuzzConfigFindUniqueArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuzzConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuzzConfigFindUniqueOrThrowArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuzzConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigFindFirstArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzConfigFindFirstArgs>(args?: SelectSubset<T, BuzzConfigFindFirstArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuzzConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigFindFirstOrThrowArgs} args - Arguments to find a BuzzConfig
     * @example
     * // Get one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuzzConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzConfigs
     * const buzzConfigs = await prisma.buzzConfig.findMany()
     * 
     * // Get first 10 BuzzConfigs
     * const buzzConfigs = await prisma.buzzConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzConfigWithIdOnly = await prisma.buzzConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzConfigFindManyArgs>(args?: SelectSubset<T, BuzzConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuzzConfig.
     * @param {BuzzConfigCreateArgs} args - Arguments to create a BuzzConfig.
     * @example
     * // Create one BuzzConfig
     * const BuzzConfig = await prisma.buzzConfig.create({
     *   data: {
     *     // ... data to create a BuzzConfig
     *   }
     * })
     * 
     */
    create<T extends BuzzConfigCreateArgs>(args: SelectSubset<T, BuzzConfigCreateArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuzzConfigs.
     * @param {BuzzConfigCreateManyArgs} args - Arguments to create many BuzzConfigs.
     * @example
     * // Create many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzConfigCreateManyArgs>(args?: SelectSubset<T, BuzzConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuzzConfigs and returns the data saved in the database.
     * @param {BuzzConfigCreateManyAndReturnArgs} args - Arguments to create many BuzzConfigs.
     * @example
     * // Create many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuzzConfigs and only return the `id`
     * const buzzConfigWithIdOnly = await prisma.buzzConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuzzConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BuzzConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BuzzConfig.
     * @param {BuzzConfigDeleteArgs} args - Arguments to delete one BuzzConfig.
     * @example
     * // Delete one BuzzConfig
     * const BuzzConfig = await prisma.buzzConfig.delete({
     *   where: {
     *     // ... filter to delete one BuzzConfig
     *   }
     * })
     * 
     */
    delete<T extends BuzzConfigDeleteArgs>(args: SelectSubset<T, BuzzConfigDeleteArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuzzConfig.
     * @param {BuzzConfigUpdateArgs} args - Arguments to update one BuzzConfig.
     * @example
     * // Update one BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzConfigUpdateArgs>(args: SelectSubset<T, BuzzConfigUpdateArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuzzConfigs.
     * @param {BuzzConfigDeleteManyArgs} args - Arguments to filter BuzzConfigs to delete.
     * @example
     * // Delete a few BuzzConfigs
     * const { count } = await prisma.buzzConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzConfigDeleteManyArgs>(args?: SelectSubset<T, BuzzConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzConfigUpdateManyArgs>(args: SelectSubset<T, BuzzConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzConfigs and returns the data updated in the database.
     * @param {BuzzConfigUpdateManyAndReturnArgs} args - Arguments to update many BuzzConfigs.
     * @example
     * // Update many BuzzConfigs
     * const buzzConfig = await prisma.buzzConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BuzzConfigs and only return the `id`
     * const buzzConfigWithIdOnly = await prisma.buzzConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BuzzConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, BuzzConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BuzzConfig.
     * @param {BuzzConfigUpsertArgs} args - Arguments to update or create a BuzzConfig.
     * @example
     * // Update or create a BuzzConfig
     * const buzzConfig = await prisma.buzzConfig.upsert({
     *   create: {
     *     // ... data to create a BuzzConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzConfig we want to update
     *   }
     * })
     */
    upsert<T extends BuzzConfigUpsertArgs>(args: SelectSubset<T, BuzzConfigUpsertArgs<ExtArgs>>): Prisma__BuzzConfigClient<$Result.GetResult<Prisma.$BuzzConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuzzConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigCountArgs} args - Arguments to filter BuzzConfigs to count.
     * @example
     * // Count the number of BuzzConfigs
     * const count = await prisma.buzzConfig.count({
     *   where: {
     *     // ... the filter for the BuzzConfigs we want to count
     *   }
     * })
    **/
    count<T extends BuzzConfigCountArgs>(
      args?: Subset<T, BuzzConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzConfigAggregateArgs>(args: Subset<T, BuzzConfigAggregateArgs>): Prisma.PrismaPromise<GetBuzzConfigAggregateType<T>>

    /**
     * Group by BuzzConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzConfigGroupByArgs['orderBy'] }
        : { orderBy?: BuzzConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzConfig model
   */
  readonly fields: BuzzConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzConfig model
   */
  interface BuzzConfigFieldRefs {
    readonly id: FieldRef<"BuzzConfig", 'String'>
    readonly keywords: FieldRef<"BuzzConfig", 'String[]'>
    readonly accounts: FieldRef<"BuzzConfig", 'String[]'>
    readonly minEngagement: FieldRef<"BuzzConfig", 'Int'>
    readonly minImpressions: FieldRef<"BuzzConfig", 'Int'>
    readonly collectInterval: FieldRef<"BuzzConfig", 'Int'>
    readonly enabled: FieldRef<"BuzzConfig", 'Boolean'>
    readonly createdAt: FieldRef<"BuzzConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BuzzConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuzzConfig findUnique
   */
  export type BuzzConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig findUniqueOrThrow
   */
  export type BuzzConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig findFirst
   */
  export type BuzzConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzConfigs.
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzConfigs.
     */
    distinct?: BuzzConfigScalarFieldEnum | BuzzConfigScalarFieldEnum[]
  }

  /**
   * BuzzConfig findFirstOrThrow
   */
  export type BuzzConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * Filter, which BuzzConfig to fetch.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzConfigs.
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzConfigs.
     */
    distinct?: BuzzConfigScalarFieldEnum | BuzzConfigScalarFieldEnum[]
  }

  /**
   * BuzzConfig findMany
   */
  export type BuzzConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * Filter, which BuzzConfigs to fetch.
     */
    where?: BuzzConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzConfigs to fetch.
     */
    orderBy?: BuzzConfigOrderByWithRelationInput | BuzzConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzConfigs.
     */
    cursor?: BuzzConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzConfigs.
     */
    skip?: number
    distinct?: BuzzConfigScalarFieldEnum | BuzzConfigScalarFieldEnum[]
  }

  /**
   * BuzzConfig create
   */
  export type BuzzConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a BuzzConfig.
     */
    data: XOR<BuzzConfigCreateInput, BuzzConfigUncheckedCreateInput>
  }

  /**
   * BuzzConfig createMany
   */
  export type BuzzConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzConfigs.
     */
    data: BuzzConfigCreateManyInput | BuzzConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzConfig createManyAndReturn
   */
  export type BuzzConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * The data used to create many BuzzConfigs.
     */
    data: BuzzConfigCreateManyInput | BuzzConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzConfig update
   */
  export type BuzzConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a BuzzConfig.
     */
    data: XOR<BuzzConfigUpdateInput, BuzzConfigUncheckedUpdateInput>
    /**
     * Choose, which BuzzConfig to update.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig updateMany
   */
  export type BuzzConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzConfigs.
     */
    data: XOR<BuzzConfigUpdateManyMutationInput, BuzzConfigUncheckedUpdateManyInput>
    /**
     * Filter which BuzzConfigs to update
     */
    where?: BuzzConfigWhereInput
    /**
     * Limit how many BuzzConfigs to update.
     */
    limit?: number
  }

  /**
   * BuzzConfig updateManyAndReturn
   */
  export type BuzzConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * The data used to update BuzzConfigs.
     */
    data: XOR<BuzzConfigUpdateManyMutationInput, BuzzConfigUncheckedUpdateManyInput>
    /**
     * Filter which BuzzConfigs to update
     */
    where?: BuzzConfigWhereInput
    /**
     * Limit how many BuzzConfigs to update.
     */
    limit?: number
  }

  /**
   * BuzzConfig upsert
   */
  export type BuzzConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the BuzzConfig to update in case it exists.
     */
    where: BuzzConfigWhereUniqueInput
    /**
     * In case the BuzzConfig found by the `where` argument doesn't exist, create a new BuzzConfig with this data.
     */
    create: XOR<BuzzConfigCreateInput, BuzzConfigUncheckedCreateInput>
    /**
     * In case the BuzzConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzConfigUpdateInput, BuzzConfigUncheckedUpdateInput>
  }

  /**
   * BuzzConfig delete
   */
  export type BuzzConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
    /**
     * Filter which BuzzConfig to delete.
     */
    where: BuzzConfigWhereUniqueInput
  }

  /**
   * BuzzConfig deleteMany
   */
  export type BuzzConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzConfigs to delete
     */
    where?: BuzzConfigWhereInput
    /**
     * Limit how many BuzzConfigs to delete.
     */
    limit?: number
  }

  /**
   * BuzzConfig without action
   */
  export type BuzzConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzConfig
     */
    select?: BuzzConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzConfig
     */
    omit?: BuzzConfigOmit<ExtArgs> | null
  }


  /**
   * Model ScheduledPost
   */

  export type AggregateScheduledPost = {
    _count: ScheduledPostCountAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  export type ScheduledPostMinAggregateOutputType = {
    id: string | null
    content: string | null
    scheduledTime: Date | null
    status: $Enums.PostStatus | null
    postType: $Enums.PostType | null
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean | null
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    scheduledTime: Date | null
    status: $Enums.PostStatus | null
    postType: $Enums.PostType | null
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean | null
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPostCountAggregateOutputType = {
    id: number
    content: number
    scheduledTime: number
    status: number
    postType: number
    refPostId: number
    templateType: number
    aiGenerated: number
    aiPrompt: number
    editedContent: number
    postedAt: number
    postResult: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledPostMinAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPostMaxAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPostCountAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    postResult?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPost to aggregate.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledPosts
    **/
    _count?: true | ScheduledPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type GetScheduledPostAggregateType<T extends ScheduledPostAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledPost[P]>
      : GetScalarType<T[P], AggregateScheduledPost[P]>
  }




  export type ScheduledPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithAggregationInput | ScheduledPostOrderByWithAggregationInput[]
    by: ScheduledPostScalarFieldEnum[] | ScheduledPostScalarFieldEnum
    having?: ScheduledPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledPostCountAggregateInputType | true
    _min?: ScheduledPostMinAggregateInputType
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type ScheduledPostGroupByOutputType = {
    id: string
    content: string
    scheduledTime: Date
    status: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    postResult: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledPostCountAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  type GetScheduledPostGroupByPayload<T extends ScheduledPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post_analytics?: boolean | ScheduledPost$post_analyticsArgs<ExtArgs>
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
    _count?: boolean | ScheduledPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectScalar = {
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "scheduledTime" | "status" | "postType" | "refPostId" | "templateType" | "aiGenerated" | "aiPrompt" | "editedContent" | "postedAt" | "postResult" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduledPost"]>
  export type ScheduledPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post_analytics?: boolean | ScheduledPost$post_analyticsArgs<ExtArgs>
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
    _count?: boolean | ScheduledPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduledPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }
  export type ScheduledPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }

  export type $ScheduledPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledPost"
    objects: {
      post_analytics: Prisma.$PostAnalyticsPayload<ExtArgs>[]
      refPost: Prisma.$BuzzPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      scheduledTime: Date
      status: $Enums.PostStatus
      postType: $Enums.PostType
      refPostId: string | null
      templateType: string | null
      aiGenerated: boolean
      aiPrompt: string | null
      editedContent: string | null
      postedAt: Date | null
      postResult: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledPost"]>
    composites: {}
  }

  type ScheduledPostGetPayload<S extends boolean | null | undefined | ScheduledPostDefaultArgs> = $Result.GetResult<Prisma.$ScheduledPostPayload, S>

  type ScheduledPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledPostCountAggregateInputType | true
    }

  export interface ScheduledPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledPost'], meta: { name: 'ScheduledPost' } }
    /**
     * Find zero or one ScheduledPost that matches the filter.
     * @param {ScheduledPostFindUniqueArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledPostFindUniqueArgs>(args: SelectSubset<T, ScheduledPostFindUniqueArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledPostFindUniqueOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledPostFindFirstArgs>(args?: SelectSubset<T, ScheduledPostFindFirstArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany()
     * 
     * // Get first 10 ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledPostFindManyArgs>(args?: SelectSubset<T, ScheduledPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledPost.
     * @param {ScheduledPostCreateArgs} args - Arguments to create a ScheduledPost.
     * @example
     * // Create one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.create({
     *   data: {
     *     // ... data to create a ScheduledPost
     *   }
     * })
     * 
     */
    create<T extends ScheduledPostCreateArgs>(args: SelectSubset<T, ScheduledPostCreateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledPosts.
     * @param {ScheduledPostCreateManyArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledPostCreateManyArgs>(args?: SelectSubset<T, ScheduledPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledPosts and returns the data saved in the database.
     * @param {ScheduledPostCreateManyAndReturnArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledPosts and only return the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledPost.
     * @param {ScheduledPostDeleteArgs} args - Arguments to delete one ScheduledPost.
     * @example
     * // Delete one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.delete({
     *   where: {
     *     // ... filter to delete one ScheduledPost
     *   }
     * })
     * 
     */
    delete<T extends ScheduledPostDeleteArgs>(args: SelectSubset<T, ScheduledPostDeleteArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledPost.
     * @param {ScheduledPostUpdateArgs} args - Arguments to update one ScheduledPost.
     * @example
     * // Update one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledPostUpdateArgs>(args: SelectSubset<T, ScheduledPostUpdateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledPosts.
     * @param {ScheduledPostDeleteManyArgs} args - Arguments to filter ScheduledPosts to delete.
     * @example
     * // Delete a few ScheduledPosts
     * const { count } = await prisma.scheduledPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledPostDeleteManyArgs>(args?: SelectSubset<T, ScheduledPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledPostUpdateManyArgs>(args: SelectSubset<T, ScheduledPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPosts and returns the data updated in the database.
     * @param {ScheduledPostUpdateManyAndReturnArgs} args - Arguments to update many ScheduledPosts.
     * @example
     * // Update many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledPosts and only return the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledPostUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledPost.
     * @param {ScheduledPostUpsertArgs} args - Arguments to update or create a ScheduledPost.
     * @example
     * // Update or create a ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.upsert({
     *   create: {
     *     // ... data to create a ScheduledPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledPost we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledPostUpsertArgs>(args: SelectSubset<T, ScheduledPostUpsertArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostCountArgs} args - Arguments to filter ScheduledPosts to count.
     * @example
     * // Count the number of ScheduledPosts
     * const count = await prisma.scheduledPost.count({
     *   where: {
     *     // ... the filter for the ScheduledPosts we want to count
     *   }
     * })
    **/
    count<T extends ScheduledPostCountArgs>(
      args?: Subset<T, ScheduledPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledPostAggregateArgs>(args: Subset<T, ScheduledPostAggregateArgs>): Prisma.PrismaPromise<GetScheduledPostAggregateType<T>>

    /**
     * Group by ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledPostGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledPost model
   */
  readonly fields: ScheduledPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post_analytics<T extends ScheduledPost$post_analyticsArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledPost$post_analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refPost<T extends ScheduledPost$refPostArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledPost$refPostArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledPost model
   */
  interface ScheduledPostFieldRefs {
    readonly id: FieldRef<"ScheduledPost", 'String'>
    readonly content: FieldRef<"ScheduledPost", 'String'>
    readonly scheduledTime: FieldRef<"ScheduledPost", 'DateTime'>
    readonly status: FieldRef<"ScheduledPost", 'PostStatus'>
    readonly postType: FieldRef<"ScheduledPost", 'PostType'>
    readonly refPostId: FieldRef<"ScheduledPost", 'String'>
    readonly templateType: FieldRef<"ScheduledPost", 'String'>
    readonly aiGenerated: FieldRef<"ScheduledPost", 'Boolean'>
    readonly aiPrompt: FieldRef<"ScheduledPost", 'String'>
    readonly editedContent: FieldRef<"ScheduledPost", 'String'>
    readonly postedAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly postResult: FieldRef<"ScheduledPost", 'Json'>
    readonly createdAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledPost findUnique
   */
  export type ScheduledPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findUniqueOrThrow
   */
  export type ScheduledPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findFirst
   */
  export type ScheduledPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findFirstOrThrow
   */
  export type ScheduledPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findMany
   */
  export type ScheduledPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPosts to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost create
   */
  export type ScheduledPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledPost.
     */
    data: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
  }

  /**
   * ScheduledPost createMany
   */
  export type ScheduledPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledPost createManyAndReturn
   */
  export type ScheduledPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledPost update
   */
  export type ScheduledPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledPost.
     */
    data: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
    /**
     * Choose, which ScheduledPost to update.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost updateMany
   */
  export type ScheduledPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledPosts.
     */
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPosts to update
     */
    where?: ScheduledPostWhereInput
    /**
     * Limit how many ScheduledPosts to update.
     */
    limit?: number
  }

  /**
   * ScheduledPost updateManyAndReturn
   */
  export type ScheduledPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledPosts.
     */
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPosts to update
     */
    where?: ScheduledPostWhereInput
    /**
     * Limit how many ScheduledPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledPost upsert
   */
  export type ScheduledPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledPost to update in case it exists.
     */
    where: ScheduledPostWhereUniqueInput
    /**
     * In case the ScheduledPost found by the `where` argument doesn't exist, create a new ScheduledPost with this data.
     */
    create: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
    /**
     * In case the ScheduledPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
  }

  /**
   * ScheduledPost delete
   */
  export type ScheduledPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter which ScheduledPost to delete.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost deleteMany
   */
  export type ScheduledPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPosts to delete
     */
    where?: ScheduledPostWhereInput
    /**
     * Limit how many ScheduledPosts to delete.
     */
    limit?: number
  }

  /**
   * ScheduledPost.post_analytics
   */
  export type ScheduledPost$post_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    where?: PostAnalyticsWhereInput
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    cursor?: PostAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * ScheduledPost.refPost
   */
  export type ScheduledPost$refPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzPost
     */
    omit?: BuzzPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    where?: BuzzPostWhereInput
  }

  /**
   * ScheduledPost without action
   */
  export type ScheduledPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
  }


  /**
   * Model PostAnalytics
   */

  export type AggregatePostAnalytics = {
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  export type PostAnalyticsAvgAggregateOutputType = {
    impressions: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    link_clicks: number | null
    engagementRate: number | null
  }

  export type PostAnalyticsSumAggregateOutputType = {
    impressions: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    link_clicks: number | null
    engagementRate: number | null
  }

  export type PostAnalyticsMinAggregateOutputType = {
    id: string | null
    scheduled_post_id: string | null
    impressions: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    link_clicks: number | null
    measured_at: Date | null
    engagementRate: number | null
    ai_analysis: string | null
  }

  export type PostAnalyticsMaxAggregateOutputType = {
    id: string | null
    scheduled_post_id: string | null
    impressions: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    link_clicks: number | null
    measured_at: Date | null
    engagementRate: number | null
    ai_analysis: string | null
  }

  export type PostAnalyticsCountAggregateOutputType = {
    id: number
    scheduled_post_id: number
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at: number
    engagementRate: number
    ai_analysis: number
    _all: number
  }


  export type PostAnalyticsAvgAggregateInputType = {
    impressions?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    link_clicks?: true
    engagementRate?: true
  }

  export type PostAnalyticsSumAggregateInputType = {
    impressions?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    link_clicks?: true
    engagementRate?: true
  }

  export type PostAnalyticsMinAggregateInputType = {
    id?: true
    scheduled_post_id?: true
    impressions?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    link_clicks?: true
    measured_at?: true
    engagementRate?: true
    ai_analysis?: true
  }

  export type PostAnalyticsMaxAggregateInputType = {
    id?: true
    scheduled_post_id?: true
    impressions?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    link_clicks?: true
    measured_at?: true
    engagementRate?: true
    ai_analysis?: true
  }

  export type PostAnalyticsCountAggregateInputType = {
    id?: true
    scheduled_post_id?: true
    impressions?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    link_clicks?: true
    measured_at?: true
    engagementRate?: true
    ai_analysis?: true
    _all?: true
  }

  export type PostAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to aggregate.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAnalytics
    **/
    _count?: true | PostAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type GetPostAnalyticsAggregateType<T extends PostAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAnalytics[P]>
      : GetScalarType<T[P], AggregatePostAnalytics[P]>
  }




  export type PostAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAnalyticsWhereInput
    orderBy?: PostAnalyticsOrderByWithAggregationInput | PostAnalyticsOrderByWithAggregationInput[]
    by: PostAnalyticsScalarFieldEnum[] | PostAnalyticsScalarFieldEnum
    having?: PostAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAnalyticsCountAggregateInputType | true
    _avg?: PostAnalyticsAvgAggregateInputType
    _sum?: PostAnalyticsSumAggregateInputType
    _min?: PostAnalyticsMinAggregateInputType
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type PostAnalyticsGroupByOutputType = {
    id: string
    scheduled_post_id: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at: Date
    engagementRate: number
    ai_analysis: string | null
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  type GetPostAnalyticsGroupByPayload<T extends PostAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PostAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduled_post_id?: boolean
    impressions?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    link_clicks?: boolean
    measured_at?: boolean
    engagementRate?: boolean
    ai_analysis?: boolean
    scheduled_posts?: boolean | ScheduledPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduled_post_id?: boolean
    impressions?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    link_clicks?: boolean
    measured_at?: boolean
    engagementRate?: boolean
    ai_analysis?: boolean
    scheduled_posts?: boolean | ScheduledPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduled_post_id?: boolean
    impressions?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    link_clicks?: boolean
    measured_at?: boolean
    engagementRate?: boolean
    ai_analysis?: boolean
    scheduled_posts?: boolean | ScheduledPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectScalar = {
    id?: boolean
    scheduled_post_id?: boolean
    impressions?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    link_clicks?: boolean
    measured_at?: boolean
    engagementRate?: boolean
    ai_analysis?: boolean
  }

  export type PostAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scheduled_post_id" | "impressions" | "likes" | "retweets" | "replies" | "profileClicks" | "link_clicks" | "measured_at" | "engagementRate" | "ai_analysis", ExtArgs["result"]["postAnalytics"]>
  export type PostAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduled_posts?: boolean | ScheduledPostDefaultArgs<ExtArgs>
  }
  export type PostAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduled_posts?: boolean | ScheduledPostDefaultArgs<ExtArgs>
  }
  export type PostAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduled_posts?: boolean | ScheduledPostDefaultArgs<ExtArgs>
  }

  export type $PostAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAnalytics"
    objects: {
      scheduled_posts: Prisma.$ScheduledPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduled_post_id: string
      impressions: number
      likes: number
      retweets: number
      replies: number
      profileClicks: number
      link_clicks: number
      measured_at: Date
      engagementRate: number
      ai_analysis: string | null
    }, ExtArgs["result"]["postAnalytics"]>
    composites: {}
  }

  type PostAnalyticsGetPayload<S extends boolean | null | undefined | PostAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PostAnalyticsPayload, S>

  type PostAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostAnalyticsCountAggregateInputType | true
    }

  export interface PostAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAnalytics'], meta: { name: 'PostAnalytics' } }
    /**
     * Find zero or one PostAnalytics that matches the filter.
     * @param {PostAnalyticsFindUniqueArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostAnalyticsFindUniqueArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostAnalyticsFindFirstArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany()
     * 
     * // Get first 10 PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostAnalyticsFindManyArgs>(args?: SelectSubset<T, PostAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostAnalytics.
     * @param {PostAnalyticsCreateArgs} args - Arguments to create a PostAnalytics.
     * @example
     * // Create one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.create({
     *   data: {
     *     // ... data to create a PostAnalytics
     *   }
     * })
     * 
     */
    create<T extends PostAnalyticsCreateArgs>(args: SelectSubset<T, PostAnalyticsCreateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostAnalytics.
     * @param {PostAnalyticsCreateManyArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostAnalyticsCreateManyArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostAnalytics and returns the data saved in the database.
     * @param {PostAnalyticsCreateManyAndReturnArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostAnalytics and only return the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostAnalytics.
     * @param {PostAnalyticsDeleteArgs} args - Arguments to delete one PostAnalytics.
     * @example
     * // Delete one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PostAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PostAnalyticsDeleteArgs>(args: SelectSubset<T, PostAnalyticsDeleteArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostAnalytics.
     * @param {PostAnalyticsUpdateArgs} args - Arguments to update one PostAnalytics.
     * @example
     * // Update one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostAnalyticsUpdateArgs>(args: SelectSubset<T, PostAnalyticsUpdateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostAnalytics.
     * @param {PostAnalyticsDeleteManyArgs} args - Arguments to filter PostAnalytics to delete.
     * @example
     * // Delete a few PostAnalytics
     * const { count } = await prisma.postAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PostAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostAnalyticsUpdateManyArgs>(args: SelectSubset<T, PostAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAnalytics and returns the data updated in the database.
     * @param {PostAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many PostAnalytics.
     * @example
     * // Update many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostAnalytics and only return the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, PostAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostAnalytics.
     * @param {PostAnalyticsUpsertArgs} args - Arguments to update or create a PostAnalytics.
     * @example
     * // Update or create a PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.upsert({
     *   create: {
     *     // ... data to create a PostAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PostAnalyticsUpsertArgs>(args: SelectSubset<T, PostAnalyticsUpsertArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsCountArgs} args - Arguments to filter PostAnalytics to count.
     * @example
     * // Count the number of PostAnalytics
     * const count = await prisma.postAnalytics.count({
     *   where: {
     *     // ... the filter for the PostAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PostAnalyticsCountArgs>(
      args?: Subset<T, PostAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAnalyticsAggregateArgs>(args: Subset<T, PostAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPostAnalyticsAggregateType<T>>

    /**
     * Group by PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PostAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAnalytics model
   */
  readonly fields: PostAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scheduled_posts<T extends ScheduledPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledPostDefaultArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAnalytics model
   */
  interface PostAnalyticsFieldRefs {
    readonly id: FieldRef<"PostAnalytics", 'String'>
    readonly scheduled_post_id: FieldRef<"PostAnalytics", 'String'>
    readonly impressions: FieldRef<"PostAnalytics", 'Int'>
    readonly likes: FieldRef<"PostAnalytics", 'Int'>
    readonly retweets: FieldRef<"PostAnalytics", 'Int'>
    readonly replies: FieldRef<"PostAnalytics", 'Int'>
    readonly profileClicks: FieldRef<"PostAnalytics", 'Int'>
    readonly link_clicks: FieldRef<"PostAnalytics", 'Int'>
    readonly measured_at: FieldRef<"PostAnalytics", 'DateTime'>
    readonly engagementRate: FieldRef<"PostAnalytics", 'Float'>
    readonly ai_analysis: FieldRef<"PostAnalytics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostAnalytics findUnique
   */
  export type PostAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findUniqueOrThrow
   */
  export type PostAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findFirst
   */
  export type PostAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findFirstOrThrow
   */
  export type PostAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findMany
   */
  export type PostAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics create
   */
  export type PostAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a PostAnalytics.
     */
    data: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
  }

  /**
   * PostAnalytics createMany
   */
  export type PostAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAnalytics createManyAndReturn
   */
  export type PostAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAnalytics update
   */
  export type PostAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PostAnalytics to update.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics updateMany
   */
  export type PostAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PostAnalytics to update
     */
    where?: PostAnalyticsWhereInput
    /**
     * Limit how many PostAnalytics to update.
     */
    limit?: number
  }

  /**
   * PostAnalytics updateManyAndReturn
   */
  export type PostAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PostAnalytics to update
     */
    where?: PostAnalyticsWhereInput
    /**
     * Limit how many PostAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAnalytics upsert
   */
  export type PostAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the PostAnalytics to update in case it exists.
     */
    where: PostAnalyticsWhereUniqueInput
    /**
     * In case the PostAnalytics found by the `where` argument doesn't exist, create a new PostAnalytics with this data.
     */
    create: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
    /**
     * In case the PostAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
  }

  /**
   * PostAnalytics delete
   */
  export type PostAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which PostAnalytics to delete.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics deleteMany
   */
  export type PostAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to delete
     */
    where?: PostAnalyticsWhereInput
    /**
     * Limit how many PostAnalytics to delete.
     */
    limit?: number
  }

  /**
   * PostAnalytics without action
   */
  export type PostAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAnalytics
     */
    omit?: PostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    name: string | null
    email: string | null
    image: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    name: string | null
    email: string | null
    image: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    twitterId: number
    username: number
    name: number
    email: number
    image: number
    accessToken: number
    refreshToken: number
    tokenSecret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    twitterId: string
    username: string
    name: string | null
    email: string | null
    image: string | null
    accessToken: string
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    watchlistUsers?: boolean | User$watchlistUsersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "twitterId" | "username" | "name" | "email" | "image" | "accessToken" | "refreshToken" | "tokenSecret" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    watchlistUsers?: boolean | User$watchlistUsersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      watchlistUsers: Prisma.$WatchlistUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      twitterId: string
      username: string
      name: string | null
      email: string | null
      image: string | null
      accessToken: string
      refreshToken: string | null
      tokenSecret: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    watchlistUsers<T extends User$watchlistUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$watchlistUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly twitterId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly tokenSecret: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.watchlistUsers
   */
  export type User$watchlistUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    where?: WatchlistUserWhereInput
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    cursor?: WatchlistUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    created_at: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    created_at: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    created_at: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    created_at?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    created_at?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    created_at?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    created_at: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    created_at?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "created_at", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      created_at: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly created_at: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model NewsSource
   */

  export type AggregateNewsSource = {
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  export type NewsSourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: string | null
    category: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type NewsSourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: string | null
    category: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type NewsSourceCountAggregateOutputType = {
    id: number
    name: number
    url: number
    type: number
    category: number
    active: number
    createdAt: number
    _all: number
  }


  export type NewsSourceMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    category?: true
    active?: true
    createdAt?: true
  }

  export type NewsSourceMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    category?: true
    active?: true
    createdAt?: true
  }

  export type NewsSourceCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    category?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type NewsSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSource to aggregate.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsSources
    **/
    _count?: true | NewsSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsSourceMaxAggregateInputType
  }

  export type GetNewsSourceAggregateType<T extends NewsSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsSource[P]>
      : GetScalarType<T[P], AggregateNewsSource[P]>
  }




  export type NewsSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsSourceWhereInput
    orderBy?: NewsSourceOrderByWithAggregationInput | NewsSourceOrderByWithAggregationInput[]
    by: NewsSourceScalarFieldEnum[] | NewsSourceScalarFieldEnum
    having?: NewsSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsSourceCountAggregateInputType | true
    _min?: NewsSourceMinAggregateInputType
    _max?: NewsSourceMaxAggregateInputType
  }

  export type NewsSourceGroupByOutputType = {
    id: string
    name: string
    url: string
    type: string
    category: string
    active: boolean
    createdAt: Date
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  type GetNewsSourceGroupByPayload<T extends NewsSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
            : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
        }
      >
    >


  export type NewsSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
    articles?: boolean | NewsSource$articlesArgs<ExtArgs>
    _count?: boolean | NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type NewsSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "type" | "category" | "active" | "createdAt", ExtArgs["result"]["newsSource"]>
  export type NewsSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | NewsSource$articlesArgs<ExtArgs>
    _count?: boolean | NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NewsSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsSource"
    objects: {
      articles: Prisma.$NewsArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      type: string
      category: string
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["newsSource"]>
    composites: {}
  }

  type NewsSourceGetPayload<S extends boolean | null | undefined | NewsSourceDefaultArgs> = $Result.GetResult<Prisma.$NewsSourcePayload, S>

  type NewsSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsSourceCountAggregateInputType | true
    }

  export interface NewsSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsSource'], meta: { name: 'NewsSource' } }
    /**
     * Find zero or one NewsSource that matches the filter.
     * @param {NewsSourceFindUniqueArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsSourceFindUniqueArgs>(args: SelectSubset<T, NewsSourceFindUniqueArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsSourceFindUniqueOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsSourceFindFirstArgs>(args?: SelectSubset<T, NewsSourceFindFirstArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsSources
     * const newsSources = await prisma.newsSource.findMany()
     * 
     * // Get first 10 NewsSources
     * const newsSources = await prisma.newsSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsSourceFindManyArgs>(args?: SelectSubset<T, NewsSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsSource.
     * @param {NewsSourceCreateArgs} args - Arguments to create a NewsSource.
     * @example
     * // Create one NewsSource
     * const NewsSource = await prisma.newsSource.create({
     *   data: {
     *     // ... data to create a NewsSource
     *   }
     * })
     * 
     */
    create<T extends NewsSourceCreateArgs>(args: SelectSubset<T, NewsSourceCreateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsSources.
     * @param {NewsSourceCreateManyArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsSourceCreateManyArgs>(args?: SelectSubset<T, NewsSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsSources and returns the data saved in the database.
     * @param {NewsSourceCreateManyAndReturnArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsSources and only return the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsSource.
     * @param {NewsSourceDeleteArgs} args - Arguments to delete one NewsSource.
     * @example
     * // Delete one NewsSource
     * const NewsSource = await prisma.newsSource.delete({
     *   where: {
     *     // ... filter to delete one NewsSource
     *   }
     * })
     * 
     */
    delete<T extends NewsSourceDeleteArgs>(args: SelectSubset<T, NewsSourceDeleteArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsSource.
     * @param {NewsSourceUpdateArgs} args - Arguments to update one NewsSource.
     * @example
     * // Update one NewsSource
     * const newsSource = await prisma.newsSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsSourceUpdateArgs>(args: SelectSubset<T, NewsSourceUpdateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsSources.
     * @param {NewsSourceDeleteManyArgs} args - Arguments to filter NewsSources to delete.
     * @example
     * // Delete a few NewsSources
     * const { count } = await prisma.newsSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsSourceDeleteManyArgs>(args?: SelectSubset<T, NewsSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsSources
     * const newsSource = await prisma.newsSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsSourceUpdateManyArgs>(args: SelectSubset<T, NewsSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsSources and returns the data updated in the database.
     * @param {NewsSourceUpdateManyAndReturnArgs} args - Arguments to update many NewsSources.
     * @example
     * // Update many NewsSources
     * const newsSource = await prisma.newsSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsSources and only return the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsSource.
     * @param {NewsSourceUpsertArgs} args - Arguments to update or create a NewsSource.
     * @example
     * // Update or create a NewsSource
     * const newsSource = await prisma.newsSource.upsert({
     *   create: {
     *     // ... data to create a NewsSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsSource we want to update
     *   }
     * })
     */
    upsert<T extends NewsSourceUpsertArgs>(args: SelectSubset<T, NewsSourceUpsertArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceCountArgs} args - Arguments to filter NewsSources to count.
     * @example
     * // Count the number of NewsSources
     * const count = await prisma.newsSource.count({
     *   where: {
     *     // ... the filter for the NewsSources we want to count
     *   }
     * })
    **/
    count<T extends NewsSourceCountArgs>(
      args?: Subset<T, NewsSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsSourceAggregateArgs>(args: Subset<T, NewsSourceAggregateArgs>): Prisma.PrismaPromise<GetNewsSourceAggregateType<T>>

    /**
     * Group by NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsSourceGroupByArgs['orderBy'] }
        : { orderBy?: NewsSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsSource model
   */
  readonly fields: NewsSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends NewsSource$articlesArgs<ExtArgs> = {}>(args?: Subset<T, NewsSource$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsSource model
   */
  interface NewsSourceFieldRefs {
    readonly id: FieldRef<"NewsSource", 'String'>
    readonly name: FieldRef<"NewsSource", 'String'>
    readonly url: FieldRef<"NewsSource", 'String'>
    readonly type: FieldRef<"NewsSource", 'String'>
    readonly category: FieldRef<"NewsSource", 'String'>
    readonly active: FieldRef<"NewsSource", 'Boolean'>
    readonly createdAt: FieldRef<"NewsSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsSource findUnique
   */
  export type NewsSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findUniqueOrThrow
   */
  export type NewsSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findFirst
   */
  export type NewsSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findFirstOrThrow
   */
  export type NewsSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findMany
   */
  export type NewsSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSources to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource create
   */
  export type NewsSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsSource.
     */
    data: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
  }

  /**
   * NewsSource createMany
   */
  export type NewsSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsSource createManyAndReturn
   */
  export type NewsSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsSource update
   */
  export type NewsSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsSource.
     */
    data: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
    /**
     * Choose, which NewsSource to update.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource updateMany
   */
  export type NewsSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsSources.
     */
    data: XOR<NewsSourceUpdateManyMutationInput, NewsSourceUncheckedUpdateManyInput>
    /**
     * Filter which NewsSources to update
     */
    where?: NewsSourceWhereInput
    /**
     * Limit how many NewsSources to update.
     */
    limit?: number
  }

  /**
   * NewsSource updateManyAndReturn
   */
  export type NewsSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * The data used to update NewsSources.
     */
    data: XOR<NewsSourceUpdateManyMutationInput, NewsSourceUncheckedUpdateManyInput>
    /**
     * Filter which NewsSources to update
     */
    where?: NewsSourceWhereInput
    /**
     * Limit how many NewsSources to update.
     */
    limit?: number
  }

  /**
   * NewsSource upsert
   */
  export type NewsSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsSource to update in case it exists.
     */
    where: NewsSourceWhereUniqueInput
    /**
     * In case the NewsSource found by the `where` argument doesn't exist, create a new NewsSource with this data.
     */
    create: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
    /**
     * In case the NewsSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
  }

  /**
   * NewsSource delete
   */
  export type NewsSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter which NewsSource to delete.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource deleteMany
   */
  export type NewsSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSources to delete
     */
    where?: NewsSourceWhereInput
    /**
     * Limit how many NewsSources to delete.
     */
    limit?: number
  }

  /**
   * NewsSource.articles
   */
  export type NewsSource$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    cursor?: NewsArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsSource without action
   */
  export type NewsSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsSource
     */
    omit?: NewsSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
  }


  /**
   * Model NewsArticle
   */

  export type AggregateNewsArticle = {
    _count: NewsArticleCountAggregateOutputType | null
    _avg: NewsArticleAvgAggregateOutputType | null
    _sum: NewsArticleSumAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  export type NewsArticleAvgAggregateOutputType = {
    importance: number | null
  }

  export type NewsArticleSumAggregateOutputType = {
    importance: number | null
  }

  export type NewsArticleMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    title: string | null
    summary: string | null
    content: string | null
    url: string | null
    publishedAt: Date | null
    category: string | null
    importance: number | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type NewsArticleMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    title: string | null
    summary: string | null
    content: string | null
    url: string | null
    publishedAt: Date | null
    category: string | null
    importance: number | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type NewsArticleCountAggregateOutputType = {
    id: number
    sourceId: number
    title: number
    summary: number
    content: number
    url: number
    publishedAt: number
    category: number
    importance: number
    processed: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type NewsArticleAvgAggregateInputType = {
    importance?: true
  }

  export type NewsArticleSumAggregateInputType = {
    importance?: true
  }

  export type NewsArticleMinAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    summary?: true
    content?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
  }

  export type NewsArticleMaxAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    summary?: true
    content?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
  }

  export type NewsArticleCountAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    summary?: true
    content?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type NewsArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticle to aggregate.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsArticles
    **/
    _count?: true | NewsArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsArticleMaxAggregateInputType
  }

  export type GetNewsArticleAggregateType<T extends NewsArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsArticle[P]>
      : GetScalarType<T[P], AggregateNewsArticle[P]>
  }




  export type NewsArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithAggregationInput | NewsArticleOrderByWithAggregationInput[]
    by: NewsArticleScalarFieldEnum[] | NewsArticleScalarFieldEnum
    having?: NewsArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsArticleCountAggregateInputType | true
    _avg?: NewsArticleAvgAggregateInputType
    _sum?: NewsArticleSumAggregateInputType
    _min?: NewsArticleMinAggregateInputType
    _max?: NewsArticleMaxAggregateInputType
  }

  export type NewsArticleGroupByOutputType = {
    id: string
    sourceId: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date
    category: string | null
    importance: number | null
    processed: boolean
    createdAt: Date
    metadata: JsonValue | null
    _count: NewsArticleCountAggregateOutputType | null
    _avg: NewsArticleAvgAggregateOutputType | null
    _sum: NewsArticleSumAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  type GetNewsArticleGroupByPayload<T extends NewsArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
            : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
        }
      >
    >


  export type NewsArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    analysis?: boolean | NewsArticle$analysisArgs<ExtArgs>
    news_analysis_results?: boolean | NewsArticle$news_analysis_resultsArgs<ExtArgs>
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
    newsThreadItems?: boolean | NewsArticle$newsThreadItemsArgs<ExtArgs>
    _count?: boolean | NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectScalar = {
    id?: boolean
    sourceId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type NewsArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceId" | "title" | "summary" | "content" | "url" | "publishedAt" | "category" | "importance" | "processed" | "createdAt" | "metadata", ExtArgs["result"]["newsArticle"]>
  export type NewsArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysis?: boolean | NewsArticle$analysisArgs<ExtArgs>
    news_analysis_results?: boolean | NewsArticle$news_analysis_resultsArgs<ExtArgs>
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
    newsThreadItems?: boolean | NewsArticle$newsThreadItemsArgs<ExtArgs>
    _count?: boolean | NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }
  export type NewsArticleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }

  export type $NewsArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsArticle"
    objects: {
      analysis: Prisma.$NewsAnalysisPayload<ExtArgs> | null
      news_analysis_results: Prisma.$news_analysis_resultsPayload<ExtArgs>[]
      source: Prisma.$NewsSourcePayload<ExtArgs>
      newsThreadItems: Prisma.$NewsThreadItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      title: string
      summary: string
      content: string
      url: string
      publishedAt: Date
      category: string | null
      importance: number | null
      processed: boolean
      createdAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["newsArticle"]>
    composites: {}
  }

  type NewsArticleGetPayload<S extends boolean | null | undefined | NewsArticleDefaultArgs> = $Result.GetResult<Prisma.$NewsArticlePayload, S>

  type NewsArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsArticleCountAggregateInputType | true
    }

  export interface NewsArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsArticle'], meta: { name: 'NewsArticle' } }
    /**
     * Find zero or one NewsArticle that matches the filter.
     * @param {NewsArticleFindUniqueArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsArticleFindUniqueArgs>(args: SelectSubset<T, NewsArticleFindUniqueArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsArticle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsArticleFindUniqueOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsArticleFindFirstArgs>(args?: SelectSubset<T, NewsArticleFindFirstArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany()
     * 
     * // Get first 10 NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsArticleFindManyArgs>(args?: SelectSubset<T, NewsArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsArticle.
     * @param {NewsArticleCreateArgs} args - Arguments to create a NewsArticle.
     * @example
     * // Create one NewsArticle
     * const NewsArticle = await prisma.newsArticle.create({
     *   data: {
     *     // ... data to create a NewsArticle
     *   }
     * })
     * 
     */
    create<T extends NewsArticleCreateArgs>(args: SelectSubset<T, NewsArticleCreateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsArticles.
     * @param {NewsArticleCreateManyArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsArticleCreateManyArgs>(args?: SelectSubset<T, NewsArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsArticles and returns the data saved in the database.
     * @param {NewsArticleCreateManyAndReturnArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsArticles and only return the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsArticle.
     * @param {NewsArticleDeleteArgs} args - Arguments to delete one NewsArticle.
     * @example
     * // Delete one NewsArticle
     * const NewsArticle = await prisma.newsArticle.delete({
     *   where: {
     *     // ... filter to delete one NewsArticle
     *   }
     * })
     * 
     */
    delete<T extends NewsArticleDeleteArgs>(args: SelectSubset<T, NewsArticleDeleteArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsArticle.
     * @param {NewsArticleUpdateArgs} args - Arguments to update one NewsArticle.
     * @example
     * // Update one NewsArticle
     * const newsArticle = await prisma.newsArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsArticleUpdateArgs>(args: SelectSubset<T, NewsArticleUpdateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsArticles.
     * @param {NewsArticleDeleteManyArgs} args - Arguments to filter NewsArticles to delete.
     * @example
     * // Delete a few NewsArticles
     * const { count } = await prisma.newsArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsArticleDeleteManyArgs>(args?: SelectSubset<T, NewsArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsArticles
     * const newsArticle = await prisma.newsArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsArticleUpdateManyArgs>(args: SelectSubset<T, NewsArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsArticles and returns the data updated in the database.
     * @param {NewsArticleUpdateManyAndReturnArgs} args - Arguments to update many NewsArticles.
     * @example
     * // Update many NewsArticles
     * const newsArticle = await prisma.newsArticle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsArticles and only return the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsArticle.
     * @param {NewsArticleUpsertArgs} args - Arguments to update or create a NewsArticle.
     * @example
     * // Update or create a NewsArticle
     * const newsArticle = await prisma.newsArticle.upsert({
     *   create: {
     *     // ... data to create a NewsArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsArticle we want to update
     *   }
     * })
     */
    upsert<T extends NewsArticleUpsertArgs>(args: SelectSubset<T, NewsArticleUpsertArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleCountArgs} args - Arguments to filter NewsArticles to count.
     * @example
     * // Count the number of NewsArticles
     * const count = await prisma.newsArticle.count({
     *   where: {
     *     // ... the filter for the NewsArticles we want to count
     *   }
     * })
    **/
    count<T extends NewsArticleCountArgs>(
      args?: Subset<T, NewsArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsArticleAggregateArgs>(args: Subset<T, NewsArticleAggregateArgs>): Prisma.PrismaPromise<GetNewsArticleAggregateType<T>>

    /**
     * Group by NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsArticleGroupByArgs['orderBy'] }
        : { orderBy?: NewsArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsArticle model
   */
  readonly fields: NewsArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analysis<T extends NewsArticle$analysisArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$analysisArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    news_analysis_results<T extends NewsArticle$news_analysis_resultsArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$news_analysis_resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    source<T extends NewsSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsSourceDefaultArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    newsThreadItems<T extends NewsArticle$newsThreadItemsArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$newsThreadItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsArticle model
   */
  interface NewsArticleFieldRefs {
    readonly id: FieldRef<"NewsArticle", 'String'>
    readonly sourceId: FieldRef<"NewsArticle", 'String'>
    readonly title: FieldRef<"NewsArticle", 'String'>
    readonly summary: FieldRef<"NewsArticle", 'String'>
    readonly content: FieldRef<"NewsArticle", 'String'>
    readonly url: FieldRef<"NewsArticle", 'String'>
    readonly publishedAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly category: FieldRef<"NewsArticle", 'String'>
    readonly importance: FieldRef<"NewsArticle", 'Float'>
    readonly processed: FieldRef<"NewsArticle", 'Boolean'>
    readonly createdAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly metadata: FieldRef<"NewsArticle", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NewsArticle findUnique
   */
  export type NewsArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findUniqueOrThrow
   */
  export type NewsArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findFirst
   */
  export type NewsArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findFirstOrThrow
   */
  export type NewsArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findMany
   */
  export type NewsArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticles to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle create
   */
  export type NewsArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsArticle.
     */
    data: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
  }

  /**
   * NewsArticle createMany
   */
  export type NewsArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsArticle createManyAndReturn
   */
  export type NewsArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsArticle update
   */
  export type NewsArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsArticle.
     */
    data: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
    /**
     * Choose, which NewsArticle to update.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle updateMany
   */
  export type NewsArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsArticles.
     */
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyInput>
    /**
     * Filter which NewsArticles to update
     */
    where?: NewsArticleWhereInput
    /**
     * Limit how many NewsArticles to update.
     */
    limit?: number
  }

  /**
   * NewsArticle updateManyAndReturn
   */
  export type NewsArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * The data used to update NewsArticles.
     */
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyInput>
    /**
     * Filter which NewsArticles to update
     */
    where?: NewsArticleWhereInput
    /**
     * Limit how many NewsArticles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsArticle upsert
   */
  export type NewsArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsArticle to update in case it exists.
     */
    where: NewsArticleWhereUniqueInput
    /**
     * In case the NewsArticle found by the `where` argument doesn't exist, create a new NewsArticle with this data.
     */
    create: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
    /**
     * In case the NewsArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
  }

  /**
   * NewsArticle delete
   */
  export type NewsArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter which NewsArticle to delete.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle deleteMany
   */
  export type NewsArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticles to delete
     */
    where?: NewsArticleWhereInput
    /**
     * Limit how many NewsArticles to delete.
     */
    limit?: number
  }

  /**
   * NewsArticle.analysis
   */
  export type NewsArticle$analysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsArticle.news_analysis_results
   */
  export type NewsArticle$news_analysis_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    where?: news_analysis_resultsWhereInput
    orderBy?: news_analysis_resultsOrderByWithRelationInput | news_analysis_resultsOrderByWithRelationInput[]
    cursor?: news_analysis_resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: News_analysis_resultsScalarFieldEnum | News_analysis_resultsScalarFieldEnum[]
  }

  /**
   * NewsArticle.newsThreadItems
   */
  export type NewsArticle$newsThreadItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    cursor?: NewsThreadItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsArticle without action
   */
  export type NewsArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
  }


  /**
   * Model NewsThread
   */

  export type AggregateNewsThread = {
    _count: NewsThreadCountAggregateOutputType | null
    _min: NewsThreadMinAggregateOutputType | null
    _max: NewsThreadMaxAggregateOutputType | null
  }

  export type NewsThreadMinAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    title: string | null
    postedAt: Date | null
  }

  export type NewsThreadMaxAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    title: string | null
    postedAt: Date | null
  }

  export type NewsThreadCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    metadata: number
    scheduledAt: number
    title: number
    postedAt: number
    _all: number
  }


  export type NewsThreadMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
  }

  export type NewsThreadMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
  }

  export type NewsThreadCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    metadata?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
    _all?: true
  }

  export type NewsThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThread to aggregate.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsThreads
    **/
    _count?: true | NewsThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsThreadMaxAggregateInputType
  }

  export type GetNewsThreadAggregateType<T extends NewsThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsThread[P]>
      : GetScalarType<T[P], AggregateNewsThread[P]>
  }




  export type NewsThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadWhereInput
    orderBy?: NewsThreadOrderByWithAggregationInput | NewsThreadOrderByWithAggregationInput[]
    by: NewsThreadScalarFieldEnum[] | NewsThreadScalarFieldEnum
    having?: NewsThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsThreadCountAggregateInputType | true
    _min?: NewsThreadMinAggregateInputType
    _max?: NewsThreadMaxAggregateInputType
  }

  export type NewsThreadGroupByOutputType = {
    id: string
    status: string
    createdAt: Date
    metadata: JsonValue | null
    scheduledAt: Date | null
    title: string
    postedAt: Date | null
    _count: NewsThreadCountAggregateOutputType | null
    _min: NewsThreadMinAggregateOutputType | null
    _max: NewsThreadMaxAggregateOutputType | null
  }

  type GetNewsThreadGroupByPayload<T extends NewsThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsThreadGroupByOutputType[P]>
            : GetScalarType<T[P], NewsThreadGroupByOutputType[P]>
        }
      >
    >


  export type NewsThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
    items?: boolean | NewsThread$itemsArgs<ExtArgs>
    _count?: boolean | NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }

  export type NewsThreadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "metadata" | "scheduledAt" | "title" | "postedAt", ExtArgs["result"]["newsThread"]>
  export type NewsThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NewsThread$itemsArgs<ExtArgs>
    _count?: boolean | NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NewsThreadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsThread"
    objects: {
      items: Prisma.$NewsThreadItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      createdAt: Date
      metadata: Prisma.JsonValue | null
      scheduledAt: Date | null
      title: string
      postedAt: Date | null
    }, ExtArgs["result"]["newsThread"]>
    composites: {}
  }

  type NewsThreadGetPayload<S extends boolean | null | undefined | NewsThreadDefaultArgs> = $Result.GetResult<Prisma.$NewsThreadPayload, S>

  type NewsThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsThreadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsThreadCountAggregateInputType | true
    }

  export interface NewsThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsThread'], meta: { name: 'NewsThread' } }
    /**
     * Find zero or one NewsThread that matches the filter.
     * @param {NewsThreadFindUniqueArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsThreadFindUniqueArgs>(args: SelectSubset<T, NewsThreadFindUniqueArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsThread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsThreadFindUniqueOrThrowArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindFirstArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsThreadFindFirstArgs>(args?: SelectSubset<T, NewsThreadFindFirstArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindFirstOrThrowArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsThreads
     * const newsThreads = await prisma.newsThread.findMany()
     * 
     * // Get first 10 NewsThreads
     * const newsThreads = await prisma.newsThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsThreadFindManyArgs>(args?: SelectSubset<T, NewsThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsThread.
     * @param {NewsThreadCreateArgs} args - Arguments to create a NewsThread.
     * @example
     * // Create one NewsThread
     * const NewsThread = await prisma.newsThread.create({
     *   data: {
     *     // ... data to create a NewsThread
     *   }
     * })
     * 
     */
    create<T extends NewsThreadCreateArgs>(args: SelectSubset<T, NewsThreadCreateArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsThreads.
     * @param {NewsThreadCreateManyArgs} args - Arguments to create many NewsThreads.
     * @example
     * // Create many NewsThreads
     * const newsThread = await prisma.newsThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsThreadCreateManyArgs>(args?: SelectSubset<T, NewsThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsThreads and returns the data saved in the database.
     * @param {NewsThreadCreateManyAndReturnArgs} args - Arguments to create many NewsThreads.
     * @example
     * // Create many NewsThreads
     * const newsThread = await prisma.newsThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsThreads and only return the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsThread.
     * @param {NewsThreadDeleteArgs} args - Arguments to delete one NewsThread.
     * @example
     * // Delete one NewsThread
     * const NewsThread = await prisma.newsThread.delete({
     *   where: {
     *     // ... filter to delete one NewsThread
     *   }
     * })
     * 
     */
    delete<T extends NewsThreadDeleteArgs>(args: SelectSubset<T, NewsThreadDeleteArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsThread.
     * @param {NewsThreadUpdateArgs} args - Arguments to update one NewsThread.
     * @example
     * // Update one NewsThread
     * const newsThread = await prisma.newsThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsThreadUpdateArgs>(args: SelectSubset<T, NewsThreadUpdateArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsThreads.
     * @param {NewsThreadDeleteManyArgs} args - Arguments to filter NewsThreads to delete.
     * @example
     * // Delete a few NewsThreads
     * const { count } = await prisma.newsThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsThreadDeleteManyArgs>(args?: SelectSubset<T, NewsThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsThreads
     * const newsThread = await prisma.newsThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsThreadUpdateManyArgs>(args: SelectSubset<T, NewsThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreads and returns the data updated in the database.
     * @param {NewsThreadUpdateManyAndReturnArgs} args - Arguments to update many NewsThreads.
     * @example
     * // Update many NewsThreads
     * const newsThread = await prisma.newsThread.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsThreads and only return the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsThreadUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsThreadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsThread.
     * @param {NewsThreadUpsertArgs} args - Arguments to update or create a NewsThread.
     * @example
     * // Update or create a NewsThread
     * const newsThread = await prisma.newsThread.upsert({
     *   create: {
     *     // ... data to create a NewsThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsThread we want to update
     *   }
     * })
     */
    upsert<T extends NewsThreadUpsertArgs>(args: SelectSubset<T, NewsThreadUpsertArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadCountArgs} args - Arguments to filter NewsThreads to count.
     * @example
     * // Count the number of NewsThreads
     * const count = await prisma.newsThread.count({
     *   where: {
     *     // ... the filter for the NewsThreads we want to count
     *   }
     * })
    **/
    count<T extends NewsThreadCountArgs>(
      args?: Subset<T, NewsThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsThreadAggregateArgs>(args: Subset<T, NewsThreadAggregateArgs>): Prisma.PrismaPromise<GetNewsThreadAggregateType<T>>

    /**
     * Group by NewsThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsThreadGroupByArgs['orderBy'] }
        : { orderBy?: NewsThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsThread model
   */
  readonly fields: NewsThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends NewsThread$itemsArgs<ExtArgs> = {}>(args?: Subset<T, NewsThread$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsThread model
   */
  interface NewsThreadFieldRefs {
    readonly id: FieldRef<"NewsThread", 'String'>
    readonly status: FieldRef<"NewsThread", 'String'>
    readonly createdAt: FieldRef<"NewsThread", 'DateTime'>
    readonly metadata: FieldRef<"NewsThread", 'Json'>
    readonly scheduledAt: FieldRef<"NewsThread", 'DateTime'>
    readonly title: FieldRef<"NewsThread", 'String'>
    readonly postedAt: FieldRef<"NewsThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsThread findUnique
   */
  export type NewsThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread findUniqueOrThrow
   */
  export type NewsThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread findFirst
   */
  export type NewsThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreads.
     */
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread findFirstOrThrow
   */
  export type NewsThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreads.
     */
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread findMany
   */
  export type NewsThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreads to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread create
   */
  export type NewsThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsThread.
     */
    data: XOR<NewsThreadCreateInput, NewsThreadUncheckedCreateInput>
  }

  /**
   * NewsThread createMany
   */
  export type NewsThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsThreads.
     */
    data: NewsThreadCreateManyInput | NewsThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThread createManyAndReturn
   */
  export type NewsThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * The data used to create many NewsThreads.
     */
    data: NewsThreadCreateManyInput | NewsThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThread update
   */
  export type NewsThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsThread.
     */
    data: XOR<NewsThreadUpdateInput, NewsThreadUncheckedUpdateInput>
    /**
     * Choose, which NewsThread to update.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread updateMany
   */
  export type NewsThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsThreads.
     */
    data: XOR<NewsThreadUpdateManyMutationInput, NewsThreadUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreads to update
     */
    where?: NewsThreadWhereInput
    /**
     * Limit how many NewsThreads to update.
     */
    limit?: number
  }

  /**
   * NewsThread updateManyAndReturn
   */
  export type NewsThreadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * The data used to update NewsThreads.
     */
    data: XOR<NewsThreadUpdateManyMutationInput, NewsThreadUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreads to update
     */
    where?: NewsThreadWhereInput
    /**
     * Limit how many NewsThreads to update.
     */
    limit?: number
  }

  /**
   * NewsThread upsert
   */
  export type NewsThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsThread to update in case it exists.
     */
    where: NewsThreadWhereUniqueInput
    /**
     * In case the NewsThread found by the `where` argument doesn't exist, create a new NewsThread with this data.
     */
    create: XOR<NewsThreadCreateInput, NewsThreadUncheckedCreateInput>
    /**
     * In case the NewsThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsThreadUpdateInput, NewsThreadUncheckedUpdateInput>
  }

  /**
   * NewsThread delete
   */
  export type NewsThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter which NewsThread to delete.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread deleteMany
   */
  export type NewsThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreads to delete
     */
    where?: NewsThreadWhereInput
    /**
     * Limit how many NewsThreads to delete.
     */
    limit?: number
  }

  /**
   * NewsThread.items
   */
  export type NewsThread$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    cursor?: NewsThreadItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThread without action
   */
  export type NewsThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThread
     */
    omit?: NewsThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
  }


  /**
   * Model NewsThreadItem
   */

  export type AggregateNewsThreadItem = {
    _count: NewsThreadItemCountAggregateOutputType | null
    _avg: NewsThreadItemAvgAggregateOutputType | null
    _sum: NewsThreadItemSumAggregateOutputType | null
    _min: NewsThreadItemMinAggregateOutputType | null
    _max: NewsThreadItemMaxAggregateOutputType | null
  }

  export type NewsThreadItemAvgAggregateOutputType = {
    position: number | null
  }

  export type NewsThreadItemSumAggregateOutputType = {
    position: number | null
  }

  export type NewsThreadItemMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    articleId: string | null
    tweet_id: string | null
    parent_tweet_id: string | null
    posted_at: Date | null
    content: string | null
    position: number | null
  }

  export type NewsThreadItemMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    articleId: string | null
    tweet_id: string | null
    parent_tweet_id: string | null
    posted_at: Date | null
    content: string | null
    position: number | null
  }

  export type NewsThreadItemCountAggregateOutputType = {
    id: number
    threadId: number
    articleId: number
    tweet_id: number
    parent_tweet_id: number
    posted_at: number
    content: number
    metadata: number
    position: number
    _all: number
  }


  export type NewsThreadItemAvgAggregateInputType = {
    position?: true
  }

  export type NewsThreadItemSumAggregateInputType = {
    position?: true
  }

  export type NewsThreadItemMinAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    tweet_id?: true
    parent_tweet_id?: true
    posted_at?: true
    content?: true
    position?: true
  }

  export type NewsThreadItemMaxAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    tweet_id?: true
    parent_tweet_id?: true
    posted_at?: true
    content?: true
    position?: true
  }

  export type NewsThreadItemCountAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    tweet_id?: true
    parent_tweet_id?: true
    posted_at?: true
    content?: true
    metadata?: true
    position?: true
    _all?: true
  }

  export type NewsThreadItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreadItem to aggregate.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsThreadItems
    **/
    _count?: true | NewsThreadItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsThreadItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsThreadItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsThreadItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsThreadItemMaxAggregateInputType
  }

  export type GetNewsThreadItemAggregateType<T extends NewsThreadItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsThreadItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsThreadItem[P]>
      : GetScalarType<T[P], AggregateNewsThreadItem[P]>
  }




  export type NewsThreadItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithAggregationInput | NewsThreadItemOrderByWithAggregationInput[]
    by: NewsThreadItemScalarFieldEnum[] | NewsThreadItemScalarFieldEnum
    having?: NewsThreadItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsThreadItemCountAggregateInputType | true
    _avg?: NewsThreadItemAvgAggregateInputType
    _sum?: NewsThreadItemSumAggregateInputType
    _min?: NewsThreadItemMinAggregateInputType
    _max?: NewsThreadItemMaxAggregateInputType
  }

  export type NewsThreadItemGroupByOutputType = {
    id: string
    threadId: string
    articleId: string | null
    tweet_id: string | null
    parent_tweet_id: string | null
    posted_at: Date | null
    content: string
    metadata: JsonValue | null
    position: number
    _count: NewsThreadItemCountAggregateOutputType | null
    _avg: NewsThreadItemAvgAggregateOutputType | null
    _sum: NewsThreadItemSumAggregateOutputType | null
    _min: NewsThreadItemMinAggregateOutputType | null
    _max: NewsThreadItemMaxAggregateOutputType | null
  }

  type GetNewsThreadItemGroupByPayload<T extends NewsThreadItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsThreadItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsThreadItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsThreadItemGroupByOutputType[P]>
            : GetScalarType<T[P], NewsThreadItemGroupByOutputType[P]>
        }
      >
    >


  export type NewsThreadItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    tweet_id?: boolean
    parent_tweet_id?: boolean
    posted_at?: boolean
    content?: boolean
    metadata?: boolean
    position?: boolean
    article?: boolean | NewsThreadItem$articleArgs<ExtArgs>
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    tweet_id?: boolean
    parent_tweet_id?: boolean
    posted_at?: boolean
    content?: boolean
    metadata?: boolean
    position?: boolean
    article?: boolean | NewsThreadItem$articleArgs<ExtArgs>
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    tweet_id?: boolean
    parent_tweet_id?: boolean
    posted_at?: boolean
    content?: boolean
    metadata?: boolean
    position?: boolean
    article?: boolean | NewsThreadItem$articleArgs<ExtArgs>
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectScalar = {
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    tweet_id?: boolean
    parent_tweet_id?: boolean
    posted_at?: boolean
    content?: boolean
    metadata?: boolean
    position?: boolean
  }

  export type NewsThreadItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threadId" | "articleId" | "tweet_id" | "parent_tweet_id" | "posted_at" | "content" | "metadata" | "position", ExtArgs["result"]["newsThreadItem"]>
  export type NewsThreadItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsThreadItem$articleArgs<ExtArgs>
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
  }
  export type NewsThreadItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsThreadItem$articleArgs<ExtArgs>
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
  }
  export type NewsThreadItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsThreadItem$articleArgs<ExtArgs>
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
  }

  export type $NewsThreadItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsThreadItem"
    objects: {
      article: Prisma.$NewsArticlePayload<ExtArgs> | null
      thread: Prisma.$NewsThreadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      articleId: string | null
      tweet_id: string | null
      parent_tweet_id: string | null
      posted_at: Date | null
      content: string
      metadata: Prisma.JsonValue | null
      position: number
    }, ExtArgs["result"]["newsThreadItem"]>
    composites: {}
  }

  type NewsThreadItemGetPayload<S extends boolean | null | undefined | NewsThreadItemDefaultArgs> = $Result.GetResult<Prisma.$NewsThreadItemPayload, S>

  type NewsThreadItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsThreadItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsThreadItemCountAggregateInputType | true
    }

  export interface NewsThreadItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsThreadItem'], meta: { name: 'NewsThreadItem' } }
    /**
     * Find zero or one NewsThreadItem that matches the filter.
     * @param {NewsThreadItemFindUniqueArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsThreadItemFindUniqueArgs>(args: SelectSubset<T, NewsThreadItemFindUniqueArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsThreadItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsThreadItemFindUniqueOrThrowArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsThreadItemFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsThreadItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsThreadItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindFirstArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsThreadItemFindFirstArgs>(args?: SelectSubset<T, NewsThreadItemFindFirstArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsThreadItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindFirstOrThrowArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsThreadItemFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsThreadItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsThreadItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsThreadItems
     * const newsThreadItems = await prisma.newsThreadItem.findMany()
     * 
     * // Get first 10 NewsThreadItems
     * const newsThreadItems = await prisma.newsThreadItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsThreadItemFindManyArgs>(args?: SelectSubset<T, NewsThreadItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsThreadItem.
     * @param {NewsThreadItemCreateArgs} args - Arguments to create a NewsThreadItem.
     * @example
     * // Create one NewsThreadItem
     * const NewsThreadItem = await prisma.newsThreadItem.create({
     *   data: {
     *     // ... data to create a NewsThreadItem
     *   }
     * })
     * 
     */
    create<T extends NewsThreadItemCreateArgs>(args: SelectSubset<T, NewsThreadItemCreateArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsThreadItems.
     * @param {NewsThreadItemCreateManyArgs} args - Arguments to create many NewsThreadItems.
     * @example
     * // Create many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsThreadItemCreateManyArgs>(args?: SelectSubset<T, NewsThreadItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsThreadItems and returns the data saved in the database.
     * @param {NewsThreadItemCreateManyAndReturnArgs} args - Arguments to create many NewsThreadItems.
     * @example
     * // Create many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsThreadItems and only return the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsThreadItemCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsThreadItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsThreadItem.
     * @param {NewsThreadItemDeleteArgs} args - Arguments to delete one NewsThreadItem.
     * @example
     * // Delete one NewsThreadItem
     * const NewsThreadItem = await prisma.newsThreadItem.delete({
     *   where: {
     *     // ... filter to delete one NewsThreadItem
     *   }
     * })
     * 
     */
    delete<T extends NewsThreadItemDeleteArgs>(args: SelectSubset<T, NewsThreadItemDeleteArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsThreadItem.
     * @param {NewsThreadItemUpdateArgs} args - Arguments to update one NewsThreadItem.
     * @example
     * // Update one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsThreadItemUpdateArgs>(args: SelectSubset<T, NewsThreadItemUpdateArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsThreadItems.
     * @param {NewsThreadItemDeleteManyArgs} args - Arguments to filter NewsThreadItems to delete.
     * @example
     * // Delete a few NewsThreadItems
     * const { count } = await prisma.newsThreadItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsThreadItemDeleteManyArgs>(args?: SelectSubset<T, NewsThreadItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreadItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsThreadItemUpdateManyArgs>(args: SelectSubset<T, NewsThreadItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreadItems and returns the data updated in the database.
     * @param {NewsThreadItemUpdateManyAndReturnArgs} args - Arguments to update many NewsThreadItems.
     * @example
     * // Update many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsThreadItems and only return the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsThreadItemUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsThreadItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsThreadItem.
     * @param {NewsThreadItemUpsertArgs} args - Arguments to update or create a NewsThreadItem.
     * @example
     * // Update or create a NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.upsert({
     *   create: {
     *     // ... data to create a NewsThreadItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsThreadItem we want to update
     *   }
     * })
     */
    upsert<T extends NewsThreadItemUpsertArgs>(args: SelectSubset<T, NewsThreadItemUpsertArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsThreadItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemCountArgs} args - Arguments to filter NewsThreadItems to count.
     * @example
     * // Count the number of NewsThreadItems
     * const count = await prisma.newsThreadItem.count({
     *   where: {
     *     // ... the filter for the NewsThreadItems we want to count
     *   }
     * })
    **/
    count<T extends NewsThreadItemCountArgs>(
      args?: Subset<T, NewsThreadItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsThreadItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsThreadItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsThreadItemAggregateArgs>(args: Subset<T, NewsThreadItemAggregateArgs>): Prisma.PrismaPromise<GetNewsThreadItemAggregateType<T>>

    /**
     * Group by NewsThreadItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsThreadItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsThreadItemGroupByArgs['orderBy'] }
        : { orderBy?: NewsThreadItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsThreadItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsThreadItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsThreadItem model
   */
  readonly fields: NewsThreadItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsThreadItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsThreadItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends NewsThreadItem$articleArgs<ExtArgs> = {}>(args?: Subset<T, NewsThreadItem$articleArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thread<T extends NewsThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsThreadDefaultArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsThreadItem model
   */
  interface NewsThreadItemFieldRefs {
    readonly id: FieldRef<"NewsThreadItem", 'String'>
    readonly threadId: FieldRef<"NewsThreadItem", 'String'>
    readonly articleId: FieldRef<"NewsThreadItem", 'String'>
    readonly tweet_id: FieldRef<"NewsThreadItem", 'String'>
    readonly parent_tweet_id: FieldRef<"NewsThreadItem", 'String'>
    readonly posted_at: FieldRef<"NewsThreadItem", 'DateTime'>
    readonly content: FieldRef<"NewsThreadItem", 'String'>
    readonly metadata: FieldRef<"NewsThreadItem", 'Json'>
    readonly position: FieldRef<"NewsThreadItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NewsThreadItem findUnique
   */
  export type NewsThreadItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem findUniqueOrThrow
   */
  export type NewsThreadItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem findFirst
   */
  export type NewsThreadItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreadItems.
     */
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem findFirstOrThrow
   */
  export type NewsThreadItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreadItems.
     */
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem findMany
   */
  export type NewsThreadItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItems to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem create
   */
  export type NewsThreadItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsThreadItem.
     */
    data: XOR<NewsThreadItemCreateInput, NewsThreadItemUncheckedCreateInput>
  }

  /**
   * NewsThreadItem createMany
   */
  export type NewsThreadItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsThreadItems.
     */
    data: NewsThreadItemCreateManyInput | NewsThreadItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThreadItem createManyAndReturn
   */
  export type NewsThreadItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * The data used to create many NewsThreadItems.
     */
    data: NewsThreadItemCreateManyInput | NewsThreadItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsThreadItem update
   */
  export type NewsThreadItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsThreadItem.
     */
    data: XOR<NewsThreadItemUpdateInput, NewsThreadItemUncheckedUpdateInput>
    /**
     * Choose, which NewsThreadItem to update.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem updateMany
   */
  export type NewsThreadItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsThreadItems.
     */
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreadItems to update
     */
    where?: NewsThreadItemWhereInput
    /**
     * Limit how many NewsThreadItems to update.
     */
    limit?: number
  }

  /**
   * NewsThreadItem updateManyAndReturn
   */
  export type NewsThreadItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * The data used to update NewsThreadItems.
     */
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreadItems to update
     */
    where?: NewsThreadItemWhereInput
    /**
     * Limit how many NewsThreadItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsThreadItem upsert
   */
  export type NewsThreadItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsThreadItem to update in case it exists.
     */
    where: NewsThreadItemWhereUniqueInput
    /**
     * In case the NewsThreadItem found by the `where` argument doesn't exist, create a new NewsThreadItem with this data.
     */
    create: XOR<NewsThreadItemCreateInput, NewsThreadItemUncheckedCreateInput>
    /**
     * In case the NewsThreadItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsThreadItemUpdateInput, NewsThreadItemUncheckedUpdateInput>
  }

  /**
   * NewsThreadItem delete
   */
  export type NewsThreadItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter which NewsThreadItem to delete.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem deleteMany
   */
  export type NewsThreadItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreadItems to delete
     */
    where?: NewsThreadItemWhereInput
    /**
     * Limit how many NewsThreadItems to delete.
     */
    limit?: number
  }

  /**
   * NewsThreadItem.article
   */
  export type NewsThreadItem$articleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsArticle
     */
    omit?: NewsArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    where?: NewsArticleWhereInput
  }

  /**
   * NewsThreadItem without action
   */
  export type NewsThreadItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsThreadItem
     */
    omit?: NewsThreadItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
  }


  /**
   * Model NewsAnalysis
   */

  export type AggregateNewsAnalysis = {
    _count: NewsAnalysisCountAggregateOutputType | null
    _min: NewsAnalysisMinAggregateOutputType | null
    _max: NewsAnalysisMaxAggregateOutputType | null
  }

  export type NewsAnalysisMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    category: string | null
    summary: string | null
    japanese_summary: string | null
    impact: string | null
    analyzed_by: string | null
    createdAt: Date | null
    updated_at: Date | null
  }

  export type NewsAnalysisMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    category: string | null
    summary: string | null
    japanese_summary: string | null
    impact: string | null
    analyzed_by: string | null
    createdAt: Date | null
    updated_at: Date | null
  }

  export type NewsAnalysisCountAggregateOutputType = {
    id: number
    articleId: number
    category: number
    summary: number
    japanese_summary: number
    key_points: number
    impact: number
    analyzed_by: number
    createdAt: number
    updated_at: number
    _all: number
  }


  export type NewsAnalysisMinAggregateInputType = {
    id?: true
    articleId?: true
    category?: true
    summary?: true
    japanese_summary?: true
    impact?: true
    analyzed_by?: true
    createdAt?: true
    updated_at?: true
  }

  export type NewsAnalysisMaxAggregateInputType = {
    id?: true
    articleId?: true
    category?: true
    summary?: true
    japanese_summary?: true
    impact?: true
    analyzed_by?: true
    createdAt?: true
    updated_at?: true
  }

  export type NewsAnalysisCountAggregateInputType = {
    id?: true
    articleId?: true
    category?: true
    summary?: true
    japanese_summary?: true
    key_points?: true
    impact?: true
    analyzed_by?: true
    createdAt?: true
    updated_at?: true
    _all?: true
  }

  export type NewsAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsAnalysis to aggregate.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsAnalyses
    **/
    _count?: true | NewsAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsAnalysisMaxAggregateInputType
  }

  export type GetNewsAnalysisAggregateType<T extends NewsAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsAnalysis[P]>
      : GetScalarType<T[P], AggregateNewsAnalysis[P]>
  }




  export type NewsAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsAnalysisWhereInput
    orderBy?: NewsAnalysisOrderByWithAggregationInput | NewsAnalysisOrderByWithAggregationInput[]
    by: NewsAnalysisScalarFieldEnum[] | NewsAnalysisScalarFieldEnum
    having?: NewsAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsAnalysisCountAggregateInputType | true
    _min?: NewsAnalysisMinAggregateInputType
    _max?: NewsAnalysisMaxAggregateInputType
  }

  export type NewsAnalysisGroupByOutputType = {
    id: string
    articleId: string
    category: string
    summary: string
    japanese_summary: string
    key_points: string[]
    impact: string
    analyzed_by: string
    createdAt: Date
    updated_at: Date
    _count: NewsAnalysisCountAggregateOutputType | null
    _min: NewsAnalysisMinAggregateOutputType | null
    _max: NewsAnalysisMaxAggregateOutputType | null
  }

  type GetNewsAnalysisGroupByPayload<T extends NewsAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], NewsAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type NewsAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    category?: boolean
    summary?: boolean
    japanese_summary?: boolean
    key_points?: boolean
    impact?: boolean
    analyzed_by?: boolean
    createdAt?: boolean
    updated_at?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    category?: boolean
    summary?: boolean
    japanese_summary?: boolean
    key_points?: boolean
    impact?: boolean
    analyzed_by?: boolean
    createdAt?: boolean
    updated_at?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    category?: boolean
    summary?: boolean
    japanese_summary?: boolean
    key_points?: boolean
    impact?: boolean
    analyzed_by?: boolean
    createdAt?: boolean
    updated_at?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectScalar = {
    id?: boolean
    articleId?: boolean
    category?: boolean
    summary?: boolean
    japanese_summary?: boolean
    key_points?: boolean
    impact?: boolean
    analyzed_by?: boolean
    createdAt?: boolean
    updated_at?: boolean
  }

  export type NewsAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "articleId" | "category" | "summary" | "japanese_summary" | "key_points" | "impact" | "analyzed_by" | "createdAt" | "updated_at", ExtArgs["result"]["newsAnalysis"]>
  export type NewsAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }
  export type NewsAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }
  export type NewsAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }

  export type $NewsAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsAnalysis"
    objects: {
      article: Prisma.$NewsArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      category: string
      summary: string
      japanese_summary: string
      key_points: string[]
      impact: string
      analyzed_by: string
      createdAt: Date
      updated_at: Date
    }, ExtArgs["result"]["newsAnalysis"]>
    composites: {}
  }

  type NewsAnalysisGetPayload<S extends boolean | null | undefined | NewsAnalysisDefaultArgs> = $Result.GetResult<Prisma.$NewsAnalysisPayload, S>

  type NewsAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsAnalysisCountAggregateInputType | true
    }

  export interface NewsAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsAnalysis'], meta: { name: 'NewsAnalysis' } }
    /**
     * Find zero or one NewsAnalysis that matches the filter.
     * @param {NewsAnalysisFindUniqueArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsAnalysisFindUniqueArgs>(args: SelectSubset<T, NewsAnalysisFindUniqueArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsAnalysisFindUniqueOrThrowArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindFirstArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsAnalysisFindFirstArgs>(args?: SelectSubset<T, NewsAnalysisFindFirstArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindFirstOrThrowArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsAnalyses
     * const newsAnalyses = await prisma.newsAnalysis.findMany()
     * 
     * // Get first 10 NewsAnalyses
     * const newsAnalyses = await prisma.newsAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsAnalysisFindManyArgs>(args?: SelectSubset<T, NewsAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsAnalysis.
     * @param {NewsAnalysisCreateArgs} args - Arguments to create a NewsAnalysis.
     * @example
     * // Create one NewsAnalysis
     * const NewsAnalysis = await prisma.newsAnalysis.create({
     *   data: {
     *     // ... data to create a NewsAnalysis
     *   }
     * })
     * 
     */
    create<T extends NewsAnalysisCreateArgs>(args: SelectSubset<T, NewsAnalysisCreateArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsAnalyses.
     * @param {NewsAnalysisCreateManyArgs} args - Arguments to create many NewsAnalyses.
     * @example
     * // Create many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsAnalysisCreateManyArgs>(args?: SelectSubset<T, NewsAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsAnalyses and returns the data saved in the database.
     * @param {NewsAnalysisCreateManyAndReturnArgs} args - Arguments to create many NewsAnalyses.
     * @example
     * // Create many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsAnalyses and only return the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsAnalysis.
     * @param {NewsAnalysisDeleteArgs} args - Arguments to delete one NewsAnalysis.
     * @example
     * // Delete one NewsAnalysis
     * const NewsAnalysis = await prisma.newsAnalysis.delete({
     *   where: {
     *     // ... filter to delete one NewsAnalysis
     *   }
     * })
     * 
     */
    delete<T extends NewsAnalysisDeleteArgs>(args: SelectSubset<T, NewsAnalysisDeleteArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsAnalysis.
     * @param {NewsAnalysisUpdateArgs} args - Arguments to update one NewsAnalysis.
     * @example
     * // Update one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsAnalysisUpdateArgs>(args: SelectSubset<T, NewsAnalysisUpdateArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsAnalyses.
     * @param {NewsAnalysisDeleteManyArgs} args - Arguments to filter NewsAnalyses to delete.
     * @example
     * // Delete a few NewsAnalyses
     * const { count } = await prisma.newsAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsAnalysisDeleteManyArgs>(args?: SelectSubset<T, NewsAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsAnalysisUpdateManyArgs>(args: SelectSubset<T, NewsAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsAnalyses and returns the data updated in the database.
     * @param {NewsAnalysisUpdateManyAndReturnArgs} args - Arguments to update many NewsAnalyses.
     * @example
     * // Update many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsAnalyses and only return the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsAnalysis.
     * @param {NewsAnalysisUpsertArgs} args - Arguments to update or create a NewsAnalysis.
     * @example
     * // Update or create a NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.upsert({
     *   create: {
     *     // ... data to create a NewsAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends NewsAnalysisUpsertArgs>(args: SelectSubset<T, NewsAnalysisUpsertArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisCountArgs} args - Arguments to filter NewsAnalyses to count.
     * @example
     * // Count the number of NewsAnalyses
     * const count = await prisma.newsAnalysis.count({
     *   where: {
     *     // ... the filter for the NewsAnalyses we want to count
     *   }
     * })
    **/
    count<T extends NewsAnalysisCountArgs>(
      args?: Subset<T, NewsAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAnalysisAggregateArgs>(args: Subset<T, NewsAnalysisAggregateArgs>): Prisma.PrismaPromise<GetNewsAnalysisAggregateType<T>>

    /**
     * Group by NewsAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: NewsAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsAnalysis model
   */
  readonly fields: NewsAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsAnalysis model
   */
  interface NewsAnalysisFieldRefs {
    readonly id: FieldRef<"NewsAnalysis", 'String'>
    readonly articleId: FieldRef<"NewsAnalysis", 'String'>
    readonly category: FieldRef<"NewsAnalysis", 'String'>
    readonly summary: FieldRef<"NewsAnalysis", 'String'>
    readonly japanese_summary: FieldRef<"NewsAnalysis", 'String'>
    readonly key_points: FieldRef<"NewsAnalysis", 'String[]'>
    readonly impact: FieldRef<"NewsAnalysis", 'String'>
    readonly analyzed_by: FieldRef<"NewsAnalysis", 'String'>
    readonly createdAt: FieldRef<"NewsAnalysis", 'DateTime'>
    readonly updated_at: FieldRef<"NewsAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsAnalysis findUnique
   */
  export type NewsAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis findUniqueOrThrow
   */
  export type NewsAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis findFirst
   */
  export type NewsAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsAnalyses.
     */
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis findFirstOrThrow
   */
  export type NewsAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsAnalyses.
     */
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis findMany
   */
  export type NewsAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalyses to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis create
   */
  export type NewsAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsAnalysis.
     */
    data: XOR<NewsAnalysisCreateInput, NewsAnalysisUncheckedCreateInput>
  }

  /**
   * NewsAnalysis createMany
   */
  export type NewsAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsAnalyses.
     */
    data: NewsAnalysisCreateManyInput | NewsAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsAnalysis createManyAndReturn
   */
  export type NewsAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many NewsAnalyses.
     */
    data: NewsAnalysisCreateManyInput | NewsAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsAnalysis update
   */
  export type NewsAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsAnalysis.
     */
    data: XOR<NewsAnalysisUpdateInput, NewsAnalysisUncheckedUpdateInput>
    /**
     * Choose, which NewsAnalysis to update.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis updateMany
   */
  export type NewsAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsAnalyses.
     */
    data: XOR<NewsAnalysisUpdateManyMutationInput, NewsAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which NewsAnalyses to update
     */
    where?: NewsAnalysisWhereInput
    /**
     * Limit how many NewsAnalyses to update.
     */
    limit?: number
  }

  /**
   * NewsAnalysis updateManyAndReturn
   */
  export type NewsAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update NewsAnalyses.
     */
    data: XOR<NewsAnalysisUpdateManyMutationInput, NewsAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which NewsAnalyses to update
     */
    where?: NewsAnalysisWhereInput
    /**
     * Limit how many NewsAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsAnalysis upsert
   */
  export type NewsAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsAnalysis to update in case it exists.
     */
    where: NewsAnalysisWhereUniqueInput
    /**
     * In case the NewsAnalysis found by the `where` argument doesn't exist, create a new NewsAnalysis with this data.
     */
    create: XOR<NewsAnalysisCreateInput, NewsAnalysisUncheckedCreateInput>
    /**
     * In case the NewsAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsAnalysisUpdateInput, NewsAnalysisUncheckedUpdateInput>
  }

  /**
   * NewsAnalysis delete
   */
  export type NewsAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter which NewsAnalysis to delete.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis deleteMany
   */
  export type NewsAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsAnalyses to delete
     */
    where?: NewsAnalysisWhereInput
    /**
     * Limit how many NewsAnalyses to delete.
     */
    limit?: number
  }

  /**
   * NewsAnalysis without action
   */
  export type NewsAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsAnalysis
     */
    omit?: NewsAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model JobQueue
   */

  export type AggregateJobQueue = {
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  export type JobQueueAvgAggregateOutputType = {
    progress: number | null
    total: number | null
  }

  export type JobQueueSumAggregateOutputType = {
    progress: number | null
    total: number | null
  }

  export type JobQueueMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    error: string | null
    progress: number | null
    total: number | null
    started_at: Date | null
    ended_at: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobQueueMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    error: string | null
    progress: number | null
    total: number | null
    started_at: Date | null
    ended_at: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobQueueCountAggregateOutputType = {
    id: number
    type: number
    status: number
    payload: number
    result: number
    error: number
    progress: number
    total: number
    started_at: number
    ended_at: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobQueueAvgAggregateInputType = {
    progress?: true
    total?: true
  }

  export type JobQueueSumAggregateInputType = {
    progress?: true
    total?: true
  }

  export type JobQueueMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    error?: true
    progress?: true
    total?: true
    started_at?: true
    ended_at?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobQueueMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    error?: true
    progress?: true
    total?: true
    started_at?: true
    ended_at?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobQueueCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    payload?: true
    result?: true
    error?: true
    progress?: true
    total?: true
    started_at?: true
    ended_at?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueue to aggregate.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobQueues
    **/
    _count?: true | JobQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobQueueMaxAggregateInputType
  }

  export type GetJobQueueAggregateType<T extends JobQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateJobQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobQueue[P]>
      : GetScalarType<T[P], AggregateJobQueue[P]>
  }




  export type JobQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobQueueWhereInput
    orderBy?: JobQueueOrderByWithAggregationInput | JobQueueOrderByWithAggregationInput[]
    by: JobQueueScalarFieldEnum[] | JobQueueScalarFieldEnum
    having?: JobQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobQueueCountAggregateInputType | true
    _avg?: JobQueueAvgAggregateInputType
    _sum?: JobQueueSumAggregateInputType
    _min?: JobQueueMinAggregateInputType
    _max?: JobQueueMaxAggregateInputType
  }

  export type JobQueueGroupByOutputType = {
    id: string
    type: string
    status: string
    payload: JsonValue | null
    result: JsonValue | null
    error: string | null
    progress: number
    total: number | null
    started_at: Date | null
    ended_at: Date | null
    createdAt: Date
    updatedAt: Date
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  type GetJobQueueGroupByPayload<T extends JobQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
            : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
        }
      >
    >


  export type JobQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    progress?: boolean
    total?: boolean
    started_at?: boolean
    ended_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    progress?: boolean
    total?: boolean
    started_at?: boolean
    ended_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    progress?: boolean
    total?: boolean
    started_at?: boolean
    ended_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    progress?: boolean
    total?: boolean
    started_at?: boolean
    ended_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "payload" | "result" | "error" | "progress" | "total" | "started_at" | "ended_at" | "createdAt" | "updatedAt", ExtArgs["result"]["jobQueue"]>

  export type $JobQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      status: string
      payload: Prisma.JsonValue | null
      result: Prisma.JsonValue | null
      error: string | null
      progress: number
      total: number | null
      started_at: Date | null
      ended_at: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobQueue"]>
    composites: {}
  }

  type JobQueueGetPayload<S extends boolean | null | undefined | JobQueueDefaultArgs> = $Result.GetResult<Prisma.$JobQueuePayload, S>

  type JobQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobQueueCountAggregateInputType | true
    }

  export interface JobQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobQueue'], meta: { name: 'JobQueue' } }
    /**
     * Find zero or one JobQueue that matches the filter.
     * @param {JobQueueFindUniqueArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobQueueFindUniqueArgs>(args: SelectSubset<T, JobQueueFindUniqueArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobQueueFindUniqueOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, JobQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobQueueFindFirstArgs>(args?: SelectSubset<T, JobQueueFindFirstArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, JobQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobQueues
     * const jobQueues = await prisma.jobQueue.findMany()
     * 
     * // Get first 10 JobQueues
     * const jobQueues = await prisma.jobQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobQueueFindManyArgs>(args?: SelectSubset<T, JobQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobQueue.
     * @param {JobQueueCreateArgs} args - Arguments to create a JobQueue.
     * @example
     * // Create one JobQueue
     * const JobQueue = await prisma.jobQueue.create({
     *   data: {
     *     // ... data to create a JobQueue
     *   }
     * })
     * 
     */
    create<T extends JobQueueCreateArgs>(args: SelectSubset<T, JobQueueCreateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobQueues.
     * @param {JobQueueCreateManyArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobQueueCreateManyArgs>(args?: SelectSubset<T, JobQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobQueues and returns the data saved in the database.
     * @param {JobQueueCreateManyAndReturnArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobQueues and only return the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, JobQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobQueue.
     * @param {JobQueueDeleteArgs} args - Arguments to delete one JobQueue.
     * @example
     * // Delete one JobQueue
     * const JobQueue = await prisma.jobQueue.delete({
     *   where: {
     *     // ... filter to delete one JobQueue
     *   }
     * })
     * 
     */
    delete<T extends JobQueueDeleteArgs>(args: SelectSubset<T, JobQueueDeleteArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobQueue.
     * @param {JobQueueUpdateArgs} args - Arguments to update one JobQueue.
     * @example
     * // Update one JobQueue
     * const jobQueue = await prisma.jobQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobQueueUpdateArgs>(args: SelectSubset<T, JobQueueUpdateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobQueues.
     * @param {JobQueueDeleteManyArgs} args - Arguments to filter JobQueues to delete.
     * @example
     * // Delete a few JobQueues
     * const { count } = await prisma.jobQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobQueueDeleteManyArgs>(args?: SelectSubset<T, JobQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobQueues
     * const jobQueue = await prisma.jobQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobQueueUpdateManyArgs>(args: SelectSubset<T, JobQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobQueues and returns the data updated in the database.
     * @param {JobQueueUpdateManyAndReturnArgs} args - Arguments to update many JobQueues.
     * @example
     * // Update many JobQueues
     * const jobQueue = await prisma.jobQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobQueues and only return the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, JobQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobQueue.
     * @param {JobQueueUpsertArgs} args - Arguments to update or create a JobQueue.
     * @example
     * // Update or create a JobQueue
     * const jobQueue = await prisma.jobQueue.upsert({
     *   create: {
     *     // ... data to create a JobQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobQueue we want to update
     *   }
     * })
     */
    upsert<T extends JobQueueUpsertArgs>(args: SelectSubset<T, JobQueueUpsertArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueCountArgs} args - Arguments to filter JobQueues to count.
     * @example
     * // Count the number of JobQueues
     * const count = await prisma.jobQueue.count({
     *   where: {
     *     // ... the filter for the JobQueues we want to count
     *   }
     * })
    **/
    count<T extends JobQueueCountArgs>(
      args?: Subset<T, JobQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobQueueAggregateArgs>(args: Subset<T, JobQueueAggregateArgs>): Prisma.PrismaPromise<GetJobQueueAggregateType<T>>

    /**
     * Group by JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobQueueGroupByArgs['orderBy'] }
        : { orderBy?: JobQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobQueue model
   */
  readonly fields: JobQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobQueue model
   */
  interface JobQueueFieldRefs {
    readonly id: FieldRef<"JobQueue", 'String'>
    readonly type: FieldRef<"JobQueue", 'String'>
    readonly status: FieldRef<"JobQueue", 'String'>
    readonly payload: FieldRef<"JobQueue", 'Json'>
    readonly result: FieldRef<"JobQueue", 'Json'>
    readonly error: FieldRef<"JobQueue", 'String'>
    readonly progress: FieldRef<"JobQueue", 'Int'>
    readonly total: FieldRef<"JobQueue", 'Int'>
    readonly started_at: FieldRef<"JobQueue", 'DateTime'>
    readonly ended_at: FieldRef<"JobQueue", 'DateTime'>
    readonly createdAt: FieldRef<"JobQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"JobQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobQueue findUnique
   */
  export type JobQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findUniqueOrThrow
   */
  export type JobQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findFirst
   */
  export type JobQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findFirstOrThrow
   */
  export type JobQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findMany
   */
  export type JobQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueues to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue create
   */
  export type JobQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a JobQueue.
     */
    data: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
  }

  /**
   * JobQueue createMany
   */
  export type JobQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue createManyAndReturn
   */
  export type JobQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue update
   */
  export type JobQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a JobQueue.
     */
    data: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
    /**
     * Choose, which JobQueue to update.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue updateMany
   */
  export type JobQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobQueues.
     */
    data: XOR<JobQueueUpdateManyMutationInput, JobQueueUncheckedUpdateManyInput>
    /**
     * Filter which JobQueues to update
     */
    where?: JobQueueWhereInput
    /**
     * Limit how many JobQueues to update.
     */
    limit?: number
  }

  /**
   * JobQueue updateManyAndReturn
   */
  export type JobQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data used to update JobQueues.
     */
    data: XOR<JobQueueUpdateManyMutationInput, JobQueueUncheckedUpdateManyInput>
    /**
     * Filter which JobQueues to update
     */
    where?: JobQueueWhereInput
    /**
     * Limit how many JobQueues to update.
     */
    limit?: number
  }

  /**
   * JobQueue upsert
   */
  export type JobQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the JobQueue to update in case it exists.
     */
    where: JobQueueWhereUniqueInput
    /**
     * In case the JobQueue found by the `where` argument doesn't exist, create a new JobQueue with this data.
     */
    create: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
    /**
     * In case the JobQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
  }

  /**
   * JobQueue delete
   */
  export type JobQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter which JobQueue to delete.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue deleteMany
   */
  export type JobQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueues to delete
     */
    where?: JobQueueWhereInput
    /**
     * Limit how many JobQueues to delete.
     */
    limit?: number
  }

  /**
   * JobQueue without action
   */
  export type JobQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
  }


  /**
   * Model ApiTask
   */

  export type AggregateApiTask = {
    _count: ApiTaskCountAggregateOutputType | null
    _avg: ApiTaskAvgAggregateOutputType | null
    _sum: ApiTaskSumAggregateOutputType | null
    _min: ApiTaskMinAggregateOutputType | null
    _max: ApiTaskMaxAggregateOutputType | null
  }

  export type ApiTaskAvgAggregateOutputType = {
    phase_number: number | null
    retry_count: number | null
  }

  export type ApiTaskSumAggregateOutputType = {
    phase_number: number | null
    retry_count: number | null
  }

  export type ApiTaskMinAggregateOutputType = {
    id: string | null
    type: string | null
    sessionId: string | null
    phase_number: number | null
    step_name: string | null
    status: string | null
    retry_count: number | null
    error: string | null
    createdAt: Date | null
    started_at: Date | null
    completed_at: Date | null
    taskType: string | null
  }

  export type ApiTaskMaxAggregateOutputType = {
    id: string | null
    type: string | null
    sessionId: string | null
    phase_number: number | null
    step_name: string | null
    status: string | null
    retry_count: number | null
    error: string | null
    createdAt: Date | null
    started_at: Date | null
    completed_at: Date | null
    taskType: string | null
  }

  export type ApiTaskCountAggregateOutputType = {
    id: number
    type: number
    sessionId: number
    phase_number: number
    step_name: number
    request: number
    status: number
    retry_count: number
    response: number
    error: number
    createdAt: number
    started_at: number
    completed_at: number
    taskType: number
    _all: number
  }


  export type ApiTaskAvgAggregateInputType = {
    phase_number?: true
    retry_count?: true
  }

  export type ApiTaskSumAggregateInputType = {
    phase_number?: true
    retry_count?: true
  }

  export type ApiTaskMinAggregateInputType = {
    id?: true
    type?: true
    sessionId?: true
    phase_number?: true
    step_name?: true
    status?: true
    retry_count?: true
    error?: true
    createdAt?: true
    started_at?: true
    completed_at?: true
    taskType?: true
  }

  export type ApiTaskMaxAggregateInputType = {
    id?: true
    type?: true
    sessionId?: true
    phase_number?: true
    step_name?: true
    status?: true
    retry_count?: true
    error?: true
    createdAt?: true
    started_at?: true
    completed_at?: true
    taskType?: true
  }

  export type ApiTaskCountAggregateInputType = {
    id?: true
    type?: true
    sessionId?: true
    phase_number?: true
    step_name?: true
    request?: true
    status?: true
    retry_count?: true
    response?: true
    error?: true
    createdAt?: true
    started_at?: true
    completed_at?: true
    taskType?: true
    _all?: true
  }

  export type ApiTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiTask to aggregate.
     */
    where?: ApiTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTasks to fetch.
     */
    orderBy?: ApiTaskOrderByWithRelationInput | ApiTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiTasks
    **/
    _count?: true | ApiTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiTaskMaxAggregateInputType
  }

  export type GetApiTaskAggregateType<T extends ApiTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateApiTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiTask[P]>
      : GetScalarType<T[P], AggregateApiTask[P]>
  }




  export type ApiTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiTaskWhereInput
    orderBy?: ApiTaskOrderByWithAggregationInput | ApiTaskOrderByWithAggregationInput[]
    by: ApiTaskScalarFieldEnum[] | ApiTaskScalarFieldEnum
    having?: ApiTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiTaskCountAggregateInputType | true
    _avg?: ApiTaskAvgAggregateInputType
    _sum?: ApiTaskSumAggregateInputType
    _min?: ApiTaskMinAggregateInputType
    _max?: ApiTaskMaxAggregateInputType
  }

  export type ApiTaskGroupByOutputType = {
    id: string
    type: string
    sessionId: string
    phase_number: number
    step_name: string
    request: JsonValue
    status: string
    retry_count: number
    response: JsonValue | null
    error: string | null
    createdAt: Date
    started_at: Date | null
    completed_at: Date | null
    taskType: string
    _count: ApiTaskCountAggregateOutputType | null
    _avg: ApiTaskAvgAggregateOutputType | null
    _sum: ApiTaskSumAggregateOutputType | null
    _min: ApiTaskMinAggregateOutputType | null
    _max: ApiTaskMaxAggregateOutputType | null
  }

  type GetApiTaskGroupByPayload<T extends ApiTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ApiTaskGroupByOutputType[P]>
        }
      >
    >


  export type ApiTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sessionId?: boolean
    phase_number?: boolean
    step_name?: boolean
    request?: boolean
    status?: boolean
    retry_count?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
    started_at?: boolean
    completed_at?: boolean
    taskType?: boolean
  }, ExtArgs["result"]["apiTask"]>

  export type ApiTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sessionId?: boolean
    phase_number?: boolean
    step_name?: boolean
    request?: boolean
    status?: boolean
    retry_count?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
    started_at?: boolean
    completed_at?: boolean
    taskType?: boolean
  }, ExtArgs["result"]["apiTask"]>

  export type ApiTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sessionId?: boolean
    phase_number?: boolean
    step_name?: boolean
    request?: boolean
    status?: boolean
    retry_count?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
    started_at?: boolean
    completed_at?: boolean
    taskType?: boolean
  }, ExtArgs["result"]["apiTask"]>

  export type ApiTaskSelectScalar = {
    id?: boolean
    type?: boolean
    sessionId?: boolean
    phase_number?: boolean
    step_name?: boolean
    request?: boolean
    status?: boolean
    retry_count?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
    started_at?: boolean
    completed_at?: boolean
    taskType?: boolean
  }

  export type ApiTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "sessionId" | "phase_number" | "step_name" | "request" | "status" | "retry_count" | "response" | "error" | "createdAt" | "started_at" | "completed_at" | "taskType", ExtArgs["result"]["apiTask"]>

  export type $ApiTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiTask"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      sessionId: string
      phase_number: number
      step_name: string
      request: Prisma.JsonValue
      status: string
      retry_count: number
      response: Prisma.JsonValue | null
      error: string | null
      createdAt: Date
      started_at: Date | null
      completed_at: Date | null
      taskType: string
    }, ExtArgs["result"]["apiTask"]>
    composites: {}
  }

  type ApiTaskGetPayload<S extends boolean | null | undefined | ApiTaskDefaultArgs> = $Result.GetResult<Prisma.$ApiTaskPayload, S>

  type ApiTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiTaskCountAggregateInputType | true
    }

  export interface ApiTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiTask'], meta: { name: 'ApiTask' } }
    /**
     * Find zero or one ApiTask that matches the filter.
     * @param {ApiTaskFindUniqueArgs} args - Arguments to find a ApiTask
     * @example
     * // Get one ApiTask
     * const apiTask = await prisma.apiTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiTaskFindUniqueArgs>(args: SelectSubset<T, ApiTaskFindUniqueArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiTaskFindUniqueOrThrowArgs} args - Arguments to find a ApiTask
     * @example
     * // Get one ApiTask
     * const apiTask = await prisma.apiTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskFindFirstArgs} args - Arguments to find a ApiTask
     * @example
     * // Get one ApiTask
     * const apiTask = await prisma.apiTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiTaskFindFirstArgs>(args?: SelectSubset<T, ApiTaskFindFirstArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskFindFirstOrThrowArgs} args - Arguments to find a ApiTask
     * @example
     * // Get one ApiTask
     * const apiTask = await prisma.apiTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiTasks
     * const apiTasks = await prisma.apiTask.findMany()
     * 
     * // Get first 10 ApiTasks
     * const apiTasks = await prisma.apiTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiTaskWithIdOnly = await prisma.apiTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiTaskFindManyArgs>(args?: SelectSubset<T, ApiTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiTask.
     * @param {ApiTaskCreateArgs} args - Arguments to create a ApiTask.
     * @example
     * // Create one ApiTask
     * const ApiTask = await prisma.apiTask.create({
     *   data: {
     *     // ... data to create a ApiTask
     *   }
     * })
     * 
     */
    create<T extends ApiTaskCreateArgs>(args: SelectSubset<T, ApiTaskCreateArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiTasks.
     * @param {ApiTaskCreateManyArgs} args - Arguments to create many ApiTasks.
     * @example
     * // Create many ApiTasks
     * const apiTask = await prisma.apiTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiTaskCreateManyArgs>(args?: SelectSubset<T, ApiTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiTasks and returns the data saved in the database.
     * @param {ApiTaskCreateManyAndReturnArgs} args - Arguments to create many ApiTasks.
     * @example
     * // Create many ApiTasks
     * const apiTask = await prisma.apiTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiTasks and only return the `id`
     * const apiTaskWithIdOnly = await prisma.apiTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiTask.
     * @param {ApiTaskDeleteArgs} args - Arguments to delete one ApiTask.
     * @example
     * // Delete one ApiTask
     * const ApiTask = await prisma.apiTask.delete({
     *   where: {
     *     // ... filter to delete one ApiTask
     *   }
     * })
     * 
     */
    delete<T extends ApiTaskDeleteArgs>(args: SelectSubset<T, ApiTaskDeleteArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiTask.
     * @param {ApiTaskUpdateArgs} args - Arguments to update one ApiTask.
     * @example
     * // Update one ApiTask
     * const apiTask = await prisma.apiTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiTaskUpdateArgs>(args: SelectSubset<T, ApiTaskUpdateArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiTasks.
     * @param {ApiTaskDeleteManyArgs} args - Arguments to filter ApiTasks to delete.
     * @example
     * // Delete a few ApiTasks
     * const { count } = await prisma.apiTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiTaskDeleteManyArgs>(args?: SelectSubset<T, ApiTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiTasks
     * const apiTask = await prisma.apiTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiTaskUpdateManyArgs>(args: SelectSubset<T, ApiTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiTasks and returns the data updated in the database.
     * @param {ApiTaskUpdateManyAndReturnArgs} args - Arguments to update many ApiTasks.
     * @example
     * // Update many ApiTasks
     * const apiTask = await prisma.apiTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiTasks and only return the `id`
     * const apiTaskWithIdOnly = await prisma.apiTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiTask.
     * @param {ApiTaskUpsertArgs} args - Arguments to update or create a ApiTask.
     * @example
     * // Update or create a ApiTask
     * const apiTask = await prisma.apiTask.upsert({
     *   create: {
     *     // ... data to create a ApiTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiTask we want to update
     *   }
     * })
     */
    upsert<T extends ApiTaskUpsertArgs>(args: SelectSubset<T, ApiTaskUpsertArgs<ExtArgs>>): Prisma__ApiTaskClient<$Result.GetResult<Prisma.$ApiTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskCountArgs} args - Arguments to filter ApiTasks to count.
     * @example
     * // Count the number of ApiTasks
     * const count = await prisma.apiTask.count({
     *   where: {
     *     // ... the filter for the ApiTasks we want to count
     *   }
     * })
    **/
    count<T extends ApiTaskCountArgs>(
      args?: Subset<T, ApiTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiTaskAggregateArgs>(args: Subset<T, ApiTaskAggregateArgs>): Prisma.PrismaPromise<GetApiTaskAggregateType<T>>

    /**
     * Group by ApiTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiTaskGroupByArgs['orderBy'] }
        : { orderBy?: ApiTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiTask model
   */
  readonly fields: ApiTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiTask model
   */
  interface ApiTaskFieldRefs {
    readonly id: FieldRef<"ApiTask", 'String'>
    readonly type: FieldRef<"ApiTask", 'String'>
    readonly sessionId: FieldRef<"ApiTask", 'String'>
    readonly phase_number: FieldRef<"ApiTask", 'Int'>
    readonly step_name: FieldRef<"ApiTask", 'String'>
    readonly request: FieldRef<"ApiTask", 'Json'>
    readonly status: FieldRef<"ApiTask", 'String'>
    readonly retry_count: FieldRef<"ApiTask", 'Int'>
    readonly response: FieldRef<"ApiTask", 'Json'>
    readonly error: FieldRef<"ApiTask", 'String'>
    readonly createdAt: FieldRef<"ApiTask", 'DateTime'>
    readonly started_at: FieldRef<"ApiTask", 'DateTime'>
    readonly completed_at: FieldRef<"ApiTask", 'DateTime'>
    readonly taskType: FieldRef<"ApiTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiTask findUnique
   */
  export type ApiTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * Filter, which ApiTask to fetch.
     */
    where: ApiTaskWhereUniqueInput
  }

  /**
   * ApiTask findUniqueOrThrow
   */
  export type ApiTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * Filter, which ApiTask to fetch.
     */
    where: ApiTaskWhereUniqueInput
  }

  /**
   * ApiTask findFirst
   */
  export type ApiTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * Filter, which ApiTask to fetch.
     */
    where?: ApiTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTasks to fetch.
     */
    orderBy?: ApiTaskOrderByWithRelationInput | ApiTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiTasks.
     */
    cursor?: ApiTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiTasks.
     */
    distinct?: ApiTaskScalarFieldEnum | ApiTaskScalarFieldEnum[]
  }

  /**
   * ApiTask findFirstOrThrow
   */
  export type ApiTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * Filter, which ApiTask to fetch.
     */
    where?: ApiTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTasks to fetch.
     */
    orderBy?: ApiTaskOrderByWithRelationInput | ApiTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiTasks.
     */
    cursor?: ApiTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiTasks.
     */
    distinct?: ApiTaskScalarFieldEnum | ApiTaskScalarFieldEnum[]
  }

  /**
   * ApiTask findMany
   */
  export type ApiTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * Filter, which ApiTasks to fetch.
     */
    where?: ApiTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTasks to fetch.
     */
    orderBy?: ApiTaskOrderByWithRelationInput | ApiTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiTasks.
     */
    cursor?: ApiTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTasks.
     */
    skip?: number
    distinct?: ApiTaskScalarFieldEnum | ApiTaskScalarFieldEnum[]
  }

  /**
   * ApiTask create
   */
  export type ApiTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiTask.
     */
    data: XOR<ApiTaskCreateInput, ApiTaskUncheckedCreateInput>
  }

  /**
   * ApiTask createMany
   */
  export type ApiTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiTasks.
     */
    data: ApiTaskCreateManyInput | ApiTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiTask createManyAndReturn
   */
  export type ApiTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * The data used to create many ApiTasks.
     */
    data: ApiTaskCreateManyInput | ApiTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiTask update
   */
  export type ApiTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiTask.
     */
    data: XOR<ApiTaskUpdateInput, ApiTaskUncheckedUpdateInput>
    /**
     * Choose, which ApiTask to update.
     */
    where: ApiTaskWhereUniqueInput
  }

  /**
   * ApiTask updateMany
   */
  export type ApiTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiTasks.
     */
    data: XOR<ApiTaskUpdateManyMutationInput, ApiTaskUncheckedUpdateManyInput>
    /**
     * Filter which ApiTasks to update
     */
    where?: ApiTaskWhereInput
    /**
     * Limit how many ApiTasks to update.
     */
    limit?: number
  }

  /**
   * ApiTask updateManyAndReturn
   */
  export type ApiTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * The data used to update ApiTasks.
     */
    data: XOR<ApiTaskUpdateManyMutationInput, ApiTaskUncheckedUpdateManyInput>
    /**
     * Filter which ApiTasks to update
     */
    where?: ApiTaskWhereInput
    /**
     * Limit how many ApiTasks to update.
     */
    limit?: number
  }

  /**
   * ApiTask upsert
   */
  export type ApiTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiTask to update in case it exists.
     */
    where: ApiTaskWhereUniqueInput
    /**
     * In case the ApiTask found by the `where` argument doesn't exist, create a new ApiTask with this data.
     */
    create: XOR<ApiTaskCreateInput, ApiTaskUncheckedCreateInput>
    /**
     * In case the ApiTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiTaskUpdateInput, ApiTaskUncheckedUpdateInput>
  }

  /**
   * ApiTask delete
   */
  export type ApiTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
    /**
     * Filter which ApiTask to delete.
     */
    where: ApiTaskWhereUniqueInput
  }

  /**
   * ApiTask deleteMany
   */
  export type ApiTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiTasks to delete
     */
    where?: ApiTaskWhereInput
    /**
     * Limit how many ApiTasks to delete.
     */
    limit?: number
  }

  /**
   * ApiTask without action
   */
  export type ApiTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTask
     */
    select?: ApiTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiTask
     */
    omit?: ApiTaskOmit<ExtArgs> | null
  }


  /**
   * Model CollectionPreset
   */

  export type AggregateCollectionPreset = {
    _count: CollectionPresetCountAggregateOutputType | null
    _avg: CollectionPresetAvgAggregateOutputType | null
    _sum: CollectionPresetSumAggregateOutputType | null
    _min: CollectionPresetMinAggregateOutputType | null
    _max: CollectionPresetMaxAggregateOutputType | null
  }

  export type CollectionPresetAvgAggregateOutputType = {
    minLikes: number | null
    minRetweets: number | null
  }

  export type CollectionPresetSumAggregateOutputType = {
    minLikes: number | null
    minRetweets: number | null
  }

  export type CollectionPresetMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    query: string | null
    minLikes: number | null
    minRetweets: number | null
    language: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionPresetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    query: string | null
    minLikes: number | null
    minRetweets: number | null
    language: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionPresetCountAggregateOutputType = {
    id: number
    name: number
    description: number
    query: number
    keywords: number
    minLikes: number
    minRetweets: number
    language: number
    category: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionPresetAvgAggregateInputType = {
    minLikes?: true
    minRetweets?: true
  }

  export type CollectionPresetSumAggregateInputType = {
    minLikes?: true
    minRetweets?: true
  }

  export type CollectionPresetMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    query?: true
    minLikes?: true
    minRetweets?: true
    language?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionPresetMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    query?: true
    minLikes?: true
    minRetweets?: true
    language?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionPresetCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    query?: true
    keywords?: true
    minLikes?: true
    minRetweets?: true
    language?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionPresetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionPreset to aggregate.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionPresets
    **/
    _count?: true | CollectionPresetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionPresetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionPresetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionPresetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionPresetMaxAggregateInputType
  }

  export type GetCollectionPresetAggregateType<T extends CollectionPresetAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionPreset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionPreset[P]>
      : GetScalarType<T[P], AggregateCollectionPreset[P]>
  }




  export type CollectionPresetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionPresetWhereInput
    orderBy?: CollectionPresetOrderByWithAggregationInput | CollectionPresetOrderByWithAggregationInput[]
    by: CollectionPresetScalarFieldEnum[] | CollectionPresetScalarFieldEnum
    having?: CollectionPresetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionPresetCountAggregateInputType | true
    _avg?: CollectionPresetAvgAggregateInputType
    _sum?: CollectionPresetSumAggregateInputType
    _min?: CollectionPresetMinAggregateInputType
    _max?: CollectionPresetMaxAggregateInputType
  }

  export type CollectionPresetGroupByOutputType = {
    id: string
    name: string
    description: string | null
    query: string
    keywords: string[]
    minLikes: number
    minRetweets: number
    language: string
    category: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollectionPresetCountAggregateOutputType | null
    _avg: CollectionPresetAvgAggregateOutputType | null
    _sum: CollectionPresetSumAggregateOutputType | null
    _min: CollectionPresetMinAggregateOutputType | null
    _max: CollectionPresetMaxAggregateOutputType | null
  }

  type GetCollectionPresetGroupByPayload<T extends CollectionPresetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionPresetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionPresetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionPresetGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionPresetGroupByOutputType[P]>
        }
      >
    >


  export type CollectionPresetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    query?: boolean
    keywords?: boolean
    minLikes?: boolean
    minRetweets?: boolean
    language?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    query?: boolean
    keywords?: boolean
    minLikes?: boolean
    minRetweets?: boolean
    language?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    query?: boolean
    keywords?: boolean
    minLikes?: boolean
    minRetweets?: boolean
    language?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    query?: boolean
    keywords?: boolean
    minLikes?: boolean
    minRetweets?: boolean
    language?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionPresetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "query" | "keywords" | "minLikes" | "minRetweets" | "language" | "category" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["collectionPreset"]>

  export type $CollectionPresetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionPreset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      query: string
      keywords: string[]
      minLikes: number
      minRetweets: number
      language: string
      category: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionPreset"]>
    composites: {}
  }

  type CollectionPresetGetPayload<S extends boolean | null | undefined | CollectionPresetDefaultArgs> = $Result.GetResult<Prisma.$CollectionPresetPayload, S>

  type CollectionPresetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionPresetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionPresetCountAggregateInputType | true
    }

  export interface CollectionPresetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionPreset'], meta: { name: 'CollectionPreset' } }
    /**
     * Find zero or one CollectionPreset that matches the filter.
     * @param {CollectionPresetFindUniqueArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionPresetFindUniqueArgs>(args: SelectSubset<T, CollectionPresetFindUniqueArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionPreset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionPresetFindUniqueOrThrowArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionPresetFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionPresetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionPreset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindFirstArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionPresetFindFirstArgs>(args?: SelectSubset<T, CollectionPresetFindFirstArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionPreset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindFirstOrThrowArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionPresetFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionPresetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionPresets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionPresets
     * const collectionPresets = await prisma.collectionPreset.findMany()
     * 
     * // Get first 10 CollectionPresets
     * const collectionPresets = await prisma.collectionPreset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionPresetFindManyArgs>(args?: SelectSubset<T, CollectionPresetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionPreset.
     * @param {CollectionPresetCreateArgs} args - Arguments to create a CollectionPreset.
     * @example
     * // Create one CollectionPreset
     * const CollectionPreset = await prisma.collectionPreset.create({
     *   data: {
     *     // ... data to create a CollectionPreset
     *   }
     * })
     * 
     */
    create<T extends CollectionPresetCreateArgs>(args: SelectSubset<T, CollectionPresetCreateArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionPresets.
     * @param {CollectionPresetCreateManyArgs} args - Arguments to create many CollectionPresets.
     * @example
     * // Create many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionPresetCreateManyArgs>(args?: SelectSubset<T, CollectionPresetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionPresets and returns the data saved in the database.
     * @param {CollectionPresetCreateManyAndReturnArgs} args - Arguments to create many CollectionPresets.
     * @example
     * // Create many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionPresets and only return the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionPresetCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionPresetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionPreset.
     * @param {CollectionPresetDeleteArgs} args - Arguments to delete one CollectionPreset.
     * @example
     * // Delete one CollectionPreset
     * const CollectionPreset = await prisma.collectionPreset.delete({
     *   where: {
     *     // ... filter to delete one CollectionPreset
     *   }
     * })
     * 
     */
    delete<T extends CollectionPresetDeleteArgs>(args: SelectSubset<T, CollectionPresetDeleteArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionPreset.
     * @param {CollectionPresetUpdateArgs} args - Arguments to update one CollectionPreset.
     * @example
     * // Update one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionPresetUpdateArgs>(args: SelectSubset<T, CollectionPresetUpdateArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionPresets.
     * @param {CollectionPresetDeleteManyArgs} args - Arguments to filter CollectionPresets to delete.
     * @example
     * // Delete a few CollectionPresets
     * const { count } = await prisma.collectionPreset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionPresetDeleteManyArgs>(args?: SelectSubset<T, CollectionPresetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionPresetUpdateManyArgs>(args: SelectSubset<T, CollectionPresetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionPresets and returns the data updated in the database.
     * @param {CollectionPresetUpdateManyAndReturnArgs} args - Arguments to update many CollectionPresets.
     * @example
     * // Update many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionPresets and only return the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionPresetUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionPresetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionPreset.
     * @param {CollectionPresetUpsertArgs} args - Arguments to update or create a CollectionPreset.
     * @example
     * // Update or create a CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.upsert({
     *   create: {
     *     // ... data to create a CollectionPreset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionPreset we want to update
     *   }
     * })
     */
    upsert<T extends CollectionPresetUpsertArgs>(args: SelectSubset<T, CollectionPresetUpsertArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetCountArgs} args - Arguments to filter CollectionPresets to count.
     * @example
     * // Count the number of CollectionPresets
     * const count = await prisma.collectionPreset.count({
     *   where: {
     *     // ... the filter for the CollectionPresets we want to count
     *   }
     * })
    **/
    count<T extends CollectionPresetCountArgs>(
      args?: Subset<T, CollectionPresetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionPresetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionPresetAggregateArgs>(args: Subset<T, CollectionPresetAggregateArgs>): Prisma.PrismaPromise<GetCollectionPresetAggregateType<T>>

    /**
     * Group by CollectionPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionPresetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionPresetGroupByArgs['orderBy'] }
        : { orderBy?: CollectionPresetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionPresetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionPresetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionPreset model
   */
  readonly fields: CollectionPresetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionPreset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionPresetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionPreset model
   */
  interface CollectionPresetFieldRefs {
    readonly id: FieldRef<"CollectionPreset", 'String'>
    readonly name: FieldRef<"CollectionPreset", 'String'>
    readonly description: FieldRef<"CollectionPreset", 'String'>
    readonly query: FieldRef<"CollectionPreset", 'String'>
    readonly keywords: FieldRef<"CollectionPreset", 'String[]'>
    readonly minLikes: FieldRef<"CollectionPreset", 'Int'>
    readonly minRetweets: FieldRef<"CollectionPreset", 'Int'>
    readonly language: FieldRef<"CollectionPreset", 'String'>
    readonly category: FieldRef<"CollectionPreset", 'String'>
    readonly isActive: FieldRef<"CollectionPreset", 'Boolean'>
    readonly createdAt: FieldRef<"CollectionPreset", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionPreset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionPreset findUnique
   */
  export type CollectionPresetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset findUniqueOrThrow
   */
  export type CollectionPresetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset findFirst
   */
  export type CollectionPresetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionPresets.
     */
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset findFirstOrThrow
   */
  export type CollectionPresetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionPresets.
     */
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset findMany
   */
  export type CollectionPresetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * Filter, which CollectionPresets to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset create
   */
  export type CollectionPresetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * The data needed to create a CollectionPreset.
     */
    data: XOR<CollectionPresetCreateInput, CollectionPresetUncheckedCreateInput>
  }

  /**
   * CollectionPreset createMany
   */
  export type CollectionPresetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionPresets.
     */
    data: CollectionPresetCreateManyInput | CollectionPresetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionPreset createManyAndReturn
   */
  export type CollectionPresetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionPresets.
     */
    data: CollectionPresetCreateManyInput | CollectionPresetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionPreset update
   */
  export type CollectionPresetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * The data needed to update a CollectionPreset.
     */
    data: XOR<CollectionPresetUpdateInput, CollectionPresetUncheckedUpdateInput>
    /**
     * Choose, which CollectionPreset to update.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset updateMany
   */
  export type CollectionPresetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionPresets.
     */
    data: XOR<CollectionPresetUpdateManyMutationInput, CollectionPresetUncheckedUpdateManyInput>
    /**
     * Filter which CollectionPresets to update
     */
    where?: CollectionPresetWhereInput
    /**
     * Limit how many CollectionPresets to update.
     */
    limit?: number
  }

  /**
   * CollectionPreset updateManyAndReturn
   */
  export type CollectionPresetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * The data used to update CollectionPresets.
     */
    data: XOR<CollectionPresetUpdateManyMutationInput, CollectionPresetUncheckedUpdateManyInput>
    /**
     * Filter which CollectionPresets to update
     */
    where?: CollectionPresetWhereInput
    /**
     * Limit how many CollectionPresets to update.
     */
    limit?: number
  }

  /**
   * CollectionPreset upsert
   */
  export type CollectionPresetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * The filter to search for the CollectionPreset to update in case it exists.
     */
    where: CollectionPresetWhereUniqueInput
    /**
     * In case the CollectionPreset found by the `where` argument doesn't exist, create a new CollectionPreset with this data.
     */
    create: XOR<CollectionPresetCreateInput, CollectionPresetUncheckedCreateInput>
    /**
     * In case the CollectionPreset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionPresetUpdateInput, CollectionPresetUncheckedUpdateInput>
  }

  /**
   * CollectionPreset delete
   */
  export type CollectionPresetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
    /**
     * Filter which CollectionPreset to delete.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset deleteMany
   */
  export type CollectionPresetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionPresets to delete
     */
    where?: CollectionPresetWhereInput
    /**
     * Limit how many CollectionPresets to delete.
     */
    limit?: number
  }

  /**
   * CollectionPreset without action
   */
  export type CollectionPresetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionPreset
     */
    omit?: CollectionPresetOmit<ExtArgs> | null
  }


  /**
   * Model WatchlistUser
   */

  export type AggregateWatchlistUser = {
    _count: WatchlistUserCountAggregateOutputType | null
    _avg: WatchlistUserAvgAggregateOutputType | null
    _sum: WatchlistUserSumAggregateOutputType | null
    _min: WatchlistUserMinAggregateOutputType | null
    _max: WatchlistUserMaxAggregateOutputType | null
  }

  export type WatchlistUserAvgAggregateOutputType = {
    followers_count: number | null
    priority: number | null
  }

  export type WatchlistUserSumAggregateOutputType = {
    followers_count: number | null
    priority: number | null
  }

  export type WatchlistUserMinAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    displayName: string | null
    profile_image: string | null
    bio: string | null
    followers_count: number | null
    notes: string | null
    priority: number | null
    is_following: boolean | null
    added_at: Date | null
    lastChecked: Date | null
    userId: string | null
  }

  export type WatchlistUserMaxAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    displayName: string | null
    profile_image: string | null
    bio: string | null
    followers_count: number | null
    notes: string | null
    priority: number | null
    is_following: boolean | null
    added_at: Date | null
    lastChecked: Date | null
    userId: string | null
  }

  export type WatchlistUserCountAggregateOutputType = {
    id: number
    twitterId: number
    username: number
    displayName: number
    profile_image: number
    bio: number
    followers_count: number
    category: number
    notes: number
    priority: number
    is_following: number
    added_at: number
    lastChecked: number
    userId: number
    _all: number
  }


  export type WatchlistUserAvgAggregateInputType = {
    followers_count?: true
    priority?: true
  }

  export type WatchlistUserSumAggregateInputType = {
    followers_count?: true
    priority?: true
  }

  export type WatchlistUserMinAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    displayName?: true
    profile_image?: true
    bio?: true
    followers_count?: true
    notes?: true
    priority?: true
    is_following?: true
    added_at?: true
    lastChecked?: true
    userId?: true
  }

  export type WatchlistUserMaxAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    displayName?: true
    profile_image?: true
    bio?: true
    followers_count?: true
    notes?: true
    priority?: true
    is_following?: true
    added_at?: true
    lastChecked?: true
    userId?: true
  }

  export type WatchlistUserCountAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    displayName?: true
    profile_image?: true
    bio?: true
    followers_count?: true
    category?: true
    notes?: true
    priority?: true
    is_following?: true
    added_at?: true
    lastChecked?: true
    userId?: true
    _all?: true
  }

  export type WatchlistUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistUser to aggregate.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistUsers
    **/
    _count?: true | WatchlistUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistUserMaxAggregateInputType
  }

  export type GetWatchlistUserAggregateType<T extends WatchlistUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistUser[P]>
      : GetScalarType<T[P], AggregateWatchlistUser[P]>
  }




  export type WatchlistUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistUserWhereInput
    orderBy?: WatchlistUserOrderByWithAggregationInput | WatchlistUserOrderByWithAggregationInput[]
    by: WatchlistUserScalarFieldEnum[] | WatchlistUserScalarFieldEnum
    having?: WatchlistUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistUserCountAggregateInputType | true
    _avg?: WatchlistUserAvgAggregateInputType
    _sum?: WatchlistUserSumAggregateInputType
    _min?: WatchlistUserMinAggregateInputType
    _max?: WatchlistUserMaxAggregateInputType
  }

  export type WatchlistUserGroupByOutputType = {
    id: string
    twitterId: string
    username: string
    displayName: string
    profile_image: string | null
    bio: string | null
    followers_count: number
    category: string[]
    notes: string | null
    priority: number
    is_following: boolean
    added_at: Date
    lastChecked: Date | null
    userId: string
    _count: WatchlistUserCountAggregateOutputType | null
    _avg: WatchlistUserAvgAggregateOutputType | null
    _sum: WatchlistUserSumAggregateOutputType | null
    _min: WatchlistUserMinAggregateOutputType | null
    _max: WatchlistUserMaxAggregateOutputType | null
  }

  type GetWatchlistUserGroupByPayload<T extends WatchlistUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistUserGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistUserGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    profile_image?: boolean
    bio?: boolean
    followers_count?: boolean
    category?: boolean
    notes?: boolean
    priority?: boolean
    is_following?: boolean
    added_at?: boolean
    lastChecked?: boolean
    userId?: boolean
    tweets?: boolean | WatchlistUser$tweetsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    profile_image?: boolean
    bio?: boolean
    followers_count?: boolean
    category?: boolean
    notes?: boolean
    priority?: boolean
    is_following?: boolean
    added_at?: boolean
    lastChecked?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    profile_image?: boolean
    bio?: boolean
    followers_count?: boolean
    category?: boolean
    notes?: boolean
    priority?: boolean
    is_following?: boolean
    added_at?: boolean
    lastChecked?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectScalar = {
    id?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    profile_image?: boolean
    bio?: boolean
    followers_count?: boolean
    category?: boolean
    notes?: boolean
    priority?: boolean
    is_following?: boolean
    added_at?: boolean
    lastChecked?: boolean
    userId?: boolean
  }

  export type WatchlistUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "twitterId" | "username" | "displayName" | "profile_image" | "bio" | "followers_count" | "category" | "notes" | "priority" | "is_following" | "added_at" | "lastChecked" | "userId", ExtArgs["result"]["watchlistUser"]>
  export type WatchlistUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | WatchlistUser$tweetsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WatchlistUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WatchlistUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WatchlistUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistUser"
    objects: {
      tweets: Prisma.$WatchlistTweetPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      twitterId: string
      username: string
      displayName: string
      profile_image: string | null
      bio: string | null
      followers_count: number
      category: string[]
      notes: string | null
      priority: number
      is_following: boolean
      added_at: Date
      lastChecked: Date | null
      userId: string
    }, ExtArgs["result"]["watchlistUser"]>
    composites: {}
  }

  type WatchlistUserGetPayload<S extends boolean | null | undefined | WatchlistUserDefaultArgs> = $Result.GetResult<Prisma.$WatchlistUserPayload, S>

  type WatchlistUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WatchlistUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WatchlistUserCountAggregateInputType | true
    }

  export interface WatchlistUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistUser'], meta: { name: 'WatchlistUser' } }
    /**
     * Find zero or one WatchlistUser that matches the filter.
     * @param {WatchlistUserFindUniqueArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistUserFindUniqueArgs>(args: SelectSubset<T, WatchlistUserFindUniqueArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WatchlistUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WatchlistUserFindUniqueOrThrowArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchlistUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindFirstArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistUserFindFirstArgs>(args?: SelectSubset<T, WatchlistUserFindFirstArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchlistUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindFirstOrThrowArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WatchlistUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistUsers
     * const watchlistUsers = await prisma.watchlistUser.findMany()
     * 
     * // Get first 10 WatchlistUsers
     * const watchlistUsers = await prisma.watchlistUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistUserFindManyArgs>(args?: SelectSubset<T, WatchlistUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WatchlistUser.
     * @param {WatchlistUserCreateArgs} args - Arguments to create a WatchlistUser.
     * @example
     * // Create one WatchlistUser
     * const WatchlistUser = await prisma.watchlistUser.create({
     *   data: {
     *     // ... data to create a WatchlistUser
     *   }
     * })
     * 
     */
    create<T extends WatchlistUserCreateArgs>(args: SelectSubset<T, WatchlistUserCreateArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WatchlistUsers.
     * @param {WatchlistUserCreateManyArgs} args - Arguments to create many WatchlistUsers.
     * @example
     * // Create many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistUserCreateManyArgs>(args?: SelectSubset<T, WatchlistUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistUsers and returns the data saved in the database.
     * @param {WatchlistUserCreateManyAndReturnArgs} args - Arguments to create many WatchlistUsers.
     * @example
     * // Create many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistUsers and only return the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WatchlistUser.
     * @param {WatchlistUserDeleteArgs} args - Arguments to delete one WatchlistUser.
     * @example
     * // Delete one WatchlistUser
     * const WatchlistUser = await prisma.watchlistUser.delete({
     *   where: {
     *     // ... filter to delete one WatchlistUser
     *   }
     * })
     * 
     */
    delete<T extends WatchlistUserDeleteArgs>(args: SelectSubset<T, WatchlistUserDeleteArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WatchlistUser.
     * @param {WatchlistUserUpdateArgs} args - Arguments to update one WatchlistUser.
     * @example
     * // Update one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistUserUpdateArgs>(args: SelectSubset<T, WatchlistUserUpdateArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WatchlistUsers.
     * @param {WatchlistUserDeleteManyArgs} args - Arguments to filter WatchlistUsers to delete.
     * @example
     * // Delete a few WatchlistUsers
     * const { count } = await prisma.watchlistUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistUserDeleteManyArgs>(args?: SelectSubset<T, WatchlistUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistUserUpdateManyArgs>(args: SelectSubset<T, WatchlistUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistUsers and returns the data updated in the database.
     * @param {WatchlistUserUpdateManyAndReturnArgs} args - Arguments to update many WatchlistUsers.
     * @example
     * // Update many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WatchlistUsers and only return the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WatchlistUserUpdateManyAndReturnArgs>(args: SelectSubset<T, WatchlistUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WatchlistUser.
     * @param {WatchlistUserUpsertArgs} args - Arguments to update or create a WatchlistUser.
     * @example
     * // Update or create a WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.upsert({
     *   create: {
     *     // ... data to create a WatchlistUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistUser we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistUserUpsertArgs>(args: SelectSubset<T, WatchlistUserUpsertArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WatchlistUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserCountArgs} args - Arguments to filter WatchlistUsers to count.
     * @example
     * // Count the number of WatchlistUsers
     * const count = await prisma.watchlistUser.count({
     *   where: {
     *     // ... the filter for the WatchlistUsers we want to count
     *   }
     * })
    **/
    count<T extends WatchlistUserCountArgs>(
      args?: Subset<T, WatchlistUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistUserAggregateArgs>(args: Subset<T, WatchlistUserAggregateArgs>): Prisma.PrismaPromise<GetWatchlistUserAggregateType<T>>

    /**
     * Group by WatchlistUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistUserGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistUser model
   */
  readonly fields: WatchlistUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends WatchlistUser$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUser$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistUser model
   */
  interface WatchlistUserFieldRefs {
    readonly id: FieldRef<"WatchlistUser", 'String'>
    readonly twitterId: FieldRef<"WatchlistUser", 'String'>
    readonly username: FieldRef<"WatchlistUser", 'String'>
    readonly displayName: FieldRef<"WatchlistUser", 'String'>
    readonly profile_image: FieldRef<"WatchlistUser", 'String'>
    readonly bio: FieldRef<"WatchlistUser", 'String'>
    readonly followers_count: FieldRef<"WatchlistUser", 'Int'>
    readonly category: FieldRef<"WatchlistUser", 'String[]'>
    readonly notes: FieldRef<"WatchlistUser", 'String'>
    readonly priority: FieldRef<"WatchlistUser", 'Int'>
    readonly is_following: FieldRef<"WatchlistUser", 'Boolean'>
    readonly added_at: FieldRef<"WatchlistUser", 'DateTime'>
    readonly lastChecked: FieldRef<"WatchlistUser", 'DateTime'>
    readonly userId: FieldRef<"WatchlistUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistUser findUnique
   */
  export type WatchlistUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser findUniqueOrThrow
   */
  export type WatchlistUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser findFirst
   */
  export type WatchlistUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistUsers.
     */
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser findFirstOrThrow
   */
  export type WatchlistUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistUsers.
     */
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser findMany
   */
  export type WatchlistUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUsers to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser create
   */
  export type WatchlistUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistUser.
     */
    data: XOR<WatchlistUserCreateInput, WatchlistUserUncheckedCreateInput>
  }

  /**
   * WatchlistUser createMany
   */
  export type WatchlistUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistUsers.
     */
    data: WatchlistUserCreateManyInput | WatchlistUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistUser createManyAndReturn
   */
  export type WatchlistUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * The data used to create many WatchlistUsers.
     */
    data: WatchlistUserCreateManyInput | WatchlistUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistUser update
   */
  export type WatchlistUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistUser.
     */
    data: XOR<WatchlistUserUpdateInput, WatchlistUserUncheckedUpdateInput>
    /**
     * Choose, which WatchlistUser to update.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser updateMany
   */
  export type WatchlistUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistUsers.
     */
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistUsers to update
     */
    where?: WatchlistUserWhereInput
    /**
     * Limit how many WatchlistUsers to update.
     */
    limit?: number
  }

  /**
   * WatchlistUser updateManyAndReturn
   */
  export type WatchlistUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * The data used to update WatchlistUsers.
     */
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistUsers to update
     */
    where?: WatchlistUserWhereInput
    /**
     * Limit how many WatchlistUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistUser upsert
   */
  export type WatchlistUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistUser to update in case it exists.
     */
    where: WatchlistUserWhereUniqueInput
    /**
     * In case the WatchlistUser found by the `where` argument doesn't exist, create a new WatchlistUser with this data.
     */
    create: XOR<WatchlistUserCreateInput, WatchlistUserUncheckedCreateInput>
    /**
     * In case the WatchlistUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistUserUpdateInput, WatchlistUserUncheckedUpdateInput>
  }

  /**
   * WatchlistUser delete
   */
  export type WatchlistUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter which WatchlistUser to delete.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser deleteMany
   */
  export type WatchlistUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistUsers to delete
     */
    where?: WatchlistUserWhereInput
    /**
     * Limit how many WatchlistUsers to delete.
     */
    limit?: number
  }

  /**
   * WatchlistUser.tweets
   */
  export type WatchlistUser$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    where?: WatchlistTweetWhereInput
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    cursor?: WatchlistTweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistUser without action
   */
  export type WatchlistUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistUser
     */
    omit?: WatchlistUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
  }


  /**
   * Model WatchlistTweet
   */

  export type AggregateWatchlistTweet = {
    _count: WatchlistTweetCountAggregateOutputType | null
    _avg: WatchlistTweetAvgAggregateOutputType | null
    _sum: WatchlistTweetSumAggregateOutputType | null
    _min: WatchlistTweetMinAggregateOutputType | null
    _max: WatchlistTweetMaxAggregateOutputType | null
  }

  export type WatchlistTweetAvgAggregateOutputType = {
    likes_count: number | null
    retweets_count: number | null
    replies_count: number | null
    impressions_count: number | null
  }

  export type WatchlistTweetSumAggregateOutputType = {
    likes_count: number | null
    retweets_count: number | null
    replies_count: number | null
    impressions_count: number | null
  }

  export type WatchlistTweetMinAggregateOutputType = {
    id: string | null
    tweetId: string | null
    watchlistUserId: string | null
    content: string | null
    likes_count: number | null
    retweets_count: number | null
    replies_count: number | null
    impressions_count: number | null
    has_replied: boolean | null
    has_quoted: boolean | null
    posted_at: Date | null
    collectedAt: Date | null
    url: string | null
  }

  export type WatchlistTweetMaxAggregateOutputType = {
    id: string | null
    tweetId: string | null
    watchlistUserId: string | null
    content: string | null
    likes_count: number | null
    retweets_count: number | null
    replies_count: number | null
    impressions_count: number | null
    has_replied: boolean | null
    has_quoted: boolean | null
    posted_at: Date | null
    collectedAt: Date | null
    url: string | null
  }

  export type WatchlistTweetCountAggregateOutputType = {
    id: number
    tweetId: number
    watchlistUserId: number
    content: number
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied: number
    has_quoted: number
    posted_at: number
    collectedAt: number
    url: number
    media_urls: number
    _all: number
  }


  export type WatchlistTweetAvgAggregateInputType = {
    likes_count?: true
    retweets_count?: true
    replies_count?: true
    impressions_count?: true
  }

  export type WatchlistTweetSumAggregateInputType = {
    likes_count?: true
    retweets_count?: true
    replies_count?: true
    impressions_count?: true
  }

  export type WatchlistTweetMinAggregateInputType = {
    id?: true
    tweetId?: true
    watchlistUserId?: true
    content?: true
    likes_count?: true
    retweets_count?: true
    replies_count?: true
    impressions_count?: true
    has_replied?: true
    has_quoted?: true
    posted_at?: true
    collectedAt?: true
    url?: true
  }

  export type WatchlistTweetMaxAggregateInputType = {
    id?: true
    tweetId?: true
    watchlistUserId?: true
    content?: true
    likes_count?: true
    retweets_count?: true
    replies_count?: true
    impressions_count?: true
    has_replied?: true
    has_quoted?: true
    posted_at?: true
    collectedAt?: true
    url?: true
  }

  export type WatchlistTweetCountAggregateInputType = {
    id?: true
    tweetId?: true
    watchlistUserId?: true
    content?: true
    likes_count?: true
    retweets_count?: true
    replies_count?: true
    impressions_count?: true
    has_replied?: true
    has_quoted?: true
    posted_at?: true
    collectedAt?: true
    url?: true
    media_urls?: true
    _all?: true
  }

  export type WatchlistTweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistTweet to aggregate.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistTweets
    **/
    _count?: true | WatchlistTweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistTweetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistTweetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistTweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistTweetMaxAggregateInputType
  }

  export type GetWatchlistTweetAggregateType<T extends WatchlistTweetAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistTweet[P]>
      : GetScalarType<T[P], AggregateWatchlistTweet[P]>
  }




  export type WatchlistTweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistTweetWhereInput
    orderBy?: WatchlistTweetOrderByWithAggregationInput | WatchlistTweetOrderByWithAggregationInput[]
    by: WatchlistTweetScalarFieldEnum[] | WatchlistTweetScalarFieldEnum
    having?: WatchlistTweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistTweetCountAggregateInputType | true
    _avg?: WatchlistTweetAvgAggregateInputType
    _sum?: WatchlistTweetSumAggregateInputType
    _min?: WatchlistTweetMinAggregateInputType
    _max?: WatchlistTweetMaxAggregateInputType
  }

  export type WatchlistTweetGroupByOutputType = {
    id: string
    tweetId: string
    watchlistUserId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied: boolean
    has_quoted: boolean
    posted_at: Date
    collectedAt: Date
    url: string
    media_urls: JsonValue | null
    _count: WatchlistTweetCountAggregateOutputType | null
    _avg: WatchlistTweetAvgAggregateOutputType | null
    _sum: WatchlistTweetSumAggregateOutputType | null
    _min: WatchlistTweetMinAggregateOutputType | null
    _max: WatchlistTweetMaxAggregateOutputType | null
  }

  type GetWatchlistTweetGroupByPayload<T extends WatchlistTweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistTweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistTweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistTweetGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistTweetGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistTweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    watchlistUserId?: boolean
    content?: boolean
    likes_count?: boolean
    retweets_count?: boolean
    replies_count?: boolean
    impressions_count?: boolean
    has_replied?: boolean
    has_quoted?: boolean
    posted_at?: boolean
    collectedAt?: boolean
    url?: boolean
    media_urls?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    watchlistUserId?: boolean
    content?: boolean
    likes_count?: boolean
    retweets_count?: boolean
    replies_count?: boolean
    impressions_count?: boolean
    has_replied?: boolean
    has_quoted?: boolean
    posted_at?: boolean
    collectedAt?: boolean
    url?: boolean
    media_urls?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    watchlistUserId?: boolean
    content?: boolean
    likes_count?: boolean
    retweets_count?: boolean
    replies_count?: boolean
    impressions_count?: boolean
    has_replied?: boolean
    has_quoted?: boolean
    posted_at?: boolean
    collectedAt?: boolean
    url?: boolean
    media_urls?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectScalar = {
    id?: boolean
    tweetId?: boolean
    watchlistUserId?: boolean
    content?: boolean
    likes_count?: boolean
    retweets_count?: boolean
    replies_count?: boolean
    impressions_count?: boolean
    has_replied?: boolean
    has_quoted?: boolean
    posted_at?: boolean
    collectedAt?: boolean
    url?: boolean
    media_urls?: boolean
  }

  export type WatchlistTweetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tweetId" | "watchlistUserId" | "content" | "likes_count" | "retweets_count" | "replies_count" | "impressions_count" | "has_replied" | "has_quoted" | "posted_at" | "collectedAt" | "url" | "media_urls", ExtArgs["result"]["watchlistTweet"]>
  export type WatchlistTweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }
  export type WatchlistTweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }
  export type WatchlistTweetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }

  export type $WatchlistTweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistTweet"
    objects: {
      watchlistUser: Prisma.$WatchlistUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tweetId: string
      watchlistUserId: string
      content: string
      likes_count: number
      retweets_count: number
      replies_count: number
      impressions_count: number
      has_replied: boolean
      has_quoted: boolean
      posted_at: Date
      collectedAt: Date
      url: string
      media_urls: Prisma.JsonValue | null
    }, ExtArgs["result"]["watchlistTweet"]>
    composites: {}
  }

  type WatchlistTweetGetPayload<S extends boolean | null | undefined | WatchlistTweetDefaultArgs> = $Result.GetResult<Prisma.$WatchlistTweetPayload, S>

  type WatchlistTweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WatchlistTweetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WatchlistTweetCountAggregateInputType | true
    }

  export interface WatchlistTweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistTweet'], meta: { name: 'WatchlistTweet' } }
    /**
     * Find zero or one WatchlistTweet that matches the filter.
     * @param {WatchlistTweetFindUniqueArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistTweetFindUniqueArgs>(args: SelectSubset<T, WatchlistTweetFindUniqueArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WatchlistTweet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WatchlistTweetFindUniqueOrThrowArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistTweetFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistTweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchlistTweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindFirstArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistTweetFindFirstArgs>(args?: SelectSubset<T, WatchlistTweetFindFirstArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchlistTweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindFirstOrThrowArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistTweetFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistTweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WatchlistTweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistTweets
     * const watchlistTweets = await prisma.watchlistTweet.findMany()
     * 
     * // Get first 10 WatchlistTweets
     * const watchlistTweets = await prisma.watchlistTweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistTweetFindManyArgs>(args?: SelectSubset<T, WatchlistTweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WatchlistTweet.
     * @param {WatchlistTweetCreateArgs} args - Arguments to create a WatchlistTweet.
     * @example
     * // Create one WatchlistTweet
     * const WatchlistTweet = await prisma.watchlistTweet.create({
     *   data: {
     *     // ... data to create a WatchlistTweet
     *   }
     * })
     * 
     */
    create<T extends WatchlistTweetCreateArgs>(args: SelectSubset<T, WatchlistTweetCreateArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WatchlistTweets.
     * @param {WatchlistTweetCreateManyArgs} args - Arguments to create many WatchlistTweets.
     * @example
     * // Create many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistTweetCreateManyArgs>(args?: SelectSubset<T, WatchlistTweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistTweets and returns the data saved in the database.
     * @param {WatchlistTweetCreateManyAndReturnArgs} args - Arguments to create many WatchlistTweets.
     * @example
     * // Create many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistTweets and only return the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistTweetCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistTweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WatchlistTweet.
     * @param {WatchlistTweetDeleteArgs} args - Arguments to delete one WatchlistTweet.
     * @example
     * // Delete one WatchlistTweet
     * const WatchlistTweet = await prisma.watchlistTweet.delete({
     *   where: {
     *     // ... filter to delete one WatchlistTweet
     *   }
     * })
     * 
     */
    delete<T extends WatchlistTweetDeleteArgs>(args: SelectSubset<T, WatchlistTweetDeleteArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WatchlistTweet.
     * @param {WatchlistTweetUpdateArgs} args - Arguments to update one WatchlistTweet.
     * @example
     * // Update one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistTweetUpdateArgs>(args: SelectSubset<T, WatchlistTweetUpdateArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WatchlistTweets.
     * @param {WatchlistTweetDeleteManyArgs} args - Arguments to filter WatchlistTweets to delete.
     * @example
     * // Delete a few WatchlistTweets
     * const { count } = await prisma.watchlistTweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistTweetDeleteManyArgs>(args?: SelectSubset<T, WatchlistTweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistTweetUpdateManyArgs>(args: SelectSubset<T, WatchlistTweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistTweets and returns the data updated in the database.
     * @param {WatchlistTweetUpdateManyAndReturnArgs} args - Arguments to update many WatchlistTweets.
     * @example
     * // Update many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WatchlistTweets and only return the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WatchlistTweetUpdateManyAndReturnArgs>(args: SelectSubset<T, WatchlistTweetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WatchlistTweet.
     * @param {WatchlistTweetUpsertArgs} args - Arguments to update or create a WatchlistTweet.
     * @example
     * // Update or create a WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.upsert({
     *   create: {
     *     // ... data to create a WatchlistTweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistTweet we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistTweetUpsertArgs>(args: SelectSubset<T, WatchlistTweetUpsertArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WatchlistTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetCountArgs} args - Arguments to filter WatchlistTweets to count.
     * @example
     * // Count the number of WatchlistTweets
     * const count = await prisma.watchlistTweet.count({
     *   where: {
     *     // ... the filter for the WatchlistTweets we want to count
     *   }
     * })
    **/
    count<T extends WatchlistTweetCountArgs>(
      args?: Subset<T, WatchlistTweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistTweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistTweetAggregateArgs>(args: Subset<T, WatchlistTweetAggregateArgs>): Prisma.PrismaPromise<GetWatchlistTweetAggregateType<T>>

    /**
     * Group by WatchlistTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistTweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistTweetGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistTweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistTweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistTweet model
   */
  readonly fields: WatchlistTweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistTweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistTweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlistUser<T extends WatchlistUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUserDefaultArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistTweet model
   */
  interface WatchlistTweetFieldRefs {
    readonly id: FieldRef<"WatchlistTweet", 'String'>
    readonly tweetId: FieldRef<"WatchlistTweet", 'String'>
    readonly watchlistUserId: FieldRef<"WatchlistTweet", 'String'>
    readonly content: FieldRef<"WatchlistTweet", 'String'>
    readonly likes_count: FieldRef<"WatchlistTweet", 'Int'>
    readonly retweets_count: FieldRef<"WatchlistTweet", 'Int'>
    readonly replies_count: FieldRef<"WatchlistTweet", 'Int'>
    readonly impressions_count: FieldRef<"WatchlistTweet", 'Int'>
    readonly has_replied: FieldRef<"WatchlistTweet", 'Boolean'>
    readonly has_quoted: FieldRef<"WatchlistTweet", 'Boolean'>
    readonly posted_at: FieldRef<"WatchlistTweet", 'DateTime'>
    readonly collectedAt: FieldRef<"WatchlistTweet", 'DateTime'>
    readonly url: FieldRef<"WatchlistTweet", 'String'>
    readonly media_urls: FieldRef<"WatchlistTweet", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistTweet findUnique
   */
  export type WatchlistTweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet findUniqueOrThrow
   */
  export type WatchlistTweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet findFirst
   */
  export type WatchlistTweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistTweets.
     */
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet findFirstOrThrow
   */
  export type WatchlistTweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistTweets.
     */
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet findMany
   */
  export type WatchlistTweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweets to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet create
   */
  export type WatchlistTweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistTweet.
     */
    data: XOR<WatchlistTweetCreateInput, WatchlistTweetUncheckedCreateInput>
  }

  /**
   * WatchlistTweet createMany
   */
  export type WatchlistTweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistTweets.
     */
    data: WatchlistTweetCreateManyInput | WatchlistTweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistTweet createManyAndReturn
   */
  export type WatchlistTweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * The data used to create many WatchlistTweets.
     */
    data: WatchlistTweetCreateManyInput | WatchlistTweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistTweet update
   */
  export type WatchlistTweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistTweet.
     */
    data: XOR<WatchlistTweetUpdateInput, WatchlistTweetUncheckedUpdateInput>
    /**
     * Choose, which WatchlistTweet to update.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet updateMany
   */
  export type WatchlistTweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistTweets.
     */
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistTweets to update
     */
    where?: WatchlistTweetWhereInput
    /**
     * Limit how many WatchlistTweets to update.
     */
    limit?: number
  }

  /**
   * WatchlistTweet updateManyAndReturn
   */
  export type WatchlistTweetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * The data used to update WatchlistTweets.
     */
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistTweets to update
     */
    where?: WatchlistTweetWhereInput
    /**
     * Limit how many WatchlistTweets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistTweet upsert
   */
  export type WatchlistTweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistTweet to update in case it exists.
     */
    where: WatchlistTweetWhereUniqueInput
    /**
     * In case the WatchlistTweet found by the `where` argument doesn't exist, create a new WatchlistTweet with this data.
     */
    create: XOR<WatchlistTweetCreateInput, WatchlistTweetUncheckedCreateInput>
    /**
     * In case the WatchlistTweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistTweetUpdateInput, WatchlistTweetUncheckedUpdateInput>
  }

  /**
   * WatchlistTweet delete
   */
  export type WatchlistTweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter which WatchlistTweet to delete.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet deleteMany
   */
  export type WatchlistTweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistTweets to delete
     */
    where?: WatchlistTweetWhereInput
    /**
     * Limit how many WatchlistTweets to delete.
     */
    limit?: number
  }

  /**
   * WatchlistTweet without action
   */
  export type WatchlistTweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchlistTweet
     */
    omit?: WatchlistTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
  }


  /**
   * Model InteractionHistory
   */

  export type AggregateInteractionHistory = {
    _count: InteractionHistoryCountAggregateOutputType | null
    _min: InteractionHistoryMinAggregateOutputType | null
    _max: InteractionHistoryMaxAggregateOutputType | null
  }

  export type InteractionHistoryMinAggregateOutputType = {
    id: string | null
    type: string | null
    source_tweet_id: string | null
    target_tweet_id: string | null
    content: string | null
    createdAt: Date | null
  }

  export type InteractionHistoryMaxAggregateOutputType = {
    id: string | null
    type: string | null
    source_tweet_id: string | null
    target_tweet_id: string | null
    content: string | null
    createdAt: Date | null
  }

  export type InteractionHistoryCountAggregateOutputType = {
    id: number
    type: number
    source_tweet_id: number
    target_tweet_id: number
    content: number
    createdAt: number
    _all: number
  }


  export type InteractionHistoryMinAggregateInputType = {
    id?: true
    type?: true
    source_tweet_id?: true
    target_tweet_id?: true
    content?: true
    createdAt?: true
  }

  export type InteractionHistoryMaxAggregateInputType = {
    id?: true
    type?: true
    source_tweet_id?: true
    target_tweet_id?: true
    content?: true
    createdAt?: true
  }

  export type InteractionHistoryCountAggregateInputType = {
    id?: true
    type?: true
    source_tweet_id?: true
    target_tweet_id?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type InteractionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionHistory to aggregate.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InteractionHistories
    **/
    _count?: true | InteractionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionHistoryMaxAggregateInputType
  }

  export type GetInteractionHistoryAggregateType<T extends InteractionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInteractionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteractionHistory[P]>
      : GetScalarType<T[P], AggregateInteractionHistory[P]>
  }




  export type InteractionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionHistoryWhereInput
    orderBy?: InteractionHistoryOrderByWithAggregationInput | InteractionHistoryOrderByWithAggregationInput[]
    by: InteractionHistoryScalarFieldEnum[] | InteractionHistoryScalarFieldEnum
    having?: InteractionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionHistoryCountAggregateInputType | true
    _min?: InteractionHistoryMinAggregateInputType
    _max?: InteractionHistoryMaxAggregateInputType
  }

  export type InteractionHistoryGroupByOutputType = {
    id: string
    type: string
    source_tweet_id: string
    target_tweet_id: string | null
    content: string | null
    createdAt: Date
    _count: InteractionHistoryCountAggregateOutputType | null
    _min: InteractionHistoryMinAggregateOutputType | null
    _max: InteractionHistoryMaxAggregateOutputType | null
  }

  type GetInteractionHistoryGroupByPayload<T extends InteractionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type InteractionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source_tweet_id?: boolean
    target_tweet_id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source_tweet_id?: boolean
    target_tweet_id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source_tweet_id?: boolean
    target_tweet_id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectScalar = {
    id?: boolean
    type?: boolean
    source_tweet_id?: boolean
    target_tweet_id?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type InteractionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "source_tweet_id" | "target_tweet_id" | "content" | "createdAt", ExtArgs["result"]["interactionHistory"]>

  export type $InteractionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InteractionHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      source_tweet_id: string
      target_tweet_id: string | null
      content: string | null
      createdAt: Date
    }, ExtArgs["result"]["interactionHistory"]>
    composites: {}
  }

  type InteractionHistoryGetPayload<S extends boolean | null | undefined | InteractionHistoryDefaultArgs> = $Result.GetResult<Prisma.$InteractionHistoryPayload, S>

  type InteractionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractionHistoryCountAggregateInputType | true
    }

  export interface InteractionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InteractionHistory'], meta: { name: 'InteractionHistory' } }
    /**
     * Find zero or one InteractionHistory that matches the filter.
     * @param {InteractionHistoryFindUniqueArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionHistoryFindUniqueArgs>(args: SelectSubset<T, InteractionHistoryFindUniqueArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InteractionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractionHistoryFindUniqueOrThrowArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteractionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindFirstArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionHistoryFindFirstArgs>(args?: SelectSubset<T, InteractionHistoryFindFirstArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteractionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindFirstOrThrowArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InteractionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InteractionHistories
     * const interactionHistories = await prisma.interactionHistory.findMany()
     * 
     * // Get first 10 InteractionHistories
     * const interactionHistories = await prisma.interactionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionHistoryFindManyArgs>(args?: SelectSubset<T, InteractionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InteractionHistory.
     * @param {InteractionHistoryCreateArgs} args - Arguments to create a InteractionHistory.
     * @example
     * // Create one InteractionHistory
     * const InteractionHistory = await prisma.interactionHistory.create({
     *   data: {
     *     // ... data to create a InteractionHistory
     *   }
     * })
     * 
     */
    create<T extends InteractionHistoryCreateArgs>(args: SelectSubset<T, InteractionHistoryCreateArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InteractionHistories.
     * @param {InteractionHistoryCreateManyArgs} args - Arguments to create many InteractionHistories.
     * @example
     * // Create many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionHistoryCreateManyArgs>(args?: SelectSubset<T, InteractionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InteractionHistories and returns the data saved in the database.
     * @param {InteractionHistoryCreateManyAndReturnArgs} args - Arguments to create many InteractionHistories.
     * @example
     * // Create many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InteractionHistories and only return the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InteractionHistory.
     * @param {InteractionHistoryDeleteArgs} args - Arguments to delete one InteractionHistory.
     * @example
     * // Delete one InteractionHistory
     * const InteractionHistory = await prisma.interactionHistory.delete({
     *   where: {
     *     // ... filter to delete one InteractionHistory
     *   }
     * })
     * 
     */
    delete<T extends InteractionHistoryDeleteArgs>(args: SelectSubset<T, InteractionHistoryDeleteArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InteractionHistory.
     * @param {InteractionHistoryUpdateArgs} args - Arguments to update one InteractionHistory.
     * @example
     * // Update one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionHistoryUpdateArgs>(args: SelectSubset<T, InteractionHistoryUpdateArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InteractionHistories.
     * @param {InteractionHistoryDeleteManyArgs} args - Arguments to filter InteractionHistories to delete.
     * @example
     * // Delete a few InteractionHistories
     * const { count } = await prisma.interactionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionHistoryDeleteManyArgs>(args?: SelectSubset<T, InteractionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionHistoryUpdateManyArgs>(args: SelectSubset<T, InteractionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractionHistories and returns the data updated in the database.
     * @param {InteractionHistoryUpdateManyAndReturnArgs} args - Arguments to update many InteractionHistories.
     * @example
     * // Update many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InteractionHistories and only return the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InteractionHistory.
     * @param {InteractionHistoryUpsertArgs} args - Arguments to update or create a InteractionHistory.
     * @example
     * // Update or create a InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.upsert({
     *   create: {
     *     // ... data to create a InteractionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InteractionHistory we want to update
     *   }
     * })
     */
    upsert<T extends InteractionHistoryUpsertArgs>(args: SelectSubset<T, InteractionHistoryUpsertArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InteractionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryCountArgs} args - Arguments to filter InteractionHistories to count.
     * @example
     * // Count the number of InteractionHistories
     * const count = await prisma.interactionHistory.count({
     *   where: {
     *     // ... the filter for the InteractionHistories we want to count
     *   }
     * })
    **/
    count<T extends InteractionHistoryCountArgs>(
      args?: Subset<T, InteractionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InteractionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionHistoryAggregateArgs>(args: Subset<T, InteractionHistoryAggregateArgs>): Prisma.PrismaPromise<GetInteractionHistoryAggregateType<T>>

    /**
     * Group by InteractionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: InteractionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InteractionHistory model
   */
  readonly fields: InteractionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InteractionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InteractionHistory model
   */
  interface InteractionHistoryFieldRefs {
    readonly id: FieldRef<"InteractionHistory", 'String'>
    readonly type: FieldRef<"InteractionHistory", 'String'>
    readonly source_tweet_id: FieldRef<"InteractionHistory", 'String'>
    readonly target_tweet_id: FieldRef<"InteractionHistory", 'String'>
    readonly content: FieldRef<"InteractionHistory", 'String'>
    readonly createdAt: FieldRef<"InteractionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InteractionHistory findUnique
   */
  export type InteractionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory findUniqueOrThrow
   */
  export type InteractionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory findFirst
   */
  export type InteractionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionHistories.
     */
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory findFirstOrThrow
   */
  export type InteractionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionHistories.
     */
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory findMany
   */
  export type InteractionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * Filter, which InteractionHistories to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory create
   */
  export type InteractionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a InteractionHistory.
     */
    data: XOR<InteractionHistoryCreateInput, InteractionHistoryUncheckedCreateInput>
  }

  /**
   * InteractionHistory createMany
   */
  export type InteractionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InteractionHistories.
     */
    data: InteractionHistoryCreateManyInput | InteractionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InteractionHistory createManyAndReturn
   */
  export type InteractionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many InteractionHistories.
     */
    data: InteractionHistoryCreateManyInput | InteractionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InteractionHistory update
   */
  export type InteractionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a InteractionHistory.
     */
    data: XOR<InteractionHistoryUpdateInput, InteractionHistoryUncheckedUpdateInput>
    /**
     * Choose, which InteractionHistory to update.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory updateMany
   */
  export type InteractionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InteractionHistories.
     */
    data: XOR<InteractionHistoryUpdateManyMutationInput, InteractionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InteractionHistories to update
     */
    where?: InteractionHistoryWhereInput
    /**
     * Limit how many InteractionHistories to update.
     */
    limit?: number
  }

  /**
   * InteractionHistory updateManyAndReturn
   */
  export type InteractionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update InteractionHistories.
     */
    data: XOR<InteractionHistoryUpdateManyMutationInput, InteractionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InteractionHistories to update
     */
    where?: InteractionHistoryWhereInput
    /**
     * Limit how many InteractionHistories to update.
     */
    limit?: number
  }

  /**
   * InteractionHistory upsert
   */
  export type InteractionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the InteractionHistory to update in case it exists.
     */
    where: InteractionHistoryWhereUniqueInput
    /**
     * In case the InteractionHistory found by the `where` argument doesn't exist, create a new InteractionHistory with this data.
     */
    create: XOR<InteractionHistoryCreateInput, InteractionHistoryUncheckedCreateInput>
    /**
     * In case the InteractionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionHistoryUpdateInput, InteractionHistoryUncheckedUpdateInput>
  }

  /**
   * InteractionHistory delete
   */
  export type InteractionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
    /**
     * Filter which InteractionHistory to delete.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory deleteMany
   */
  export type InteractionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionHistories to delete
     */
    where?: InteractionHistoryWhereInput
    /**
     * Limit how many InteractionHistories to delete.
     */
    limit?: number
  }

  /**
   * InteractionHistory without action
   */
  export type InteractionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionHistory
     */
    omit?: InteractionHistoryOmit<ExtArgs> | null
  }


  /**
   * Model PerplexityReport
   */

  export type AggregatePerplexityReport = {
    _count: PerplexityReportCountAggregateOutputType | null
    _avg: PerplexityReportAvgAggregateOutputType | null
    _sum: PerplexityReportSumAggregateOutputType | null
    _min: PerplexityReportMinAggregateOutputType | null
    _max: PerplexityReportMaxAggregateOutputType | null
  }

  export type PerplexityReportAvgAggregateOutputType = {
    buzz_prediction: number | null
  }

  export type PerplexityReportSumAggregateOutputType = {
    buzz_prediction: number | null
  }

  export type PerplexityReportMinAggregateOutputType = {
    id: string | null
    query: string | null
    focus: string | null
    rawAnalysis: string | null
    buzz_prediction: number | null
    createdAt: Date | null
  }

  export type PerplexityReportMaxAggregateOutputType = {
    id: string | null
    query: string | null
    focus: string | null
    rawAnalysis: string | null
    buzz_prediction: number | null
    createdAt: Date | null
  }

  export type PerplexityReportCountAggregateOutputType = {
    id: number
    query: number
    focus: number
    rawAnalysis: number
    trends: number
    insights: number
    personal_angles: number
    buzz_prediction: number
    recommendations: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type PerplexityReportAvgAggregateInputType = {
    buzz_prediction?: true
  }

  export type PerplexityReportSumAggregateInputType = {
    buzz_prediction?: true
  }

  export type PerplexityReportMinAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    buzz_prediction?: true
    createdAt?: true
  }

  export type PerplexityReportMaxAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    buzz_prediction?: true
    createdAt?: true
  }

  export type PerplexityReportCountAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    trends?: true
    insights?: true
    personal_angles?: true
    buzz_prediction?: true
    recommendations?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type PerplexityReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerplexityReport to aggregate.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerplexityReports
    **/
    _count?: true | PerplexityReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerplexityReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerplexityReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerplexityReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerplexityReportMaxAggregateInputType
  }

  export type GetPerplexityReportAggregateType<T extends PerplexityReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePerplexityReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerplexityReport[P]>
      : GetScalarType<T[P], AggregatePerplexityReport[P]>
  }




  export type PerplexityReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerplexityReportWhereInput
    orderBy?: PerplexityReportOrderByWithAggregationInput | PerplexityReportOrderByWithAggregationInput[]
    by: PerplexityReportScalarFieldEnum[] | PerplexityReportScalarFieldEnum
    having?: PerplexityReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerplexityReportCountAggregateInputType | true
    _avg?: PerplexityReportAvgAggregateInputType
    _sum?: PerplexityReportSumAggregateInputType
    _min?: PerplexityReportMinAggregateInputType
    _max?: PerplexityReportMaxAggregateInputType
  }

  export type PerplexityReportGroupByOutputType = {
    id: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonValue
    insights: JsonValue
    personal_angles: JsonValue
    buzz_prediction: number
    recommendations: JsonValue
    metadata: JsonValue
    createdAt: Date
    _count: PerplexityReportCountAggregateOutputType | null
    _avg: PerplexityReportAvgAggregateOutputType | null
    _sum: PerplexityReportSumAggregateOutputType | null
    _min: PerplexityReportMinAggregateOutputType | null
    _max: PerplexityReportMaxAggregateOutputType | null
  }

  type GetPerplexityReportGroupByPayload<T extends PerplexityReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerplexityReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerplexityReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerplexityReportGroupByOutputType[P]>
            : GetScalarType<T[P], PerplexityReportGroupByOutputType[P]>
        }
      >
    >


  export type PerplexityReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    personal_angles?: boolean
    buzz_prediction?: boolean
    recommendations?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    personal_angles?: boolean
    buzz_prediction?: boolean
    recommendations?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    personal_angles?: boolean
    buzz_prediction?: boolean
    recommendations?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectScalar = {
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    personal_angles?: boolean
    buzz_prediction?: boolean
    recommendations?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type PerplexityReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "focus" | "rawAnalysis" | "trends" | "insights" | "personal_angles" | "buzz_prediction" | "recommendations" | "metadata" | "createdAt", ExtArgs["result"]["perplexityReport"]>

  export type $PerplexityReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerplexityReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      focus: string
      rawAnalysis: string
      trends: Prisma.JsonValue
      insights: Prisma.JsonValue
      personal_angles: Prisma.JsonValue
      buzz_prediction: number
      recommendations: Prisma.JsonValue
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["perplexityReport"]>
    composites: {}
  }

  type PerplexityReportGetPayload<S extends boolean | null | undefined | PerplexityReportDefaultArgs> = $Result.GetResult<Prisma.$PerplexityReportPayload, S>

  type PerplexityReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerplexityReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerplexityReportCountAggregateInputType | true
    }

  export interface PerplexityReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerplexityReport'], meta: { name: 'PerplexityReport' } }
    /**
     * Find zero or one PerplexityReport that matches the filter.
     * @param {PerplexityReportFindUniqueArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerplexityReportFindUniqueArgs>(args: SelectSubset<T, PerplexityReportFindUniqueArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerplexityReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerplexityReportFindUniqueOrThrowArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerplexityReportFindUniqueOrThrowArgs>(args: SelectSubset<T, PerplexityReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerplexityReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindFirstArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerplexityReportFindFirstArgs>(args?: SelectSubset<T, PerplexityReportFindFirstArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerplexityReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindFirstOrThrowArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerplexityReportFindFirstOrThrowArgs>(args?: SelectSubset<T, PerplexityReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerplexityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerplexityReports
     * const perplexityReports = await prisma.perplexityReport.findMany()
     * 
     * // Get first 10 PerplexityReports
     * const perplexityReports = await prisma.perplexityReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerplexityReportFindManyArgs>(args?: SelectSubset<T, PerplexityReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerplexityReport.
     * @param {PerplexityReportCreateArgs} args - Arguments to create a PerplexityReport.
     * @example
     * // Create one PerplexityReport
     * const PerplexityReport = await prisma.perplexityReport.create({
     *   data: {
     *     // ... data to create a PerplexityReport
     *   }
     * })
     * 
     */
    create<T extends PerplexityReportCreateArgs>(args: SelectSubset<T, PerplexityReportCreateArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerplexityReports.
     * @param {PerplexityReportCreateManyArgs} args - Arguments to create many PerplexityReports.
     * @example
     * // Create many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerplexityReportCreateManyArgs>(args?: SelectSubset<T, PerplexityReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerplexityReports and returns the data saved in the database.
     * @param {PerplexityReportCreateManyAndReturnArgs} args - Arguments to create many PerplexityReports.
     * @example
     * // Create many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerplexityReports and only return the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerplexityReportCreateManyAndReturnArgs>(args?: SelectSubset<T, PerplexityReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerplexityReport.
     * @param {PerplexityReportDeleteArgs} args - Arguments to delete one PerplexityReport.
     * @example
     * // Delete one PerplexityReport
     * const PerplexityReport = await prisma.perplexityReport.delete({
     *   where: {
     *     // ... filter to delete one PerplexityReport
     *   }
     * })
     * 
     */
    delete<T extends PerplexityReportDeleteArgs>(args: SelectSubset<T, PerplexityReportDeleteArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerplexityReport.
     * @param {PerplexityReportUpdateArgs} args - Arguments to update one PerplexityReport.
     * @example
     * // Update one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerplexityReportUpdateArgs>(args: SelectSubset<T, PerplexityReportUpdateArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerplexityReports.
     * @param {PerplexityReportDeleteManyArgs} args - Arguments to filter PerplexityReports to delete.
     * @example
     * // Delete a few PerplexityReports
     * const { count } = await prisma.perplexityReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerplexityReportDeleteManyArgs>(args?: SelectSubset<T, PerplexityReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerplexityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerplexityReportUpdateManyArgs>(args: SelectSubset<T, PerplexityReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerplexityReports and returns the data updated in the database.
     * @param {PerplexityReportUpdateManyAndReturnArgs} args - Arguments to update many PerplexityReports.
     * @example
     * // Update many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerplexityReports and only return the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerplexityReportUpdateManyAndReturnArgs>(args: SelectSubset<T, PerplexityReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerplexityReport.
     * @param {PerplexityReportUpsertArgs} args - Arguments to update or create a PerplexityReport.
     * @example
     * // Update or create a PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.upsert({
     *   create: {
     *     // ... data to create a PerplexityReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerplexityReport we want to update
     *   }
     * })
     */
    upsert<T extends PerplexityReportUpsertArgs>(args: SelectSubset<T, PerplexityReportUpsertArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerplexityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportCountArgs} args - Arguments to filter PerplexityReports to count.
     * @example
     * // Count the number of PerplexityReports
     * const count = await prisma.perplexityReport.count({
     *   where: {
     *     // ... the filter for the PerplexityReports we want to count
     *   }
     * })
    **/
    count<T extends PerplexityReportCountArgs>(
      args?: Subset<T, PerplexityReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerplexityReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerplexityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerplexityReportAggregateArgs>(args: Subset<T, PerplexityReportAggregateArgs>): Prisma.PrismaPromise<GetPerplexityReportAggregateType<T>>

    /**
     * Group by PerplexityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerplexityReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerplexityReportGroupByArgs['orderBy'] }
        : { orderBy?: PerplexityReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerplexityReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerplexityReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerplexityReport model
   */
  readonly fields: PerplexityReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerplexityReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerplexityReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerplexityReport model
   */
  interface PerplexityReportFieldRefs {
    readonly id: FieldRef<"PerplexityReport", 'String'>
    readonly query: FieldRef<"PerplexityReport", 'String'>
    readonly focus: FieldRef<"PerplexityReport", 'String'>
    readonly rawAnalysis: FieldRef<"PerplexityReport", 'String'>
    readonly trends: FieldRef<"PerplexityReport", 'Json'>
    readonly insights: FieldRef<"PerplexityReport", 'Json'>
    readonly personal_angles: FieldRef<"PerplexityReport", 'Json'>
    readonly buzz_prediction: FieldRef<"PerplexityReport", 'Float'>
    readonly recommendations: FieldRef<"PerplexityReport", 'Json'>
    readonly metadata: FieldRef<"PerplexityReport", 'Json'>
    readonly createdAt: FieldRef<"PerplexityReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerplexityReport findUnique
   */
  export type PerplexityReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport findUniqueOrThrow
   */
  export type PerplexityReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport findFirst
   */
  export type PerplexityReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerplexityReports.
     */
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport findFirstOrThrow
   */
  export type PerplexityReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerplexityReports.
     */
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport findMany
   */
  export type PerplexityReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * Filter, which PerplexityReports to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport create
   */
  export type PerplexityReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * The data needed to create a PerplexityReport.
     */
    data: XOR<PerplexityReportCreateInput, PerplexityReportUncheckedCreateInput>
  }

  /**
   * PerplexityReport createMany
   */
  export type PerplexityReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerplexityReports.
     */
    data: PerplexityReportCreateManyInput | PerplexityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerplexityReport createManyAndReturn
   */
  export type PerplexityReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * The data used to create many PerplexityReports.
     */
    data: PerplexityReportCreateManyInput | PerplexityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerplexityReport update
   */
  export type PerplexityReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * The data needed to update a PerplexityReport.
     */
    data: XOR<PerplexityReportUpdateInput, PerplexityReportUncheckedUpdateInput>
    /**
     * Choose, which PerplexityReport to update.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport updateMany
   */
  export type PerplexityReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerplexityReports.
     */
    data: XOR<PerplexityReportUpdateManyMutationInput, PerplexityReportUncheckedUpdateManyInput>
    /**
     * Filter which PerplexityReports to update
     */
    where?: PerplexityReportWhereInput
    /**
     * Limit how many PerplexityReports to update.
     */
    limit?: number
  }

  /**
   * PerplexityReport updateManyAndReturn
   */
  export type PerplexityReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * The data used to update PerplexityReports.
     */
    data: XOR<PerplexityReportUpdateManyMutationInput, PerplexityReportUncheckedUpdateManyInput>
    /**
     * Filter which PerplexityReports to update
     */
    where?: PerplexityReportWhereInput
    /**
     * Limit how many PerplexityReports to update.
     */
    limit?: number
  }

  /**
   * PerplexityReport upsert
   */
  export type PerplexityReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * The filter to search for the PerplexityReport to update in case it exists.
     */
    where: PerplexityReportWhereUniqueInput
    /**
     * In case the PerplexityReport found by the `where` argument doesn't exist, create a new PerplexityReport with this data.
     */
    create: XOR<PerplexityReportCreateInput, PerplexityReportUncheckedCreateInput>
    /**
     * In case the PerplexityReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerplexityReportUpdateInput, PerplexityReportUncheckedUpdateInput>
  }

  /**
   * PerplexityReport delete
   */
  export type PerplexityReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
    /**
     * Filter which PerplexityReport to delete.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport deleteMany
   */
  export type PerplexityReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerplexityReports to delete
     */
    where?: PerplexityReportWhereInput
    /**
     * Limit how many PerplexityReports to delete.
     */
    limit?: number
  }

  /**
   * PerplexityReport without action
   */
  export type PerplexityReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerplexityReport
     */
    omit?: PerplexityReportOmit<ExtArgs> | null
  }


  /**
   * Model CotSession
   */

  export type AggregateCotSession = {
    _count: CotSessionCountAggregateOutputType | null
    _avg: CotSessionAvgAggregateOutputType | null
    _sum: CotSessionSumAggregateOutputType | null
    _min: CotSessionMinAggregateOutputType | null
    _max: CotSessionMaxAggregateOutputType | null
  }

  export type CotSessionAvgAggregateOutputType = {
    currentPhase: number | null
    retryCount: number | null
    totalTokens: number | null
    totalDuration: number | null
  }

  export type CotSessionSumAggregateOutputType = {
    currentPhase: number | null
    retryCount: number | null
    totalTokens: number | null
    totalDuration: number | null
  }

  export type CotSessionMinAggregateOutputType = {
    id: string | null
    theme: string | null
    style: string | null
    platform: string | null
    status: $Enums.CotSessionStatus | null
    currentPhase: number | null
    currentStep: $Enums.CotPhaseStep | null
    lastError: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    totalTokens: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type CotSessionMaxAggregateOutputType = {
    id: string | null
    theme: string | null
    style: string | null
    platform: string | null
    status: $Enums.CotSessionStatus | null
    currentPhase: number | null
    currentStep: $Enums.CotPhaseStep | null
    lastError: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    totalTokens: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type CotSessionCountAggregateOutputType = {
    id: number
    theme: number
    style: number
    platform: number
    status: number
    currentPhase: number
    currentStep: number
    lastError: number
    retryCount: number
    nextRetryAt: number
    totalTokens: number
    totalDuration: number
    createdAt: number
    updatedAt: number
    completedAt: number
    metadata: number
    _all: number
  }


  export type CotSessionAvgAggregateInputType = {
    currentPhase?: true
    retryCount?: true
    totalTokens?: true
    totalDuration?: true
  }

  export type CotSessionSumAggregateInputType = {
    currentPhase?: true
    retryCount?: true
    totalTokens?: true
    totalDuration?: true
  }

  export type CotSessionMinAggregateInputType = {
    id?: true
    theme?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type CotSessionMaxAggregateInputType = {
    id?: true
    theme?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type CotSessionCountAggregateInputType = {
    id?: true
    theme?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    metadata?: true
    _all?: true
  }

  export type CotSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotSession to aggregate.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotSessions
    **/
    _count?: true | CotSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotSessionMaxAggregateInputType
  }

  export type GetCotSessionAggregateType<T extends CotSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCotSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotSession[P]>
      : GetScalarType<T[P], AggregateCotSession[P]>
  }




  export type CotSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotSessionWhereInput
    orderBy?: CotSessionOrderByWithAggregationInput | CotSessionOrderByWithAggregationInput[]
    by: CotSessionScalarFieldEnum[] | CotSessionScalarFieldEnum
    having?: CotSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotSessionCountAggregateInputType | true
    _avg?: CotSessionAvgAggregateInputType
    _sum?: CotSessionSumAggregateInputType
    _min?: CotSessionMinAggregateInputType
    _max?: CotSessionMaxAggregateInputType
  }

  export type CotSessionGroupByOutputType = {
    id: string
    theme: string
    style: string
    platform: string
    status: $Enums.CotSessionStatus
    currentPhase: number
    currentStep: $Enums.CotPhaseStep
    lastError: string | null
    retryCount: number
    nextRetryAt: Date | null
    totalTokens: number
    totalDuration: number
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    metadata: JsonValue | null
    _count: CotSessionCountAggregateOutputType | null
    _avg: CotSessionAvgAggregateOutputType | null
    _sum: CotSessionSumAggregateOutputType | null
    _min: CotSessionMinAggregateOutputType | null
    _max: CotSessionMaxAggregateOutputType | null
  }

  type GetCotSessionGroupByPayload<T extends CotSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CotSessionGroupByOutputType[P]>
        }
      >
    >


  export type CotSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    drafts?: boolean | CotSession$draftsArgs<ExtArgs>
    phases?: boolean | CotSession$phasesArgs<ExtArgs>
    _count?: boolean | CotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectScalar = {
    id?: boolean
    theme?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
  }

  export type CotSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "theme" | "style" | "platform" | "status" | "currentPhase" | "currentStep" | "lastError" | "retryCount" | "nextRetryAt" | "totalTokens" | "totalDuration" | "createdAt" | "updatedAt" | "completedAt" | "metadata", ExtArgs["result"]["cotSession"]>
  export type CotSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | CotSession$draftsArgs<ExtArgs>
    phases?: boolean | CotSession$phasesArgs<ExtArgs>
    _count?: boolean | CotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CotSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CotSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CotSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotSession"
    objects: {
      drafts: Prisma.$CotDraftPayload<ExtArgs>[]
      phases: Prisma.$CotPhasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      theme: string
      style: string
      platform: string
      status: $Enums.CotSessionStatus
      currentPhase: number
      currentStep: $Enums.CotPhaseStep
      lastError: string | null
      retryCount: number
      nextRetryAt: Date | null
      totalTokens: number
      totalDuration: number
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["cotSession"]>
    composites: {}
  }

  type CotSessionGetPayload<S extends boolean | null | undefined | CotSessionDefaultArgs> = $Result.GetResult<Prisma.$CotSessionPayload, S>

  type CotSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CotSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CotSessionCountAggregateInputType | true
    }

  export interface CotSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotSession'], meta: { name: 'CotSession' } }
    /**
     * Find zero or one CotSession that matches the filter.
     * @param {CotSessionFindUniqueArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotSessionFindUniqueArgs>(args: SelectSubset<T, CotSessionFindUniqueArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CotSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CotSessionFindUniqueOrThrowArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CotSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindFirstArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotSessionFindFirstArgs>(args?: SelectSubset<T, CotSessionFindFirstArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindFirstOrThrowArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CotSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CotSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotSessions
     * const cotSessions = await prisma.cotSession.findMany()
     * 
     * // Get first 10 CotSessions
     * const cotSessions = await prisma.cotSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotSessionFindManyArgs>(args?: SelectSubset<T, CotSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CotSession.
     * @param {CotSessionCreateArgs} args - Arguments to create a CotSession.
     * @example
     * // Create one CotSession
     * const CotSession = await prisma.cotSession.create({
     *   data: {
     *     // ... data to create a CotSession
     *   }
     * })
     * 
     */
    create<T extends CotSessionCreateArgs>(args: SelectSubset<T, CotSessionCreateArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CotSessions.
     * @param {CotSessionCreateManyArgs} args - Arguments to create many CotSessions.
     * @example
     * // Create many CotSessions
     * const cotSession = await prisma.cotSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotSessionCreateManyArgs>(args?: SelectSubset<T, CotSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotSessions and returns the data saved in the database.
     * @param {CotSessionCreateManyAndReturnArgs} args - Arguments to create many CotSessions.
     * @example
     * // Create many CotSessions
     * const cotSession = await prisma.cotSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotSessions and only return the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CotSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CotSession.
     * @param {CotSessionDeleteArgs} args - Arguments to delete one CotSession.
     * @example
     * // Delete one CotSession
     * const CotSession = await prisma.cotSession.delete({
     *   where: {
     *     // ... filter to delete one CotSession
     *   }
     * })
     * 
     */
    delete<T extends CotSessionDeleteArgs>(args: SelectSubset<T, CotSessionDeleteArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CotSession.
     * @param {CotSessionUpdateArgs} args - Arguments to update one CotSession.
     * @example
     * // Update one CotSession
     * const cotSession = await prisma.cotSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotSessionUpdateArgs>(args: SelectSubset<T, CotSessionUpdateArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CotSessions.
     * @param {CotSessionDeleteManyArgs} args - Arguments to filter CotSessions to delete.
     * @example
     * // Delete a few CotSessions
     * const { count } = await prisma.cotSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotSessionDeleteManyArgs>(args?: SelectSubset<T, CotSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotSessions
     * const cotSession = await prisma.cotSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotSessionUpdateManyArgs>(args: SelectSubset<T, CotSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotSessions and returns the data updated in the database.
     * @param {CotSessionUpdateManyAndReturnArgs} args - Arguments to update many CotSessions.
     * @example
     * // Update many CotSessions
     * const cotSession = await prisma.cotSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CotSessions and only return the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CotSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CotSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CotSession.
     * @param {CotSessionUpsertArgs} args - Arguments to update or create a CotSession.
     * @example
     * // Update or create a CotSession
     * const cotSession = await prisma.cotSession.upsert({
     *   create: {
     *     // ... data to create a CotSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotSession we want to update
     *   }
     * })
     */
    upsert<T extends CotSessionUpsertArgs>(args: SelectSubset<T, CotSessionUpsertArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionCountArgs} args - Arguments to filter CotSessions to count.
     * @example
     * // Count the number of CotSessions
     * const count = await prisma.cotSession.count({
     *   where: {
     *     // ... the filter for the CotSessions we want to count
     *   }
     * })
    **/
    count<T extends CotSessionCountArgs>(
      args?: Subset<T, CotSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotSessionAggregateArgs>(args: Subset<T, CotSessionAggregateArgs>): Prisma.PrismaPromise<GetCotSessionAggregateType<T>>

    /**
     * Group by CotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotSessionGroupByArgs['orderBy'] }
        : { orderBy?: CotSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotSession model
   */
  readonly fields: CotSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drafts<T extends CotSession$draftsArgs<ExtArgs> = {}>(args?: Subset<T, CotSession$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phases<T extends CotSession$phasesArgs<ExtArgs> = {}>(args?: Subset<T, CotSession$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotSession model
   */
  interface CotSessionFieldRefs {
    readonly id: FieldRef<"CotSession", 'String'>
    readonly theme: FieldRef<"CotSession", 'String'>
    readonly style: FieldRef<"CotSession", 'String'>
    readonly platform: FieldRef<"CotSession", 'String'>
    readonly status: FieldRef<"CotSession", 'CotSessionStatus'>
    readonly currentPhase: FieldRef<"CotSession", 'Int'>
    readonly currentStep: FieldRef<"CotSession", 'CotPhaseStep'>
    readonly lastError: FieldRef<"CotSession", 'String'>
    readonly retryCount: FieldRef<"CotSession", 'Int'>
    readonly nextRetryAt: FieldRef<"CotSession", 'DateTime'>
    readonly totalTokens: FieldRef<"CotSession", 'Int'>
    readonly totalDuration: FieldRef<"CotSession", 'Int'>
    readonly createdAt: FieldRef<"CotSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CotSession", 'DateTime'>
    readonly completedAt: FieldRef<"CotSession", 'DateTime'>
    readonly metadata: FieldRef<"CotSession", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CotSession findUnique
   */
  export type CotSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession findUniqueOrThrow
   */
  export type CotSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession findFirst
   */
  export type CotSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotSessions.
     */
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession findFirstOrThrow
   */
  export type CotSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotSessions.
     */
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession findMany
   */
  export type CotSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSessions to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession create
   */
  export type CotSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CotSession.
     */
    data: XOR<CotSessionCreateInput, CotSessionUncheckedCreateInput>
  }

  /**
   * CotSession createMany
   */
  export type CotSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotSessions.
     */
    data: CotSessionCreateManyInput | CotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotSession createManyAndReturn
   */
  export type CotSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CotSessions.
     */
    data: CotSessionCreateManyInput | CotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotSession update
   */
  export type CotSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CotSession.
     */
    data: XOR<CotSessionUpdateInput, CotSessionUncheckedUpdateInput>
    /**
     * Choose, which CotSession to update.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession updateMany
   */
  export type CotSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotSessions.
     */
    data: XOR<CotSessionUpdateManyMutationInput, CotSessionUncheckedUpdateManyInput>
    /**
     * Filter which CotSessions to update
     */
    where?: CotSessionWhereInput
    /**
     * Limit how many CotSessions to update.
     */
    limit?: number
  }

  /**
   * CotSession updateManyAndReturn
   */
  export type CotSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * The data used to update CotSessions.
     */
    data: XOR<CotSessionUpdateManyMutationInput, CotSessionUncheckedUpdateManyInput>
    /**
     * Filter which CotSessions to update
     */
    where?: CotSessionWhereInput
    /**
     * Limit how many CotSessions to update.
     */
    limit?: number
  }

  /**
   * CotSession upsert
   */
  export type CotSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CotSession to update in case it exists.
     */
    where: CotSessionWhereUniqueInput
    /**
     * In case the CotSession found by the `where` argument doesn't exist, create a new CotSession with this data.
     */
    create: XOR<CotSessionCreateInput, CotSessionUncheckedCreateInput>
    /**
     * In case the CotSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotSessionUpdateInput, CotSessionUncheckedUpdateInput>
  }

  /**
   * CotSession delete
   */
  export type CotSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter which CotSession to delete.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession deleteMany
   */
  export type CotSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotSessions to delete
     */
    where?: CotSessionWhereInput
    /**
     * Limit how many CotSessions to delete.
     */
    limit?: number
  }

  /**
   * CotSession.drafts
   */
  export type CotSession$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    where?: CotDraftWhereInput
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    cursor?: CotDraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotSession.phases
   */
  export type CotSession$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    where?: CotPhaseWhereInput
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    cursor?: CotPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotSession without action
   */
  export type CotSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotSession
     */
    omit?: CotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
  }


  /**
   * Model CotPhase
   */

  export type AggregateCotPhase = {
    _count: CotPhaseCountAggregateOutputType | null
    _avg: CotPhaseAvgAggregateOutputType | null
    _sum: CotPhaseSumAggregateOutputType | null
    _min: CotPhaseMinAggregateOutputType | null
    _max: CotPhaseMaxAggregateOutputType | null
  }

  export type CotPhaseAvgAggregateOutputType = {
    phaseNumber: number | null
    thinkTokens: number | null
    executeDuration: number | null
    integrateTokens: number | null
  }

  export type CotPhaseSumAggregateOutputType = {
    phaseNumber: number | null
    thinkTokens: number | null
    executeDuration: number | null
    integrateTokens: number | null
  }

  export type CotPhaseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phaseNumber: number | null
    thinkPrompt: string | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotPhaseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phaseNumber: number | null
    thinkPrompt: string | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotPhaseCountAggregateOutputType = {
    id: number
    sessionId: number
    phaseNumber: number
    thinkPrompt: number
    thinkResult: number
    thinkTokens: number
    thinkAt: number
    executeResult: number
    executeDuration: number
    executeAt: number
    integratePrompt: number
    integrateResult: number
    integrateTokens: number
    integrateAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CotPhaseAvgAggregateInputType = {
    phaseNumber?: true
    thinkTokens?: true
    executeDuration?: true
    integrateTokens?: true
  }

  export type CotPhaseSumAggregateInputType = {
    phaseNumber?: true
    thinkTokens?: true
    executeDuration?: true
    integrateTokens?: true
  }

  export type CotPhaseMinAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkTokens?: true
    thinkAt?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotPhaseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkTokens?: true
    thinkAt?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotPhaseCountAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkResult?: true
    thinkTokens?: true
    thinkAt?: true
    executeResult?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateResult?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CotPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotPhase to aggregate.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotPhases
    **/
    _count?: true | CotPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotPhaseMaxAggregateInputType
  }

  export type GetCotPhaseAggregateType<T extends CotPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCotPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotPhase[P]>
      : GetScalarType<T[P], AggregateCotPhase[P]>
  }




  export type CotPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotPhaseWhereInput
    orderBy?: CotPhaseOrderByWithAggregationInput | CotPhaseOrderByWithAggregationInput[]
    by: CotPhaseScalarFieldEnum[] | CotPhaseScalarFieldEnum
    having?: CotPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotPhaseCountAggregateInputType | true
    _avg?: CotPhaseAvgAggregateInputType
    _sum?: CotPhaseSumAggregateInputType
    _min?: CotPhaseMinAggregateInputType
    _max?: CotPhaseMaxAggregateInputType
  }

  export type CotPhaseGroupByOutputType = {
    id: string
    sessionId: string
    phaseNumber: number
    thinkPrompt: string | null
    thinkResult: JsonValue | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeResult: JsonValue | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateResult: JsonValue | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus
    createdAt: Date
    updatedAt: Date
    _count: CotPhaseCountAggregateOutputType | null
    _avg: CotPhaseAvgAggregateOutputType | null
    _sum: CotPhaseSumAggregateOutputType | null
    _min: CotPhaseMinAggregateOutputType | null
    _max: CotPhaseMaxAggregateOutputType | null
  }

  type GetCotPhaseGroupByPayload<T extends CotPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], CotPhaseGroupByOutputType[P]>
        }
      >
    >


  export type CotPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CotPhaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "phaseNumber" | "thinkPrompt" | "thinkResult" | "thinkTokens" | "thinkAt" | "executeResult" | "executeDuration" | "executeAt" | "integratePrompt" | "integrateResult" | "integrateTokens" | "integrateAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["cotPhase"]>
  export type CotPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }
  export type CotPhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }
  export type CotPhaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }

  export type $CotPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotPhase"
    objects: {
      session: Prisma.$CotSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      phaseNumber: number
      thinkPrompt: string | null
      thinkResult: Prisma.JsonValue | null
      thinkTokens: number | null
      thinkAt: Date | null
      executeResult: Prisma.JsonValue | null
      executeDuration: number | null
      executeAt: Date | null
      integratePrompt: string | null
      integrateResult: Prisma.JsonValue | null
      integrateTokens: number | null
      integrateAt: Date | null
      status: $Enums.CotPhaseStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cotPhase"]>
    composites: {}
  }

  type CotPhaseGetPayload<S extends boolean | null | undefined | CotPhaseDefaultArgs> = $Result.GetResult<Prisma.$CotPhasePayload, S>

  type CotPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CotPhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CotPhaseCountAggregateInputType | true
    }

  export interface CotPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotPhase'], meta: { name: 'CotPhase' } }
    /**
     * Find zero or one CotPhase that matches the filter.
     * @param {CotPhaseFindUniqueArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotPhaseFindUniqueArgs>(args: SelectSubset<T, CotPhaseFindUniqueArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CotPhase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CotPhaseFindUniqueOrThrowArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CotPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindFirstArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotPhaseFindFirstArgs>(args?: SelectSubset<T, CotPhaseFindFirstArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindFirstOrThrowArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CotPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CotPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotPhases
     * const cotPhases = await prisma.cotPhase.findMany()
     * 
     * // Get first 10 CotPhases
     * const cotPhases = await prisma.cotPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotPhaseFindManyArgs>(args?: SelectSubset<T, CotPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CotPhase.
     * @param {CotPhaseCreateArgs} args - Arguments to create a CotPhase.
     * @example
     * // Create one CotPhase
     * const CotPhase = await prisma.cotPhase.create({
     *   data: {
     *     // ... data to create a CotPhase
     *   }
     * })
     * 
     */
    create<T extends CotPhaseCreateArgs>(args: SelectSubset<T, CotPhaseCreateArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CotPhases.
     * @param {CotPhaseCreateManyArgs} args - Arguments to create many CotPhases.
     * @example
     * // Create many CotPhases
     * const cotPhase = await prisma.cotPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotPhaseCreateManyArgs>(args?: SelectSubset<T, CotPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotPhases and returns the data saved in the database.
     * @param {CotPhaseCreateManyAndReturnArgs} args - Arguments to create many CotPhases.
     * @example
     * // Create many CotPhases
     * const cotPhase = await prisma.cotPhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotPhases and only return the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotPhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CotPhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CotPhase.
     * @param {CotPhaseDeleteArgs} args - Arguments to delete one CotPhase.
     * @example
     * // Delete one CotPhase
     * const CotPhase = await prisma.cotPhase.delete({
     *   where: {
     *     // ... filter to delete one CotPhase
     *   }
     * })
     * 
     */
    delete<T extends CotPhaseDeleteArgs>(args: SelectSubset<T, CotPhaseDeleteArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CotPhase.
     * @param {CotPhaseUpdateArgs} args - Arguments to update one CotPhase.
     * @example
     * // Update one CotPhase
     * const cotPhase = await prisma.cotPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotPhaseUpdateArgs>(args: SelectSubset<T, CotPhaseUpdateArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CotPhases.
     * @param {CotPhaseDeleteManyArgs} args - Arguments to filter CotPhases to delete.
     * @example
     * // Delete a few CotPhases
     * const { count } = await prisma.cotPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotPhaseDeleteManyArgs>(args?: SelectSubset<T, CotPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotPhases
     * const cotPhase = await prisma.cotPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotPhaseUpdateManyArgs>(args: SelectSubset<T, CotPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotPhases and returns the data updated in the database.
     * @param {CotPhaseUpdateManyAndReturnArgs} args - Arguments to update many CotPhases.
     * @example
     * // Update many CotPhases
     * const cotPhase = await prisma.cotPhase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CotPhases and only return the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CotPhaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CotPhaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CotPhase.
     * @param {CotPhaseUpsertArgs} args - Arguments to update or create a CotPhase.
     * @example
     * // Update or create a CotPhase
     * const cotPhase = await prisma.cotPhase.upsert({
     *   create: {
     *     // ... data to create a CotPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotPhase we want to update
     *   }
     * })
     */
    upsert<T extends CotPhaseUpsertArgs>(args: SelectSubset<T, CotPhaseUpsertArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CotPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseCountArgs} args - Arguments to filter CotPhases to count.
     * @example
     * // Count the number of CotPhases
     * const count = await prisma.cotPhase.count({
     *   where: {
     *     // ... the filter for the CotPhases we want to count
     *   }
     * })
    **/
    count<T extends CotPhaseCountArgs>(
      args?: Subset<T, CotPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotPhaseAggregateArgs>(args: Subset<T, CotPhaseAggregateArgs>): Prisma.PrismaPromise<GetCotPhaseAggregateType<T>>

    /**
     * Group by CotPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotPhaseGroupByArgs['orderBy'] }
        : { orderBy?: CotPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotPhase model
   */
  readonly fields: CotPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotSessionDefaultArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotPhase model
   */
  interface CotPhaseFieldRefs {
    readonly id: FieldRef<"CotPhase", 'String'>
    readonly sessionId: FieldRef<"CotPhase", 'String'>
    readonly phaseNumber: FieldRef<"CotPhase", 'Int'>
    readonly thinkPrompt: FieldRef<"CotPhase", 'String'>
    readonly thinkResult: FieldRef<"CotPhase", 'Json'>
    readonly thinkTokens: FieldRef<"CotPhase", 'Int'>
    readonly thinkAt: FieldRef<"CotPhase", 'DateTime'>
    readonly executeResult: FieldRef<"CotPhase", 'Json'>
    readonly executeDuration: FieldRef<"CotPhase", 'Int'>
    readonly executeAt: FieldRef<"CotPhase", 'DateTime'>
    readonly integratePrompt: FieldRef<"CotPhase", 'String'>
    readonly integrateResult: FieldRef<"CotPhase", 'Json'>
    readonly integrateTokens: FieldRef<"CotPhase", 'Int'>
    readonly integrateAt: FieldRef<"CotPhase", 'DateTime'>
    readonly status: FieldRef<"CotPhase", 'CotPhaseStatus'>
    readonly createdAt: FieldRef<"CotPhase", 'DateTime'>
    readonly updatedAt: FieldRef<"CotPhase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotPhase findUnique
   */
  export type CotPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase findUniqueOrThrow
   */
  export type CotPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase findFirst
   */
  export type CotPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotPhases.
     */
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase findFirstOrThrow
   */
  export type CotPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotPhases.
     */
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase findMany
   */
  export type CotPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhases to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase create
   */
  export type CotPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CotPhase.
     */
    data: XOR<CotPhaseCreateInput, CotPhaseUncheckedCreateInput>
  }

  /**
   * CotPhase createMany
   */
  export type CotPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotPhases.
     */
    data: CotPhaseCreateManyInput | CotPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotPhase createManyAndReturn
   */
  export type CotPhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * The data used to create many CotPhases.
     */
    data: CotPhaseCreateManyInput | CotPhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotPhase update
   */
  export type CotPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CotPhase.
     */
    data: XOR<CotPhaseUpdateInput, CotPhaseUncheckedUpdateInput>
    /**
     * Choose, which CotPhase to update.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase updateMany
   */
  export type CotPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotPhases.
     */
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyInput>
    /**
     * Filter which CotPhases to update
     */
    where?: CotPhaseWhereInput
    /**
     * Limit how many CotPhases to update.
     */
    limit?: number
  }

  /**
   * CotPhase updateManyAndReturn
   */
  export type CotPhaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * The data used to update CotPhases.
     */
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyInput>
    /**
     * Filter which CotPhases to update
     */
    where?: CotPhaseWhereInput
    /**
     * Limit how many CotPhases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotPhase upsert
   */
  export type CotPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CotPhase to update in case it exists.
     */
    where: CotPhaseWhereUniqueInput
    /**
     * In case the CotPhase found by the `where` argument doesn't exist, create a new CotPhase with this data.
     */
    create: XOR<CotPhaseCreateInput, CotPhaseUncheckedCreateInput>
    /**
     * In case the CotPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotPhaseUpdateInput, CotPhaseUncheckedUpdateInput>
  }

  /**
   * CotPhase delete
   */
  export type CotPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter which CotPhase to delete.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase deleteMany
   */
  export type CotPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotPhases to delete
     */
    where?: CotPhaseWhereInput
    /**
     * Limit how many CotPhases to delete.
     */
    limit?: number
  }

  /**
   * CotPhase without action
   */
  export type CotPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotPhase
     */
    omit?: CotPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
  }


  /**
   * Model CotDraft
   */

  export type AggregateCotDraft = {
    _count: CotDraftCountAggregateOutputType | null
    _avg: CotDraftAvgAggregateOutputType | null
    _sum: CotDraftSumAggregateOutputType | null
    _min: CotDraftMinAggregateOutputType | null
    _max: CotDraftMaxAggregateOutputType | null
  }

  export type CotDraftAvgAggregateOutputType = {
    conceptNumber: number | null
    viralScore: number | null
  }

  export type CotDraftSumAggregateOutputType = {
    conceptNumber: number | null
    viralScore: number | null
  }

  export type CotDraftMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptNumber: number | null
    title: string | null
    hook: string | null
    angle: string | null
    format: string | null
    content: string | null
    visualGuide: string | null
    timing: string | null
    newsSource: string | null
    sourceUrl: string | null
    status: $Enums.CotDraftStatus | null
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotDraftMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptNumber: number | null
    title: string | null
    hook: string | null
    angle: string | null
    format: string | null
    content: string | null
    visualGuide: string | null
    timing: string | null
    newsSource: string | null
    sourceUrl: string | null
    status: $Enums.CotDraftStatus | null
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotDraftCountAggregateOutputType = {
    id: number
    sessionId: number
    conceptNumber: number
    title: number
    hook: number
    angle: number
    format: number
    content: number
    thread_content: number
    visualGuide: number
    timing: number
    hashtags: number
    newsSource: number
    sourceUrl: number
    kpis: number
    riskAssessment: number
    optimizationTips: number
    status: number
    editedContent: number
    scheduledAt: number
    postedAt: number
    postId: number
    viralScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CotDraftAvgAggregateInputType = {
    conceptNumber?: true
    viralScore?: true
  }

  export type CotDraftSumAggregateInputType = {
    conceptNumber?: true
    viralScore?: true
  }

  export type CotDraftMinAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    newsSource?: true
    sourceUrl?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotDraftMaxAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    newsSource?: true
    sourceUrl?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotDraftCountAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    thread_content?: true
    visualGuide?: true
    timing?: true
    hashtags?: true
    newsSource?: true
    sourceUrl?: true
    kpis?: true
    riskAssessment?: true
    optimizationTips?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CotDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraft to aggregate.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotDrafts
    **/
    _count?: true | CotDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotDraftMaxAggregateInputType
  }

  export type GetCotDraftAggregateType<T extends CotDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateCotDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotDraft[P]>
      : GetScalarType<T[P], AggregateCotDraft[P]>
  }




  export type CotDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftWhereInput
    orderBy?: CotDraftOrderByWithAggregationInput | CotDraftOrderByWithAggregationInput[]
    by: CotDraftScalarFieldEnum[] | CotDraftScalarFieldEnum
    having?: CotDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotDraftCountAggregateInputType | true
    _avg?: CotDraftAvgAggregateInputType
    _sum?: CotDraftSumAggregateInputType
    _min?: CotDraftMinAggregateInputType
    _max?: CotDraftMaxAggregateInputType
  }

  export type CotDraftGroupByOutputType = {
    id: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content: string | null
    thread_content: JsonValue | null
    visualGuide: string | null
    timing: string
    hashtags: string[]
    newsSource: string | null
    sourceUrl: string | null
    kpis: JsonValue | null
    riskAssessment: JsonValue | null
    optimizationTips: JsonValue | null
    status: $Enums.CotDraftStatus
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: CotDraftCountAggregateOutputType | null
    _avg: CotDraftAvgAggregateOutputType | null
    _sum: CotDraftSumAggregateOutputType | null
    _min: CotDraftMinAggregateOutputType | null
    _max: CotDraftMaxAggregateOutputType | null
  }

  type GetCotDraftGroupByPayload<T extends CotDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotDraftGroupByOutputType[P]>
            : GetScalarType<T[P], CotDraftGroupByOutputType[P]>
        }
      >
    >


  export type CotDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    thread_content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    performance?: boolean | CotDraft$performanceArgs<ExtArgs>
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    thread_content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    thread_content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectScalar = {
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    thread_content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CotDraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "conceptNumber" | "title" | "hook" | "angle" | "format" | "content" | "thread_content" | "visualGuide" | "timing" | "hashtags" | "newsSource" | "sourceUrl" | "kpis" | "riskAssessment" | "optimizationTips" | "status" | "editedContent" | "scheduledAt" | "postedAt" | "postId" | "viralScore" | "createdAt" | "updatedAt", ExtArgs["result"]["cotDraft"]>
  export type CotDraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performance?: boolean | CotDraft$performanceArgs<ExtArgs>
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }
  export type CotDraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }
  export type CotDraftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }

  export type $CotDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotDraft"
    objects: {
      performance: Prisma.$CotDraftPerformancePayload<ExtArgs> | null
      session: Prisma.$CotSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      conceptNumber: number
      title: string
      hook: string
      angle: string
      format: string
      content: string | null
      thread_content: Prisma.JsonValue | null
      visualGuide: string | null
      timing: string
      hashtags: string[]
      newsSource: string | null
      sourceUrl: string | null
      kpis: Prisma.JsonValue | null
      riskAssessment: Prisma.JsonValue | null
      optimizationTips: Prisma.JsonValue | null
      status: $Enums.CotDraftStatus
      editedContent: string | null
      scheduledAt: Date | null
      postedAt: Date | null
      postId: string | null
      viralScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cotDraft"]>
    composites: {}
  }

  type CotDraftGetPayload<S extends boolean | null | undefined | CotDraftDefaultArgs> = $Result.GetResult<Prisma.$CotDraftPayload, S>

  type CotDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CotDraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CotDraftCountAggregateInputType | true
    }

  export interface CotDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotDraft'], meta: { name: 'CotDraft' } }
    /**
     * Find zero or one CotDraft that matches the filter.
     * @param {CotDraftFindUniqueArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotDraftFindUniqueArgs>(args: SelectSubset<T, CotDraftFindUniqueArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CotDraft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CotDraftFindUniqueOrThrowArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotDraftFindUniqueOrThrowArgs>(args: SelectSubset<T, CotDraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindFirstArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotDraftFindFirstArgs>(args?: SelectSubset<T, CotDraftFindFirstArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindFirstOrThrowArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotDraftFindFirstOrThrowArgs>(args?: SelectSubset<T, CotDraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CotDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotDrafts
     * const cotDrafts = await prisma.cotDraft.findMany()
     * 
     * // Get first 10 CotDrafts
     * const cotDrafts = await prisma.cotDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotDraftFindManyArgs>(args?: SelectSubset<T, CotDraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CotDraft.
     * @param {CotDraftCreateArgs} args - Arguments to create a CotDraft.
     * @example
     * // Create one CotDraft
     * const CotDraft = await prisma.cotDraft.create({
     *   data: {
     *     // ... data to create a CotDraft
     *   }
     * })
     * 
     */
    create<T extends CotDraftCreateArgs>(args: SelectSubset<T, CotDraftCreateArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CotDrafts.
     * @param {CotDraftCreateManyArgs} args - Arguments to create many CotDrafts.
     * @example
     * // Create many CotDrafts
     * const cotDraft = await prisma.cotDraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotDraftCreateManyArgs>(args?: SelectSubset<T, CotDraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotDrafts and returns the data saved in the database.
     * @param {CotDraftCreateManyAndReturnArgs} args - Arguments to create many CotDrafts.
     * @example
     * // Create many CotDrafts
     * const cotDraft = await prisma.cotDraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotDrafts and only return the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotDraftCreateManyAndReturnArgs>(args?: SelectSubset<T, CotDraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CotDraft.
     * @param {CotDraftDeleteArgs} args - Arguments to delete one CotDraft.
     * @example
     * // Delete one CotDraft
     * const CotDraft = await prisma.cotDraft.delete({
     *   where: {
     *     // ... filter to delete one CotDraft
     *   }
     * })
     * 
     */
    delete<T extends CotDraftDeleteArgs>(args: SelectSubset<T, CotDraftDeleteArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CotDraft.
     * @param {CotDraftUpdateArgs} args - Arguments to update one CotDraft.
     * @example
     * // Update one CotDraft
     * const cotDraft = await prisma.cotDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotDraftUpdateArgs>(args: SelectSubset<T, CotDraftUpdateArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CotDrafts.
     * @param {CotDraftDeleteManyArgs} args - Arguments to filter CotDrafts to delete.
     * @example
     * // Delete a few CotDrafts
     * const { count } = await prisma.cotDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotDraftDeleteManyArgs>(args?: SelectSubset<T, CotDraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotDrafts
     * const cotDraft = await prisma.cotDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotDraftUpdateManyArgs>(args: SelectSubset<T, CotDraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDrafts and returns the data updated in the database.
     * @param {CotDraftUpdateManyAndReturnArgs} args - Arguments to update many CotDrafts.
     * @example
     * // Update many CotDrafts
     * const cotDraft = await prisma.cotDraft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CotDrafts and only return the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CotDraftUpdateManyAndReturnArgs>(args: SelectSubset<T, CotDraftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CotDraft.
     * @param {CotDraftUpsertArgs} args - Arguments to update or create a CotDraft.
     * @example
     * // Update or create a CotDraft
     * const cotDraft = await prisma.cotDraft.upsert({
     *   create: {
     *     // ... data to create a CotDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotDraft we want to update
     *   }
     * })
     */
    upsert<T extends CotDraftUpsertArgs>(args: SelectSubset<T, CotDraftUpsertArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CotDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftCountArgs} args - Arguments to filter CotDrafts to count.
     * @example
     * // Count the number of CotDrafts
     * const count = await prisma.cotDraft.count({
     *   where: {
     *     // ... the filter for the CotDrafts we want to count
     *   }
     * })
    **/
    count<T extends CotDraftCountArgs>(
      args?: Subset<T, CotDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotDraftAggregateArgs>(args: Subset<T, CotDraftAggregateArgs>): Prisma.PrismaPromise<GetCotDraftAggregateType<T>>

    /**
     * Group by CotDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotDraftGroupByArgs['orderBy'] }
        : { orderBy?: CotDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotDraft model
   */
  readonly fields: CotDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performance<T extends CotDraft$performanceArgs<ExtArgs> = {}>(args?: Subset<T, CotDraft$performanceArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends CotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotSessionDefaultArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotDraft model
   */
  interface CotDraftFieldRefs {
    readonly id: FieldRef<"CotDraft", 'String'>
    readonly sessionId: FieldRef<"CotDraft", 'String'>
    readonly conceptNumber: FieldRef<"CotDraft", 'Int'>
    readonly title: FieldRef<"CotDraft", 'String'>
    readonly hook: FieldRef<"CotDraft", 'String'>
    readonly angle: FieldRef<"CotDraft", 'String'>
    readonly format: FieldRef<"CotDraft", 'String'>
    readonly content: FieldRef<"CotDraft", 'String'>
    readonly thread_content: FieldRef<"CotDraft", 'Json'>
    readonly visualGuide: FieldRef<"CotDraft", 'String'>
    readonly timing: FieldRef<"CotDraft", 'String'>
    readonly hashtags: FieldRef<"CotDraft", 'String[]'>
    readonly newsSource: FieldRef<"CotDraft", 'String'>
    readonly sourceUrl: FieldRef<"CotDraft", 'String'>
    readonly kpis: FieldRef<"CotDraft", 'Json'>
    readonly riskAssessment: FieldRef<"CotDraft", 'Json'>
    readonly optimizationTips: FieldRef<"CotDraft", 'Json'>
    readonly status: FieldRef<"CotDraft", 'CotDraftStatus'>
    readonly editedContent: FieldRef<"CotDraft", 'String'>
    readonly scheduledAt: FieldRef<"CotDraft", 'DateTime'>
    readonly postedAt: FieldRef<"CotDraft", 'DateTime'>
    readonly postId: FieldRef<"CotDraft", 'String'>
    readonly viralScore: FieldRef<"CotDraft", 'Float'>
    readonly createdAt: FieldRef<"CotDraft", 'DateTime'>
    readonly updatedAt: FieldRef<"CotDraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotDraft findUnique
   */
  export type CotDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft findUniqueOrThrow
   */
  export type CotDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft findFirst
   */
  export type CotDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDrafts.
     */
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft findFirstOrThrow
   */
  export type CotDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDrafts.
     */
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft findMany
   */
  export type CotDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDrafts to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft create
   */
  export type CotDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The data needed to create a CotDraft.
     */
    data: XOR<CotDraftCreateInput, CotDraftUncheckedCreateInput>
  }

  /**
   * CotDraft createMany
   */
  export type CotDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotDrafts.
     */
    data: CotDraftCreateManyInput | CotDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotDraft createManyAndReturn
   */
  export type CotDraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * The data used to create many CotDrafts.
     */
    data: CotDraftCreateManyInput | CotDraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraft update
   */
  export type CotDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The data needed to update a CotDraft.
     */
    data: XOR<CotDraftUpdateInput, CotDraftUncheckedUpdateInput>
    /**
     * Choose, which CotDraft to update.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft updateMany
   */
  export type CotDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotDrafts.
     */
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyInput>
    /**
     * Filter which CotDrafts to update
     */
    where?: CotDraftWhereInput
    /**
     * Limit how many CotDrafts to update.
     */
    limit?: number
  }

  /**
   * CotDraft updateManyAndReturn
   */
  export type CotDraftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * The data used to update CotDrafts.
     */
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyInput>
    /**
     * Filter which CotDrafts to update
     */
    where?: CotDraftWhereInput
    /**
     * Limit how many CotDrafts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraft upsert
   */
  export type CotDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The filter to search for the CotDraft to update in case it exists.
     */
    where: CotDraftWhereUniqueInput
    /**
     * In case the CotDraft found by the `where` argument doesn't exist, create a new CotDraft with this data.
     */
    create: XOR<CotDraftCreateInput, CotDraftUncheckedCreateInput>
    /**
     * In case the CotDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotDraftUpdateInput, CotDraftUncheckedUpdateInput>
  }

  /**
   * CotDraft delete
   */
  export type CotDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter which CotDraft to delete.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft deleteMany
   */
  export type CotDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDrafts to delete
     */
    where?: CotDraftWhereInput
    /**
     * Limit how many CotDrafts to delete.
     */
    limit?: number
  }

  /**
   * CotDraft.performance
   */
  export type CotDraft$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraft without action
   */
  export type CotDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraft
     */
    omit?: CotDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
  }


  /**
   * Model CotDraftPerformance
   */

  export type AggregateCotDraftPerformance = {
    _count: CotDraftPerformanceCountAggregateOutputType | null
    _avg: CotDraftPerformanceAvgAggregateOutputType | null
    _sum: CotDraftPerformanceSumAggregateOutputType | null
    _min: CotDraftPerformanceMinAggregateOutputType | null
    _max: CotDraftPerformanceMaxAggregateOutputType | null
  }

  export type CotDraftPerformanceAvgAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type CotDraftPerformanceSumAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type CotDraftPerformanceMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    lastUpdateAt: Date | null
  }

  export type CotDraftPerformanceMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    lastUpdateAt: Date | null
  }

  export type CotDraftPerformanceCountAggregateOutputType = {
    id: number
    draftId: number
    likes30m: number
    retweets30m: number
    replies30m: number
    impressions30m: number
    likes1h: number
    retweets1h: number
    replies1h: number
    impressions1h: number
    likes24h: number
    retweets24h: number
    replies24h: number
    impressions24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    lastUpdateAt: number
    _all: number
  }


  export type CotDraftPerformanceAvgAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type CotDraftPerformanceSumAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type CotDraftPerformanceMinAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
  }

  export type CotDraftPerformanceMaxAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
  }

  export type CotDraftPerformanceCountAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
    _all?: true
  }

  export type CotDraftPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraftPerformance to aggregate.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotDraftPerformances
    **/
    _count?: true | CotDraftPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotDraftPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotDraftPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotDraftPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotDraftPerformanceMaxAggregateInputType
  }

  export type GetCotDraftPerformanceAggregateType<T extends CotDraftPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCotDraftPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotDraftPerformance[P]>
      : GetScalarType<T[P], AggregateCotDraftPerformance[P]>
  }




  export type CotDraftPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftPerformanceWhereInput
    orderBy?: CotDraftPerformanceOrderByWithAggregationInput | CotDraftPerformanceOrderByWithAggregationInput[]
    by: CotDraftPerformanceScalarFieldEnum[] | CotDraftPerformanceScalarFieldEnum
    having?: CotDraftPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotDraftPerformanceCountAggregateInputType | true
    _avg?: CotDraftPerformanceAvgAggregateInputType
    _sum?: CotDraftPerformanceSumAggregateInputType
    _min?: CotDraftPerformanceMinAggregateInputType
    _max?: CotDraftPerformanceMaxAggregateInputType
  }

  export type CotDraftPerformanceGroupByOutputType = {
    id: string
    draftId: string
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    lastUpdateAt: Date
    _count: CotDraftPerformanceCountAggregateOutputType | null
    _avg: CotDraftPerformanceAvgAggregateOutputType | null
    _sum: CotDraftPerformanceSumAggregateOutputType | null
    _min: CotDraftPerformanceMinAggregateOutputType | null
    _max: CotDraftPerformanceMaxAggregateOutputType | null
  }

  type GetCotDraftPerformanceGroupByPayload<T extends CotDraftPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotDraftPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotDraftPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotDraftPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], CotDraftPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type CotDraftPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectScalar = {
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
  }

  export type CotDraftPerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "draftId" | "likes30m" | "retweets30m" | "replies30m" | "impressions30m" | "likes1h" | "retweets1h" | "replies1h" | "impressions1h" | "likes24h" | "retweets24h" | "replies24h" | "impressions24h" | "engagementRate" | "viralCoefficient" | "collectedAt" | "lastUpdateAt", ExtArgs["result"]["cotDraftPerformance"]>
  export type CotDraftPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }
  export type CotDraftPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }
  export type CotDraftPerformanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }

  export type $CotDraftPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotDraftPerformance"
    objects: {
      draft: Prisma.$CotDraftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      likes30m: number | null
      retweets30m: number | null
      replies30m: number | null
      impressions30m: number | null
      likes1h: number | null
      retweets1h: number | null
      replies1h: number | null
      impressions1h: number | null
      likes24h: number | null
      retweets24h: number | null
      replies24h: number | null
      impressions24h: number | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      lastUpdateAt: Date
    }, ExtArgs["result"]["cotDraftPerformance"]>
    composites: {}
  }

  type CotDraftPerformanceGetPayload<S extends boolean | null | undefined | CotDraftPerformanceDefaultArgs> = $Result.GetResult<Prisma.$CotDraftPerformancePayload, S>

  type CotDraftPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CotDraftPerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CotDraftPerformanceCountAggregateInputType | true
    }

  export interface CotDraftPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotDraftPerformance'], meta: { name: 'CotDraftPerformance' } }
    /**
     * Find zero or one CotDraftPerformance that matches the filter.
     * @param {CotDraftPerformanceFindUniqueArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotDraftPerformanceFindUniqueArgs>(args: SelectSubset<T, CotDraftPerformanceFindUniqueArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CotDraftPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CotDraftPerformanceFindUniqueOrThrowArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotDraftPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotDraftPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindFirstArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotDraftPerformanceFindFirstArgs>(args?: SelectSubset<T, CotDraftPerformanceFindFirstArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CotDraftPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindFirstOrThrowArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotDraftPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CotDraftPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotDraftPerformances
     * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany()
     * 
     * // Get first 10 CotDraftPerformances
     * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotDraftPerformanceFindManyArgs>(args?: SelectSubset<T, CotDraftPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CotDraftPerformance.
     * @param {CotDraftPerformanceCreateArgs} args - Arguments to create a CotDraftPerformance.
     * @example
     * // Create one CotDraftPerformance
     * const CotDraftPerformance = await prisma.cotDraftPerformance.create({
     *   data: {
     *     // ... data to create a CotDraftPerformance
     *   }
     * })
     * 
     */
    create<T extends CotDraftPerformanceCreateArgs>(args: SelectSubset<T, CotDraftPerformanceCreateArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CotDraftPerformances.
     * @param {CotDraftPerformanceCreateManyArgs} args - Arguments to create many CotDraftPerformances.
     * @example
     * // Create many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotDraftPerformanceCreateManyArgs>(args?: SelectSubset<T, CotDraftPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotDraftPerformances and returns the data saved in the database.
     * @param {CotDraftPerformanceCreateManyAndReturnArgs} args - Arguments to create many CotDraftPerformances.
     * @example
     * // Create many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotDraftPerformances and only return the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotDraftPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CotDraftPerformance.
     * @param {CotDraftPerformanceDeleteArgs} args - Arguments to delete one CotDraftPerformance.
     * @example
     * // Delete one CotDraftPerformance
     * const CotDraftPerformance = await prisma.cotDraftPerformance.delete({
     *   where: {
     *     // ... filter to delete one CotDraftPerformance
     *   }
     * })
     * 
     */
    delete<T extends CotDraftPerformanceDeleteArgs>(args: SelectSubset<T, CotDraftPerformanceDeleteArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CotDraftPerformance.
     * @param {CotDraftPerformanceUpdateArgs} args - Arguments to update one CotDraftPerformance.
     * @example
     * // Update one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotDraftPerformanceUpdateArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CotDraftPerformances.
     * @param {CotDraftPerformanceDeleteManyArgs} args - Arguments to filter CotDraftPerformances to delete.
     * @example
     * // Delete a few CotDraftPerformances
     * const { count } = await prisma.cotDraftPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotDraftPerformanceDeleteManyArgs>(args?: SelectSubset<T, CotDraftPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotDraftPerformanceUpdateManyArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDraftPerformances and returns the data updated in the database.
     * @param {CotDraftPerformanceUpdateManyAndReturnArgs} args - Arguments to update many CotDraftPerformances.
     * @example
     * // Update many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CotDraftPerformances and only return the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CotDraftPerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CotDraftPerformance.
     * @param {CotDraftPerformanceUpsertArgs} args - Arguments to update or create a CotDraftPerformance.
     * @example
     * // Update or create a CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.upsert({
     *   create: {
     *     // ... data to create a CotDraftPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotDraftPerformance we want to update
     *   }
     * })
     */
    upsert<T extends CotDraftPerformanceUpsertArgs>(args: SelectSubset<T, CotDraftPerformanceUpsertArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CotDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceCountArgs} args - Arguments to filter CotDraftPerformances to count.
     * @example
     * // Count the number of CotDraftPerformances
     * const count = await prisma.cotDraftPerformance.count({
     *   where: {
     *     // ... the filter for the CotDraftPerformances we want to count
     *   }
     * })
    **/
    count<T extends CotDraftPerformanceCountArgs>(
      args?: Subset<T, CotDraftPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotDraftPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotDraftPerformanceAggregateArgs>(args: Subset<T, CotDraftPerformanceAggregateArgs>): Prisma.PrismaPromise<GetCotDraftPerformanceAggregateType<T>>

    /**
     * Group by CotDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotDraftPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotDraftPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: CotDraftPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotDraftPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotDraftPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotDraftPerformance model
   */
  readonly fields: CotDraftPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotDraftPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotDraftPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends CotDraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotDraftDefaultArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotDraftPerformance model
   */
  interface CotDraftPerformanceFieldRefs {
    readonly id: FieldRef<"CotDraftPerformance", 'String'>
    readonly draftId: FieldRef<"CotDraftPerformance", 'String'>
    readonly likes30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly likes1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly likes24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly engagementRate: FieldRef<"CotDraftPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"CotDraftPerformance", 'Float'>
    readonly collectedAt: FieldRef<"CotDraftPerformance", 'DateTime'>
    readonly lastUpdateAt: FieldRef<"CotDraftPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotDraftPerformance findUnique
   */
  export type CotDraftPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance findUniqueOrThrow
   */
  export type CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance findFirst
   */
  export type CotDraftPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDraftPerformances.
     */
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance findFirstOrThrow
   */
  export type CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDraftPerformances.
     */
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance findMany
   */
  export type CotDraftPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformances to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance create
   */
  export type CotDraftPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a CotDraftPerformance.
     */
    data: XOR<CotDraftPerformanceCreateInput, CotDraftPerformanceUncheckedCreateInput>
  }

  /**
   * CotDraftPerformance createMany
   */
  export type CotDraftPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotDraftPerformances.
     */
    data: CotDraftPerformanceCreateManyInput | CotDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotDraftPerformance createManyAndReturn
   */
  export type CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many CotDraftPerformances.
     */
    data: CotDraftPerformanceCreateManyInput | CotDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraftPerformance update
   */
  export type CotDraftPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a CotDraftPerformance.
     */
    data: XOR<CotDraftPerformanceUpdateInput, CotDraftPerformanceUncheckedUpdateInput>
    /**
     * Choose, which CotDraftPerformance to update.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance updateMany
   */
  export type CotDraftPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotDraftPerformances.
     */
    data: XOR<CotDraftPerformanceUpdateManyMutationInput, CotDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which CotDraftPerformances to update
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * Limit how many CotDraftPerformances to update.
     */
    limit?: number
  }

  /**
   * CotDraftPerformance updateManyAndReturn
   */
  export type CotDraftPerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * The data used to update CotDraftPerformances.
     */
    data: XOR<CotDraftPerformanceUpdateManyMutationInput, CotDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which CotDraftPerformances to update
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * Limit how many CotDraftPerformances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraftPerformance upsert
   */
  export type CotDraftPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the CotDraftPerformance to update in case it exists.
     */
    where: CotDraftPerformanceWhereUniqueInput
    /**
     * In case the CotDraftPerformance found by the `where` argument doesn't exist, create a new CotDraftPerformance with this data.
     */
    create: XOR<CotDraftPerformanceCreateInput, CotDraftPerformanceUncheckedCreateInput>
    /**
     * In case the CotDraftPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotDraftPerformanceUpdateInput, CotDraftPerformanceUncheckedUpdateInput>
  }

  /**
   * CotDraftPerformance delete
   */
  export type CotDraftPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter which CotDraftPerformance to delete.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance deleteMany
   */
  export type CotDraftPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraftPerformances to delete
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * Limit how many CotDraftPerformances to delete.
     */
    limit?: number
  }

  /**
   * CotDraftPerformance without action
   */
  export type CotDraftPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CotDraftPerformance
     */
    omit?: CotDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledRetweet
   */

  export type AggregateScheduledRetweet = {
    _count: ScheduledRetweetCountAggregateOutputType | null
    _min: ScheduledRetweetMinAggregateOutputType | null
    _max: ScheduledRetweetMaxAggregateOutputType | null
  }

  export type ScheduledRetweetMinAggregateOutputType = {
    id: string | null
    originalPostId: string | null
    originalContent: string | null
    scheduledAt: Date | null
    status: $Enums.RTStatus | null
    rtStrategy: string | null
    addComment: boolean | null
    commentText: string | null
    viralDraftId: string | null
    cotDraftId: string | null
    executedAt: Date | null
    rtPostId: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledRetweetMaxAggregateOutputType = {
    id: string | null
    originalPostId: string | null
    originalContent: string | null
    scheduledAt: Date | null
    status: $Enums.RTStatus | null
    rtStrategy: string | null
    addComment: boolean | null
    commentText: string | null
    viralDraftId: string | null
    cotDraftId: string | null
    executedAt: Date | null
    rtPostId: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledRetweetCountAggregateOutputType = {
    id: number
    originalPostId: number
    originalContent: number
    scheduledAt: number
    status: number
    rtStrategy: number
    addComment: number
    commentText: number
    viralDraftId: number
    cotDraftId: number
    executedAt: number
    rtPostId: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledRetweetMinAggregateInputType = {
    id?: true
    originalPostId?: true
    originalContent?: true
    scheduledAt?: true
    status?: true
    rtStrategy?: true
    addComment?: true
    commentText?: true
    viralDraftId?: true
    cotDraftId?: true
    executedAt?: true
    rtPostId?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledRetweetMaxAggregateInputType = {
    id?: true
    originalPostId?: true
    originalContent?: true
    scheduledAt?: true
    status?: true
    rtStrategy?: true
    addComment?: true
    commentText?: true
    viralDraftId?: true
    cotDraftId?: true
    executedAt?: true
    rtPostId?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledRetweetCountAggregateInputType = {
    id?: true
    originalPostId?: true
    originalContent?: true
    scheduledAt?: true
    status?: true
    rtStrategy?: true
    addComment?: true
    commentText?: true
    viralDraftId?: true
    cotDraftId?: true
    executedAt?: true
    rtPostId?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledRetweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledRetweet to aggregate.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledRetweets
    **/
    _count?: true | ScheduledRetweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledRetweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledRetweetMaxAggregateInputType
  }

  export type GetScheduledRetweetAggregateType<T extends ScheduledRetweetAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledRetweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledRetweet[P]>
      : GetScalarType<T[P], AggregateScheduledRetweet[P]>
  }




  export type ScheduledRetweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledRetweetWhereInput
    orderBy?: ScheduledRetweetOrderByWithAggregationInput | ScheduledRetweetOrderByWithAggregationInput[]
    by: ScheduledRetweetScalarFieldEnum[] | ScheduledRetweetScalarFieldEnum
    having?: ScheduledRetweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledRetweetCountAggregateInputType | true
    _min?: ScheduledRetweetMinAggregateInputType
    _max?: ScheduledRetweetMaxAggregateInputType
  }

  export type ScheduledRetweetGroupByOutputType = {
    id: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date
    status: $Enums.RTStatus
    rtStrategy: string
    addComment: boolean
    commentText: string | null
    viralDraftId: string | null
    cotDraftId: string | null
    executedAt: Date | null
    rtPostId: string | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledRetweetCountAggregateOutputType | null
    _min: ScheduledRetweetMinAggregateOutputType | null
    _max: ScheduledRetweetMaxAggregateOutputType | null
  }

  type GetScheduledRetweetGroupByPayload<T extends ScheduledRetweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledRetweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledRetweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledRetweetGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledRetweetGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledRetweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduledRetweet"]>

  export type ScheduledRetweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduledRetweet"]>

  export type ScheduledRetweetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduledRetweet"]>

  export type ScheduledRetweetSelectScalar = {
    id?: boolean
    originalPostId?: boolean
    originalContent?: boolean
    scheduledAt?: boolean
    status?: boolean
    rtStrategy?: boolean
    addComment?: boolean
    commentText?: boolean
    viralDraftId?: boolean
    cotDraftId?: boolean
    executedAt?: boolean
    rtPostId?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledRetweetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originalPostId" | "originalContent" | "scheduledAt" | "status" | "rtStrategy" | "addComment" | "commentText" | "viralDraftId" | "cotDraftId" | "executedAt" | "rtPostId" | "error" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduledRetweet"]>

  export type $ScheduledRetweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledRetweet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      originalPostId: string
      originalContent: string
      scheduledAt: Date
      status: $Enums.RTStatus
      rtStrategy: string
      addComment: boolean
      commentText: string | null
      viralDraftId: string | null
      cotDraftId: string | null
      executedAt: Date | null
      rtPostId: string | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledRetweet"]>
    composites: {}
  }

  type ScheduledRetweetGetPayload<S extends boolean | null | undefined | ScheduledRetweetDefaultArgs> = $Result.GetResult<Prisma.$ScheduledRetweetPayload, S>

  type ScheduledRetweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledRetweetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledRetweetCountAggregateInputType | true
    }

  export interface ScheduledRetweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledRetweet'], meta: { name: 'ScheduledRetweet' } }
    /**
     * Find zero or one ScheduledRetweet that matches the filter.
     * @param {ScheduledRetweetFindUniqueArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledRetweetFindUniqueArgs>(args: SelectSubset<T, ScheduledRetweetFindUniqueArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledRetweet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledRetweetFindUniqueOrThrowArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledRetweetFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledRetweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledRetweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetFindFirstArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledRetweetFindFirstArgs>(args?: SelectSubset<T, ScheduledRetweetFindFirstArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledRetweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetFindFirstOrThrowArgs} args - Arguments to find a ScheduledRetweet
     * @example
     * // Get one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledRetweetFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledRetweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledRetweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledRetweets
     * const scheduledRetweets = await prisma.scheduledRetweet.findMany()
     * 
     * // Get first 10 ScheduledRetweets
     * const scheduledRetweets = await prisma.scheduledRetweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledRetweetWithIdOnly = await prisma.scheduledRetweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledRetweetFindManyArgs>(args?: SelectSubset<T, ScheduledRetweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledRetweet.
     * @param {ScheduledRetweetCreateArgs} args - Arguments to create a ScheduledRetweet.
     * @example
     * // Create one ScheduledRetweet
     * const ScheduledRetweet = await prisma.scheduledRetweet.create({
     *   data: {
     *     // ... data to create a ScheduledRetweet
     *   }
     * })
     * 
     */
    create<T extends ScheduledRetweetCreateArgs>(args: SelectSubset<T, ScheduledRetweetCreateArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledRetweets.
     * @param {ScheduledRetweetCreateManyArgs} args - Arguments to create many ScheduledRetweets.
     * @example
     * // Create many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledRetweetCreateManyArgs>(args?: SelectSubset<T, ScheduledRetweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledRetweets and returns the data saved in the database.
     * @param {ScheduledRetweetCreateManyAndReturnArgs} args - Arguments to create many ScheduledRetweets.
     * @example
     * // Create many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledRetweets and only return the `id`
     * const scheduledRetweetWithIdOnly = await prisma.scheduledRetweet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledRetweetCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledRetweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledRetweet.
     * @param {ScheduledRetweetDeleteArgs} args - Arguments to delete one ScheduledRetweet.
     * @example
     * // Delete one ScheduledRetweet
     * const ScheduledRetweet = await prisma.scheduledRetweet.delete({
     *   where: {
     *     // ... filter to delete one ScheduledRetweet
     *   }
     * })
     * 
     */
    delete<T extends ScheduledRetweetDeleteArgs>(args: SelectSubset<T, ScheduledRetweetDeleteArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledRetweet.
     * @param {ScheduledRetweetUpdateArgs} args - Arguments to update one ScheduledRetweet.
     * @example
     * // Update one ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledRetweetUpdateArgs>(args: SelectSubset<T, ScheduledRetweetUpdateArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledRetweets.
     * @param {ScheduledRetweetDeleteManyArgs} args - Arguments to filter ScheduledRetweets to delete.
     * @example
     * // Delete a few ScheduledRetweets
     * const { count } = await prisma.scheduledRetweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledRetweetDeleteManyArgs>(args?: SelectSubset<T, ScheduledRetweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledRetweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledRetweetUpdateManyArgs>(args: SelectSubset<T, ScheduledRetweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledRetweets and returns the data updated in the database.
     * @param {ScheduledRetweetUpdateManyAndReturnArgs} args - Arguments to update many ScheduledRetweets.
     * @example
     * // Update many ScheduledRetweets
     * const scheduledRetweet = await prisma.scheduledRetweet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledRetweets and only return the `id`
     * const scheduledRetweetWithIdOnly = await prisma.scheduledRetweet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledRetweetUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledRetweetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledRetweet.
     * @param {ScheduledRetweetUpsertArgs} args - Arguments to update or create a ScheduledRetweet.
     * @example
     * // Update or create a ScheduledRetweet
     * const scheduledRetweet = await prisma.scheduledRetweet.upsert({
     *   create: {
     *     // ... data to create a ScheduledRetweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledRetweet we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledRetweetUpsertArgs>(args: SelectSubset<T, ScheduledRetweetUpsertArgs<ExtArgs>>): Prisma__ScheduledRetweetClient<$Result.GetResult<Prisma.$ScheduledRetweetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledRetweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetCountArgs} args - Arguments to filter ScheduledRetweets to count.
     * @example
     * // Count the number of ScheduledRetweets
     * const count = await prisma.scheduledRetweet.count({
     *   where: {
     *     // ... the filter for the ScheduledRetweets we want to count
     *   }
     * })
    **/
    count<T extends ScheduledRetweetCountArgs>(
      args?: Subset<T, ScheduledRetweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledRetweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledRetweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledRetweetAggregateArgs>(args: Subset<T, ScheduledRetweetAggregateArgs>): Prisma.PrismaPromise<GetScheduledRetweetAggregateType<T>>

    /**
     * Group by ScheduledRetweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRetweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledRetweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledRetweetGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledRetweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledRetweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledRetweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledRetweet model
   */
  readonly fields: ScheduledRetweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledRetweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledRetweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledRetweet model
   */
  interface ScheduledRetweetFieldRefs {
    readonly id: FieldRef<"ScheduledRetweet", 'String'>
    readonly originalPostId: FieldRef<"ScheduledRetweet", 'String'>
    readonly originalContent: FieldRef<"ScheduledRetweet", 'String'>
    readonly scheduledAt: FieldRef<"ScheduledRetweet", 'DateTime'>
    readonly status: FieldRef<"ScheduledRetweet", 'RTStatus'>
    readonly rtStrategy: FieldRef<"ScheduledRetweet", 'String'>
    readonly addComment: FieldRef<"ScheduledRetweet", 'Boolean'>
    readonly commentText: FieldRef<"ScheduledRetweet", 'String'>
    readonly viralDraftId: FieldRef<"ScheduledRetweet", 'String'>
    readonly cotDraftId: FieldRef<"ScheduledRetweet", 'String'>
    readonly executedAt: FieldRef<"ScheduledRetweet", 'DateTime'>
    readonly rtPostId: FieldRef<"ScheduledRetweet", 'String'>
    readonly error: FieldRef<"ScheduledRetweet", 'String'>
    readonly createdAt: FieldRef<"ScheduledRetweet", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledRetweet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledRetweet findUnique
   */
  export type ScheduledRetweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet findUniqueOrThrow
   */
  export type ScheduledRetweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet findFirst
   */
  export type ScheduledRetweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledRetweets.
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledRetweets.
     */
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ScheduledRetweet findFirstOrThrow
   */
  export type ScheduledRetweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweet to fetch.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledRetweets.
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledRetweets.
     */
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ScheduledRetweet findMany
   */
  export type ScheduledRetweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledRetweets to fetch.
     */
    where?: ScheduledRetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRetweets to fetch.
     */
    orderBy?: ScheduledRetweetOrderByWithRelationInput | ScheduledRetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledRetweets.
     */
    cursor?: ScheduledRetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRetweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRetweets.
     */
    skip?: number
    distinct?: ScheduledRetweetScalarFieldEnum | ScheduledRetweetScalarFieldEnum[]
  }

  /**
   * ScheduledRetweet create
   */
  export type ScheduledRetweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * The data needed to create a ScheduledRetweet.
     */
    data: XOR<ScheduledRetweetCreateInput, ScheduledRetweetUncheckedCreateInput>
  }

  /**
   * ScheduledRetweet createMany
   */
  export type ScheduledRetweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledRetweets.
     */
    data: ScheduledRetweetCreateManyInput | ScheduledRetweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledRetweet createManyAndReturn
   */
  export type ScheduledRetweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledRetweets.
     */
    data: ScheduledRetweetCreateManyInput | ScheduledRetweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledRetweet update
   */
  export type ScheduledRetweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * The data needed to update a ScheduledRetweet.
     */
    data: XOR<ScheduledRetweetUpdateInput, ScheduledRetweetUncheckedUpdateInput>
    /**
     * Choose, which ScheduledRetweet to update.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet updateMany
   */
  export type ScheduledRetweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledRetweets.
     */
    data: XOR<ScheduledRetweetUpdateManyMutationInput, ScheduledRetweetUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledRetweets to update
     */
    where?: ScheduledRetweetWhereInput
    /**
     * Limit how many ScheduledRetweets to update.
     */
    limit?: number
  }

  /**
   * ScheduledRetweet updateManyAndReturn
   */
  export type ScheduledRetweetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledRetweets.
     */
    data: XOR<ScheduledRetweetUpdateManyMutationInput, ScheduledRetweetUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledRetweets to update
     */
    where?: ScheduledRetweetWhereInput
    /**
     * Limit how many ScheduledRetweets to update.
     */
    limit?: number
  }

  /**
   * ScheduledRetweet upsert
   */
  export type ScheduledRetweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * The filter to search for the ScheduledRetweet to update in case it exists.
     */
    where: ScheduledRetweetWhereUniqueInput
    /**
     * In case the ScheduledRetweet found by the `where` argument doesn't exist, create a new ScheduledRetweet with this data.
     */
    create: XOR<ScheduledRetweetCreateInput, ScheduledRetweetUncheckedCreateInput>
    /**
     * In case the ScheduledRetweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledRetweetUpdateInput, ScheduledRetweetUncheckedUpdateInput>
  }

  /**
   * ScheduledRetweet delete
   */
  export type ScheduledRetweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
    /**
     * Filter which ScheduledRetweet to delete.
     */
    where: ScheduledRetweetWhereUniqueInput
  }

  /**
   * ScheduledRetweet deleteMany
   */
  export type ScheduledRetweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledRetweets to delete
     */
    where?: ScheduledRetweetWhereInput
    /**
     * Limit how many ScheduledRetweets to delete.
     */
    limit?: number
  }

  /**
   * ScheduledRetweet without action
   */
  export type ScheduledRetweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRetweet
     */
    select?: ScheduledRetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledRetweet
     */
    omit?: ScheduledRetweetOmit<ExtArgs> | null
  }


  /**
   * Model UnifiedPerformance
   */

  export type AggregateUnifiedPerformance = {
    _count: UnifiedPerformanceCountAggregateOutputType | null
    _avg: UnifiedPerformanceAvgAggregateOutputType | null
    _sum: UnifiedPerformanceSumAggregateOutputType | null
    _min: UnifiedPerformanceMinAggregateOutputType | null
    _max: UnifiedPerformanceMaxAggregateOutputType | null
  }

  export type UnifiedPerformanceAvgAggregateOutputType = {
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type UnifiedPerformanceSumAggregateOutputType = {
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type UnifiedPerformanceMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    contentType: string | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedPerformanceMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    contentType: string | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedPerformanceCountAggregateOutputType = {
    id: number
    contentId: number
    contentType: number
    metrics30m: number
    metrics1h: number
    metrics24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    updatedAt: number
    _all: number
  }


  export type UnifiedPerformanceAvgAggregateInputType = {
    engagementRate?: true
    viralCoefficient?: true
  }

  export type UnifiedPerformanceSumAggregateInputType = {
    engagementRate?: true
    viralCoefficient?: true
  }

  export type UnifiedPerformanceMinAggregateInputType = {
    id?: true
    contentId?: true
    contentType?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type UnifiedPerformanceMaxAggregateInputType = {
    id?: true
    contentId?: true
    contentType?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type UnifiedPerformanceCountAggregateInputType = {
    id?: true
    contentId?: true
    contentType?: true
    metrics30m?: true
    metrics1h?: true
    metrics24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnifiedPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedPerformance to aggregate.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnifiedPerformances
    **/
    _count?: true | UnifiedPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnifiedPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnifiedPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnifiedPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnifiedPerformanceMaxAggregateInputType
  }

  export type GetUnifiedPerformanceAggregateType<T extends UnifiedPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateUnifiedPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnifiedPerformance[P]>
      : GetScalarType<T[P], AggregateUnifiedPerformance[P]>
  }




  export type UnifiedPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnifiedPerformanceWhereInput
    orderBy?: UnifiedPerformanceOrderByWithAggregationInput | UnifiedPerformanceOrderByWithAggregationInput[]
    by: UnifiedPerformanceScalarFieldEnum[] | UnifiedPerformanceScalarFieldEnum
    having?: UnifiedPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnifiedPerformanceCountAggregateInputType | true
    _avg?: UnifiedPerformanceAvgAggregateInputType
    _sum?: UnifiedPerformanceSumAggregateInputType
    _min?: UnifiedPerformanceMinAggregateInputType
    _max?: UnifiedPerformanceMaxAggregateInputType
  }

  export type UnifiedPerformanceGroupByOutputType = {
    id: string
    contentId: string
    contentType: string
    metrics30m: JsonValue | null
    metrics1h: JsonValue | null
    metrics24h: JsonValue | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    updatedAt: Date
    _count: UnifiedPerformanceCountAggregateOutputType | null
    _avg: UnifiedPerformanceAvgAggregateOutputType | null
    _sum: UnifiedPerformanceSumAggregateOutputType | null
    _min: UnifiedPerformanceMinAggregateOutputType | null
    _max: UnifiedPerformanceMaxAggregateOutputType | null
  }

  type GetUnifiedPerformanceGroupByPayload<T extends UnifiedPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnifiedPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnifiedPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnifiedPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], UnifiedPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type UnifiedPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedPerformance"]>

  export type UnifiedPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedPerformance"]>

  export type UnifiedPerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedPerformance"]>

  export type UnifiedPerformanceSelectScalar = {
    id?: boolean
    contentId?: boolean
    contentType?: boolean
    metrics30m?: boolean
    metrics1h?: boolean
    metrics24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }

  export type UnifiedPerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentId" | "contentType" | "metrics30m" | "metrics1h" | "metrics24h" | "engagementRate" | "viralCoefficient" | "collectedAt" | "updatedAt", ExtArgs["result"]["unifiedPerformance"]>

  export type $UnifiedPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnifiedPerformance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      contentType: string
      metrics30m: Prisma.JsonValue | null
      metrics1h: Prisma.JsonValue | null
      metrics24h: Prisma.JsonValue | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unifiedPerformance"]>
    composites: {}
  }

  type UnifiedPerformanceGetPayload<S extends boolean | null | undefined | UnifiedPerformanceDefaultArgs> = $Result.GetResult<Prisma.$UnifiedPerformancePayload, S>

  type UnifiedPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnifiedPerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnifiedPerformanceCountAggregateInputType | true
    }

  export interface UnifiedPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnifiedPerformance'], meta: { name: 'UnifiedPerformance' } }
    /**
     * Find zero or one UnifiedPerformance that matches the filter.
     * @param {UnifiedPerformanceFindUniqueArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnifiedPerformanceFindUniqueArgs>(args: SelectSubset<T, UnifiedPerformanceFindUniqueArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnifiedPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnifiedPerformanceFindUniqueOrThrowArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnifiedPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, UnifiedPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnifiedPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceFindFirstArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnifiedPerformanceFindFirstArgs>(args?: SelectSubset<T, UnifiedPerformanceFindFirstArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnifiedPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceFindFirstOrThrowArgs} args - Arguments to find a UnifiedPerformance
     * @example
     * // Get one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnifiedPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, UnifiedPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnifiedPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnifiedPerformances
     * const unifiedPerformances = await prisma.unifiedPerformance.findMany()
     * 
     * // Get first 10 UnifiedPerformances
     * const unifiedPerformances = await prisma.unifiedPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unifiedPerformanceWithIdOnly = await prisma.unifiedPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnifiedPerformanceFindManyArgs>(args?: SelectSubset<T, UnifiedPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnifiedPerformance.
     * @param {UnifiedPerformanceCreateArgs} args - Arguments to create a UnifiedPerformance.
     * @example
     * // Create one UnifiedPerformance
     * const UnifiedPerformance = await prisma.unifiedPerformance.create({
     *   data: {
     *     // ... data to create a UnifiedPerformance
     *   }
     * })
     * 
     */
    create<T extends UnifiedPerformanceCreateArgs>(args: SelectSubset<T, UnifiedPerformanceCreateArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnifiedPerformances.
     * @param {UnifiedPerformanceCreateManyArgs} args - Arguments to create many UnifiedPerformances.
     * @example
     * // Create many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnifiedPerformanceCreateManyArgs>(args?: SelectSubset<T, UnifiedPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnifiedPerformances and returns the data saved in the database.
     * @param {UnifiedPerformanceCreateManyAndReturnArgs} args - Arguments to create many UnifiedPerformances.
     * @example
     * // Create many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnifiedPerformances and only return the `id`
     * const unifiedPerformanceWithIdOnly = await prisma.unifiedPerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnifiedPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, UnifiedPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnifiedPerformance.
     * @param {UnifiedPerformanceDeleteArgs} args - Arguments to delete one UnifiedPerformance.
     * @example
     * // Delete one UnifiedPerformance
     * const UnifiedPerformance = await prisma.unifiedPerformance.delete({
     *   where: {
     *     // ... filter to delete one UnifiedPerformance
     *   }
     * })
     * 
     */
    delete<T extends UnifiedPerformanceDeleteArgs>(args: SelectSubset<T, UnifiedPerformanceDeleteArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnifiedPerformance.
     * @param {UnifiedPerformanceUpdateArgs} args - Arguments to update one UnifiedPerformance.
     * @example
     * // Update one UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnifiedPerformanceUpdateArgs>(args: SelectSubset<T, UnifiedPerformanceUpdateArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnifiedPerformances.
     * @param {UnifiedPerformanceDeleteManyArgs} args - Arguments to filter UnifiedPerformances to delete.
     * @example
     * // Delete a few UnifiedPerformances
     * const { count } = await prisma.unifiedPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnifiedPerformanceDeleteManyArgs>(args?: SelectSubset<T, UnifiedPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnifiedPerformanceUpdateManyArgs>(args: SelectSubset<T, UnifiedPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedPerformances and returns the data updated in the database.
     * @param {UnifiedPerformanceUpdateManyAndReturnArgs} args - Arguments to update many UnifiedPerformances.
     * @example
     * // Update many UnifiedPerformances
     * const unifiedPerformance = await prisma.unifiedPerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnifiedPerformances and only return the `id`
     * const unifiedPerformanceWithIdOnly = await prisma.unifiedPerformance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnifiedPerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, UnifiedPerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnifiedPerformance.
     * @param {UnifiedPerformanceUpsertArgs} args - Arguments to update or create a UnifiedPerformance.
     * @example
     * // Update or create a UnifiedPerformance
     * const unifiedPerformance = await prisma.unifiedPerformance.upsert({
     *   create: {
     *     // ... data to create a UnifiedPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnifiedPerformance we want to update
     *   }
     * })
     */
    upsert<T extends UnifiedPerformanceUpsertArgs>(args: SelectSubset<T, UnifiedPerformanceUpsertArgs<ExtArgs>>): Prisma__UnifiedPerformanceClient<$Result.GetResult<Prisma.$UnifiedPerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnifiedPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceCountArgs} args - Arguments to filter UnifiedPerformances to count.
     * @example
     * // Count the number of UnifiedPerformances
     * const count = await prisma.unifiedPerformance.count({
     *   where: {
     *     // ... the filter for the UnifiedPerformances we want to count
     *   }
     * })
    **/
    count<T extends UnifiedPerformanceCountArgs>(
      args?: Subset<T, UnifiedPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnifiedPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnifiedPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnifiedPerformanceAggregateArgs>(args: Subset<T, UnifiedPerformanceAggregateArgs>): Prisma.PrismaPromise<GetUnifiedPerformanceAggregateType<T>>

    /**
     * Group by UnifiedPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnifiedPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnifiedPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: UnifiedPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnifiedPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnifiedPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnifiedPerformance model
   */
  readonly fields: UnifiedPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnifiedPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnifiedPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnifiedPerformance model
   */
  interface UnifiedPerformanceFieldRefs {
    readonly id: FieldRef<"UnifiedPerformance", 'String'>
    readonly contentId: FieldRef<"UnifiedPerformance", 'String'>
    readonly contentType: FieldRef<"UnifiedPerformance", 'String'>
    readonly metrics30m: FieldRef<"UnifiedPerformance", 'Json'>
    readonly metrics1h: FieldRef<"UnifiedPerformance", 'Json'>
    readonly metrics24h: FieldRef<"UnifiedPerformance", 'Json'>
    readonly engagementRate: FieldRef<"UnifiedPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"UnifiedPerformance", 'Float'>
    readonly collectedAt: FieldRef<"UnifiedPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"UnifiedPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnifiedPerformance findUnique
   */
  export type UnifiedPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance findUniqueOrThrow
   */
  export type UnifiedPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance findFirst
   */
  export type UnifiedPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedPerformances.
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedPerformances.
     */
    distinct?: UnifiedPerformanceScalarFieldEnum | UnifiedPerformanceScalarFieldEnum[]
  }

  /**
   * UnifiedPerformance findFirstOrThrow
   */
  export type UnifiedPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformance to fetch.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedPerformances.
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedPerformances.
     */
    distinct?: UnifiedPerformanceScalarFieldEnum | UnifiedPerformanceScalarFieldEnum[]
  }

  /**
   * UnifiedPerformance findMany
   */
  export type UnifiedPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which UnifiedPerformances to fetch.
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedPerformances to fetch.
     */
    orderBy?: UnifiedPerformanceOrderByWithRelationInput | UnifiedPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnifiedPerformances.
     */
    cursor?: UnifiedPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedPerformances.
     */
    skip?: number
    distinct?: UnifiedPerformanceScalarFieldEnum | UnifiedPerformanceScalarFieldEnum[]
  }

  /**
   * UnifiedPerformance create
   */
  export type UnifiedPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * The data needed to create a UnifiedPerformance.
     */
    data: XOR<UnifiedPerformanceCreateInput, UnifiedPerformanceUncheckedCreateInput>
  }

  /**
   * UnifiedPerformance createMany
   */
  export type UnifiedPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnifiedPerformances.
     */
    data: UnifiedPerformanceCreateManyInput | UnifiedPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedPerformance createManyAndReturn
   */
  export type UnifiedPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many UnifiedPerformances.
     */
    data: UnifiedPerformanceCreateManyInput | UnifiedPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedPerformance update
   */
  export type UnifiedPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * The data needed to update a UnifiedPerformance.
     */
    data: XOR<UnifiedPerformanceUpdateInput, UnifiedPerformanceUncheckedUpdateInput>
    /**
     * Choose, which UnifiedPerformance to update.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance updateMany
   */
  export type UnifiedPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnifiedPerformances.
     */
    data: XOR<UnifiedPerformanceUpdateManyMutationInput, UnifiedPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedPerformances to update
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * Limit how many UnifiedPerformances to update.
     */
    limit?: number
  }

  /**
   * UnifiedPerformance updateManyAndReturn
   */
  export type UnifiedPerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * The data used to update UnifiedPerformances.
     */
    data: XOR<UnifiedPerformanceUpdateManyMutationInput, UnifiedPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedPerformances to update
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * Limit how many UnifiedPerformances to update.
     */
    limit?: number
  }

  /**
   * UnifiedPerformance upsert
   */
  export type UnifiedPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * The filter to search for the UnifiedPerformance to update in case it exists.
     */
    where: UnifiedPerformanceWhereUniqueInput
    /**
     * In case the UnifiedPerformance found by the `where` argument doesn't exist, create a new UnifiedPerformance with this data.
     */
    create: XOR<UnifiedPerformanceCreateInput, UnifiedPerformanceUncheckedCreateInput>
    /**
     * In case the UnifiedPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnifiedPerformanceUpdateInput, UnifiedPerformanceUncheckedUpdateInput>
  }

  /**
   * UnifiedPerformance delete
   */
  export type UnifiedPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
    /**
     * Filter which UnifiedPerformance to delete.
     */
    where: UnifiedPerformanceWhereUniqueInput
  }

  /**
   * UnifiedPerformance deleteMany
   */
  export type UnifiedPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedPerformances to delete
     */
    where?: UnifiedPerformanceWhereInput
    /**
     * Limit how many UnifiedPerformances to delete.
     */
    limit?: number
  }

  /**
   * UnifiedPerformance without action
   */
  export type UnifiedPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedPerformance
     */
    select?: UnifiedPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedPerformance
     */
    omit?: UnifiedPerformanceOmit<ExtArgs> | null
  }


  /**
   * Model NewsViralRelation
   */

  export type AggregateNewsViralRelation = {
    _count: NewsViralRelationCountAggregateOutputType | null
    _avg: NewsViralRelationAvgAggregateOutputType | null
    _sum: NewsViralRelationSumAggregateOutputType | null
    _min: NewsViralRelationMinAggregateOutputType | null
    _max: NewsViralRelationMaxAggregateOutputType | null
  }

  export type NewsViralRelationAvgAggregateOutputType = {
    relevanceScore: number | null
  }

  export type NewsViralRelationSumAggregateOutputType = {
    relevanceScore: number | null
  }

  export type NewsViralRelationMinAggregateOutputType = {
    id: string | null
    newsId: string | null
    sessionId: string | null
    relevanceScore: number | null
    usedInContent: boolean | null
    createdAt: Date | null
  }

  export type NewsViralRelationMaxAggregateOutputType = {
    id: string | null
    newsId: string | null
    sessionId: string | null
    relevanceScore: number | null
    usedInContent: boolean | null
    createdAt: Date | null
  }

  export type NewsViralRelationCountAggregateOutputType = {
    id: number
    newsId: number
    sessionId: number
    relevanceScore: number
    usedInContent: number
    createdAt: number
    _all: number
  }


  export type NewsViralRelationAvgAggregateInputType = {
    relevanceScore?: true
  }

  export type NewsViralRelationSumAggregateInputType = {
    relevanceScore?: true
  }

  export type NewsViralRelationMinAggregateInputType = {
    id?: true
    newsId?: true
    sessionId?: true
    relevanceScore?: true
    usedInContent?: true
    createdAt?: true
  }

  export type NewsViralRelationMaxAggregateInputType = {
    id?: true
    newsId?: true
    sessionId?: true
    relevanceScore?: true
    usedInContent?: true
    createdAt?: true
  }

  export type NewsViralRelationCountAggregateInputType = {
    id?: true
    newsId?: true
    sessionId?: true
    relevanceScore?: true
    usedInContent?: true
    createdAt?: true
    _all?: true
  }

  export type NewsViralRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsViralRelation to aggregate.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsViralRelations
    **/
    _count?: true | NewsViralRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsViralRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsViralRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsViralRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsViralRelationMaxAggregateInputType
  }

  export type GetNewsViralRelationAggregateType<T extends NewsViralRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsViralRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsViralRelation[P]>
      : GetScalarType<T[P], AggregateNewsViralRelation[P]>
  }




  export type NewsViralRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsViralRelationWhereInput
    orderBy?: NewsViralRelationOrderByWithAggregationInput | NewsViralRelationOrderByWithAggregationInput[]
    by: NewsViralRelationScalarFieldEnum[] | NewsViralRelationScalarFieldEnum
    having?: NewsViralRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsViralRelationCountAggregateInputType | true
    _avg?: NewsViralRelationAvgAggregateInputType
    _sum?: NewsViralRelationSumAggregateInputType
    _min?: NewsViralRelationMinAggregateInputType
    _max?: NewsViralRelationMaxAggregateInputType
  }

  export type NewsViralRelationGroupByOutputType = {
    id: string
    newsId: string
    sessionId: string
    relevanceScore: number | null
    usedInContent: boolean
    createdAt: Date
    _count: NewsViralRelationCountAggregateOutputType | null
    _avg: NewsViralRelationAvgAggregateOutputType | null
    _sum: NewsViralRelationSumAggregateOutputType | null
    _min: NewsViralRelationMinAggregateOutputType | null
    _max: NewsViralRelationMaxAggregateOutputType | null
  }

  type GetNewsViralRelationGroupByPayload<T extends NewsViralRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsViralRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsViralRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsViralRelationGroupByOutputType[P]>
            : GetScalarType<T[P], NewsViralRelationGroupByOutputType[P]>
        }
      >
    >


  export type NewsViralRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsViralRelation"]>

  export type NewsViralRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsViralRelation"]>

  export type NewsViralRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsViralRelation"]>

  export type NewsViralRelationSelectScalar = {
    id?: boolean
    newsId?: boolean
    sessionId?: boolean
    relevanceScore?: boolean
    usedInContent?: boolean
    createdAt?: boolean
  }

  export type NewsViralRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "newsId" | "sessionId" | "relevanceScore" | "usedInContent" | "createdAt", ExtArgs["result"]["newsViralRelation"]>

  export type $NewsViralRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsViralRelation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      newsId: string
      sessionId: string
      relevanceScore: number | null
      usedInContent: boolean
      createdAt: Date
    }, ExtArgs["result"]["newsViralRelation"]>
    composites: {}
  }

  type NewsViralRelationGetPayload<S extends boolean | null | undefined | NewsViralRelationDefaultArgs> = $Result.GetResult<Prisma.$NewsViralRelationPayload, S>

  type NewsViralRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsViralRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsViralRelationCountAggregateInputType | true
    }

  export interface NewsViralRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsViralRelation'], meta: { name: 'NewsViralRelation' } }
    /**
     * Find zero or one NewsViralRelation that matches the filter.
     * @param {NewsViralRelationFindUniqueArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsViralRelationFindUniqueArgs>(args: SelectSubset<T, NewsViralRelationFindUniqueArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsViralRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsViralRelationFindUniqueOrThrowArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsViralRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsViralRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsViralRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationFindFirstArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsViralRelationFindFirstArgs>(args?: SelectSubset<T, NewsViralRelationFindFirstArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsViralRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationFindFirstOrThrowArgs} args - Arguments to find a NewsViralRelation
     * @example
     * // Get one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsViralRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsViralRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsViralRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsViralRelations
     * const newsViralRelations = await prisma.newsViralRelation.findMany()
     * 
     * // Get first 10 NewsViralRelations
     * const newsViralRelations = await prisma.newsViralRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsViralRelationWithIdOnly = await prisma.newsViralRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsViralRelationFindManyArgs>(args?: SelectSubset<T, NewsViralRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsViralRelation.
     * @param {NewsViralRelationCreateArgs} args - Arguments to create a NewsViralRelation.
     * @example
     * // Create one NewsViralRelation
     * const NewsViralRelation = await prisma.newsViralRelation.create({
     *   data: {
     *     // ... data to create a NewsViralRelation
     *   }
     * })
     * 
     */
    create<T extends NewsViralRelationCreateArgs>(args: SelectSubset<T, NewsViralRelationCreateArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsViralRelations.
     * @param {NewsViralRelationCreateManyArgs} args - Arguments to create many NewsViralRelations.
     * @example
     * // Create many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsViralRelationCreateManyArgs>(args?: SelectSubset<T, NewsViralRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsViralRelations and returns the data saved in the database.
     * @param {NewsViralRelationCreateManyAndReturnArgs} args - Arguments to create many NewsViralRelations.
     * @example
     * // Create many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsViralRelations and only return the `id`
     * const newsViralRelationWithIdOnly = await prisma.newsViralRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsViralRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsViralRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsViralRelation.
     * @param {NewsViralRelationDeleteArgs} args - Arguments to delete one NewsViralRelation.
     * @example
     * // Delete one NewsViralRelation
     * const NewsViralRelation = await prisma.newsViralRelation.delete({
     *   where: {
     *     // ... filter to delete one NewsViralRelation
     *   }
     * })
     * 
     */
    delete<T extends NewsViralRelationDeleteArgs>(args: SelectSubset<T, NewsViralRelationDeleteArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsViralRelation.
     * @param {NewsViralRelationUpdateArgs} args - Arguments to update one NewsViralRelation.
     * @example
     * // Update one NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsViralRelationUpdateArgs>(args: SelectSubset<T, NewsViralRelationUpdateArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsViralRelations.
     * @param {NewsViralRelationDeleteManyArgs} args - Arguments to filter NewsViralRelations to delete.
     * @example
     * // Delete a few NewsViralRelations
     * const { count } = await prisma.newsViralRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsViralRelationDeleteManyArgs>(args?: SelectSubset<T, NewsViralRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsViralRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsViralRelationUpdateManyArgs>(args: SelectSubset<T, NewsViralRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsViralRelations and returns the data updated in the database.
     * @param {NewsViralRelationUpdateManyAndReturnArgs} args - Arguments to update many NewsViralRelations.
     * @example
     * // Update many NewsViralRelations
     * const newsViralRelation = await prisma.newsViralRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsViralRelations and only return the `id`
     * const newsViralRelationWithIdOnly = await prisma.newsViralRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsViralRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsViralRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsViralRelation.
     * @param {NewsViralRelationUpsertArgs} args - Arguments to update or create a NewsViralRelation.
     * @example
     * // Update or create a NewsViralRelation
     * const newsViralRelation = await prisma.newsViralRelation.upsert({
     *   create: {
     *     // ... data to create a NewsViralRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsViralRelation we want to update
     *   }
     * })
     */
    upsert<T extends NewsViralRelationUpsertArgs>(args: SelectSubset<T, NewsViralRelationUpsertArgs<ExtArgs>>): Prisma__NewsViralRelationClient<$Result.GetResult<Prisma.$NewsViralRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsViralRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationCountArgs} args - Arguments to filter NewsViralRelations to count.
     * @example
     * // Count the number of NewsViralRelations
     * const count = await prisma.newsViralRelation.count({
     *   where: {
     *     // ... the filter for the NewsViralRelations we want to count
     *   }
     * })
    **/
    count<T extends NewsViralRelationCountArgs>(
      args?: Subset<T, NewsViralRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsViralRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsViralRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsViralRelationAggregateArgs>(args: Subset<T, NewsViralRelationAggregateArgs>): Prisma.PrismaPromise<GetNewsViralRelationAggregateType<T>>

    /**
     * Group by NewsViralRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsViralRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsViralRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsViralRelationGroupByArgs['orderBy'] }
        : { orderBy?: NewsViralRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsViralRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsViralRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsViralRelation model
   */
  readonly fields: NewsViralRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsViralRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsViralRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsViralRelation model
   */
  interface NewsViralRelationFieldRefs {
    readonly id: FieldRef<"NewsViralRelation", 'String'>
    readonly newsId: FieldRef<"NewsViralRelation", 'String'>
    readonly sessionId: FieldRef<"NewsViralRelation", 'String'>
    readonly relevanceScore: FieldRef<"NewsViralRelation", 'Float'>
    readonly usedInContent: FieldRef<"NewsViralRelation", 'Boolean'>
    readonly createdAt: FieldRef<"NewsViralRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsViralRelation findUnique
   */
  export type NewsViralRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation findUniqueOrThrow
   */
  export type NewsViralRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation findFirst
   */
  export type NewsViralRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsViralRelations.
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsViralRelations.
     */
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsViralRelation findFirstOrThrow
   */
  export type NewsViralRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * Filter, which NewsViralRelation to fetch.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsViralRelations.
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsViralRelations.
     */
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsViralRelation findMany
   */
  export type NewsViralRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * Filter, which NewsViralRelations to fetch.
     */
    where?: NewsViralRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsViralRelations to fetch.
     */
    orderBy?: NewsViralRelationOrderByWithRelationInput | NewsViralRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsViralRelations.
     */
    cursor?: NewsViralRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsViralRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsViralRelations.
     */
    skip?: number
    distinct?: NewsViralRelationScalarFieldEnum | NewsViralRelationScalarFieldEnum[]
  }

  /**
   * NewsViralRelation create
   */
  export type NewsViralRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * The data needed to create a NewsViralRelation.
     */
    data: XOR<NewsViralRelationCreateInput, NewsViralRelationUncheckedCreateInput>
  }

  /**
   * NewsViralRelation createMany
   */
  export type NewsViralRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsViralRelations.
     */
    data: NewsViralRelationCreateManyInput | NewsViralRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsViralRelation createManyAndReturn
   */
  export type NewsViralRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * The data used to create many NewsViralRelations.
     */
    data: NewsViralRelationCreateManyInput | NewsViralRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsViralRelation update
   */
  export type NewsViralRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * The data needed to update a NewsViralRelation.
     */
    data: XOR<NewsViralRelationUpdateInput, NewsViralRelationUncheckedUpdateInput>
    /**
     * Choose, which NewsViralRelation to update.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation updateMany
   */
  export type NewsViralRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsViralRelations.
     */
    data: XOR<NewsViralRelationUpdateManyMutationInput, NewsViralRelationUncheckedUpdateManyInput>
    /**
     * Filter which NewsViralRelations to update
     */
    where?: NewsViralRelationWhereInput
    /**
     * Limit how many NewsViralRelations to update.
     */
    limit?: number
  }

  /**
   * NewsViralRelation updateManyAndReturn
   */
  export type NewsViralRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * The data used to update NewsViralRelations.
     */
    data: XOR<NewsViralRelationUpdateManyMutationInput, NewsViralRelationUncheckedUpdateManyInput>
    /**
     * Filter which NewsViralRelations to update
     */
    where?: NewsViralRelationWhereInput
    /**
     * Limit how many NewsViralRelations to update.
     */
    limit?: number
  }

  /**
   * NewsViralRelation upsert
   */
  export type NewsViralRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * The filter to search for the NewsViralRelation to update in case it exists.
     */
    where: NewsViralRelationWhereUniqueInput
    /**
     * In case the NewsViralRelation found by the `where` argument doesn't exist, create a new NewsViralRelation with this data.
     */
    create: XOR<NewsViralRelationCreateInput, NewsViralRelationUncheckedCreateInput>
    /**
     * In case the NewsViralRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsViralRelationUpdateInput, NewsViralRelationUncheckedUpdateInput>
  }

  /**
   * NewsViralRelation delete
   */
  export type NewsViralRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
    /**
     * Filter which NewsViralRelation to delete.
     */
    where: NewsViralRelationWhereUniqueInput
  }

  /**
   * NewsViralRelation deleteMany
   */
  export type NewsViralRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsViralRelations to delete
     */
    where?: NewsViralRelationWhereInput
    /**
     * Limit how many NewsViralRelations to delete.
     */
    limit?: number
  }

  /**
   * NewsViralRelation without action
   */
  export type NewsViralRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsViralRelation
     */
    select?: NewsViralRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsViralRelation
     */
    omit?: NewsViralRelationOmit<ExtArgs> | null
  }


  /**
   * Model SessionActivityLog
   */

  export type AggregateSessionActivityLog = {
    _count: SessionActivityLogCountAggregateOutputType | null
    _min: SessionActivityLogMinAggregateOutputType | null
    _max: SessionActivityLogMaxAggregateOutputType | null
  }

  export type SessionActivityLogMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sessionType: string | null
    activityType: string | null
    createdAt: Date | null
  }

  export type SessionActivityLogMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sessionType: string | null
    activityType: string | null
    createdAt: Date | null
  }

  export type SessionActivityLogCountAggregateOutputType = {
    id: number
    sessionId: number
    sessionType: number
    activityType: number
    details: number
    createdAt: number
    _all: number
  }


  export type SessionActivityLogMinAggregateInputType = {
    id?: true
    sessionId?: true
    sessionType?: true
    activityType?: true
    createdAt?: true
  }

  export type SessionActivityLogMaxAggregateInputType = {
    id?: true
    sessionId?: true
    sessionType?: true
    activityType?: true
    createdAt?: true
  }

  export type SessionActivityLogCountAggregateInputType = {
    id?: true
    sessionId?: true
    sessionType?: true
    activityType?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type SessionActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionActivityLog to aggregate.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionActivityLogs
    **/
    _count?: true | SessionActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionActivityLogMaxAggregateInputType
  }

  export type GetSessionActivityLogAggregateType<T extends SessionActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionActivityLog[P]>
      : GetScalarType<T[P], AggregateSessionActivityLog[P]>
  }




  export type SessionActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionActivityLogWhereInput
    orderBy?: SessionActivityLogOrderByWithAggregationInput | SessionActivityLogOrderByWithAggregationInput[]
    by: SessionActivityLogScalarFieldEnum[] | SessionActivityLogScalarFieldEnum
    having?: SessionActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionActivityLogCountAggregateInputType | true
    _min?: SessionActivityLogMinAggregateInputType
    _max?: SessionActivityLogMaxAggregateInputType
  }

  export type SessionActivityLogGroupByOutputType = {
    id: string
    sessionId: string
    sessionType: string
    activityType: string
    details: JsonValue | null
    createdAt: Date
    _count: SessionActivityLogCountAggregateOutputType | null
    _min: SessionActivityLogMinAggregateOutputType | null
    _max: SessionActivityLogMaxAggregateOutputType | null
  }

  type GetSessionActivityLogGroupByPayload<T extends SessionActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], SessionActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type SessionActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sessionActivityLog"]>

  export type SessionActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sessionActivityLog"]>

  export type SessionActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sessionActivityLog"]>

  export type SessionActivityLogSelectScalar = {
    id?: boolean
    sessionId?: boolean
    sessionType?: boolean
    activityType?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type SessionActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "sessionType" | "activityType" | "details" | "createdAt", ExtArgs["result"]["sessionActivityLog"]>

  export type $SessionActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionActivityLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      sessionType: string
      activityType: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["sessionActivityLog"]>
    composites: {}
  }

  type SessionActivityLogGetPayload<S extends boolean | null | undefined | SessionActivityLogDefaultArgs> = $Result.GetResult<Prisma.$SessionActivityLogPayload, S>

  type SessionActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionActivityLogCountAggregateInputType | true
    }

  export interface SessionActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionActivityLog'], meta: { name: 'SessionActivityLog' } }
    /**
     * Find zero or one SessionActivityLog that matches the filter.
     * @param {SessionActivityLogFindUniqueArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionActivityLogFindUniqueArgs>(args: SelectSubset<T, SessionActivityLogFindUniqueArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionActivityLogFindUniqueOrThrowArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogFindFirstArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionActivityLogFindFirstArgs>(args?: SelectSubset<T, SessionActivityLogFindFirstArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogFindFirstOrThrowArgs} args - Arguments to find a SessionActivityLog
     * @example
     * // Get one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionActivityLogs
     * const sessionActivityLogs = await prisma.sessionActivityLog.findMany()
     * 
     * // Get first 10 SessionActivityLogs
     * const sessionActivityLogs = await prisma.sessionActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionActivityLogWithIdOnly = await prisma.sessionActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionActivityLogFindManyArgs>(args?: SelectSubset<T, SessionActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionActivityLog.
     * @param {SessionActivityLogCreateArgs} args - Arguments to create a SessionActivityLog.
     * @example
     * // Create one SessionActivityLog
     * const SessionActivityLog = await prisma.sessionActivityLog.create({
     *   data: {
     *     // ... data to create a SessionActivityLog
     *   }
     * })
     * 
     */
    create<T extends SessionActivityLogCreateArgs>(args: SelectSubset<T, SessionActivityLogCreateArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionActivityLogs.
     * @param {SessionActivityLogCreateManyArgs} args - Arguments to create many SessionActivityLogs.
     * @example
     * // Create many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionActivityLogCreateManyArgs>(args?: SelectSubset<T, SessionActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionActivityLogs and returns the data saved in the database.
     * @param {SessionActivityLogCreateManyAndReturnArgs} args - Arguments to create many SessionActivityLogs.
     * @example
     * // Create many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionActivityLogs and only return the `id`
     * const sessionActivityLogWithIdOnly = await prisma.sessionActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionActivityLog.
     * @param {SessionActivityLogDeleteArgs} args - Arguments to delete one SessionActivityLog.
     * @example
     * // Delete one SessionActivityLog
     * const SessionActivityLog = await prisma.sessionActivityLog.delete({
     *   where: {
     *     // ... filter to delete one SessionActivityLog
     *   }
     * })
     * 
     */
    delete<T extends SessionActivityLogDeleteArgs>(args: SelectSubset<T, SessionActivityLogDeleteArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionActivityLog.
     * @param {SessionActivityLogUpdateArgs} args - Arguments to update one SessionActivityLog.
     * @example
     * // Update one SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionActivityLogUpdateArgs>(args: SelectSubset<T, SessionActivityLogUpdateArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionActivityLogs.
     * @param {SessionActivityLogDeleteManyArgs} args - Arguments to filter SessionActivityLogs to delete.
     * @example
     * // Delete a few SessionActivityLogs
     * const { count } = await prisma.sessionActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionActivityLogDeleteManyArgs>(args?: SelectSubset<T, SessionActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionActivityLogUpdateManyArgs>(args: SelectSubset<T, SessionActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionActivityLogs and returns the data updated in the database.
     * @param {SessionActivityLogUpdateManyAndReturnArgs} args - Arguments to update many SessionActivityLogs.
     * @example
     * // Update many SessionActivityLogs
     * const sessionActivityLog = await prisma.sessionActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionActivityLogs and only return the `id`
     * const sessionActivityLogWithIdOnly = await prisma.sessionActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionActivityLog.
     * @param {SessionActivityLogUpsertArgs} args - Arguments to update or create a SessionActivityLog.
     * @example
     * // Update or create a SessionActivityLog
     * const sessionActivityLog = await prisma.sessionActivityLog.upsert({
     *   create: {
     *     // ... data to create a SessionActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends SessionActivityLogUpsertArgs>(args: SelectSubset<T, SessionActivityLogUpsertArgs<ExtArgs>>): Prisma__SessionActivityLogClient<$Result.GetResult<Prisma.$SessionActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogCountArgs} args - Arguments to filter SessionActivityLogs to count.
     * @example
     * // Count the number of SessionActivityLogs
     * const count = await prisma.sessionActivityLog.count({
     *   where: {
     *     // ... the filter for the SessionActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends SessionActivityLogCountArgs>(
      args?: Subset<T, SessionActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionActivityLogAggregateArgs>(args: Subset<T, SessionActivityLogAggregateArgs>): Prisma.PrismaPromise<GetSessionActivityLogAggregateType<T>>

    /**
     * Group by SessionActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: SessionActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionActivityLog model
   */
  readonly fields: SessionActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionActivityLog model
   */
  interface SessionActivityLogFieldRefs {
    readonly id: FieldRef<"SessionActivityLog", 'String'>
    readonly sessionId: FieldRef<"SessionActivityLog", 'String'>
    readonly sessionType: FieldRef<"SessionActivityLog", 'String'>
    readonly activityType: FieldRef<"SessionActivityLog", 'String'>
    readonly details: FieldRef<"SessionActivityLog", 'Json'>
    readonly createdAt: FieldRef<"SessionActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionActivityLog findUnique
   */
  export type SessionActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog findUniqueOrThrow
   */
  export type SessionActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog findFirst
   */
  export type SessionActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionActivityLogs.
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionActivityLogs.
     */
    distinct?: SessionActivityLogScalarFieldEnum | SessionActivityLogScalarFieldEnum[]
  }

  /**
   * SessionActivityLog findFirstOrThrow
   */
  export type SessionActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which SessionActivityLog to fetch.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionActivityLogs.
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionActivityLogs.
     */
    distinct?: SessionActivityLogScalarFieldEnum | SessionActivityLogScalarFieldEnum[]
  }

  /**
   * SessionActivityLog findMany
   */
  export type SessionActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which SessionActivityLogs to fetch.
     */
    where?: SessionActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionActivityLogs to fetch.
     */
    orderBy?: SessionActivityLogOrderByWithRelationInput | SessionActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionActivityLogs.
     */
    cursor?: SessionActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionActivityLogs.
     */
    skip?: number
    distinct?: SessionActivityLogScalarFieldEnum | SessionActivityLogScalarFieldEnum[]
  }

  /**
   * SessionActivityLog create
   */
  export type SessionActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SessionActivityLog.
     */
    data: XOR<SessionActivityLogCreateInput, SessionActivityLogUncheckedCreateInput>
  }

  /**
   * SessionActivityLog createMany
   */
  export type SessionActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionActivityLogs.
     */
    data: SessionActivityLogCreateManyInput | SessionActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionActivityLog createManyAndReturn
   */
  export type SessionActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many SessionActivityLogs.
     */
    data: SessionActivityLogCreateManyInput | SessionActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionActivityLog update
   */
  export type SessionActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SessionActivityLog.
     */
    data: XOR<SessionActivityLogUpdateInput, SessionActivityLogUncheckedUpdateInput>
    /**
     * Choose, which SessionActivityLog to update.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog updateMany
   */
  export type SessionActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionActivityLogs.
     */
    data: XOR<SessionActivityLogUpdateManyMutationInput, SessionActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which SessionActivityLogs to update
     */
    where?: SessionActivityLogWhereInput
    /**
     * Limit how many SessionActivityLogs to update.
     */
    limit?: number
  }

  /**
   * SessionActivityLog updateManyAndReturn
   */
  export type SessionActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update SessionActivityLogs.
     */
    data: XOR<SessionActivityLogUpdateManyMutationInput, SessionActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which SessionActivityLogs to update
     */
    where?: SessionActivityLogWhereInput
    /**
     * Limit how many SessionActivityLogs to update.
     */
    limit?: number
  }

  /**
   * SessionActivityLog upsert
   */
  export type SessionActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SessionActivityLog to update in case it exists.
     */
    where: SessionActivityLogWhereUniqueInput
    /**
     * In case the SessionActivityLog found by the `where` argument doesn't exist, create a new SessionActivityLog with this data.
     */
    create: XOR<SessionActivityLogCreateInput, SessionActivityLogUncheckedCreateInput>
    /**
     * In case the SessionActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionActivityLogUpdateInput, SessionActivityLogUncheckedUpdateInput>
  }

  /**
   * SessionActivityLog delete
   */
  export type SessionActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
    /**
     * Filter which SessionActivityLog to delete.
     */
    where: SessionActivityLogWhereUniqueInput
  }

  /**
   * SessionActivityLog deleteMany
   */
  export type SessionActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionActivityLogs to delete
     */
    where?: SessionActivityLogWhereInput
    /**
     * Limit how many SessionActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * SessionActivityLog without action
   */
  export type SessionActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionActivityLog
     */
    select?: SessionActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionActivityLog
     */
    omit?: SessionActivityLogOmit<ExtArgs> | null
  }


  /**
   * Model ApiErrorLog
   */

  export type AggregateApiErrorLog = {
    _count: ApiErrorLogCountAggregateOutputType | null
    _avg: ApiErrorLogAvgAggregateOutputType | null
    _sum: ApiErrorLogSumAggregateOutputType | null
    _min: ApiErrorLogMinAggregateOutputType | null
    _max: ApiErrorLogMaxAggregateOutputType | null
  }

  export type ApiErrorLogAvgAggregateOutputType = {
    statusCode: number | null
  }

  export type ApiErrorLogSumAggregateOutputType = {
    statusCode: number | null
  }

  export type ApiErrorLogMinAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    errorMessage: string | null
    stackTrace: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type ApiErrorLogMaxAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    errorMessage: string | null
    stackTrace: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type ApiErrorLogCountAggregateOutputType = {
    id: number
    endpoint: number
    method: number
    statusCode: number
    errorMessage: number
    stackTrace: number
    requestBody: number
    requestHeaders: number
    userAgent: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type ApiErrorLogAvgAggregateInputType = {
    statusCode?: true
  }

  export type ApiErrorLogSumAggregateInputType = {
    statusCode?: true
  }

  export type ApiErrorLogMinAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    errorMessage?: true
    stackTrace?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type ApiErrorLogMaxAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    errorMessage?: true
    stackTrace?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type ApiErrorLogCountAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    errorMessage?: true
    stackTrace?: true
    requestBody?: true
    requestHeaders?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type ApiErrorLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiErrorLog to aggregate.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiErrorLogs
    **/
    _count?: true | ApiErrorLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiErrorLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiErrorLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiErrorLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiErrorLogMaxAggregateInputType
  }

  export type GetApiErrorLogAggregateType<T extends ApiErrorLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiErrorLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiErrorLog[P]>
      : GetScalarType<T[P], AggregateApiErrorLog[P]>
  }




  export type ApiErrorLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiErrorLogWhereInput
    orderBy?: ApiErrorLogOrderByWithAggregationInput | ApiErrorLogOrderByWithAggregationInput[]
    by: ApiErrorLogScalarFieldEnum[] | ApiErrorLogScalarFieldEnum
    having?: ApiErrorLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiErrorLogCountAggregateInputType | true
    _avg?: ApiErrorLogAvgAggregateInputType
    _sum?: ApiErrorLogSumAggregateInputType
    _min?: ApiErrorLogMinAggregateInputType
    _max?: ApiErrorLogMaxAggregateInputType
  }

  export type ApiErrorLogGroupByOutputType = {
    id: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage: string | null
    stackTrace: string | null
    requestBody: JsonValue | null
    requestHeaders: JsonValue | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    _count: ApiErrorLogCountAggregateOutputType | null
    _avg: ApiErrorLogAvgAggregateOutputType | null
    _sum: ApiErrorLogSumAggregateOutputType | null
    _min: ApiErrorLogMinAggregateOutputType | null
    _max: ApiErrorLogMaxAggregateOutputType | null
  }

  type GetApiErrorLogGroupByPayload<T extends ApiErrorLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiErrorLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiErrorLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiErrorLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiErrorLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiErrorLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiErrorLog"]>

  export type ApiErrorLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiErrorLog"]>

  export type ApiErrorLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiErrorLog"]>

  export type ApiErrorLogSelectScalar = {
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    errorMessage?: boolean
    stackTrace?: boolean
    requestBody?: boolean
    requestHeaders?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type ApiErrorLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "endpoint" | "method" | "statusCode" | "errorMessage" | "stackTrace" | "requestBody" | "requestHeaders" | "userAgent" | "ipAddress" | "createdAt", ExtArgs["result"]["apiErrorLog"]>

  export type $ApiErrorLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiErrorLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endpoint: string
      method: string
      statusCode: number
      errorMessage: string | null
      stackTrace: string | null
      requestBody: Prisma.JsonValue | null
      requestHeaders: Prisma.JsonValue | null
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["apiErrorLog"]>
    composites: {}
  }

  type ApiErrorLogGetPayload<S extends boolean | null | undefined | ApiErrorLogDefaultArgs> = $Result.GetResult<Prisma.$ApiErrorLogPayload, S>

  type ApiErrorLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiErrorLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiErrorLogCountAggregateInputType | true
    }

  export interface ApiErrorLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiErrorLog'], meta: { name: 'ApiErrorLog' } }
    /**
     * Find zero or one ApiErrorLog that matches the filter.
     * @param {ApiErrorLogFindUniqueArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiErrorLogFindUniqueArgs>(args: SelectSubset<T, ApiErrorLogFindUniqueArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiErrorLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiErrorLogFindUniqueOrThrowArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiErrorLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiErrorLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiErrorLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogFindFirstArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiErrorLogFindFirstArgs>(args?: SelectSubset<T, ApiErrorLogFindFirstArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiErrorLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogFindFirstOrThrowArgs} args - Arguments to find a ApiErrorLog
     * @example
     * // Get one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiErrorLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiErrorLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiErrorLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiErrorLogs
     * const apiErrorLogs = await prisma.apiErrorLog.findMany()
     * 
     * // Get first 10 ApiErrorLogs
     * const apiErrorLogs = await prisma.apiErrorLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiErrorLogWithIdOnly = await prisma.apiErrorLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiErrorLogFindManyArgs>(args?: SelectSubset<T, ApiErrorLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiErrorLog.
     * @param {ApiErrorLogCreateArgs} args - Arguments to create a ApiErrorLog.
     * @example
     * // Create one ApiErrorLog
     * const ApiErrorLog = await prisma.apiErrorLog.create({
     *   data: {
     *     // ... data to create a ApiErrorLog
     *   }
     * })
     * 
     */
    create<T extends ApiErrorLogCreateArgs>(args: SelectSubset<T, ApiErrorLogCreateArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiErrorLogs.
     * @param {ApiErrorLogCreateManyArgs} args - Arguments to create many ApiErrorLogs.
     * @example
     * // Create many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiErrorLogCreateManyArgs>(args?: SelectSubset<T, ApiErrorLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiErrorLogs and returns the data saved in the database.
     * @param {ApiErrorLogCreateManyAndReturnArgs} args - Arguments to create many ApiErrorLogs.
     * @example
     * // Create many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiErrorLogs and only return the `id`
     * const apiErrorLogWithIdOnly = await prisma.apiErrorLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiErrorLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiErrorLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiErrorLog.
     * @param {ApiErrorLogDeleteArgs} args - Arguments to delete one ApiErrorLog.
     * @example
     * // Delete one ApiErrorLog
     * const ApiErrorLog = await prisma.apiErrorLog.delete({
     *   where: {
     *     // ... filter to delete one ApiErrorLog
     *   }
     * })
     * 
     */
    delete<T extends ApiErrorLogDeleteArgs>(args: SelectSubset<T, ApiErrorLogDeleteArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiErrorLog.
     * @param {ApiErrorLogUpdateArgs} args - Arguments to update one ApiErrorLog.
     * @example
     * // Update one ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiErrorLogUpdateArgs>(args: SelectSubset<T, ApiErrorLogUpdateArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiErrorLogs.
     * @param {ApiErrorLogDeleteManyArgs} args - Arguments to filter ApiErrorLogs to delete.
     * @example
     * // Delete a few ApiErrorLogs
     * const { count } = await prisma.apiErrorLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiErrorLogDeleteManyArgs>(args?: SelectSubset<T, ApiErrorLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiErrorLogUpdateManyArgs>(args: SelectSubset<T, ApiErrorLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiErrorLogs and returns the data updated in the database.
     * @param {ApiErrorLogUpdateManyAndReturnArgs} args - Arguments to update many ApiErrorLogs.
     * @example
     * // Update many ApiErrorLogs
     * const apiErrorLog = await prisma.apiErrorLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiErrorLogs and only return the `id`
     * const apiErrorLogWithIdOnly = await prisma.apiErrorLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiErrorLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiErrorLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiErrorLog.
     * @param {ApiErrorLogUpsertArgs} args - Arguments to update or create a ApiErrorLog.
     * @example
     * // Update or create a ApiErrorLog
     * const apiErrorLog = await prisma.apiErrorLog.upsert({
     *   create: {
     *     // ... data to create a ApiErrorLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiErrorLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiErrorLogUpsertArgs>(args: SelectSubset<T, ApiErrorLogUpsertArgs<ExtArgs>>): Prisma__ApiErrorLogClient<$Result.GetResult<Prisma.$ApiErrorLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogCountArgs} args - Arguments to filter ApiErrorLogs to count.
     * @example
     * // Count the number of ApiErrorLogs
     * const count = await prisma.apiErrorLog.count({
     *   where: {
     *     // ... the filter for the ApiErrorLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiErrorLogCountArgs>(
      args?: Subset<T, ApiErrorLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiErrorLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiErrorLogAggregateArgs>(args: Subset<T, ApiErrorLogAggregateArgs>): Prisma.PrismaPromise<GetApiErrorLogAggregateType<T>>

    /**
     * Group by ApiErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiErrorLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiErrorLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiErrorLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiErrorLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiErrorLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiErrorLog model
   */
  readonly fields: ApiErrorLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiErrorLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiErrorLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiErrorLog model
   */
  interface ApiErrorLogFieldRefs {
    readonly id: FieldRef<"ApiErrorLog", 'String'>
    readonly endpoint: FieldRef<"ApiErrorLog", 'String'>
    readonly method: FieldRef<"ApiErrorLog", 'String'>
    readonly statusCode: FieldRef<"ApiErrorLog", 'Int'>
    readonly errorMessage: FieldRef<"ApiErrorLog", 'String'>
    readonly stackTrace: FieldRef<"ApiErrorLog", 'String'>
    readonly requestBody: FieldRef<"ApiErrorLog", 'Json'>
    readonly requestHeaders: FieldRef<"ApiErrorLog", 'Json'>
    readonly userAgent: FieldRef<"ApiErrorLog", 'String'>
    readonly ipAddress: FieldRef<"ApiErrorLog", 'String'>
    readonly createdAt: FieldRef<"ApiErrorLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiErrorLog findUnique
   */
  export type ApiErrorLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog findUniqueOrThrow
   */
  export type ApiErrorLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog findFirst
   */
  export type ApiErrorLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiErrorLogs.
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiErrorLogs.
     */
    distinct?: ApiErrorLogScalarFieldEnum | ApiErrorLogScalarFieldEnum[]
  }

  /**
   * ApiErrorLog findFirstOrThrow
   */
  export type ApiErrorLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiErrorLog to fetch.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiErrorLogs.
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiErrorLogs.
     */
    distinct?: ApiErrorLogScalarFieldEnum | ApiErrorLogScalarFieldEnum[]
  }

  /**
   * ApiErrorLog findMany
   */
  export type ApiErrorLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiErrorLogs to fetch.
     */
    where?: ApiErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorLogs to fetch.
     */
    orderBy?: ApiErrorLogOrderByWithRelationInput | ApiErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiErrorLogs.
     */
    cursor?: ApiErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorLogs.
     */
    skip?: number
    distinct?: ApiErrorLogScalarFieldEnum | ApiErrorLogScalarFieldEnum[]
  }

  /**
   * ApiErrorLog create
   */
  export type ApiErrorLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiErrorLog.
     */
    data: XOR<ApiErrorLogCreateInput, ApiErrorLogUncheckedCreateInput>
  }

  /**
   * ApiErrorLog createMany
   */
  export type ApiErrorLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiErrorLogs.
     */
    data: ApiErrorLogCreateManyInput | ApiErrorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiErrorLog createManyAndReturn
   */
  export type ApiErrorLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * The data used to create many ApiErrorLogs.
     */
    data: ApiErrorLogCreateManyInput | ApiErrorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiErrorLog update
   */
  export type ApiErrorLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiErrorLog.
     */
    data: XOR<ApiErrorLogUpdateInput, ApiErrorLogUncheckedUpdateInput>
    /**
     * Choose, which ApiErrorLog to update.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog updateMany
   */
  export type ApiErrorLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiErrorLogs.
     */
    data: XOR<ApiErrorLogUpdateManyMutationInput, ApiErrorLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiErrorLogs to update
     */
    where?: ApiErrorLogWhereInput
    /**
     * Limit how many ApiErrorLogs to update.
     */
    limit?: number
  }

  /**
   * ApiErrorLog updateManyAndReturn
   */
  export type ApiErrorLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * The data used to update ApiErrorLogs.
     */
    data: XOR<ApiErrorLogUpdateManyMutationInput, ApiErrorLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiErrorLogs to update
     */
    where?: ApiErrorLogWhereInput
    /**
     * Limit how many ApiErrorLogs to update.
     */
    limit?: number
  }

  /**
   * ApiErrorLog upsert
   */
  export type ApiErrorLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiErrorLog to update in case it exists.
     */
    where: ApiErrorLogWhereUniqueInput
    /**
     * In case the ApiErrorLog found by the `where` argument doesn't exist, create a new ApiErrorLog with this data.
     */
    create: XOR<ApiErrorLogCreateInput, ApiErrorLogUncheckedCreateInput>
    /**
     * In case the ApiErrorLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiErrorLogUpdateInput, ApiErrorLogUncheckedUpdateInput>
  }

  /**
   * ApiErrorLog delete
   */
  export type ApiErrorLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
    /**
     * Filter which ApiErrorLog to delete.
     */
    where: ApiErrorLogWhereUniqueInput
  }

  /**
   * ApiErrorLog deleteMany
   */
  export type ApiErrorLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiErrorLogs to delete
     */
    where?: ApiErrorLogWhereInput
    /**
     * Limit how many ApiErrorLogs to delete.
     */
    limit?: number
  }

  /**
   * ApiErrorLog without action
   */
  export type ApiErrorLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorLog
     */
    select?: ApiErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorLog
     */
    omit?: ApiErrorLogOmit<ExtArgs> | null
  }


  /**
   * Model ViralSession
   */

  export type AggregateViralSession = {
    _count: ViralSessionCountAggregateOutputType | null
    _min: ViralSessionMinAggregateOutputType | null
    _max: ViralSessionMaxAggregateOutputType | null
  }

  export type ViralSessionMinAggregateOutputType = {
    id: string | null
    theme: string | null
    platform: string | null
    style: string | null
    status: string | null
    createdAt: Date | null
    characterProfileId: string | null
    voiceStyleMode: string | null
  }

  export type ViralSessionMaxAggregateOutputType = {
    id: string | null
    theme: string | null
    platform: string | null
    style: string | null
    status: string | null
    createdAt: Date | null
    characterProfileId: string | null
    voiceStyleMode: string | null
  }

  export type ViralSessionCountAggregateOutputType = {
    id: number
    theme: number
    platform: number
    style: number
    status: number
    createdAt: number
    topics: number
    concepts: number
    selectedIds: number
    contents: number
    characterProfileId: number
    voiceStyleMode: number
    _all: number
  }


  export type ViralSessionMinAggregateInputType = {
    id?: true
    theme?: true
    platform?: true
    style?: true
    status?: true
    createdAt?: true
    characterProfileId?: true
    voiceStyleMode?: true
  }

  export type ViralSessionMaxAggregateInputType = {
    id?: true
    theme?: true
    platform?: true
    style?: true
    status?: true
    createdAt?: true
    characterProfileId?: true
    voiceStyleMode?: true
  }

  export type ViralSessionCountAggregateInputType = {
    id?: true
    theme?: true
    platform?: true
    style?: true
    status?: true
    createdAt?: true
    topics?: true
    concepts?: true
    selectedIds?: true
    contents?: true
    characterProfileId?: true
    voiceStyleMode?: true
    _all?: true
  }

  export type ViralSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralSession to aggregate.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViralSessions
    **/
    _count?: true | ViralSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViralSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViralSessionMaxAggregateInputType
  }

  export type GetViralSessionAggregateType<T extends ViralSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateViralSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViralSession[P]>
      : GetScalarType<T[P], AggregateViralSession[P]>
  }




  export type ViralSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralSessionWhereInput
    orderBy?: ViralSessionOrderByWithAggregationInput | ViralSessionOrderByWithAggregationInput[]
    by: ViralSessionScalarFieldEnum[] | ViralSessionScalarFieldEnum
    having?: ViralSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViralSessionCountAggregateInputType | true
    _min?: ViralSessionMinAggregateInputType
    _max?: ViralSessionMaxAggregateInputType
  }

  export type ViralSessionGroupByOutputType = {
    id: string
    theme: string
    platform: string
    style: string
    status: string
    createdAt: Date
    topics: JsonValue | null
    concepts: JsonValue | null
    selectedIds: string[]
    contents: JsonValue | null
    characterProfileId: string | null
    voiceStyleMode: string | null
    _count: ViralSessionCountAggregateOutputType | null
    _min: ViralSessionMinAggregateOutputType | null
    _max: ViralSessionMaxAggregateOutputType | null
  }

  type GetViralSessionGroupByPayload<T extends ViralSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViralSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViralSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViralSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ViralSessionGroupByOutputType[P]>
        }
      >
    >


  export type ViralSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
    drafts?: boolean | ViralSession$draftsArgs<ExtArgs>
    _count?: boolean | ViralSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralSession"]>

  export type ViralSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
  }, ExtArgs["result"]["viralSession"]>

  export type ViralSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
  }, ExtArgs["result"]["viralSession"]>

  export type ViralSessionSelectScalar = {
    id?: boolean
    theme?: boolean
    platform?: boolean
    style?: boolean
    status?: boolean
    createdAt?: boolean
    topics?: boolean
    concepts?: boolean
    selectedIds?: boolean
    contents?: boolean
    characterProfileId?: boolean
    voiceStyleMode?: boolean
  }

  export type ViralSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "theme" | "platform" | "style" | "status" | "createdAt" | "topics" | "concepts" | "selectedIds" | "contents" | "characterProfileId" | "voiceStyleMode", ExtArgs["result"]["viralSession"]>
  export type ViralSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | ViralSession$draftsArgs<ExtArgs>
    _count?: boolean | ViralSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViralSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ViralSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ViralSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViralSession"
    objects: {
      drafts: Prisma.$ViralDraftV2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      theme: string
      platform: string
      style: string
      status: string
      createdAt: Date
      topics: Prisma.JsonValue | null
      concepts: Prisma.JsonValue | null
      selectedIds: string[]
      contents: Prisma.JsonValue | null
      characterProfileId: string | null
      voiceStyleMode: string | null
    }, ExtArgs["result"]["viralSession"]>
    composites: {}
  }

  type ViralSessionGetPayload<S extends boolean | null | undefined | ViralSessionDefaultArgs> = $Result.GetResult<Prisma.$ViralSessionPayload, S>

  type ViralSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViralSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViralSessionCountAggregateInputType | true
    }

  export interface ViralSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViralSession'], meta: { name: 'ViralSession' } }
    /**
     * Find zero or one ViralSession that matches the filter.
     * @param {ViralSessionFindUniqueArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViralSessionFindUniqueArgs>(args: SelectSubset<T, ViralSessionFindUniqueArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViralSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViralSessionFindUniqueOrThrowArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViralSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ViralSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViralSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionFindFirstArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViralSessionFindFirstArgs>(args?: SelectSubset<T, ViralSessionFindFirstArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViralSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionFindFirstOrThrowArgs} args - Arguments to find a ViralSession
     * @example
     * // Get one ViralSession
     * const viralSession = await prisma.viralSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViralSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ViralSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViralSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViralSessions
     * const viralSessions = await prisma.viralSession.findMany()
     * 
     * // Get first 10 ViralSessions
     * const viralSessions = await prisma.viralSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viralSessionWithIdOnly = await prisma.viralSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViralSessionFindManyArgs>(args?: SelectSubset<T, ViralSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViralSession.
     * @param {ViralSessionCreateArgs} args - Arguments to create a ViralSession.
     * @example
     * // Create one ViralSession
     * const ViralSession = await prisma.viralSession.create({
     *   data: {
     *     // ... data to create a ViralSession
     *   }
     * })
     * 
     */
    create<T extends ViralSessionCreateArgs>(args: SelectSubset<T, ViralSessionCreateArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViralSessions.
     * @param {ViralSessionCreateManyArgs} args - Arguments to create many ViralSessions.
     * @example
     * // Create many ViralSessions
     * const viralSession = await prisma.viralSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViralSessionCreateManyArgs>(args?: SelectSubset<T, ViralSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViralSessions and returns the data saved in the database.
     * @param {ViralSessionCreateManyAndReturnArgs} args - Arguments to create many ViralSessions.
     * @example
     * // Create many ViralSessions
     * const viralSession = await prisma.viralSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViralSessions and only return the `id`
     * const viralSessionWithIdOnly = await prisma.viralSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViralSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ViralSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViralSession.
     * @param {ViralSessionDeleteArgs} args - Arguments to delete one ViralSession.
     * @example
     * // Delete one ViralSession
     * const ViralSession = await prisma.viralSession.delete({
     *   where: {
     *     // ... filter to delete one ViralSession
     *   }
     * })
     * 
     */
    delete<T extends ViralSessionDeleteArgs>(args: SelectSubset<T, ViralSessionDeleteArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViralSession.
     * @param {ViralSessionUpdateArgs} args - Arguments to update one ViralSession.
     * @example
     * // Update one ViralSession
     * const viralSession = await prisma.viralSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViralSessionUpdateArgs>(args: SelectSubset<T, ViralSessionUpdateArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViralSessions.
     * @param {ViralSessionDeleteManyArgs} args - Arguments to filter ViralSessions to delete.
     * @example
     * // Delete a few ViralSessions
     * const { count } = await prisma.viralSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViralSessionDeleteManyArgs>(args?: SelectSubset<T, ViralSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViralSessions
     * const viralSession = await prisma.viralSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViralSessionUpdateManyArgs>(args: SelectSubset<T, ViralSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralSessions and returns the data updated in the database.
     * @param {ViralSessionUpdateManyAndReturnArgs} args - Arguments to update many ViralSessions.
     * @example
     * // Update many ViralSessions
     * const viralSession = await prisma.viralSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViralSessions and only return the `id`
     * const viralSessionWithIdOnly = await prisma.viralSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViralSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ViralSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViralSession.
     * @param {ViralSessionUpsertArgs} args - Arguments to update or create a ViralSession.
     * @example
     * // Update or create a ViralSession
     * const viralSession = await prisma.viralSession.upsert({
     *   create: {
     *     // ... data to create a ViralSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViralSession we want to update
     *   }
     * })
     */
    upsert<T extends ViralSessionUpsertArgs>(args: SelectSubset<T, ViralSessionUpsertArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViralSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionCountArgs} args - Arguments to filter ViralSessions to count.
     * @example
     * // Count the number of ViralSessions
     * const count = await prisma.viralSession.count({
     *   where: {
     *     // ... the filter for the ViralSessions we want to count
     *   }
     * })
    **/
    count<T extends ViralSessionCountArgs>(
      args?: Subset<T, ViralSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViralSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViralSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViralSessionAggregateArgs>(args: Subset<T, ViralSessionAggregateArgs>): Prisma.PrismaPromise<GetViralSessionAggregateType<T>>

    /**
     * Group by ViralSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViralSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViralSessionGroupByArgs['orderBy'] }
        : { orderBy?: ViralSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViralSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViralSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViralSession model
   */
  readonly fields: ViralSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViralSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViralSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drafts<T extends ViralSession$draftsArgs<ExtArgs> = {}>(args?: Subset<T, ViralSession$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViralSession model
   */
  interface ViralSessionFieldRefs {
    readonly id: FieldRef<"ViralSession", 'String'>
    readonly theme: FieldRef<"ViralSession", 'String'>
    readonly platform: FieldRef<"ViralSession", 'String'>
    readonly style: FieldRef<"ViralSession", 'String'>
    readonly status: FieldRef<"ViralSession", 'String'>
    readonly createdAt: FieldRef<"ViralSession", 'DateTime'>
    readonly topics: FieldRef<"ViralSession", 'Json'>
    readonly concepts: FieldRef<"ViralSession", 'Json'>
    readonly selectedIds: FieldRef<"ViralSession", 'String[]'>
    readonly contents: FieldRef<"ViralSession", 'Json'>
    readonly characterProfileId: FieldRef<"ViralSession", 'String'>
    readonly voiceStyleMode: FieldRef<"ViralSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViralSession findUnique
   */
  export type ViralSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession findUniqueOrThrow
   */
  export type ViralSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession findFirst
   */
  export type ViralSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralSessions.
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralSessions.
     */
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * ViralSession findFirstOrThrow
   */
  export type ViralSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSession to fetch.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralSessions.
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralSessions.
     */
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * ViralSession findMany
   */
  export type ViralSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViralSessions to fetch.
     */
    where?: ViralSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralSessions to fetch.
     */
    orderBy?: ViralSessionOrderByWithRelationInput | ViralSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViralSessions.
     */
    cursor?: ViralSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralSessions.
     */
    skip?: number
    distinct?: ViralSessionScalarFieldEnum | ViralSessionScalarFieldEnum[]
  }

  /**
   * ViralSession create
   */
  export type ViralSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ViralSession.
     */
    data: XOR<ViralSessionCreateInput, ViralSessionUncheckedCreateInput>
  }

  /**
   * ViralSession createMany
   */
  export type ViralSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViralSessions.
     */
    data: ViralSessionCreateManyInput | ViralSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralSession createManyAndReturn
   */
  export type ViralSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ViralSessions.
     */
    data: ViralSessionCreateManyInput | ViralSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralSession update
   */
  export type ViralSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ViralSession.
     */
    data: XOR<ViralSessionUpdateInput, ViralSessionUncheckedUpdateInput>
    /**
     * Choose, which ViralSession to update.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession updateMany
   */
  export type ViralSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViralSessions.
     */
    data: XOR<ViralSessionUpdateManyMutationInput, ViralSessionUncheckedUpdateManyInput>
    /**
     * Filter which ViralSessions to update
     */
    where?: ViralSessionWhereInput
    /**
     * Limit how many ViralSessions to update.
     */
    limit?: number
  }

  /**
   * ViralSession updateManyAndReturn
   */
  export type ViralSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * The data used to update ViralSessions.
     */
    data: XOR<ViralSessionUpdateManyMutationInput, ViralSessionUncheckedUpdateManyInput>
    /**
     * Filter which ViralSessions to update
     */
    where?: ViralSessionWhereInput
    /**
     * Limit how many ViralSessions to update.
     */
    limit?: number
  }

  /**
   * ViralSession upsert
   */
  export type ViralSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ViralSession to update in case it exists.
     */
    where: ViralSessionWhereUniqueInput
    /**
     * In case the ViralSession found by the `where` argument doesn't exist, create a new ViralSession with this data.
     */
    create: XOR<ViralSessionCreateInput, ViralSessionUncheckedCreateInput>
    /**
     * In case the ViralSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViralSessionUpdateInput, ViralSessionUncheckedUpdateInput>
  }

  /**
   * ViralSession delete
   */
  export type ViralSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
    /**
     * Filter which ViralSession to delete.
     */
    where: ViralSessionWhereUniqueInput
  }

  /**
   * ViralSession deleteMany
   */
  export type ViralSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralSessions to delete
     */
    where?: ViralSessionWhereInput
    /**
     * Limit how many ViralSessions to delete.
     */
    limit?: number
  }

  /**
   * ViralSession.drafts
   */
  export type ViralSession$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    where?: ViralDraftV2WhereInput
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    cursor?: ViralDraftV2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralSession without action
   */
  export type ViralSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralSession
     */
    select?: ViralSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralSession
     */
    omit?: ViralSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralSessionInclude<ExtArgs> | null
  }


  /**
   * Model ViralDraftV2
   */

  export type AggregateViralDraftV2 = {
    _count: ViralDraftV2CountAggregateOutputType | null
    _min: ViralDraftV2MinAggregateOutputType | null
    _max: ViralDraftV2MaxAggregateOutputType | null
  }

  export type ViralDraftV2MinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptId: string | null
    title: string | null
    content: string | null
    visualNote: string | null
    status: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    tweetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    characterId: string | null
    characterNote: string | null
    sourceUrl: string | null
    news_article_id: string | null
  }

  export type ViralDraftV2MaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptId: string | null
    title: string | null
    content: string | null
    visualNote: string | null
    status: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    tweetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    characterId: string | null
    characterNote: string | null
    sourceUrl: string | null
    news_article_id: string | null
  }

  export type ViralDraftV2CountAggregateOutputType = {
    id: number
    sessionId: number
    conceptId: number
    title: number
    content: number
    hashtags: number
    visualNote: number
    status: number
    scheduledAt: number
    postedAt: number
    tweetId: number
    createdAt: number
    updatedAt: number
    characterId: number
    characterNote: number
    sourceUrl: number
    news_article_id: number
    _all: number
  }


  export type ViralDraftV2MinAggregateInputType = {
    id?: true
    sessionId?: true
    conceptId?: true
    title?: true
    content?: true
    visualNote?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    tweetId?: true
    createdAt?: true
    updatedAt?: true
    characterId?: true
    characterNote?: true
    sourceUrl?: true
    news_article_id?: true
  }

  export type ViralDraftV2MaxAggregateInputType = {
    id?: true
    sessionId?: true
    conceptId?: true
    title?: true
    content?: true
    visualNote?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    tweetId?: true
    createdAt?: true
    updatedAt?: true
    characterId?: true
    characterNote?: true
    sourceUrl?: true
    news_article_id?: true
  }

  export type ViralDraftV2CountAggregateInputType = {
    id?: true
    sessionId?: true
    conceptId?: true
    title?: true
    content?: true
    hashtags?: true
    visualNote?: true
    status?: true
    scheduledAt?: true
    postedAt?: true
    tweetId?: true
    createdAt?: true
    updatedAt?: true
    characterId?: true
    characterNote?: true
    sourceUrl?: true
    news_article_id?: true
    _all?: true
  }

  export type ViralDraftV2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftV2 to aggregate.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViralDraftV2s
    **/
    _count?: true | ViralDraftV2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViralDraftV2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViralDraftV2MaxAggregateInputType
  }

  export type GetViralDraftV2AggregateType<T extends ViralDraftV2AggregateArgs> = {
        [P in keyof T & keyof AggregateViralDraftV2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViralDraftV2[P]>
      : GetScalarType<T[P], AggregateViralDraftV2[P]>
  }




  export type ViralDraftV2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralDraftV2WhereInput
    orderBy?: ViralDraftV2OrderByWithAggregationInput | ViralDraftV2OrderByWithAggregationInput[]
    by: ViralDraftV2ScalarFieldEnum[] | ViralDraftV2ScalarFieldEnum
    having?: ViralDraftV2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViralDraftV2CountAggregateInputType | true
    _min?: ViralDraftV2MinAggregateInputType
    _max?: ViralDraftV2MaxAggregateInputType
  }

  export type ViralDraftV2GroupByOutputType = {
    id: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags: string[]
    visualNote: string | null
    status: string
    scheduledAt: Date | null
    postedAt: Date | null
    tweetId: string | null
    createdAt: Date
    updatedAt: Date
    characterId: string | null
    characterNote: string | null
    sourceUrl: string | null
    news_article_id: string | null
    _count: ViralDraftV2CountAggregateOutputType | null
    _min: ViralDraftV2MinAggregateOutputType | null
    _max: ViralDraftV2MaxAggregateOutputType | null
  }

  type GetViralDraftV2GroupByPayload<T extends ViralDraftV2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViralDraftV2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViralDraftV2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViralDraftV2GroupByOutputType[P]>
            : GetScalarType<T[P], ViralDraftV2GroupByOutputType[P]>
        }
      >
    >


  export type ViralDraftV2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterId?: boolean
    characterNote?: boolean
    sourceUrl?: boolean
    news_article_id?: boolean
    performance?: boolean | ViralDraftV2$performanceArgs<ExtArgs>
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftV2"]>

  export type ViralDraftV2SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterId?: boolean
    characterNote?: boolean
    sourceUrl?: boolean
    news_article_id?: boolean
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftV2"]>

  export type ViralDraftV2SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterId?: boolean
    characterNote?: boolean
    sourceUrl?: boolean
    news_article_id?: boolean
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftV2"]>

  export type ViralDraftV2SelectScalar = {
    id?: boolean
    sessionId?: boolean
    conceptId?: boolean
    title?: boolean
    content?: boolean
    hashtags?: boolean
    visualNote?: boolean
    status?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    tweetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterId?: boolean
    characterNote?: boolean
    sourceUrl?: boolean
    news_article_id?: boolean
  }

  export type ViralDraftV2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "conceptId" | "title" | "content" | "hashtags" | "visualNote" | "status" | "scheduledAt" | "postedAt" | "tweetId" | "createdAt" | "updatedAt" | "characterId" | "characterNote" | "sourceUrl" | "news_article_id", ExtArgs["result"]["viralDraftV2"]>
  export type ViralDraftV2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performance?: boolean | ViralDraftV2$performanceArgs<ExtArgs>
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }
  export type ViralDraftV2IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }
  export type ViralDraftV2IncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ViralSessionDefaultArgs<ExtArgs>
  }

  export type $ViralDraftV2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViralDraftV2"
    objects: {
      performance: Prisma.$ViralDraftPerformancePayload<ExtArgs> | null
      session: Prisma.$ViralSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      conceptId: string
      title: string
      content: string
      hashtags: string[]
      visualNote: string | null
      status: string
      scheduledAt: Date | null
      postedAt: Date | null
      tweetId: string | null
      createdAt: Date
      updatedAt: Date
      characterId: string | null
      characterNote: string | null
      sourceUrl: string | null
      news_article_id: string | null
    }, ExtArgs["result"]["viralDraftV2"]>
    composites: {}
  }

  type ViralDraftV2GetPayload<S extends boolean | null | undefined | ViralDraftV2DefaultArgs> = $Result.GetResult<Prisma.$ViralDraftV2Payload, S>

  type ViralDraftV2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViralDraftV2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViralDraftV2CountAggregateInputType | true
    }

  export interface ViralDraftV2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViralDraftV2'], meta: { name: 'ViralDraftV2' } }
    /**
     * Find zero or one ViralDraftV2 that matches the filter.
     * @param {ViralDraftV2FindUniqueArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViralDraftV2FindUniqueArgs>(args: SelectSubset<T, ViralDraftV2FindUniqueArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViralDraftV2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViralDraftV2FindUniqueOrThrowArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViralDraftV2FindUniqueOrThrowArgs>(args: SelectSubset<T, ViralDraftV2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViralDraftV2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2FindFirstArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViralDraftV2FindFirstArgs>(args?: SelectSubset<T, ViralDraftV2FindFirstArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViralDraftV2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2FindFirstOrThrowArgs} args - Arguments to find a ViralDraftV2
     * @example
     * // Get one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViralDraftV2FindFirstOrThrowArgs>(args?: SelectSubset<T, ViralDraftV2FindFirstOrThrowArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViralDraftV2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViralDraftV2s
     * const viralDraftV2s = await prisma.viralDraftV2.findMany()
     * 
     * // Get first 10 ViralDraftV2s
     * const viralDraftV2s = await prisma.viralDraftV2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viralDraftV2WithIdOnly = await prisma.viralDraftV2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViralDraftV2FindManyArgs>(args?: SelectSubset<T, ViralDraftV2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViralDraftV2.
     * @param {ViralDraftV2CreateArgs} args - Arguments to create a ViralDraftV2.
     * @example
     * // Create one ViralDraftV2
     * const ViralDraftV2 = await prisma.viralDraftV2.create({
     *   data: {
     *     // ... data to create a ViralDraftV2
     *   }
     * })
     * 
     */
    create<T extends ViralDraftV2CreateArgs>(args: SelectSubset<T, ViralDraftV2CreateArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViralDraftV2s.
     * @param {ViralDraftV2CreateManyArgs} args - Arguments to create many ViralDraftV2s.
     * @example
     * // Create many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViralDraftV2CreateManyArgs>(args?: SelectSubset<T, ViralDraftV2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViralDraftV2s and returns the data saved in the database.
     * @param {ViralDraftV2CreateManyAndReturnArgs} args - Arguments to create many ViralDraftV2s.
     * @example
     * // Create many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViralDraftV2s and only return the `id`
     * const viralDraftV2WithIdOnly = await prisma.viralDraftV2.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViralDraftV2CreateManyAndReturnArgs>(args?: SelectSubset<T, ViralDraftV2CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViralDraftV2.
     * @param {ViralDraftV2DeleteArgs} args - Arguments to delete one ViralDraftV2.
     * @example
     * // Delete one ViralDraftV2
     * const ViralDraftV2 = await prisma.viralDraftV2.delete({
     *   where: {
     *     // ... filter to delete one ViralDraftV2
     *   }
     * })
     * 
     */
    delete<T extends ViralDraftV2DeleteArgs>(args: SelectSubset<T, ViralDraftV2DeleteArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViralDraftV2.
     * @param {ViralDraftV2UpdateArgs} args - Arguments to update one ViralDraftV2.
     * @example
     * // Update one ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViralDraftV2UpdateArgs>(args: SelectSubset<T, ViralDraftV2UpdateArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViralDraftV2s.
     * @param {ViralDraftV2DeleteManyArgs} args - Arguments to filter ViralDraftV2s to delete.
     * @example
     * // Delete a few ViralDraftV2s
     * const { count } = await prisma.viralDraftV2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViralDraftV2DeleteManyArgs>(args?: SelectSubset<T, ViralDraftV2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralDraftV2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViralDraftV2UpdateManyArgs>(args: SelectSubset<T, ViralDraftV2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralDraftV2s and returns the data updated in the database.
     * @param {ViralDraftV2UpdateManyAndReturnArgs} args - Arguments to update many ViralDraftV2s.
     * @example
     * // Update many ViralDraftV2s
     * const viralDraftV2 = await prisma.viralDraftV2.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViralDraftV2s and only return the `id`
     * const viralDraftV2WithIdOnly = await prisma.viralDraftV2.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViralDraftV2UpdateManyAndReturnArgs>(args: SelectSubset<T, ViralDraftV2UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViralDraftV2.
     * @param {ViralDraftV2UpsertArgs} args - Arguments to update or create a ViralDraftV2.
     * @example
     * // Update or create a ViralDraftV2
     * const viralDraftV2 = await prisma.viralDraftV2.upsert({
     *   create: {
     *     // ... data to create a ViralDraftV2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViralDraftV2 we want to update
     *   }
     * })
     */
    upsert<T extends ViralDraftV2UpsertArgs>(args: SelectSubset<T, ViralDraftV2UpsertArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViralDraftV2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2CountArgs} args - Arguments to filter ViralDraftV2s to count.
     * @example
     * // Count the number of ViralDraftV2s
     * const count = await prisma.viralDraftV2.count({
     *   where: {
     *     // ... the filter for the ViralDraftV2s we want to count
     *   }
     * })
    **/
    count<T extends ViralDraftV2CountArgs>(
      args?: Subset<T, ViralDraftV2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViralDraftV2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViralDraftV2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViralDraftV2AggregateArgs>(args: Subset<T, ViralDraftV2AggregateArgs>): Prisma.PrismaPromise<GetViralDraftV2AggregateType<T>>

    /**
     * Group by ViralDraftV2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftV2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViralDraftV2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViralDraftV2GroupByArgs['orderBy'] }
        : { orderBy?: ViralDraftV2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViralDraftV2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViralDraftV2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViralDraftV2 model
   */
  readonly fields: ViralDraftV2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViralDraftV2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViralDraftV2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performance<T extends ViralDraftV2$performanceArgs<ExtArgs> = {}>(args?: Subset<T, ViralDraftV2$performanceArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends ViralSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViralSessionDefaultArgs<ExtArgs>>): Prisma__ViralSessionClient<$Result.GetResult<Prisma.$ViralSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViralDraftV2 model
   */
  interface ViralDraftV2FieldRefs {
    readonly id: FieldRef<"ViralDraftV2", 'String'>
    readonly sessionId: FieldRef<"ViralDraftV2", 'String'>
    readonly conceptId: FieldRef<"ViralDraftV2", 'String'>
    readonly title: FieldRef<"ViralDraftV2", 'String'>
    readonly content: FieldRef<"ViralDraftV2", 'String'>
    readonly hashtags: FieldRef<"ViralDraftV2", 'String[]'>
    readonly visualNote: FieldRef<"ViralDraftV2", 'String'>
    readonly status: FieldRef<"ViralDraftV2", 'String'>
    readonly scheduledAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly postedAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly tweetId: FieldRef<"ViralDraftV2", 'String'>
    readonly createdAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly updatedAt: FieldRef<"ViralDraftV2", 'DateTime'>
    readonly characterId: FieldRef<"ViralDraftV2", 'String'>
    readonly characterNote: FieldRef<"ViralDraftV2", 'String'>
    readonly sourceUrl: FieldRef<"ViralDraftV2", 'String'>
    readonly news_article_id: FieldRef<"ViralDraftV2", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViralDraftV2 findUnique
   */
  export type ViralDraftV2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 findUniqueOrThrow
   */
  export type ViralDraftV2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 findFirst
   */
  export type ViralDraftV2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftV2s.
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftV2s.
     */
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 findFirstOrThrow
   */
  export type ViralDraftV2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2 to fetch.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftV2s.
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftV2s.
     */
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 findMany
   */
  export type ViralDraftV2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter, which ViralDraftV2s to fetch.
     */
    where?: ViralDraftV2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftV2s to fetch.
     */
    orderBy?: ViralDraftV2OrderByWithRelationInput | ViralDraftV2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViralDraftV2s.
     */
    cursor?: ViralDraftV2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftV2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftV2s.
     */
    skip?: number
    distinct?: ViralDraftV2ScalarFieldEnum | ViralDraftV2ScalarFieldEnum[]
  }

  /**
   * ViralDraftV2 create
   */
  export type ViralDraftV2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * The data needed to create a ViralDraftV2.
     */
    data: XOR<ViralDraftV2CreateInput, ViralDraftV2UncheckedCreateInput>
  }

  /**
   * ViralDraftV2 createMany
   */
  export type ViralDraftV2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViralDraftV2s.
     */
    data: ViralDraftV2CreateManyInput | ViralDraftV2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralDraftV2 createManyAndReturn
   */
  export type ViralDraftV2CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * The data used to create many ViralDraftV2s.
     */
    data: ViralDraftV2CreateManyInput | ViralDraftV2CreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2IncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralDraftV2 update
   */
  export type ViralDraftV2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * The data needed to update a ViralDraftV2.
     */
    data: XOR<ViralDraftV2UpdateInput, ViralDraftV2UncheckedUpdateInput>
    /**
     * Choose, which ViralDraftV2 to update.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 updateMany
   */
  export type ViralDraftV2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViralDraftV2s.
     */
    data: XOR<ViralDraftV2UpdateManyMutationInput, ViralDraftV2UncheckedUpdateManyInput>
    /**
     * Filter which ViralDraftV2s to update
     */
    where?: ViralDraftV2WhereInput
    /**
     * Limit how many ViralDraftV2s to update.
     */
    limit?: number
  }

  /**
   * ViralDraftV2 updateManyAndReturn
   */
  export type ViralDraftV2UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * The data used to update ViralDraftV2s.
     */
    data: XOR<ViralDraftV2UpdateManyMutationInput, ViralDraftV2UncheckedUpdateManyInput>
    /**
     * Filter which ViralDraftV2s to update
     */
    where?: ViralDraftV2WhereInput
    /**
     * Limit how many ViralDraftV2s to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2IncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralDraftV2 upsert
   */
  export type ViralDraftV2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * The filter to search for the ViralDraftV2 to update in case it exists.
     */
    where: ViralDraftV2WhereUniqueInput
    /**
     * In case the ViralDraftV2 found by the `where` argument doesn't exist, create a new ViralDraftV2 with this data.
     */
    create: XOR<ViralDraftV2CreateInput, ViralDraftV2UncheckedCreateInput>
    /**
     * In case the ViralDraftV2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViralDraftV2UpdateInput, ViralDraftV2UncheckedUpdateInput>
  }

  /**
   * ViralDraftV2 delete
   */
  export type ViralDraftV2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
    /**
     * Filter which ViralDraftV2 to delete.
     */
    where: ViralDraftV2WhereUniqueInput
  }

  /**
   * ViralDraftV2 deleteMany
   */
  export type ViralDraftV2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftV2s to delete
     */
    where?: ViralDraftV2WhereInput
    /**
     * Limit how many ViralDraftV2s to delete.
     */
    limit?: number
  }

  /**
   * ViralDraftV2.performance
   */
  export type ViralDraftV2$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    where?: ViralDraftPerformanceWhereInput
  }

  /**
   * ViralDraftV2 without action
   */
  export type ViralDraftV2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftV2
     */
    select?: ViralDraftV2Select<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftV2
     */
    omit?: ViralDraftV2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftV2Include<ExtArgs> | null
  }


  /**
   * Model ViralDraftPerformance
   */

  export type AggregateViralDraftPerformance = {
    _count: ViralDraftPerformanceCountAggregateOutputType | null
    _avg: ViralDraftPerformanceAvgAggregateOutputType | null
    _sum: ViralDraftPerformanceSumAggregateOutputType | null
    _min: ViralDraftPerformanceMinAggregateOutputType | null
    _max: ViralDraftPerformanceMaxAggregateOutputType | null
  }

  export type ViralDraftPerformanceAvgAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type ViralDraftPerformanceSumAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type ViralDraftPerformanceMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type ViralDraftPerformanceMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    updatedAt: Date | null
  }

  export type ViralDraftPerformanceCountAggregateOutputType = {
    id: number
    draftId: number
    likes30m: number
    retweets30m: number
    replies30m: number
    impressions30m: number
    likes1h: number
    retweets1h: number
    replies1h: number
    impressions1h: number
    likes24h: number
    retweets24h: number
    replies24h: number
    impressions24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    updatedAt: number
    _all: number
  }


  export type ViralDraftPerformanceAvgAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type ViralDraftPerformanceSumAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type ViralDraftPerformanceMinAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type ViralDraftPerformanceMaxAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
  }

  export type ViralDraftPerformanceCountAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ViralDraftPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftPerformance to aggregate.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViralDraftPerformances
    **/
    _count?: true | ViralDraftPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViralDraftPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViralDraftPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViralDraftPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViralDraftPerformanceMaxAggregateInputType
  }

  export type GetViralDraftPerformanceAggregateType<T extends ViralDraftPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateViralDraftPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViralDraftPerformance[P]>
      : GetScalarType<T[P], AggregateViralDraftPerformance[P]>
  }




  export type ViralDraftPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViralDraftPerformanceWhereInput
    orderBy?: ViralDraftPerformanceOrderByWithAggregationInput | ViralDraftPerformanceOrderByWithAggregationInput[]
    by: ViralDraftPerformanceScalarFieldEnum[] | ViralDraftPerformanceScalarFieldEnum
    having?: ViralDraftPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViralDraftPerformanceCountAggregateInputType | true
    _avg?: ViralDraftPerformanceAvgAggregateInputType
    _sum?: ViralDraftPerformanceSumAggregateInputType
    _min?: ViralDraftPerformanceMinAggregateInputType
    _max?: ViralDraftPerformanceMaxAggregateInputType
  }

  export type ViralDraftPerformanceGroupByOutputType = {
    id: string
    draftId: string
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    updatedAt: Date
    _count: ViralDraftPerformanceCountAggregateOutputType | null
    _avg: ViralDraftPerformanceAvgAggregateOutputType | null
    _sum: ViralDraftPerformanceSumAggregateOutputType | null
    _min: ViralDraftPerformanceMinAggregateOutputType | null
    _max: ViralDraftPerformanceMaxAggregateOutputType | null
  }

  type GetViralDraftPerformanceGroupByPayload<T extends ViralDraftPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViralDraftPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViralDraftPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViralDraftPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], ViralDraftPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type ViralDraftPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftPerformance"]>

  export type ViralDraftPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftPerformance"]>

  export type ViralDraftPerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viralDraftPerformance"]>

  export type ViralDraftPerformanceSelectScalar = {
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    updatedAt?: boolean
  }

  export type ViralDraftPerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "draftId" | "likes30m" | "retweets30m" | "replies30m" | "impressions30m" | "likes1h" | "retweets1h" | "replies1h" | "impressions1h" | "likes24h" | "retweets24h" | "replies24h" | "impressions24h" | "engagementRate" | "viralCoefficient" | "collectedAt" | "updatedAt", ExtArgs["result"]["viralDraftPerformance"]>
  export type ViralDraftPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }
  export type ViralDraftPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }
  export type ViralDraftPerformanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | ViralDraftV2DefaultArgs<ExtArgs>
  }

  export type $ViralDraftPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViralDraftPerformance"
    objects: {
      draft: Prisma.$ViralDraftV2Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      likes30m: number | null
      retweets30m: number | null
      replies30m: number | null
      impressions30m: number | null
      likes1h: number | null
      retweets1h: number | null
      replies1h: number | null
      impressions1h: number | null
      likes24h: number | null
      retweets24h: number | null
      replies24h: number | null
      impressions24h: number | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["viralDraftPerformance"]>
    composites: {}
  }

  type ViralDraftPerformanceGetPayload<S extends boolean | null | undefined | ViralDraftPerformanceDefaultArgs> = $Result.GetResult<Prisma.$ViralDraftPerformancePayload, S>

  type ViralDraftPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViralDraftPerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViralDraftPerformanceCountAggregateInputType | true
    }

  export interface ViralDraftPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViralDraftPerformance'], meta: { name: 'ViralDraftPerformance' } }
    /**
     * Find zero or one ViralDraftPerformance that matches the filter.
     * @param {ViralDraftPerformanceFindUniqueArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViralDraftPerformanceFindUniqueArgs>(args: SelectSubset<T, ViralDraftPerformanceFindUniqueArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViralDraftPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViralDraftPerformanceFindUniqueOrThrowArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViralDraftPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ViralDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViralDraftPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceFindFirstArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViralDraftPerformanceFindFirstArgs>(args?: SelectSubset<T, ViralDraftPerformanceFindFirstArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViralDraftPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceFindFirstOrThrowArgs} args - Arguments to find a ViralDraftPerformance
     * @example
     * // Get one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViralDraftPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ViralDraftPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViralDraftPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViralDraftPerformances
     * const viralDraftPerformances = await prisma.viralDraftPerformance.findMany()
     * 
     * // Get first 10 ViralDraftPerformances
     * const viralDraftPerformances = await prisma.viralDraftPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viralDraftPerformanceWithIdOnly = await prisma.viralDraftPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViralDraftPerformanceFindManyArgs>(args?: SelectSubset<T, ViralDraftPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViralDraftPerformance.
     * @param {ViralDraftPerformanceCreateArgs} args - Arguments to create a ViralDraftPerformance.
     * @example
     * // Create one ViralDraftPerformance
     * const ViralDraftPerformance = await prisma.viralDraftPerformance.create({
     *   data: {
     *     // ... data to create a ViralDraftPerformance
     *   }
     * })
     * 
     */
    create<T extends ViralDraftPerformanceCreateArgs>(args: SelectSubset<T, ViralDraftPerformanceCreateArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViralDraftPerformances.
     * @param {ViralDraftPerformanceCreateManyArgs} args - Arguments to create many ViralDraftPerformances.
     * @example
     * // Create many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViralDraftPerformanceCreateManyArgs>(args?: SelectSubset<T, ViralDraftPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViralDraftPerformances and returns the data saved in the database.
     * @param {ViralDraftPerformanceCreateManyAndReturnArgs} args - Arguments to create many ViralDraftPerformances.
     * @example
     * // Create many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViralDraftPerformances and only return the `id`
     * const viralDraftPerformanceWithIdOnly = await prisma.viralDraftPerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViralDraftPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, ViralDraftPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViralDraftPerformance.
     * @param {ViralDraftPerformanceDeleteArgs} args - Arguments to delete one ViralDraftPerformance.
     * @example
     * // Delete one ViralDraftPerformance
     * const ViralDraftPerformance = await prisma.viralDraftPerformance.delete({
     *   where: {
     *     // ... filter to delete one ViralDraftPerformance
     *   }
     * })
     * 
     */
    delete<T extends ViralDraftPerformanceDeleteArgs>(args: SelectSubset<T, ViralDraftPerformanceDeleteArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViralDraftPerformance.
     * @param {ViralDraftPerformanceUpdateArgs} args - Arguments to update one ViralDraftPerformance.
     * @example
     * // Update one ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViralDraftPerformanceUpdateArgs>(args: SelectSubset<T, ViralDraftPerformanceUpdateArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViralDraftPerformances.
     * @param {ViralDraftPerformanceDeleteManyArgs} args - Arguments to filter ViralDraftPerformances to delete.
     * @example
     * // Delete a few ViralDraftPerformances
     * const { count } = await prisma.viralDraftPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViralDraftPerformanceDeleteManyArgs>(args?: SelectSubset<T, ViralDraftPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViralDraftPerformanceUpdateManyArgs>(args: SelectSubset<T, ViralDraftPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViralDraftPerformances and returns the data updated in the database.
     * @param {ViralDraftPerformanceUpdateManyAndReturnArgs} args - Arguments to update many ViralDraftPerformances.
     * @example
     * // Update many ViralDraftPerformances
     * const viralDraftPerformance = await prisma.viralDraftPerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViralDraftPerformances and only return the `id`
     * const viralDraftPerformanceWithIdOnly = await prisma.viralDraftPerformance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViralDraftPerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, ViralDraftPerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViralDraftPerformance.
     * @param {ViralDraftPerformanceUpsertArgs} args - Arguments to update or create a ViralDraftPerformance.
     * @example
     * // Update or create a ViralDraftPerformance
     * const viralDraftPerformance = await prisma.viralDraftPerformance.upsert({
     *   create: {
     *     // ... data to create a ViralDraftPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViralDraftPerformance we want to update
     *   }
     * })
     */
    upsert<T extends ViralDraftPerformanceUpsertArgs>(args: SelectSubset<T, ViralDraftPerformanceUpsertArgs<ExtArgs>>): Prisma__ViralDraftPerformanceClient<$Result.GetResult<Prisma.$ViralDraftPerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViralDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceCountArgs} args - Arguments to filter ViralDraftPerformances to count.
     * @example
     * // Count the number of ViralDraftPerformances
     * const count = await prisma.viralDraftPerformance.count({
     *   where: {
     *     // ... the filter for the ViralDraftPerformances we want to count
     *   }
     * })
    **/
    count<T extends ViralDraftPerformanceCountArgs>(
      args?: Subset<T, ViralDraftPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViralDraftPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViralDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViralDraftPerformanceAggregateArgs>(args: Subset<T, ViralDraftPerformanceAggregateArgs>): Prisma.PrismaPromise<GetViralDraftPerformanceAggregateType<T>>

    /**
     * Group by ViralDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViralDraftPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViralDraftPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViralDraftPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: ViralDraftPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViralDraftPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViralDraftPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViralDraftPerformance model
   */
  readonly fields: ViralDraftPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViralDraftPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViralDraftPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends ViralDraftV2DefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViralDraftV2DefaultArgs<ExtArgs>>): Prisma__ViralDraftV2Client<$Result.GetResult<Prisma.$ViralDraftV2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViralDraftPerformance model
   */
  interface ViralDraftPerformanceFieldRefs {
    readonly id: FieldRef<"ViralDraftPerformance", 'String'>
    readonly draftId: FieldRef<"ViralDraftPerformance", 'String'>
    readonly likes30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly retweets30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly replies30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly impressions30m: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly likes1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly retweets1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly replies1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly impressions1h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly likes24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly retweets24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly replies24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly impressions24h: FieldRef<"ViralDraftPerformance", 'Int'>
    readonly engagementRate: FieldRef<"ViralDraftPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"ViralDraftPerformance", 'Float'>
    readonly collectedAt: FieldRef<"ViralDraftPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"ViralDraftPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViralDraftPerformance findUnique
   */
  export type ViralDraftPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance findUniqueOrThrow
   */
  export type ViralDraftPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance findFirst
   */
  export type ViralDraftPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftPerformances.
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftPerformances.
     */
    distinct?: ViralDraftPerformanceScalarFieldEnum | ViralDraftPerformanceScalarFieldEnum[]
  }

  /**
   * ViralDraftPerformance findFirstOrThrow
   */
  export type ViralDraftPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformance to fetch.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViralDraftPerformances.
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViralDraftPerformances.
     */
    distinct?: ViralDraftPerformanceScalarFieldEnum | ViralDraftPerformanceScalarFieldEnum[]
  }

  /**
   * ViralDraftPerformance findMany
   */
  export type ViralDraftPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which ViralDraftPerformances to fetch.
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViralDraftPerformances to fetch.
     */
    orderBy?: ViralDraftPerformanceOrderByWithRelationInput | ViralDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViralDraftPerformances.
     */
    cursor?: ViralDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViralDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViralDraftPerformances.
     */
    skip?: number
    distinct?: ViralDraftPerformanceScalarFieldEnum | ViralDraftPerformanceScalarFieldEnum[]
  }

  /**
   * ViralDraftPerformance create
   */
  export type ViralDraftPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a ViralDraftPerformance.
     */
    data: XOR<ViralDraftPerformanceCreateInput, ViralDraftPerformanceUncheckedCreateInput>
  }

  /**
   * ViralDraftPerformance createMany
   */
  export type ViralDraftPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViralDraftPerformances.
     */
    data: ViralDraftPerformanceCreateManyInput | ViralDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViralDraftPerformance createManyAndReturn
   */
  export type ViralDraftPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many ViralDraftPerformances.
     */
    data: ViralDraftPerformanceCreateManyInput | ViralDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralDraftPerformance update
   */
  export type ViralDraftPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a ViralDraftPerformance.
     */
    data: XOR<ViralDraftPerformanceUpdateInput, ViralDraftPerformanceUncheckedUpdateInput>
    /**
     * Choose, which ViralDraftPerformance to update.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance updateMany
   */
  export type ViralDraftPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViralDraftPerformances.
     */
    data: XOR<ViralDraftPerformanceUpdateManyMutationInput, ViralDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which ViralDraftPerformances to update
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * Limit how many ViralDraftPerformances to update.
     */
    limit?: number
  }

  /**
   * ViralDraftPerformance updateManyAndReturn
   */
  export type ViralDraftPerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * The data used to update ViralDraftPerformances.
     */
    data: XOR<ViralDraftPerformanceUpdateManyMutationInput, ViralDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which ViralDraftPerformances to update
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * Limit how many ViralDraftPerformances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViralDraftPerformance upsert
   */
  export type ViralDraftPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the ViralDraftPerformance to update in case it exists.
     */
    where: ViralDraftPerformanceWhereUniqueInput
    /**
     * In case the ViralDraftPerformance found by the `where` argument doesn't exist, create a new ViralDraftPerformance with this data.
     */
    create: XOR<ViralDraftPerformanceCreateInput, ViralDraftPerformanceUncheckedCreateInput>
    /**
     * In case the ViralDraftPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViralDraftPerformanceUpdateInput, ViralDraftPerformanceUncheckedUpdateInput>
  }

  /**
   * ViralDraftPerformance delete
   */
  export type ViralDraftPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter which ViralDraftPerformance to delete.
     */
    where: ViralDraftPerformanceWhereUniqueInput
  }

  /**
   * ViralDraftPerformance deleteMany
   */
  export type ViralDraftPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViralDraftPerformances to delete
     */
    where?: ViralDraftPerformanceWhereInput
    /**
     * Limit how many ViralDraftPerformances to delete.
     */
    limit?: number
  }

  /**
   * ViralDraftPerformance without action
   */
  export type ViralDraftPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViralDraftPerformance
     */
    select?: ViralDraftPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViralDraftPerformance
     */
    omit?: ViralDraftPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViralDraftPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model CharacterProfile
   */

  export type AggregateCharacterProfile = {
    _count: CharacterProfileCountAggregateOutputType | null
    _avg: CharacterProfileAvgAggregateOutputType | null
    _sum: CharacterProfileSumAggregateOutputType | null
    _min: CharacterProfileMinAggregateOutputType | null
    _max: CharacterProfileMaxAggregateOutputType | null
  }

  export type CharacterProfileAvgAggregateOutputType = {
    age: number | null
  }

  export type CharacterProfileSumAggregateOutputType = {
    age: number | null
  }

  export type CharacterProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    display_name: string | null
    age: number | null
    gender: $Enums.Gender | null
    occupation: string | null
    catchphrase: string | null
    personality: string | null
    speaking_style: string | null
    expertise: string | null
    backstory: string | null
    philosophy: string | null
    tone: string | null
    emoji_style: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    display_name: string | null
    age: number | null
    gender: $Enums.Gender | null
    occupation: string | null
    catchphrase: string | null
    personality: string | null
    speaking_style: string | null
    expertise: string | null
    backstory: string | null
    philosophy: string | null
    tone: string | null
    emoji_style: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterProfileCountAggregateOutputType = {
    id: number
    name: number
    display_name: number
    age: number
    gender: number
    occupation: number
    catchphrase: number
    personality: number
    speaking_style: number
    expertise: number
    backstory: number
    philosophy: number
    tone: number
    voiceStyle: number
    emoji_style: number
    createdAt: number
    updatedAt: number
    preferredNewsCategories: number
    newsCommentStyle: number
    topicExpertise: number
    _all: number
  }


  export type CharacterProfileAvgAggregateInputType = {
    age?: true
  }

  export type CharacterProfileSumAggregateInputType = {
    age?: true
  }

  export type CharacterProfileMinAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    age?: true
    gender?: true
    occupation?: true
    catchphrase?: true
    personality?: true
    speaking_style?: true
    expertise?: true
    backstory?: true
    philosophy?: true
    tone?: true
    emoji_style?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterProfileMaxAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    age?: true
    gender?: true
    occupation?: true
    catchphrase?: true
    personality?: true
    speaking_style?: true
    expertise?: true
    backstory?: true
    philosophy?: true
    tone?: true
    emoji_style?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterProfileCountAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    age?: true
    gender?: true
    occupation?: true
    catchphrase?: true
    personality?: true
    speaking_style?: true
    expertise?: true
    backstory?: true
    philosophy?: true
    tone?: true
    voiceStyle?: true
    emoji_style?: true
    createdAt?: true
    updatedAt?: true
    preferredNewsCategories?: true
    newsCommentStyle?: true
    topicExpertise?: true
    _all?: true
  }

  export type CharacterProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterProfile to aggregate.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterProfiles
    **/
    _count?: true | CharacterProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterProfileMaxAggregateInputType
  }

  export type GetCharacterProfileAggregateType<T extends CharacterProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterProfile[P]>
      : GetScalarType<T[P], AggregateCharacterProfile[P]>
  }




  export type CharacterProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterProfileWhereInput
    orderBy?: CharacterProfileOrderByWithAggregationInput | CharacterProfileOrderByWithAggregationInput[]
    by: CharacterProfileScalarFieldEnum[] | CharacterProfileScalarFieldEnum
    having?: CharacterProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterProfileCountAggregateInputType | true
    _avg?: CharacterProfileAvgAggregateInputType
    _sum?: CharacterProfileSumAggregateInputType
    _min?: CharacterProfileMinAggregateInputType
    _max?: CharacterProfileMaxAggregateInputType
  }

  export type CharacterProfileGroupByOutputType = {
    id: string
    name: string
    display_name: string
    age: number
    gender: $Enums.Gender
    occupation: string
    catchphrase: string
    personality: string
    speaking_style: string
    expertise: string
    backstory: string
    philosophy: string | null
    tone: string
    voiceStyle: JsonValue
    emoji_style: string
    createdAt: Date
    updatedAt: Date
    preferredNewsCategories: string[]
    newsCommentStyle: JsonValue | null
    topicExpertise: JsonValue | null
    _count: CharacterProfileCountAggregateOutputType | null
    _avg: CharacterProfileAvgAggregateOutputType | null
    _sum: CharacterProfileSumAggregateOutputType | null
    _min: CharacterProfileMinAggregateOutputType | null
    _max: CharacterProfileMaxAggregateOutputType | null
  }

  type GetCharacterProfileGroupByPayload<T extends CharacterProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterProfileGroupByOutputType[P]>
        }
      >
    >


  export type CharacterProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    display_name?: boolean
    age?: boolean
    gender?: boolean
    occupation?: boolean
    catchphrase?: boolean
    personality?: boolean
    speaking_style?: boolean
    expertise?: boolean
    backstory?: boolean
    philosophy?: boolean
    tone?: boolean
    voiceStyle?: boolean
    emoji_style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
  }, ExtArgs["result"]["characterProfile"]>

  export type CharacterProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    display_name?: boolean
    age?: boolean
    gender?: boolean
    occupation?: boolean
    catchphrase?: boolean
    personality?: boolean
    speaking_style?: boolean
    expertise?: boolean
    backstory?: boolean
    philosophy?: boolean
    tone?: boolean
    voiceStyle?: boolean
    emoji_style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
  }, ExtArgs["result"]["characterProfile"]>

  export type CharacterProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    display_name?: boolean
    age?: boolean
    gender?: boolean
    occupation?: boolean
    catchphrase?: boolean
    personality?: boolean
    speaking_style?: boolean
    expertise?: boolean
    backstory?: boolean
    philosophy?: boolean
    tone?: boolean
    voiceStyle?: boolean
    emoji_style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
  }, ExtArgs["result"]["characterProfile"]>

  export type CharacterProfileSelectScalar = {
    id?: boolean
    name?: boolean
    display_name?: boolean
    age?: boolean
    gender?: boolean
    occupation?: boolean
    catchphrase?: boolean
    personality?: boolean
    speaking_style?: boolean
    expertise?: boolean
    backstory?: boolean
    philosophy?: boolean
    tone?: boolean
    voiceStyle?: boolean
    emoji_style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredNewsCategories?: boolean
    newsCommentStyle?: boolean
    topicExpertise?: boolean
  }

  export type CharacterProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "display_name" | "age" | "gender" | "occupation" | "catchphrase" | "personality" | "speaking_style" | "expertise" | "backstory" | "philosophy" | "tone" | "voiceStyle" | "emoji_style" | "createdAt" | "updatedAt" | "preferredNewsCategories" | "newsCommentStyle" | "topicExpertise", ExtArgs["result"]["characterProfile"]>

  export type $CharacterProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      display_name: string
      age: number
      gender: $Enums.Gender
      occupation: string
      catchphrase: string
      personality: string
      speaking_style: string
      expertise: string
      backstory: string
      philosophy: string | null
      tone: string
      voiceStyle: Prisma.JsonValue
      emoji_style: string
      createdAt: Date
      updatedAt: Date
      preferredNewsCategories: string[]
      newsCommentStyle: Prisma.JsonValue | null
      topicExpertise: Prisma.JsonValue | null
    }, ExtArgs["result"]["characterProfile"]>
    composites: {}
  }

  type CharacterProfileGetPayload<S extends boolean | null | undefined | CharacterProfileDefaultArgs> = $Result.GetResult<Prisma.$CharacterProfilePayload, S>

  type CharacterProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterProfileCountAggregateInputType | true
    }

  export interface CharacterProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterProfile'], meta: { name: 'CharacterProfile' } }
    /**
     * Find zero or one CharacterProfile that matches the filter.
     * @param {CharacterProfileFindUniqueArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterProfileFindUniqueArgs>(args: SelectSubset<T, CharacterProfileFindUniqueArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterProfileFindUniqueOrThrowArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileFindFirstArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterProfileFindFirstArgs>(args?: SelectSubset<T, CharacterProfileFindFirstArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileFindFirstOrThrowArgs} args - Arguments to find a CharacterProfile
     * @example
     * // Get one CharacterProfile
     * const characterProfile = await prisma.characterProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterProfiles
     * const characterProfiles = await prisma.characterProfile.findMany()
     * 
     * // Get first 10 CharacterProfiles
     * const characterProfiles = await prisma.characterProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterProfileWithIdOnly = await prisma.characterProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterProfileFindManyArgs>(args?: SelectSubset<T, CharacterProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterProfile.
     * @param {CharacterProfileCreateArgs} args - Arguments to create a CharacterProfile.
     * @example
     * // Create one CharacterProfile
     * const CharacterProfile = await prisma.characterProfile.create({
     *   data: {
     *     // ... data to create a CharacterProfile
     *   }
     * })
     * 
     */
    create<T extends CharacterProfileCreateArgs>(args: SelectSubset<T, CharacterProfileCreateArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterProfiles.
     * @param {CharacterProfileCreateManyArgs} args - Arguments to create many CharacterProfiles.
     * @example
     * // Create many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterProfileCreateManyArgs>(args?: SelectSubset<T, CharacterProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterProfiles and returns the data saved in the database.
     * @param {CharacterProfileCreateManyAndReturnArgs} args - Arguments to create many CharacterProfiles.
     * @example
     * // Create many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterProfiles and only return the `id`
     * const characterProfileWithIdOnly = await prisma.characterProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterProfile.
     * @param {CharacterProfileDeleteArgs} args - Arguments to delete one CharacterProfile.
     * @example
     * // Delete one CharacterProfile
     * const CharacterProfile = await prisma.characterProfile.delete({
     *   where: {
     *     // ... filter to delete one CharacterProfile
     *   }
     * })
     * 
     */
    delete<T extends CharacterProfileDeleteArgs>(args: SelectSubset<T, CharacterProfileDeleteArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterProfile.
     * @param {CharacterProfileUpdateArgs} args - Arguments to update one CharacterProfile.
     * @example
     * // Update one CharacterProfile
     * const characterProfile = await prisma.characterProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterProfileUpdateArgs>(args: SelectSubset<T, CharacterProfileUpdateArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterProfiles.
     * @param {CharacterProfileDeleteManyArgs} args - Arguments to filter CharacterProfiles to delete.
     * @example
     * // Delete a few CharacterProfiles
     * const { count } = await prisma.characterProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterProfileDeleteManyArgs>(args?: SelectSubset<T, CharacterProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterProfileUpdateManyArgs>(args: SelectSubset<T, CharacterProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterProfiles and returns the data updated in the database.
     * @param {CharacterProfileUpdateManyAndReturnArgs} args - Arguments to update many CharacterProfiles.
     * @example
     * // Update many CharacterProfiles
     * const characterProfile = await prisma.characterProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterProfiles and only return the `id`
     * const characterProfileWithIdOnly = await prisma.characterProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterProfile.
     * @param {CharacterProfileUpsertArgs} args - Arguments to update or create a CharacterProfile.
     * @example
     * // Update or create a CharacterProfile
     * const characterProfile = await prisma.characterProfile.upsert({
     *   create: {
     *     // ... data to create a CharacterProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterProfile we want to update
     *   }
     * })
     */
    upsert<T extends CharacterProfileUpsertArgs>(args: SelectSubset<T, CharacterProfileUpsertArgs<ExtArgs>>): Prisma__CharacterProfileClient<$Result.GetResult<Prisma.$CharacterProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileCountArgs} args - Arguments to filter CharacterProfiles to count.
     * @example
     * // Count the number of CharacterProfiles
     * const count = await prisma.characterProfile.count({
     *   where: {
     *     // ... the filter for the CharacterProfiles we want to count
     *   }
     * })
    **/
    count<T extends CharacterProfileCountArgs>(
      args?: Subset<T, CharacterProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterProfileAggregateArgs>(args: Subset<T, CharacterProfileAggregateArgs>): Prisma.PrismaPromise<GetCharacterProfileAggregateType<T>>

    /**
     * Group by CharacterProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterProfileGroupByArgs['orderBy'] }
        : { orderBy?: CharacterProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterProfile model
   */
  readonly fields: CharacterProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterProfile model
   */
  interface CharacterProfileFieldRefs {
    readonly id: FieldRef<"CharacterProfile", 'String'>
    readonly name: FieldRef<"CharacterProfile", 'String'>
    readonly display_name: FieldRef<"CharacterProfile", 'String'>
    readonly age: FieldRef<"CharacterProfile", 'Int'>
    readonly gender: FieldRef<"CharacterProfile", 'Gender'>
    readonly occupation: FieldRef<"CharacterProfile", 'String'>
    readonly catchphrase: FieldRef<"CharacterProfile", 'String'>
    readonly personality: FieldRef<"CharacterProfile", 'String'>
    readonly speaking_style: FieldRef<"CharacterProfile", 'String'>
    readonly expertise: FieldRef<"CharacterProfile", 'String'>
    readonly backstory: FieldRef<"CharacterProfile", 'String'>
    readonly philosophy: FieldRef<"CharacterProfile", 'String'>
    readonly tone: FieldRef<"CharacterProfile", 'String'>
    readonly voiceStyle: FieldRef<"CharacterProfile", 'Json'>
    readonly emoji_style: FieldRef<"CharacterProfile", 'String'>
    readonly createdAt: FieldRef<"CharacterProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterProfile", 'DateTime'>
    readonly preferredNewsCategories: FieldRef<"CharacterProfile", 'String[]'>
    readonly newsCommentStyle: FieldRef<"CharacterProfile", 'Json'>
    readonly topicExpertise: FieldRef<"CharacterProfile", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CharacterProfile findUnique
   */
  export type CharacterProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile findUniqueOrThrow
   */
  export type CharacterProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile findFirst
   */
  export type CharacterProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterProfiles.
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterProfiles.
     */
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * CharacterProfile findFirstOrThrow
   */
  export type CharacterProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * Filter, which CharacterProfile to fetch.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterProfiles.
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterProfiles.
     */
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * CharacterProfile findMany
   */
  export type CharacterProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * Filter, which CharacterProfiles to fetch.
     */
    where?: CharacterProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterProfiles to fetch.
     */
    orderBy?: CharacterProfileOrderByWithRelationInput | CharacterProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterProfiles.
     */
    cursor?: CharacterProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterProfiles.
     */
    skip?: number
    distinct?: CharacterProfileScalarFieldEnum | CharacterProfileScalarFieldEnum[]
  }

  /**
   * CharacterProfile create
   */
  export type CharacterProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a CharacterProfile.
     */
    data: XOR<CharacterProfileCreateInput, CharacterProfileUncheckedCreateInput>
  }

  /**
   * CharacterProfile createMany
   */
  export type CharacterProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterProfiles.
     */
    data: CharacterProfileCreateManyInput | CharacterProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterProfile createManyAndReturn
   */
  export type CharacterProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterProfiles.
     */
    data: CharacterProfileCreateManyInput | CharacterProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterProfile update
   */
  export type CharacterProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a CharacterProfile.
     */
    data: XOR<CharacterProfileUpdateInput, CharacterProfileUncheckedUpdateInput>
    /**
     * Choose, which CharacterProfile to update.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile updateMany
   */
  export type CharacterProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterProfiles.
     */
    data: XOR<CharacterProfileUpdateManyMutationInput, CharacterProfileUncheckedUpdateManyInput>
    /**
     * Filter which CharacterProfiles to update
     */
    where?: CharacterProfileWhereInput
    /**
     * Limit how many CharacterProfiles to update.
     */
    limit?: number
  }

  /**
   * CharacterProfile updateManyAndReturn
   */
  export type CharacterProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * The data used to update CharacterProfiles.
     */
    data: XOR<CharacterProfileUpdateManyMutationInput, CharacterProfileUncheckedUpdateManyInput>
    /**
     * Filter which CharacterProfiles to update
     */
    where?: CharacterProfileWhereInput
    /**
     * Limit how many CharacterProfiles to update.
     */
    limit?: number
  }

  /**
   * CharacterProfile upsert
   */
  export type CharacterProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the CharacterProfile to update in case it exists.
     */
    where: CharacterProfileWhereUniqueInput
    /**
     * In case the CharacterProfile found by the `where` argument doesn't exist, create a new CharacterProfile with this data.
     */
    create: XOR<CharacterProfileCreateInput, CharacterProfileUncheckedCreateInput>
    /**
     * In case the CharacterProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterProfileUpdateInput, CharacterProfileUncheckedUpdateInput>
  }

  /**
   * CharacterProfile delete
   */
  export type CharacterProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
    /**
     * Filter which CharacterProfile to delete.
     */
    where: CharacterProfileWhereUniqueInput
  }

  /**
   * CharacterProfile deleteMany
   */
  export type CharacterProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterProfiles to delete
     */
    where?: CharacterProfileWhereInput
    /**
     * Limit how many CharacterProfiles to delete.
     */
    limit?: number
  }

  /**
   * CharacterProfile without action
   */
  export type CharacterProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterProfile
     */
    select?: CharacterProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterProfile
     */
    omit?: CharacterProfileOmit<ExtArgs> | null
  }


  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountsSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: string | null
    provider: string | null
    provider_account_id: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: string | null
    provider: string | null
    provider_account_id: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    provider: number
    provider_account_id: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountsSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: string
    user_id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "provider" | "provider_account_id" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["accounts"]>
  export type accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type accountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      type: string
      provider: string
      provider_account_id: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountsFindUniqueArgs>(args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountsFindFirstArgs>(args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountsFindManyArgs>(args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
     */
    create<T extends accountsCreateArgs>(args: SelectSubset<T, accountsCreateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountsCreateManyArgs>(args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {accountsCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountsWithIdOnly = await prisma.accounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
     */
    delete<T extends accountsDeleteArgs>(args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountsUpdateArgs>(args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountsDeleteManyArgs>(args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountsUpdateManyArgs>(args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {accountsUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountsWithIdOnly = await prisma.accounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends accountsUpdateManyAndReturnArgs>(args: SelectSubset<T, accountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
     */
    upsert<T extends accountsUpsertArgs>(args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accounts model
   */
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'String'>
    readonly user_id: FieldRef<"accounts", 'String'>
    readonly type: FieldRef<"accounts", 'String'>
    readonly provider: FieldRef<"accounts", 'String'>
    readonly provider_account_id: FieldRef<"accounts", 'String'>
    readonly refresh_token: FieldRef<"accounts", 'String'>
    readonly access_token: FieldRef<"accounts", 'String'>
    readonly expires_at: FieldRef<"accounts", 'Int'>
    readonly token_type: FieldRef<"accounts", 'String'>
    readonly scope: FieldRef<"accounts", 'String'>
    readonly id_token: FieldRef<"accounts", 'String'>
    readonly session_state: FieldRef<"accounts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts createManyAndReturn
   */
  export type accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * accounts updateManyAndReturn
   */
  export type accountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
  }


  /**
   * Model ai_patterns
   */

  export type AggregateAi_patterns = {
    _count: Ai_patternsCountAggregateOutputType | null
    _avg: Ai_patternsAvgAggregateOutputType | null
    _sum: Ai_patternsSumAggregateOutputType | null
    _min: Ai_patternsMinAggregateOutputType | null
    _max: Ai_patternsMaxAggregateOutputType | null
  }

  export type Ai_patternsAvgAggregateOutputType = {
    success_rate: number | null
    usage_count: number | null
  }

  export type Ai_patternsSumAggregateOutputType = {
    success_rate: number | null
    usage_count: number | null
  }

  export type Ai_patternsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    prompt_template: string | null
    example_output: string | null
    success_rate: number | null
    usage_count: number | null
    created_at: Date | null
  }

  export type Ai_patternsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    prompt_template: string | null
    example_output: string | null
    success_rate: number | null
    usage_count: number | null
    created_at: Date | null
  }

  export type Ai_patternsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    prompt_template: number
    example_output: number
    success_rate: number
    usage_count: number
    created_at: number
    _all: number
  }


  export type Ai_patternsAvgAggregateInputType = {
    success_rate?: true
    usage_count?: true
  }

  export type Ai_patternsSumAggregateInputType = {
    success_rate?: true
    usage_count?: true
  }

  export type Ai_patternsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prompt_template?: true
    example_output?: true
    success_rate?: true
    usage_count?: true
    created_at?: true
  }

  export type Ai_patternsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prompt_template?: true
    example_output?: true
    success_rate?: true
    usage_count?: true
    created_at?: true
  }

  export type Ai_patternsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prompt_template?: true
    example_output?: true
    success_rate?: true
    usage_count?: true
    created_at?: true
    _all?: true
  }

  export type Ai_patternsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_patterns to aggregate.
     */
    where?: ai_patternsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_patterns to fetch.
     */
    orderBy?: ai_patternsOrderByWithRelationInput | ai_patternsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_patternsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_patterns
    **/
    _count?: true | Ai_patternsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_patternsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_patternsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_patternsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_patternsMaxAggregateInputType
  }

  export type GetAi_patternsAggregateType<T extends Ai_patternsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_patterns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_patterns[P]>
      : GetScalarType<T[P], AggregateAi_patterns[P]>
  }




  export type ai_patternsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_patternsWhereInput
    orderBy?: ai_patternsOrderByWithAggregationInput | ai_patternsOrderByWithAggregationInput[]
    by: Ai_patternsScalarFieldEnum[] | Ai_patternsScalarFieldEnum
    having?: ai_patternsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_patternsCountAggregateInputType | true
    _avg?: Ai_patternsAvgAggregateInputType
    _sum?: Ai_patternsSumAggregateInputType
    _min?: Ai_patternsMinAggregateInputType
    _max?: Ai_patternsMaxAggregateInputType
  }

  export type Ai_patternsGroupByOutputType = {
    id: string
    name: string
    description: string
    prompt_template: string
    example_output: string
    success_rate: number
    usage_count: number
    created_at: Date
    _count: Ai_patternsCountAggregateOutputType | null
    _avg: Ai_patternsAvgAggregateOutputType | null
    _sum: Ai_patternsSumAggregateOutputType | null
    _min: Ai_patternsMinAggregateOutputType | null
    _max: Ai_patternsMaxAggregateOutputType | null
  }

  type GetAi_patternsGroupByPayload<T extends ai_patternsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_patternsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_patternsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_patternsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_patternsGroupByOutputType[P]>
        }
      >
    >


  export type ai_patternsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prompt_template?: boolean
    example_output?: boolean
    success_rate?: boolean
    usage_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ai_patterns"]>

  export type ai_patternsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prompt_template?: boolean
    example_output?: boolean
    success_rate?: boolean
    usage_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ai_patterns"]>

  export type ai_patternsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prompt_template?: boolean
    example_output?: boolean
    success_rate?: boolean
    usage_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ai_patterns"]>

  export type ai_patternsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    prompt_template?: boolean
    example_output?: boolean
    success_rate?: boolean
    usage_count?: boolean
    created_at?: boolean
  }

  export type ai_patternsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "prompt_template" | "example_output" | "success_rate" | "usage_count" | "created_at", ExtArgs["result"]["ai_patterns"]>

  export type $ai_patternsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_patterns"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      prompt_template: string
      example_output: string
      success_rate: number
      usage_count: number
      created_at: Date
    }, ExtArgs["result"]["ai_patterns"]>
    composites: {}
  }

  type ai_patternsGetPayload<S extends boolean | null | undefined | ai_patternsDefaultArgs> = $Result.GetResult<Prisma.$ai_patternsPayload, S>

  type ai_patternsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_patternsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_patternsCountAggregateInputType | true
    }

  export interface ai_patternsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_patterns'], meta: { name: 'ai_patterns' } }
    /**
     * Find zero or one Ai_patterns that matches the filter.
     * @param {ai_patternsFindUniqueArgs} args - Arguments to find a Ai_patterns
     * @example
     * // Get one Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_patternsFindUniqueArgs>(args: SelectSubset<T, ai_patternsFindUniqueArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_patterns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_patternsFindUniqueOrThrowArgs} args - Arguments to find a Ai_patterns
     * @example
     * // Get one Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_patternsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_patternsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_patterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_patternsFindFirstArgs} args - Arguments to find a Ai_patterns
     * @example
     * // Get one Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_patternsFindFirstArgs>(args?: SelectSubset<T, ai_patternsFindFirstArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_patterns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_patternsFindFirstOrThrowArgs} args - Arguments to find a Ai_patterns
     * @example
     * // Get one Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_patternsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_patternsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_patterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_patternsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.findMany()
     * 
     * // Get first 10 Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_patternsWithIdOnly = await prisma.ai_patterns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_patternsFindManyArgs>(args?: SelectSubset<T, ai_patternsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_patterns.
     * @param {ai_patternsCreateArgs} args - Arguments to create a Ai_patterns.
     * @example
     * // Create one Ai_patterns
     * const Ai_patterns = await prisma.ai_patterns.create({
     *   data: {
     *     // ... data to create a Ai_patterns
     *   }
     * })
     * 
     */
    create<T extends ai_patternsCreateArgs>(args: SelectSubset<T, ai_patternsCreateArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_patterns.
     * @param {ai_patternsCreateManyArgs} args - Arguments to create many Ai_patterns.
     * @example
     * // Create many Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_patternsCreateManyArgs>(args?: SelectSubset<T, ai_patternsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_patterns and returns the data saved in the database.
     * @param {ai_patternsCreateManyAndReturnArgs} args - Arguments to create many Ai_patterns.
     * @example
     * // Create many Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_patterns and only return the `id`
     * const ai_patternsWithIdOnly = await prisma.ai_patterns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_patternsCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_patternsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_patterns.
     * @param {ai_patternsDeleteArgs} args - Arguments to delete one Ai_patterns.
     * @example
     * // Delete one Ai_patterns
     * const Ai_patterns = await prisma.ai_patterns.delete({
     *   where: {
     *     // ... filter to delete one Ai_patterns
     *   }
     * })
     * 
     */
    delete<T extends ai_patternsDeleteArgs>(args: SelectSubset<T, ai_patternsDeleteArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_patterns.
     * @param {ai_patternsUpdateArgs} args - Arguments to update one Ai_patterns.
     * @example
     * // Update one Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_patternsUpdateArgs>(args: SelectSubset<T, ai_patternsUpdateArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_patterns.
     * @param {ai_patternsDeleteManyArgs} args - Arguments to filter Ai_patterns to delete.
     * @example
     * // Delete a few Ai_patterns
     * const { count } = await prisma.ai_patterns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_patternsDeleteManyArgs>(args?: SelectSubset<T, ai_patternsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_patternsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_patternsUpdateManyArgs>(args: SelectSubset<T, ai_patternsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_patterns and returns the data updated in the database.
     * @param {ai_patternsUpdateManyAndReturnArgs} args - Arguments to update many Ai_patterns.
     * @example
     * // Update many Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_patterns and only return the `id`
     * const ai_patternsWithIdOnly = await prisma.ai_patterns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_patternsUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_patternsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_patterns.
     * @param {ai_patternsUpsertArgs} args - Arguments to update or create a Ai_patterns.
     * @example
     * // Update or create a Ai_patterns
     * const ai_patterns = await prisma.ai_patterns.upsert({
     *   create: {
     *     // ... data to create a Ai_patterns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_patterns we want to update
     *   }
     * })
     */
    upsert<T extends ai_patternsUpsertArgs>(args: SelectSubset<T, ai_patternsUpsertArgs<ExtArgs>>): Prisma__ai_patternsClient<$Result.GetResult<Prisma.$ai_patternsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_patternsCountArgs} args - Arguments to filter Ai_patterns to count.
     * @example
     * // Count the number of Ai_patterns
     * const count = await prisma.ai_patterns.count({
     *   where: {
     *     // ... the filter for the Ai_patterns we want to count
     *   }
     * })
    **/
    count<T extends ai_patternsCountArgs>(
      args?: Subset<T, ai_patternsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_patternsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_patternsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_patternsAggregateArgs>(args: Subset<T, Ai_patternsAggregateArgs>): Prisma.PrismaPromise<GetAi_patternsAggregateType<T>>

    /**
     * Group by Ai_patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_patternsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_patternsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_patternsGroupByArgs['orderBy'] }
        : { orderBy?: ai_patternsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_patternsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_patternsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_patterns model
   */
  readonly fields: ai_patternsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_patterns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_patternsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_patterns model
   */
  interface ai_patternsFieldRefs {
    readonly id: FieldRef<"ai_patterns", 'String'>
    readonly name: FieldRef<"ai_patterns", 'String'>
    readonly description: FieldRef<"ai_patterns", 'String'>
    readonly prompt_template: FieldRef<"ai_patterns", 'String'>
    readonly example_output: FieldRef<"ai_patterns", 'String'>
    readonly success_rate: FieldRef<"ai_patterns", 'Float'>
    readonly usage_count: FieldRef<"ai_patterns", 'Int'>
    readonly created_at: FieldRef<"ai_patterns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_patterns findUnique
   */
  export type ai_patternsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * Filter, which ai_patterns to fetch.
     */
    where: ai_patternsWhereUniqueInput
  }

  /**
   * ai_patterns findUniqueOrThrow
   */
  export type ai_patternsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * Filter, which ai_patterns to fetch.
     */
    where: ai_patternsWhereUniqueInput
  }

  /**
   * ai_patterns findFirst
   */
  export type ai_patternsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * Filter, which ai_patterns to fetch.
     */
    where?: ai_patternsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_patterns to fetch.
     */
    orderBy?: ai_patternsOrderByWithRelationInput | ai_patternsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_patterns.
     */
    cursor?: ai_patternsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_patterns.
     */
    distinct?: Ai_patternsScalarFieldEnum | Ai_patternsScalarFieldEnum[]
  }

  /**
   * ai_patterns findFirstOrThrow
   */
  export type ai_patternsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * Filter, which ai_patterns to fetch.
     */
    where?: ai_patternsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_patterns to fetch.
     */
    orderBy?: ai_patternsOrderByWithRelationInput | ai_patternsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_patterns.
     */
    cursor?: ai_patternsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_patterns.
     */
    distinct?: Ai_patternsScalarFieldEnum | Ai_patternsScalarFieldEnum[]
  }

  /**
   * ai_patterns findMany
   */
  export type ai_patternsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * Filter, which ai_patterns to fetch.
     */
    where?: ai_patternsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_patterns to fetch.
     */
    orderBy?: ai_patternsOrderByWithRelationInput | ai_patternsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_patterns.
     */
    cursor?: ai_patternsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_patterns.
     */
    skip?: number
    distinct?: Ai_patternsScalarFieldEnum | Ai_patternsScalarFieldEnum[]
  }

  /**
   * ai_patterns create
   */
  export type ai_patternsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * The data needed to create a ai_patterns.
     */
    data: XOR<ai_patternsCreateInput, ai_patternsUncheckedCreateInput>
  }

  /**
   * ai_patterns createMany
   */
  export type ai_patternsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_patterns.
     */
    data: ai_patternsCreateManyInput | ai_patternsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_patterns createManyAndReturn
   */
  export type ai_patternsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * The data used to create many ai_patterns.
     */
    data: ai_patternsCreateManyInput | ai_patternsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_patterns update
   */
  export type ai_patternsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * The data needed to update a ai_patterns.
     */
    data: XOR<ai_patternsUpdateInput, ai_patternsUncheckedUpdateInput>
    /**
     * Choose, which ai_patterns to update.
     */
    where: ai_patternsWhereUniqueInput
  }

  /**
   * ai_patterns updateMany
   */
  export type ai_patternsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_patterns.
     */
    data: XOR<ai_patternsUpdateManyMutationInput, ai_patternsUncheckedUpdateManyInput>
    /**
     * Filter which ai_patterns to update
     */
    where?: ai_patternsWhereInput
    /**
     * Limit how many ai_patterns to update.
     */
    limit?: number
  }

  /**
   * ai_patterns updateManyAndReturn
   */
  export type ai_patternsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * The data used to update ai_patterns.
     */
    data: XOR<ai_patternsUpdateManyMutationInput, ai_patternsUncheckedUpdateManyInput>
    /**
     * Filter which ai_patterns to update
     */
    where?: ai_patternsWhereInput
    /**
     * Limit how many ai_patterns to update.
     */
    limit?: number
  }

  /**
   * ai_patterns upsert
   */
  export type ai_patternsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * The filter to search for the ai_patterns to update in case it exists.
     */
    where: ai_patternsWhereUniqueInput
    /**
     * In case the ai_patterns found by the `where` argument doesn't exist, create a new ai_patterns with this data.
     */
    create: XOR<ai_patternsCreateInput, ai_patternsUncheckedCreateInput>
    /**
     * In case the ai_patterns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_patternsUpdateInput, ai_patternsUncheckedUpdateInput>
  }

  /**
   * ai_patterns delete
   */
  export type ai_patternsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
    /**
     * Filter which ai_patterns to delete.
     */
    where: ai_patternsWhereUniqueInput
  }

  /**
   * ai_patterns deleteMany
   */
  export type ai_patternsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_patterns to delete
     */
    where?: ai_patternsWhereInput
    /**
     * Limit how many ai_patterns to delete.
     */
    limit?: number
  }

  /**
   * ai_patterns without action
   */
  export type ai_patternsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_patterns
     */
    select?: ai_patternsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_patterns
     */
    omit?: ai_patternsOmit<ExtArgs> | null
  }


  /**
   * Model content_drafts
   */

  export type AggregateContent_drafts = {
    _count: Content_draftsCountAggregateOutputType | null
    _min: Content_draftsMinAggregateOutputType | null
    _max: Content_draftsMaxAggregateOutputType | null
  }

  export type Content_draftsMinAggregateOutputType = {
    id: string | null
    analysis_id: string | null
    concept_type: string | null
    category: string | null
    title: string | null
    content: string | null
    edited_content: string | null
    explanation: string | null
    target_audience: string | null
    visual_guide: string | null
    platform: string | null
    format: string | null
    status: string | null
    editor_notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Content_draftsMaxAggregateOutputType = {
    id: string | null
    analysis_id: string | null
    concept_type: string | null
    category: string | null
    title: string | null
    content: string | null
    edited_content: string | null
    explanation: string | null
    target_audience: string | null
    visual_guide: string | null
    platform: string | null
    format: string | null
    status: string | null
    editor_notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Content_draftsCountAggregateOutputType = {
    id: number
    analysis_id: number
    concept_type: number
    category: number
    title: number
    content: number
    edited_content: number
    explanation: number
    buzz_factors: number
    target_audience: number
    estimated_engagement: number
    hashtags: number
    visual_guide: number
    platform: number
    format: number
    status: number
    editor_notes: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Content_draftsMinAggregateInputType = {
    id?: true
    analysis_id?: true
    concept_type?: true
    category?: true
    title?: true
    content?: true
    edited_content?: true
    explanation?: true
    target_audience?: true
    visual_guide?: true
    platform?: true
    format?: true
    status?: true
    editor_notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Content_draftsMaxAggregateInputType = {
    id?: true
    analysis_id?: true
    concept_type?: true
    category?: true
    title?: true
    content?: true
    edited_content?: true
    explanation?: true
    target_audience?: true
    visual_guide?: true
    platform?: true
    format?: true
    status?: true
    editor_notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Content_draftsCountAggregateInputType = {
    id?: true
    analysis_id?: true
    concept_type?: true
    category?: true
    title?: true
    content?: true
    edited_content?: true
    explanation?: true
    buzz_factors?: true
    target_audience?: true
    estimated_engagement?: true
    hashtags?: true
    visual_guide?: true
    platform?: true
    format?: true
    status?: true
    editor_notes?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Content_draftsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which content_drafts to aggregate.
     */
    where?: content_draftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of content_drafts to fetch.
     */
    orderBy?: content_draftsOrderByWithRelationInput | content_draftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: content_draftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` content_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` content_drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned content_drafts
    **/
    _count?: true | Content_draftsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Content_draftsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Content_draftsMaxAggregateInputType
  }

  export type GetContent_draftsAggregateType<T extends Content_draftsAggregateArgs> = {
        [P in keyof T & keyof AggregateContent_drafts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent_drafts[P]>
      : GetScalarType<T[P], AggregateContent_drafts[P]>
  }




  export type content_draftsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: content_draftsWhereInput
    orderBy?: content_draftsOrderByWithAggregationInput | content_draftsOrderByWithAggregationInput[]
    by: Content_draftsScalarFieldEnum[] | Content_draftsScalarFieldEnum
    having?: content_draftsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Content_draftsCountAggregateInputType | true
    _min?: Content_draftsMinAggregateInputType
    _max?: Content_draftsMaxAggregateInputType
  }

  export type Content_draftsGroupByOutputType = {
    id: string
    analysis_id: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content: string | null
    explanation: string | null
    buzz_factors: JsonValue | null
    target_audience: string | null
    estimated_engagement: JsonValue | null
    hashtags: JsonValue | null
    visual_guide: string | null
    platform: string | null
    format: string | null
    status: string | null
    editor_notes: string | null
    metadata: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    _count: Content_draftsCountAggregateOutputType | null
    _min: Content_draftsMinAggregateOutputType | null
    _max: Content_draftsMaxAggregateOutputType | null
  }

  type GetContent_draftsGroupByPayload<T extends content_draftsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Content_draftsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Content_draftsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Content_draftsGroupByOutputType[P]>
            : GetScalarType<T[P], Content_draftsGroupByOutputType[P]>
        }
      >
    >


  export type content_draftsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysis_id?: boolean
    concept_type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    edited_content?: boolean
    explanation?: boolean
    buzz_factors?: boolean
    target_audience?: boolean
    estimated_engagement?: boolean
    hashtags?: boolean
    visual_guide?: boolean
    platform?: boolean
    format?: boolean
    status?: boolean
    editor_notes?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    gpt_analyses?: boolean | gpt_analysesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content_drafts"]>

  export type content_draftsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysis_id?: boolean
    concept_type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    edited_content?: boolean
    explanation?: boolean
    buzz_factors?: boolean
    target_audience?: boolean
    estimated_engagement?: boolean
    hashtags?: boolean
    visual_guide?: boolean
    platform?: boolean
    format?: boolean
    status?: boolean
    editor_notes?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    gpt_analyses?: boolean | gpt_analysesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content_drafts"]>

  export type content_draftsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysis_id?: boolean
    concept_type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    edited_content?: boolean
    explanation?: boolean
    buzz_factors?: boolean
    target_audience?: boolean
    estimated_engagement?: boolean
    hashtags?: boolean
    visual_guide?: boolean
    platform?: boolean
    format?: boolean
    status?: boolean
    editor_notes?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    gpt_analyses?: boolean | gpt_analysesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content_drafts"]>

  export type content_draftsSelectScalar = {
    id?: boolean
    analysis_id?: boolean
    concept_type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    edited_content?: boolean
    explanation?: boolean
    buzz_factors?: boolean
    target_audience?: boolean
    estimated_engagement?: boolean
    hashtags?: boolean
    visual_guide?: boolean
    platform?: boolean
    format?: boolean
    status?: boolean
    editor_notes?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type content_draftsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "analysis_id" | "concept_type" | "category" | "title" | "content" | "edited_content" | "explanation" | "buzz_factors" | "target_audience" | "estimated_engagement" | "hashtags" | "visual_guide" | "platform" | "format" | "status" | "editor_notes" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["content_drafts"]>
  export type content_draftsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gpt_analyses?: boolean | gpt_analysesDefaultArgs<ExtArgs>
  }
  export type content_draftsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gpt_analyses?: boolean | gpt_analysesDefaultArgs<ExtArgs>
  }
  export type content_draftsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gpt_analyses?: boolean | gpt_analysesDefaultArgs<ExtArgs>
  }

  export type $content_draftsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "content_drafts"
    objects: {
      gpt_analyses: Prisma.$gpt_analysesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      analysis_id: string
      concept_type: string
      category: string
      title: string
      content: string
      edited_content: string | null
      explanation: string | null
      buzz_factors: Prisma.JsonValue | null
      target_audience: string | null
      estimated_engagement: Prisma.JsonValue | null
      hashtags: Prisma.JsonValue | null
      visual_guide: string | null
      platform: string | null
      format: string | null
      status: string | null
      editor_notes: string | null
      metadata: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["content_drafts"]>
    composites: {}
  }

  type content_draftsGetPayload<S extends boolean | null | undefined | content_draftsDefaultArgs> = $Result.GetResult<Prisma.$content_draftsPayload, S>

  type content_draftsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<content_draftsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Content_draftsCountAggregateInputType | true
    }

  export interface content_draftsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['content_drafts'], meta: { name: 'content_drafts' } }
    /**
     * Find zero or one Content_drafts that matches the filter.
     * @param {content_draftsFindUniqueArgs} args - Arguments to find a Content_drafts
     * @example
     * // Get one Content_drafts
     * const content_drafts = await prisma.content_drafts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends content_draftsFindUniqueArgs>(args: SelectSubset<T, content_draftsFindUniqueArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Content_drafts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {content_draftsFindUniqueOrThrowArgs} args - Arguments to find a Content_drafts
     * @example
     * // Get one Content_drafts
     * const content_drafts = await prisma.content_drafts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends content_draftsFindUniqueOrThrowArgs>(args: SelectSubset<T, content_draftsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content_drafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {content_draftsFindFirstArgs} args - Arguments to find a Content_drafts
     * @example
     * // Get one Content_drafts
     * const content_drafts = await prisma.content_drafts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends content_draftsFindFirstArgs>(args?: SelectSubset<T, content_draftsFindFirstArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content_drafts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {content_draftsFindFirstOrThrowArgs} args - Arguments to find a Content_drafts
     * @example
     * // Get one Content_drafts
     * const content_drafts = await prisma.content_drafts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends content_draftsFindFirstOrThrowArgs>(args?: SelectSubset<T, content_draftsFindFirstOrThrowArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Content_drafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {content_draftsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Content_drafts
     * const content_drafts = await prisma.content_drafts.findMany()
     * 
     * // Get first 10 Content_drafts
     * const content_drafts = await prisma.content_drafts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const content_draftsWithIdOnly = await prisma.content_drafts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends content_draftsFindManyArgs>(args?: SelectSubset<T, content_draftsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Content_drafts.
     * @param {content_draftsCreateArgs} args - Arguments to create a Content_drafts.
     * @example
     * // Create one Content_drafts
     * const Content_drafts = await prisma.content_drafts.create({
     *   data: {
     *     // ... data to create a Content_drafts
     *   }
     * })
     * 
     */
    create<T extends content_draftsCreateArgs>(args: SelectSubset<T, content_draftsCreateArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Content_drafts.
     * @param {content_draftsCreateManyArgs} args - Arguments to create many Content_drafts.
     * @example
     * // Create many Content_drafts
     * const content_drafts = await prisma.content_drafts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends content_draftsCreateManyArgs>(args?: SelectSubset<T, content_draftsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Content_drafts and returns the data saved in the database.
     * @param {content_draftsCreateManyAndReturnArgs} args - Arguments to create many Content_drafts.
     * @example
     * // Create many Content_drafts
     * const content_drafts = await prisma.content_drafts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Content_drafts and only return the `id`
     * const content_draftsWithIdOnly = await prisma.content_drafts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends content_draftsCreateManyAndReturnArgs>(args?: SelectSubset<T, content_draftsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Content_drafts.
     * @param {content_draftsDeleteArgs} args - Arguments to delete one Content_drafts.
     * @example
     * // Delete one Content_drafts
     * const Content_drafts = await prisma.content_drafts.delete({
     *   where: {
     *     // ... filter to delete one Content_drafts
     *   }
     * })
     * 
     */
    delete<T extends content_draftsDeleteArgs>(args: SelectSubset<T, content_draftsDeleteArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Content_drafts.
     * @param {content_draftsUpdateArgs} args - Arguments to update one Content_drafts.
     * @example
     * // Update one Content_drafts
     * const content_drafts = await prisma.content_drafts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends content_draftsUpdateArgs>(args: SelectSubset<T, content_draftsUpdateArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Content_drafts.
     * @param {content_draftsDeleteManyArgs} args - Arguments to filter Content_drafts to delete.
     * @example
     * // Delete a few Content_drafts
     * const { count } = await prisma.content_drafts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends content_draftsDeleteManyArgs>(args?: SelectSubset<T, content_draftsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Content_drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {content_draftsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Content_drafts
     * const content_drafts = await prisma.content_drafts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends content_draftsUpdateManyArgs>(args: SelectSubset<T, content_draftsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Content_drafts and returns the data updated in the database.
     * @param {content_draftsUpdateManyAndReturnArgs} args - Arguments to update many Content_drafts.
     * @example
     * // Update many Content_drafts
     * const content_drafts = await prisma.content_drafts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Content_drafts and only return the `id`
     * const content_draftsWithIdOnly = await prisma.content_drafts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends content_draftsUpdateManyAndReturnArgs>(args: SelectSubset<T, content_draftsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Content_drafts.
     * @param {content_draftsUpsertArgs} args - Arguments to update or create a Content_drafts.
     * @example
     * // Update or create a Content_drafts
     * const content_drafts = await prisma.content_drafts.upsert({
     *   create: {
     *     // ... data to create a Content_drafts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content_drafts we want to update
     *   }
     * })
     */
    upsert<T extends content_draftsUpsertArgs>(args: SelectSubset<T, content_draftsUpsertArgs<ExtArgs>>): Prisma__content_draftsClient<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Content_drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {content_draftsCountArgs} args - Arguments to filter Content_drafts to count.
     * @example
     * // Count the number of Content_drafts
     * const count = await prisma.content_drafts.count({
     *   where: {
     *     // ... the filter for the Content_drafts we want to count
     *   }
     * })
    **/
    count<T extends content_draftsCountArgs>(
      args?: Subset<T, content_draftsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Content_draftsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content_drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Content_draftsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Content_draftsAggregateArgs>(args: Subset<T, Content_draftsAggregateArgs>): Prisma.PrismaPromise<GetContent_draftsAggregateType<T>>

    /**
     * Group by Content_drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {content_draftsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends content_draftsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: content_draftsGroupByArgs['orderBy'] }
        : { orderBy?: content_draftsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, content_draftsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContent_draftsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the content_drafts model
   */
  readonly fields: content_draftsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for content_drafts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__content_draftsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gpt_analyses<T extends gpt_analysesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gpt_analysesDefaultArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the content_drafts model
   */
  interface content_draftsFieldRefs {
    readonly id: FieldRef<"content_drafts", 'String'>
    readonly analysis_id: FieldRef<"content_drafts", 'String'>
    readonly concept_type: FieldRef<"content_drafts", 'String'>
    readonly category: FieldRef<"content_drafts", 'String'>
    readonly title: FieldRef<"content_drafts", 'String'>
    readonly content: FieldRef<"content_drafts", 'String'>
    readonly edited_content: FieldRef<"content_drafts", 'String'>
    readonly explanation: FieldRef<"content_drafts", 'String'>
    readonly buzz_factors: FieldRef<"content_drafts", 'Json'>
    readonly target_audience: FieldRef<"content_drafts", 'String'>
    readonly estimated_engagement: FieldRef<"content_drafts", 'Json'>
    readonly hashtags: FieldRef<"content_drafts", 'Json'>
    readonly visual_guide: FieldRef<"content_drafts", 'String'>
    readonly platform: FieldRef<"content_drafts", 'String'>
    readonly format: FieldRef<"content_drafts", 'String'>
    readonly status: FieldRef<"content_drafts", 'String'>
    readonly editor_notes: FieldRef<"content_drafts", 'String'>
    readonly metadata: FieldRef<"content_drafts", 'Json'>
    readonly created_at: FieldRef<"content_drafts", 'DateTime'>
    readonly updated_at: FieldRef<"content_drafts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * content_drafts findUnique
   */
  export type content_draftsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * Filter, which content_drafts to fetch.
     */
    where: content_draftsWhereUniqueInput
  }

  /**
   * content_drafts findUniqueOrThrow
   */
  export type content_draftsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * Filter, which content_drafts to fetch.
     */
    where: content_draftsWhereUniqueInput
  }

  /**
   * content_drafts findFirst
   */
  export type content_draftsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * Filter, which content_drafts to fetch.
     */
    where?: content_draftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of content_drafts to fetch.
     */
    orderBy?: content_draftsOrderByWithRelationInput | content_draftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for content_drafts.
     */
    cursor?: content_draftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` content_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` content_drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of content_drafts.
     */
    distinct?: Content_draftsScalarFieldEnum | Content_draftsScalarFieldEnum[]
  }

  /**
   * content_drafts findFirstOrThrow
   */
  export type content_draftsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * Filter, which content_drafts to fetch.
     */
    where?: content_draftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of content_drafts to fetch.
     */
    orderBy?: content_draftsOrderByWithRelationInput | content_draftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for content_drafts.
     */
    cursor?: content_draftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` content_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` content_drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of content_drafts.
     */
    distinct?: Content_draftsScalarFieldEnum | Content_draftsScalarFieldEnum[]
  }

  /**
   * content_drafts findMany
   */
  export type content_draftsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * Filter, which content_drafts to fetch.
     */
    where?: content_draftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of content_drafts to fetch.
     */
    orderBy?: content_draftsOrderByWithRelationInput | content_draftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing content_drafts.
     */
    cursor?: content_draftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` content_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` content_drafts.
     */
    skip?: number
    distinct?: Content_draftsScalarFieldEnum | Content_draftsScalarFieldEnum[]
  }

  /**
   * content_drafts create
   */
  export type content_draftsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * The data needed to create a content_drafts.
     */
    data: XOR<content_draftsCreateInput, content_draftsUncheckedCreateInput>
  }

  /**
   * content_drafts createMany
   */
  export type content_draftsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many content_drafts.
     */
    data: content_draftsCreateManyInput | content_draftsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * content_drafts createManyAndReturn
   */
  export type content_draftsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * The data used to create many content_drafts.
     */
    data: content_draftsCreateManyInput | content_draftsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * content_drafts update
   */
  export type content_draftsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * The data needed to update a content_drafts.
     */
    data: XOR<content_draftsUpdateInput, content_draftsUncheckedUpdateInput>
    /**
     * Choose, which content_drafts to update.
     */
    where: content_draftsWhereUniqueInput
  }

  /**
   * content_drafts updateMany
   */
  export type content_draftsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update content_drafts.
     */
    data: XOR<content_draftsUpdateManyMutationInput, content_draftsUncheckedUpdateManyInput>
    /**
     * Filter which content_drafts to update
     */
    where?: content_draftsWhereInput
    /**
     * Limit how many content_drafts to update.
     */
    limit?: number
  }

  /**
   * content_drafts updateManyAndReturn
   */
  export type content_draftsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * The data used to update content_drafts.
     */
    data: XOR<content_draftsUpdateManyMutationInput, content_draftsUncheckedUpdateManyInput>
    /**
     * Filter which content_drafts to update
     */
    where?: content_draftsWhereInput
    /**
     * Limit how many content_drafts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * content_drafts upsert
   */
  export type content_draftsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * The filter to search for the content_drafts to update in case it exists.
     */
    where: content_draftsWhereUniqueInput
    /**
     * In case the content_drafts found by the `where` argument doesn't exist, create a new content_drafts with this data.
     */
    create: XOR<content_draftsCreateInput, content_draftsUncheckedCreateInput>
    /**
     * In case the content_drafts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<content_draftsUpdateInput, content_draftsUncheckedUpdateInput>
  }

  /**
   * content_drafts delete
   */
  export type content_draftsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    /**
     * Filter which content_drafts to delete.
     */
    where: content_draftsWhereUniqueInput
  }

  /**
   * content_drafts deleteMany
   */
  export type content_draftsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which content_drafts to delete
     */
    where?: content_draftsWhereInput
    /**
     * Limit how many content_drafts to delete.
     */
    limit?: number
  }

  /**
   * content_drafts without action
   */
  export type content_draftsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
  }


  /**
   * Model gpt_analyses
   */

  export type AggregateGpt_analyses = {
    _count: Gpt_analysesCountAggregateOutputType | null
    _avg: Gpt_analysesAvgAggregateOutputType | null
    _sum: Gpt_analysesSumAggregateOutputType | null
    _min: Gpt_analysesMinAggregateOutputType | null
    _max: Gpt_analysesMaxAggregateOutputType | null
  }

  export type Gpt_analysesAvgAggregateOutputType = {
    tokens: number | null
    duration: number | null
  }

  export type Gpt_analysesSumAggregateOutputType = {
    tokens: number | null
    duration: number | null
  }

  export type Gpt_analysesMinAggregateOutputType = {
    id: string | null
    analysis_type: string | null
    prompt: string | null
    tokens: number | null
    duration: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Gpt_analysesMaxAggregateOutputType = {
    id: string | null
    analysis_type: string | null
    prompt: string | null
    tokens: number | null
    duration: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Gpt_analysesCountAggregateOutputType = {
    id: number
    analysis_type: number
    prompt: number
    response: number
    tokens: number
    duration: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Gpt_analysesAvgAggregateInputType = {
    tokens?: true
    duration?: true
  }

  export type Gpt_analysesSumAggregateInputType = {
    tokens?: true
    duration?: true
  }

  export type Gpt_analysesMinAggregateInputType = {
    id?: true
    analysis_type?: true
    prompt?: true
    tokens?: true
    duration?: true
    created_at?: true
    updated_at?: true
  }

  export type Gpt_analysesMaxAggregateInputType = {
    id?: true
    analysis_type?: true
    prompt?: true
    tokens?: true
    duration?: true
    created_at?: true
    updated_at?: true
  }

  export type Gpt_analysesCountAggregateInputType = {
    id?: true
    analysis_type?: true
    prompt?: true
    response?: true
    tokens?: true
    duration?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Gpt_analysesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gpt_analyses to aggregate.
     */
    where?: gpt_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gpt_analyses to fetch.
     */
    orderBy?: gpt_analysesOrderByWithRelationInput | gpt_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gpt_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gpt_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gpt_analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gpt_analyses
    **/
    _count?: true | Gpt_analysesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gpt_analysesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gpt_analysesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gpt_analysesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gpt_analysesMaxAggregateInputType
  }

  export type GetGpt_analysesAggregateType<T extends Gpt_analysesAggregateArgs> = {
        [P in keyof T & keyof AggregateGpt_analyses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGpt_analyses[P]>
      : GetScalarType<T[P], AggregateGpt_analyses[P]>
  }




  export type gpt_analysesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gpt_analysesWhereInput
    orderBy?: gpt_analysesOrderByWithAggregationInput | gpt_analysesOrderByWithAggregationInput[]
    by: Gpt_analysesScalarFieldEnum[] | Gpt_analysesScalarFieldEnum
    having?: gpt_analysesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gpt_analysesCountAggregateInputType | true
    _avg?: Gpt_analysesAvgAggregateInputType
    _sum?: Gpt_analysesSumAggregateInputType
    _min?: Gpt_analysesMinAggregateInputType
    _max?: Gpt_analysesMaxAggregateInputType
  }

  export type Gpt_analysesGroupByOutputType = {
    id: string
    analysis_type: string
    prompt: string
    response: JsonValue
    tokens: number | null
    duration: number | null
    metadata: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    _count: Gpt_analysesCountAggregateOutputType | null
    _avg: Gpt_analysesAvgAggregateOutputType | null
    _sum: Gpt_analysesSumAggregateOutputType | null
    _min: Gpt_analysesMinAggregateOutputType | null
    _max: Gpt_analysesMaxAggregateOutputType | null
  }

  type GetGpt_analysesGroupByPayload<T extends gpt_analysesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gpt_analysesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gpt_analysesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gpt_analysesGroupByOutputType[P]>
            : GetScalarType<T[P], Gpt_analysesGroupByOutputType[P]>
        }
      >
    >


  export type gpt_analysesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysis_type?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    content_drafts?: boolean | gpt_analyses$content_draftsArgs<ExtArgs>
    _count?: boolean | Gpt_analysesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gpt_analyses"]>

  export type gpt_analysesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysis_type?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["gpt_analyses"]>

  export type gpt_analysesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysis_type?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["gpt_analyses"]>

  export type gpt_analysesSelectScalar = {
    id?: boolean
    analysis_type?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type gpt_analysesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "analysis_type" | "prompt" | "response" | "tokens" | "duration" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["gpt_analyses"]>
  export type gpt_analysesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content_drafts?: boolean | gpt_analyses$content_draftsArgs<ExtArgs>
    _count?: boolean | Gpt_analysesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type gpt_analysesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type gpt_analysesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $gpt_analysesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gpt_analyses"
    objects: {
      content_drafts: Prisma.$content_draftsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      analysis_type: string
      prompt: string
      response: Prisma.JsonValue
      tokens: number | null
      duration: number | null
      metadata: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["gpt_analyses"]>
    composites: {}
  }

  type gpt_analysesGetPayload<S extends boolean | null | undefined | gpt_analysesDefaultArgs> = $Result.GetResult<Prisma.$gpt_analysesPayload, S>

  type gpt_analysesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gpt_analysesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gpt_analysesCountAggregateInputType | true
    }

  export interface gpt_analysesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gpt_analyses'], meta: { name: 'gpt_analyses' } }
    /**
     * Find zero or one Gpt_analyses that matches the filter.
     * @param {gpt_analysesFindUniqueArgs} args - Arguments to find a Gpt_analyses
     * @example
     * // Get one Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gpt_analysesFindUniqueArgs>(args: SelectSubset<T, gpt_analysesFindUniqueArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gpt_analyses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gpt_analysesFindUniqueOrThrowArgs} args - Arguments to find a Gpt_analyses
     * @example
     * // Get one Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gpt_analysesFindUniqueOrThrowArgs>(args: SelectSubset<T, gpt_analysesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gpt_analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gpt_analysesFindFirstArgs} args - Arguments to find a Gpt_analyses
     * @example
     * // Get one Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gpt_analysesFindFirstArgs>(args?: SelectSubset<T, gpt_analysesFindFirstArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gpt_analyses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gpt_analysesFindFirstOrThrowArgs} args - Arguments to find a Gpt_analyses
     * @example
     * // Get one Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gpt_analysesFindFirstOrThrowArgs>(args?: SelectSubset<T, gpt_analysesFindFirstOrThrowArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gpt_analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gpt_analysesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.findMany()
     * 
     * // Get first 10 Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gpt_analysesWithIdOnly = await prisma.gpt_analyses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gpt_analysesFindManyArgs>(args?: SelectSubset<T, gpt_analysesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gpt_analyses.
     * @param {gpt_analysesCreateArgs} args - Arguments to create a Gpt_analyses.
     * @example
     * // Create one Gpt_analyses
     * const Gpt_analyses = await prisma.gpt_analyses.create({
     *   data: {
     *     // ... data to create a Gpt_analyses
     *   }
     * })
     * 
     */
    create<T extends gpt_analysesCreateArgs>(args: SelectSubset<T, gpt_analysesCreateArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gpt_analyses.
     * @param {gpt_analysesCreateManyArgs} args - Arguments to create many Gpt_analyses.
     * @example
     * // Create many Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gpt_analysesCreateManyArgs>(args?: SelectSubset<T, gpt_analysesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gpt_analyses and returns the data saved in the database.
     * @param {gpt_analysesCreateManyAndReturnArgs} args - Arguments to create many Gpt_analyses.
     * @example
     * // Create many Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gpt_analyses and only return the `id`
     * const gpt_analysesWithIdOnly = await prisma.gpt_analyses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gpt_analysesCreateManyAndReturnArgs>(args?: SelectSubset<T, gpt_analysesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gpt_analyses.
     * @param {gpt_analysesDeleteArgs} args - Arguments to delete one Gpt_analyses.
     * @example
     * // Delete one Gpt_analyses
     * const Gpt_analyses = await prisma.gpt_analyses.delete({
     *   where: {
     *     // ... filter to delete one Gpt_analyses
     *   }
     * })
     * 
     */
    delete<T extends gpt_analysesDeleteArgs>(args: SelectSubset<T, gpt_analysesDeleteArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gpt_analyses.
     * @param {gpt_analysesUpdateArgs} args - Arguments to update one Gpt_analyses.
     * @example
     * // Update one Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gpt_analysesUpdateArgs>(args: SelectSubset<T, gpt_analysesUpdateArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gpt_analyses.
     * @param {gpt_analysesDeleteManyArgs} args - Arguments to filter Gpt_analyses to delete.
     * @example
     * // Delete a few Gpt_analyses
     * const { count } = await prisma.gpt_analyses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gpt_analysesDeleteManyArgs>(args?: SelectSubset<T, gpt_analysesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gpt_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gpt_analysesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gpt_analysesUpdateManyArgs>(args: SelectSubset<T, gpt_analysesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gpt_analyses and returns the data updated in the database.
     * @param {gpt_analysesUpdateManyAndReturnArgs} args - Arguments to update many Gpt_analyses.
     * @example
     * // Update many Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gpt_analyses and only return the `id`
     * const gpt_analysesWithIdOnly = await prisma.gpt_analyses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends gpt_analysesUpdateManyAndReturnArgs>(args: SelectSubset<T, gpt_analysesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gpt_analyses.
     * @param {gpt_analysesUpsertArgs} args - Arguments to update or create a Gpt_analyses.
     * @example
     * // Update or create a Gpt_analyses
     * const gpt_analyses = await prisma.gpt_analyses.upsert({
     *   create: {
     *     // ... data to create a Gpt_analyses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gpt_analyses we want to update
     *   }
     * })
     */
    upsert<T extends gpt_analysesUpsertArgs>(args: SelectSubset<T, gpt_analysesUpsertArgs<ExtArgs>>): Prisma__gpt_analysesClient<$Result.GetResult<Prisma.$gpt_analysesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gpt_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gpt_analysesCountArgs} args - Arguments to filter Gpt_analyses to count.
     * @example
     * // Count the number of Gpt_analyses
     * const count = await prisma.gpt_analyses.count({
     *   where: {
     *     // ... the filter for the Gpt_analyses we want to count
     *   }
     * })
    **/
    count<T extends gpt_analysesCountArgs>(
      args?: Subset<T, gpt_analysesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gpt_analysesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gpt_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gpt_analysesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gpt_analysesAggregateArgs>(args: Subset<T, Gpt_analysesAggregateArgs>): Prisma.PrismaPromise<GetGpt_analysesAggregateType<T>>

    /**
     * Group by Gpt_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gpt_analysesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gpt_analysesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gpt_analysesGroupByArgs['orderBy'] }
        : { orderBy?: gpt_analysesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gpt_analysesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGpt_analysesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gpt_analyses model
   */
  readonly fields: gpt_analysesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gpt_analyses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gpt_analysesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content_drafts<T extends gpt_analyses$content_draftsArgs<ExtArgs> = {}>(args?: Subset<T, gpt_analyses$content_draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$content_draftsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gpt_analyses model
   */
  interface gpt_analysesFieldRefs {
    readonly id: FieldRef<"gpt_analyses", 'String'>
    readonly analysis_type: FieldRef<"gpt_analyses", 'String'>
    readonly prompt: FieldRef<"gpt_analyses", 'String'>
    readonly response: FieldRef<"gpt_analyses", 'Json'>
    readonly tokens: FieldRef<"gpt_analyses", 'Int'>
    readonly duration: FieldRef<"gpt_analyses", 'Int'>
    readonly metadata: FieldRef<"gpt_analyses", 'Json'>
    readonly created_at: FieldRef<"gpt_analyses", 'DateTime'>
    readonly updated_at: FieldRef<"gpt_analyses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * gpt_analyses findUnique
   */
  export type gpt_analysesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * Filter, which gpt_analyses to fetch.
     */
    where: gpt_analysesWhereUniqueInput
  }

  /**
   * gpt_analyses findUniqueOrThrow
   */
  export type gpt_analysesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * Filter, which gpt_analyses to fetch.
     */
    where: gpt_analysesWhereUniqueInput
  }

  /**
   * gpt_analyses findFirst
   */
  export type gpt_analysesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * Filter, which gpt_analyses to fetch.
     */
    where?: gpt_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gpt_analyses to fetch.
     */
    orderBy?: gpt_analysesOrderByWithRelationInput | gpt_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gpt_analyses.
     */
    cursor?: gpt_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gpt_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gpt_analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gpt_analyses.
     */
    distinct?: Gpt_analysesScalarFieldEnum | Gpt_analysesScalarFieldEnum[]
  }

  /**
   * gpt_analyses findFirstOrThrow
   */
  export type gpt_analysesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * Filter, which gpt_analyses to fetch.
     */
    where?: gpt_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gpt_analyses to fetch.
     */
    orderBy?: gpt_analysesOrderByWithRelationInput | gpt_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gpt_analyses.
     */
    cursor?: gpt_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gpt_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gpt_analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gpt_analyses.
     */
    distinct?: Gpt_analysesScalarFieldEnum | Gpt_analysesScalarFieldEnum[]
  }

  /**
   * gpt_analyses findMany
   */
  export type gpt_analysesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * Filter, which gpt_analyses to fetch.
     */
    where?: gpt_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gpt_analyses to fetch.
     */
    orderBy?: gpt_analysesOrderByWithRelationInput | gpt_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gpt_analyses.
     */
    cursor?: gpt_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gpt_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gpt_analyses.
     */
    skip?: number
    distinct?: Gpt_analysesScalarFieldEnum | Gpt_analysesScalarFieldEnum[]
  }

  /**
   * gpt_analyses create
   */
  export type gpt_analysesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * The data needed to create a gpt_analyses.
     */
    data: XOR<gpt_analysesCreateInput, gpt_analysesUncheckedCreateInput>
  }

  /**
   * gpt_analyses createMany
   */
  export type gpt_analysesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gpt_analyses.
     */
    data: gpt_analysesCreateManyInput | gpt_analysesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gpt_analyses createManyAndReturn
   */
  export type gpt_analysesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * The data used to create many gpt_analyses.
     */
    data: gpt_analysesCreateManyInput | gpt_analysesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gpt_analyses update
   */
  export type gpt_analysesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * The data needed to update a gpt_analyses.
     */
    data: XOR<gpt_analysesUpdateInput, gpt_analysesUncheckedUpdateInput>
    /**
     * Choose, which gpt_analyses to update.
     */
    where: gpt_analysesWhereUniqueInput
  }

  /**
   * gpt_analyses updateMany
   */
  export type gpt_analysesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gpt_analyses.
     */
    data: XOR<gpt_analysesUpdateManyMutationInput, gpt_analysesUncheckedUpdateManyInput>
    /**
     * Filter which gpt_analyses to update
     */
    where?: gpt_analysesWhereInput
    /**
     * Limit how many gpt_analyses to update.
     */
    limit?: number
  }

  /**
   * gpt_analyses updateManyAndReturn
   */
  export type gpt_analysesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * The data used to update gpt_analyses.
     */
    data: XOR<gpt_analysesUpdateManyMutationInput, gpt_analysesUncheckedUpdateManyInput>
    /**
     * Filter which gpt_analyses to update
     */
    where?: gpt_analysesWhereInput
    /**
     * Limit how many gpt_analyses to update.
     */
    limit?: number
  }

  /**
   * gpt_analyses upsert
   */
  export type gpt_analysesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * The filter to search for the gpt_analyses to update in case it exists.
     */
    where: gpt_analysesWhereUniqueInput
    /**
     * In case the gpt_analyses found by the `where` argument doesn't exist, create a new gpt_analyses with this data.
     */
    create: XOR<gpt_analysesCreateInput, gpt_analysesUncheckedCreateInput>
    /**
     * In case the gpt_analyses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gpt_analysesUpdateInput, gpt_analysesUncheckedUpdateInput>
  }

  /**
   * gpt_analyses delete
   */
  export type gpt_analysesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
    /**
     * Filter which gpt_analyses to delete.
     */
    where: gpt_analysesWhereUniqueInput
  }

  /**
   * gpt_analyses deleteMany
   */
  export type gpt_analysesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gpt_analyses to delete
     */
    where?: gpt_analysesWhereInput
    /**
     * Limit how many gpt_analyses to delete.
     */
    limit?: number
  }

  /**
   * gpt_analyses.content_drafts
   */
  export type gpt_analyses$content_draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content_drafts
     */
    select?: content_draftsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the content_drafts
     */
    omit?: content_draftsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: content_draftsInclude<ExtArgs> | null
    where?: content_draftsWhereInput
    orderBy?: content_draftsOrderByWithRelationInput | content_draftsOrderByWithRelationInput[]
    cursor?: content_draftsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Content_draftsScalarFieldEnum | Content_draftsScalarFieldEnum[]
  }

  /**
   * gpt_analyses without action
   */
  export type gpt_analysesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gpt_analyses
     */
    select?: gpt_analysesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gpt_analyses
     */
    omit?: gpt_analysesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gpt_analysesInclude<ExtArgs> | null
  }


  /**
   * Model news_analysis_jobs
   */

  export type AggregateNews_analysis_jobs = {
    _count: News_analysis_jobsCountAggregateOutputType | null
    _min: News_analysis_jobsMinAggregateOutputType | null
    _max: News_analysis_jobsMaxAggregateOutputType | null
  }

  export type News_analysis_jobsMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type News_analysis_jobsMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type News_analysis_jobsCountAggregateOutputType = {
    id: number
    type: number
    status: number
    started_at: number
    completed_at: number
    error: number
    result: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type News_analysis_jobsMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    started_at?: true
    completed_at?: true
    error?: true
    created_at?: true
    updated_at?: true
  }

  export type News_analysis_jobsMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    started_at?: true
    completed_at?: true
    error?: true
    created_at?: true
    updated_at?: true
  }

  export type News_analysis_jobsCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    started_at?: true
    completed_at?: true
    error?: true
    result?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type News_analysis_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_analysis_jobs to aggregate.
     */
    where?: news_analysis_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_jobs to fetch.
     */
    orderBy?: news_analysis_jobsOrderByWithRelationInput | news_analysis_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: news_analysis_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned news_analysis_jobs
    **/
    _count?: true | News_analysis_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: News_analysis_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: News_analysis_jobsMaxAggregateInputType
  }

  export type GetNews_analysis_jobsAggregateType<T extends News_analysis_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews_analysis_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews_analysis_jobs[P]>
      : GetScalarType<T[P], AggregateNews_analysis_jobs[P]>
  }




  export type news_analysis_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: news_analysis_jobsWhereInput
    orderBy?: news_analysis_jobsOrderByWithAggregationInput | news_analysis_jobsOrderByWithAggregationInput[]
    by: News_analysis_jobsScalarFieldEnum[] | News_analysis_jobsScalarFieldEnum
    having?: news_analysis_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: News_analysis_jobsCountAggregateInputType | true
    _min?: News_analysis_jobsMinAggregateInputType
    _max?: News_analysis_jobsMaxAggregateInputType
  }

  export type News_analysis_jobsGroupByOutputType = {
    id: string
    type: string
    status: string
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    result: JsonValue | null
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: News_analysis_jobsCountAggregateOutputType | null
    _min: News_analysis_jobsMinAggregateOutputType | null
    _max: News_analysis_jobsMaxAggregateOutputType | null
  }

  type GetNews_analysis_jobsGroupByPayload<T extends news_analysis_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<News_analysis_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof News_analysis_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], News_analysis_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], News_analysis_jobsGroupByOutputType[P]>
        }
      >
    >


  export type news_analysis_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    news_analysis_results?: boolean | news_analysis_jobs$news_analysis_resultsArgs<ExtArgs>
    _count?: boolean | News_analysis_jobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news_analysis_jobs"]>

  export type news_analysis_jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["news_analysis_jobs"]>

  export type news_analysis_jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["news_analysis_jobs"]>

  export type news_analysis_jobsSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type news_analysis_jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "started_at" | "completed_at" | "error" | "result" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["news_analysis_jobs"]>
  export type news_analysis_jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news_analysis_results?: boolean | news_analysis_jobs$news_analysis_resultsArgs<ExtArgs>
    _count?: boolean | News_analysis_jobsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type news_analysis_jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type news_analysis_jobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $news_analysis_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "news_analysis_jobs"
    objects: {
      news_analysis_results: Prisma.$news_analysis_resultsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      status: string
      started_at: Date | null
      completed_at: Date | null
      error: string | null
      result: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["news_analysis_jobs"]>
    composites: {}
  }

  type news_analysis_jobsGetPayload<S extends boolean | null | undefined | news_analysis_jobsDefaultArgs> = $Result.GetResult<Prisma.$news_analysis_jobsPayload, S>

  type news_analysis_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<news_analysis_jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: News_analysis_jobsCountAggregateInputType | true
    }

  export interface news_analysis_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['news_analysis_jobs'], meta: { name: 'news_analysis_jobs' } }
    /**
     * Find zero or one News_analysis_jobs that matches the filter.
     * @param {news_analysis_jobsFindUniqueArgs} args - Arguments to find a News_analysis_jobs
     * @example
     * // Get one News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends news_analysis_jobsFindUniqueArgs>(args: SelectSubset<T, news_analysis_jobsFindUniqueArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News_analysis_jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {news_analysis_jobsFindUniqueOrThrowArgs} args - Arguments to find a News_analysis_jobs
     * @example
     * // Get one News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends news_analysis_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, news_analysis_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News_analysis_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_jobsFindFirstArgs} args - Arguments to find a News_analysis_jobs
     * @example
     * // Get one News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends news_analysis_jobsFindFirstArgs>(args?: SelectSubset<T, news_analysis_jobsFindFirstArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News_analysis_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_jobsFindFirstOrThrowArgs} args - Arguments to find a News_analysis_jobs
     * @example
     * // Get one News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends news_analysis_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, news_analysis_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News_analysis_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.findMany()
     * 
     * // Get first 10 News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const news_analysis_jobsWithIdOnly = await prisma.news_analysis_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends news_analysis_jobsFindManyArgs>(args?: SelectSubset<T, news_analysis_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News_analysis_jobs.
     * @param {news_analysis_jobsCreateArgs} args - Arguments to create a News_analysis_jobs.
     * @example
     * // Create one News_analysis_jobs
     * const News_analysis_jobs = await prisma.news_analysis_jobs.create({
     *   data: {
     *     // ... data to create a News_analysis_jobs
     *   }
     * })
     * 
     */
    create<T extends news_analysis_jobsCreateArgs>(args: SelectSubset<T, news_analysis_jobsCreateArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News_analysis_jobs.
     * @param {news_analysis_jobsCreateManyArgs} args - Arguments to create many News_analysis_jobs.
     * @example
     * // Create many News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends news_analysis_jobsCreateManyArgs>(args?: SelectSubset<T, news_analysis_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News_analysis_jobs and returns the data saved in the database.
     * @param {news_analysis_jobsCreateManyAndReturnArgs} args - Arguments to create many News_analysis_jobs.
     * @example
     * // Create many News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News_analysis_jobs and only return the `id`
     * const news_analysis_jobsWithIdOnly = await prisma.news_analysis_jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends news_analysis_jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, news_analysis_jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a News_analysis_jobs.
     * @param {news_analysis_jobsDeleteArgs} args - Arguments to delete one News_analysis_jobs.
     * @example
     * // Delete one News_analysis_jobs
     * const News_analysis_jobs = await prisma.news_analysis_jobs.delete({
     *   where: {
     *     // ... filter to delete one News_analysis_jobs
     *   }
     * })
     * 
     */
    delete<T extends news_analysis_jobsDeleteArgs>(args: SelectSubset<T, news_analysis_jobsDeleteArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News_analysis_jobs.
     * @param {news_analysis_jobsUpdateArgs} args - Arguments to update one News_analysis_jobs.
     * @example
     * // Update one News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends news_analysis_jobsUpdateArgs>(args: SelectSubset<T, news_analysis_jobsUpdateArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News_analysis_jobs.
     * @param {news_analysis_jobsDeleteManyArgs} args - Arguments to filter News_analysis_jobs to delete.
     * @example
     * // Delete a few News_analysis_jobs
     * const { count } = await prisma.news_analysis_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends news_analysis_jobsDeleteManyArgs>(args?: SelectSubset<T, news_analysis_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News_analysis_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends news_analysis_jobsUpdateManyArgs>(args: SelectSubset<T, news_analysis_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News_analysis_jobs and returns the data updated in the database.
     * @param {news_analysis_jobsUpdateManyAndReturnArgs} args - Arguments to update many News_analysis_jobs.
     * @example
     * // Update many News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more News_analysis_jobs and only return the `id`
     * const news_analysis_jobsWithIdOnly = await prisma.news_analysis_jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends news_analysis_jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, news_analysis_jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one News_analysis_jobs.
     * @param {news_analysis_jobsUpsertArgs} args - Arguments to update or create a News_analysis_jobs.
     * @example
     * // Update or create a News_analysis_jobs
     * const news_analysis_jobs = await prisma.news_analysis_jobs.upsert({
     *   create: {
     *     // ... data to create a News_analysis_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News_analysis_jobs we want to update
     *   }
     * })
     */
    upsert<T extends news_analysis_jobsUpsertArgs>(args: SelectSubset<T, news_analysis_jobsUpsertArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News_analysis_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_jobsCountArgs} args - Arguments to filter News_analysis_jobs to count.
     * @example
     * // Count the number of News_analysis_jobs
     * const count = await prisma.news_analysis_jobs.count({
     *   where: {
     *     // ... the filter for the News_analysis_jobs we want to count
     *   }
     * })
    **/
    count<T extends news_analysis_jobsCountArgs>(
      args?: Subset<T, news_analysis_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], News_analysis_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News_analysis_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {News_analysis_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends News_analysis_jobsAggregateArgs>(args: Subset<T, News_analysis_jobsAggregateArgs>): Prisma.PrismaPromise<GetNews_analysis_jobsAggregateType<T>>

    /**
     * Group by News_analysis_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends news_analysis_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: news_analysis_jobsGroupByArgs['orderBy'] }
        : { orderBy?: news_analysis_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, news_analysis_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNews_analysis_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the news_analysis_jobs model
   */
  readonly fields: news_analysis_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news_analysis_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__news_analysis_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    news_analysis_results<T extends news_analysis_jobs$news_analysis_resultsArgs<ExtArgs> = {}>(args?: Subset<T, news_analysis_jobs$news_analysis_resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the news_analysis_jobs model
   */
  interface news_analysis_jobsFieldRefs {
    readonly id: FieldRef<"news_analysis_jobs", 'String'>
    readonly type: FieldRef<"news_analysis_jobs", 'String'>
    readonly status: FieldRef<"news_analysis_jobs", 'String'>
    readonly started_at: FieldRef<"news_analysis_jobs", 'DateTime'>
    readonly completed_at: FieldRef<"news_analysis_jobs", 'DateTime'>
    readonly error: FieldRef<"news_analysis_jobs", 'String'>
    readonly result: FieldRef<"news_analysis_jobs", 'Json'>
    readonly metadata: FieldRef<"news_analysis_jobs", 'Json'>
    readonly created_at: FieldRef<"news_analysis_jobs", 'DateTime'>
    readonly updated_at: FieldRef<"news_analysis_jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * news_analysis_jobs findUnique
   */
  export type news_analysis_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_jobs to fetch.
     */
    where: news_analysis_jobsWhereUniqueInput
  }

  /**
   * news_analysis_jobs findUniqueOrThrow
   */
  export type news_analysis_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_jobs to fetch.
     */
    where: news_analysis_jobsWhereUniqueInput
  }

  /**
   * news_analysis_jobs findFirst
   */
  export type news_analysis_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_jobs to fetch.
     */
    where?: news_analysis_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_jobs to fetch.
     */
    orderBy?: news_analysis_jobsOrderByWithRelationInput | news_analysis_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_analysis_jobs.
     */
    cursor?: news_analysis_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_analysis_jobs.
     */
    distinct?: News_analysis_jobsScalarFieldEnum | News_analysis_jobsScalarFieldEnum[]
  }

  /**
   * news_analysis_jobs findFirstOrThrow
   */
  export type news_analysis_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_jobs to fetch.
     */
    where?: news_analysis_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_jobs to fetch.
     */
    orderBy?: news_analysis_jobsOrderByWithRelationInput | news_analysis_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_analysis_jobs.
     */
    cursor?: news_analysis_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_analysis_jobs.
     */
    distinct?: News_analysis_jobsScalarFieldEnum | News_analysis_jobsScalarFieldEnum[]
  }

  /**
   * news_analysis_jobs findMany
   */
  export type news_analysis_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_jobs to fetch.
     */
    where?: news_analysis_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_jobs to fetch.
     */
    orderBy?: news_analysis_jobsOrderByWithRelationInput | news_analysis_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing news_analysis_jobs.
     */
    cursor?: news_analysis_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_jobs.
     */
    skip?: number
    distinct?: News_analysis_jobsScalarFieldEnum | News_analysis_jobsScalarFieldEnum[]
  }

  /**
   * news_analysis_jobs create
   */
  export type news_analysis_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a news_analysis_jobs.
     */
    data: XOR<news_analysis_jobsCreateInput, news_analysis_jobsUncheckedCreateInput>
  }

  /**
   * news_analysis_jobs createMany
   */
  export type news_analysis_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many news_analysis_jobs.
     */
    data: news_analysis_jobsCreateManyInput | news_analysis_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * news_analysis_jobs createManyAndReturn
   */
  export type news_analysis_jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * The data used to create many news_analysis_jobs.
     */
    data: news_analysis_jobsCreateManyInput | news_analysis_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * news_analysis_jobs update
   */
  export type news_analysis_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a news_analysis_jobs.
     */
    data: XOR<news_analysis_jobsUpdateInput, news_analysis_jobsUncheckedUpdateInput>
    /**
     * Choose, which news_analysis_jobs to update.
     */
    where: news_analysis_jobsWhereUniqueInput
  }

  /**
   * news_analysis_jobs updateMany
   */
  export type news_analysis_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update news_analysis_jobs.
     */
    data: XOR<news_analysis_jobsUpdateManyMutationInput, news_analysis_jobsUncheckedUpdateManyInput>
    /**
     * Filter which news_analysis_jobs to update
     */
    where?: news_analysis_jobsWhereInput
    /**
     * Limit how many news_analysis_jobs to update.
     */
    limit?: number
  }

  /**
   * news_analysis_jobs updateManyAndReturn
   */
  export type news_analysis_jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * The data used to update news_analysis_jobs.
     */
    data: XOR<news_analysis_jobsUpdateManyMutationInput, news_analysis_jobsUncheckedUpdateManyInput>
    /**
     * Filter which news_analysis_jobs to update
     */
    where?: news_analysis_jobsWhereInput
    /**
     * Limit how many news_analysis_jobs to update.
     */
    limit?: number
  }

  /**
   * news_analysis_jobs upsert
   */
  export type news_analysis_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the news_analysis_jobs to update in case it exists.
     */
    where: news_analysis_jobsWhereUniqueInput
    /**
     * In case the news_analysis_jobs found by the `where` argument doesn't exist, create a new news_analysis_jobs with this data.
     */
    create: XOR<news_analysis_jobsCreateInput, news_analysis_jobsUncheckedCreateInput>
    /**
     * In case the news_analysis_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<news_analysis_jobsUpdateInput, news_analysis_jobsUncheckedUpdateInput>
  }

  /**
   * news_analysis_jobs delete
   */
  export type news_analysis_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
    /**
     * Filter which news_analysis_jobs to delete.
     */
    where: news_analysis_jobsWhereUniqueInput
  }

  /**
   * news_analysis_jobs deleteMany
   */
  export type news_analysis_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_analysis_jobs to delete
     */
    where?: news_analysis_jobsWhereInput
    /**
     * Limit how many news_analysis_jobs to delete.
     */
    limit?: number
  }

  /**
   * news_analysis_jobs.news_analysis_results
   */
  export type news_analysis_jobs$news_analysis_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    where?: news_analysis_resultsWhereInput
    orderBy?: news_analysis_resultsOrderByWithRelationInput | news_analysis_resultsOrderByWithRelationInput[]
    cursor?: news_analysis_resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: News_analysis_resultsScalarFieldEnum | News_analysis_resultsScalarFieldEnum[]
  }

  /**
   * news_analysis_jobs without action
   */
  export type news_analysis_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_jobs
     */
    select?: news_analysis_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_jobs
     */
    omit?: news_analysis_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_jobsInclude<ExtArgs> | null
  }


  /**
   * Model news_analysis_results
   */

  export type AggregateNews_analysis_results = {
    _count: News_analysis_resultsCountAggregateOutputType | null
    _avg: News_analysis_resultsAvgAggregateOutputType | null
    _sum: News_analysis_resultsSumAggregateOutputType | null
    _min: News_analysis_resultsMinAggregateOutputType | null
    _max: News_analysis_resultsMaxAggregateOutputType | null
  }

  export type News_analysis_resultsAvgAggregateOutputType = {
    importance_score: number | null
  }

  export type News_analysis_resultsSumAggregateOutputType = {
    importance_score: number | null
  }

  export type News_analysis_resultsMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    article_id: string | null
    importance_score: number | null
    category: string | null
    summary_ja: string | null
    impact_assessment: string | null
    expert_perspective: string | null
    created_at: Date | null
  }

  export type News_analysis_resultsMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    article_id: string | null
    importance_score: number | null
    category: string | null
    summary_ja: string | null
    impact_assessment: string | null
    expert_perspective: string | null
    created_at: Date | null
  }

  export type News_analysis_resultsCountAggregateOutputType = {
    id: number
    job_id: number
    article_id: number
    importance_score: number
    category: number
    summary_ja: number
    key_points: number
    impact_assessment: number
    expert_perspective: number
    metadata: number
    created_at: number
    _all: number
  }


  export type News_analysis_resultsAvgAggregateInputType = {
    importance_score?: true
  }

  export type News_analysis_resultsSumAggregateInputType = {
    importance_score?: true
  }

  export type News_analysis_resultsMinAggregateInputType = {
    id?: true
    job_id?: true
    article_id?: true
    importance_score?: true
    category?: true
    summary_ja?: true
    impact_assessment?: true
    expert_perspective?: true
    created_at?: true
  }

  export type News_analysis_resultsMaxAggregateInputType = {
    id?: true
    job_id?: true
    article_id?: true
    importance_score?: true
    category?: true
    summary_ja?: true
    impact_assessment?: true
    expert_perspective?: true
    created_at?: true
  }

  export type News_analysis_resultsCountAggregateInputType = {
    id?: true
    job_id?: true
    article_id?: true
    importance_score?: true
    category?: true
    summary_ja?: true
    key_points?: true
    impact_assessment?: true
    expert_perspective?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type News_analysis_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_analysis_results to aggregate.
     */
    where?: news_analysis_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_results to fetch.
     */
    orderBy?: news_analysis_resultsOrderByWithRelationInput | news_analysis_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: news_analysis_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned news_analysis_results
    **/
    _count?: true | News_analysis_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: News_analysis_resultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: News_analysis_resultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: News_analysis_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: News_analysis_resultsMaxAggregateInputType
  }

  export type GetNews_analysis_resultsAggregateType<T extends News_analysis_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews_analysis_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews_analysis_results[P]>
      : GetScalarType<T[P], AggregateNews_analysis_results[P]>
  }




  export type news_analysis_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: news_analysis_resultsWhereInput
    orderBy?: news_analysis_resultsOrderByWithAggregationInput | news_analysis_resultsOrderByWithAggregationInput[]
    by: News_analysis_resultsScalarFieldEnum[] | News_analysis_resultsScalarFieldEnum
    having?: news_analysis_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: News_analysis_resultsCountAggregateInputType | true
    _avg?: News_analysis_resultsAvgAggregateInputType
    _sum?: News_analysis_resultsSumAggregateInputType
    _min?: News_analysis_resultsMinAggregateInputType
    _max?: News_analysis_resultsMaxAggregateInputType
  }

  export type News_analysis_resultsGroupByOutputType = {
    id: string
    job_id: string
    article_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonValue
    impact_assessment: string
    expert_perspective: string | null
    metadata: JsonValue | null
    created_at: Date
    _count: News_analysis_resultsCountAggregateOutputType | null
    _avg: News_analysis_resultsAvgAggregateOutputType | null
    _sum: News_analysis_resultsSumAggregateOutputType | null
    _min: News_analysis_resultsMinAggregateOutputType | null
    _max: News_analysis_resultsMaxAggregateOutputType | null
  }

  type GetNews_analysis_resultsGroupByPayload<T extends news_analysis_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<News_analysis_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof News_analysis_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], News_analysis_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], News_analysis_resultsGroupByOutputType[P]>
        }
      >
    >


  export type news_analysis_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    article_id?: boolean
    importance_score?: boolean
    category?: boolean
    summary_ja?: boolean
    key_points?: boolean
    impact_assessment?: boolean
    expert_perspective?: boolean
    metadata?: boolean
    created_at?: boolean
    news_articles?: boolean | NewsArticleDefaultArgs<ExtArgs>
    news_analysis_jobs?: boolean | news_analysis_jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news_analysis_results"]>

  export type news_analysis_resultsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    article_id?: boolean
    importance_score?: boolean
    category?: boolean
    summary_ja?: boolean
    key_points?: boolean
    impact_assessment?: boolean
    expert_perspective?: boolean
    metadata?: boolean
    created_at?: boolean
    news_articles?: boolean | NewsArticleDefaultArgs<ExtArgs>
    news_analysis_jobs?: boolean | news_analysis_jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news_analysis_results"]>

  export type news_analysis_resultsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    article_id?: boolean
    importance_score?: boolean
    category?: boolean
    summary_ja?: boolean
    key_points?: boolean
    impact_assessment?: boolean
    expert_perspective?: boolean
    metadata?: boolean
    created_at?: boolean
    news_articles?: boolean | NewsArticleDefaultArgs<ExtArgs>
    news_analysis_jobs?: boolean | news_analysis_jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news_analysis_results"]>

  export type news_analysis_resultsSelectScalar = {
    id?: boolean
    job_id?: boolean
    article_id?: boolean
    importance_score?: boolean
    category?: boolean
    summary_ja?: boolean
    key_points?: boolean
    impact_assessment?: boolean
    expert_perspective?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type news_analysis_resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "article_id" | "importance_score" | "category" | "summary_ja" | "key_points" | "impact_assessment" | "expert_perspective" | "metadata" | "created_at", ExtArgs["result"]["news_analysis_results"]>
  export type news_analysis_resultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news_articles?: boolean | NewsArticleDefaultArgs<ExtArgs>
    news_analysis_jobs?: boolean | news_analysis_jobsDefaultArgs<ExtArgs>
  }
  export type news_analysis_resultsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news_articles?: boolean | NewsArticleDefaultArgs<ExtArgs>
    news_analysis_jobs?: boolean | news_analysis_jobsDefaultArgs<ExtArgs>
  }
  export type news_analysis_resultsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news_articles?: boolean | NewsArticleDefaultArgs<ExtArgs>
    news_analysis_jobs?: boolean | news_analysis_jobsDefaultArgs<ExtArgs>
  }

  export type $news_analysis_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "news_analysis_results"
    objects: {
      news_articles: Prisma.$NewsArticlePayload<ExtArgs>
      news_analysis_jobs: Prisma.$news_analysis_jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string
      article_id: string
      importance_score: number
      category: string
      summary_ja: string
      key_points: Prisma.JsonValue
      impact_assessment: string
      expert_perspective: string | null
      metadata: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["news_analysis_results"]>
    composites: {}
  }

  type news_analysis_resultsGetPayload<S extends boolean | null | undefined | news_analysis_resultsDefaultArgs> = $Result.GetResult<Prisma.$news_analysis_resultsPayload, S>

  type news_analysis_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<news_analysis_resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: News_analysis_resultsCountAggregateInputType | true
    }

  export interface news_analysis_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['news_analysis_results'], meta: { name: 'news_analysis_results' } }
    /**
     * Find zero or one News_analysis_results that matches the filter.
     * @param {news_analysis_resultsFindUniqueArgs} args - Arguments to find a News_analysis_results
     * @example
     * // Get one News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends news_analysis_resultsFindUniqueArgs>(args: SelectSubset<T, news_analysis_resultsFindUniqueArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News_analysis_results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {news_analysis_resultsFindUniqueOrThrowArgs} args - Arguments to find a News_analysis_results
     * @example
     * // Get one News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends news_analysis_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, news_analysis_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News_analysis_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_resultsFindFirstArgs} args - Arguments to find a News_analysis_results
     * @example
     * // Get one News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends news_analysis_resultsFindFirstArgs>(args?: SelectSubset<T, news_analysis_resultsFindFirstArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News_analysis_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_resultsFindFirstOrThrowArgs} args - Arguments to find a News_analysis_results
     * @example
     * // Get one News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends news_analysis_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, news_analysis_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News_analysis_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.findMany()
     * 
     * // Get first 10 News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const news_analysis_resultsWithIdOnly = await prisma.news_analysis_results.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends news_analysis_resultsFindManyArgs>(args?: SelectSubset<T, news_analysis_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News_analysis_results.
     * @param {news_analysis_resultsCreateArgs} args - Arguments to create a News_analysis_results.
     * @example
     * // Create one News_analysis_results
     * const News_analysis_results = await prisma.news_analysis_results.create({
     *   data: {
     *     // ... data to create a News_analysis_results
     *   }
     * })
     * 
     */
    create<T extends news_analysis_resultsCreateArgs>(args: SelectSubset<T, news_analysis_resultsCreateArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News_analysis_results.
     * @param {news_analysis_resultsCreateManyArgs} args - Arguments to create many News_analysis_results.
     * @example
     * // Create many News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends news_analysis_resultsCreateManyArgs>(args?: SelectSubset<T, news_analysis_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News_analysis_results and returns the data saved in the database.
     * @param {news_analysis_resultsCreateManyAndReturnArgs} args - Arguments to create many News_analysis_results.
     * @example
     * // Create many News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News_analysis_results and only return the `id`
     * const news_analysis_resultsWithIdOnly = await prisma.news_analysis_results.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends news_analysis_resultsCreateManyAndReturnArgs>(args?: SelectSubset<T, news_analysis_resultsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a News_analysis_results.
     * @param {news_analysis_resultsDeleteArgs} args - Arguments to delete one News_analysis_results.
     * @example
     * // Delete one News_analysis_results
     * const News_analysis_results = await prisma.news_analysis_results.delete({
     *   where: {
     *     // ... filter to delete one News_analysis_results
     *   }
     * })
     * 
     */
    delete<T extends news_analysis_resultsDeleteArgs>(args: SelectSubset<T, news_analysis_resultsDeleteArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News_analysis_results.
     * @param {news_analysis_resultsUpdateArgs} args - Arguments to update one News_analysis_results.
     * @example
     * // Update one News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends news_analysis_resultsUpdateArgs>(args: SelectSubset<T, news_analysis_resultsUpdateArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News_analysis_results.
     * @param {news_analysis_resultsDeleteManyArgs} args - Arguments to filter News_analysis_results to delete.
     * @example
     * // Delete a few News_analysis_results
     * const { count } = await prisma.news_analysis_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends news_analysis_resultsDeleteManyArgs>(args?: SelectSubset<T, news_analysis_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News_analysis_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends news_analysis_resultsUpdateManyArgs>(args: SelectSubset<T, news_analysis_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News_analysis_results and returns the data updated in the database.
     * @param {news_analysis_resultsUpdateManyAndReturnArgs} args - Arguments to update many News_analysis_results.
     * @example
     * // Update many News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more News_analysis_results and only return the `id`
     * const news_analysis_resultsWithIdOnly = await prisma.news_analysis_results.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends news_analysis_resultsUpdateManyAndReturnArgs>(args: SelectSubset<T, news_analysis_resultsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one News_analysis_results.
     * @param {news_analysis_resultsUpsertArgs} args - Arguments to update or create a News_analysis_results.
     * @example
     * // Update or create a News_analysis_results
     * const news_analysis_results = await prisma.news_analysis_results.upsert({
     *   create: {
     *     // ... data to create a News_analysis_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News_analysis_results we want to update
     *   }
     * })
     */
    upsert<T extends news_analysis_resultsUpsertArgs>(args: SelectSubset<T, news_analysis_resultsUpsertArgs<ExtArgs>>): Prisma__news_analysis_resultsClient<$Result.GetResult<Prisma.$news_analysis_resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News_analysis_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_resultsCountArgs} args - Arguments to filter News_analysis_results to count.
     * @example
     * // Count the number of News_analysis_results
     * const count = await prisma.news_analysis_results.count({
     *   where: {
     *     // ... the filter for the News_analysis_results we want to count
     *   }
     * })
    **/
    count<T extends news_analysis_resultsCountArgs>(
      args?: Subset<T, news_analysis_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], News_analysis_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News_analysis_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {News_analysis_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends News_analysis_resultsAggregateArgs>(args: Subset<T, News_analysis_resultsAggregateArgs>): Prisma.PrismaPromise<GetNews_analysis_resultsAggregateType<T>>

    /**
     * Group by News_analysis_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_analysis_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends news_analysis_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: news_analysis_resultsGroupByArgs['orderBy'] }
        : { orderBy?: news_analysis_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, news_analysis_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNews_analysis_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the news_analysis_results model
   */
  readonly fields: news_analysis_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news_analysis_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__news_analysis_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    news_articles<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    news_analysis_jobs<T extends news_analysis_jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, news_analysis_jobsDefaultArgs<ExtArgs>>): Prisma__news_analysis_jobsClient<$Result.GetResult<Prisma.$news_analysis_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the news_analysis_results model
   */
  interface news_analysis_resultsFieldRefs {
    readonly id: FieldRef<"news_analysis_results", 'String'>
    readonly job_id: FieldRef<"news_analysis_results", 'String'>
    readonly article_id: FieldRef<"news_analysis_results", 'String'>
    readonly importance_score: FieldRef<"news_analysis_results", 'Float'>
    readonly category: FieldRef<"news_analysis_results", 'String'>
    readonly summary_ja: FieldRef<"news_analysis_results", 'String'>
    readonly key_points: FieldRef<"news_analysis_results", 'Json'>
    readonly impact_assessment: FieldRef<"news_analysis_results", 'String'>
    readonly expert_perspective: FieldRef<"news_analysis_results", 'String'>
    readonly metadata: FieldRef<"news_analysis_results", 'Json'>
    readonly created_at: FieldRef<"news_analysis_results", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * news_analysis_results findUnique
   */
  export type news_analysis_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_results to fetch.
     */
    where: news_analysis_resultsWhereUniqueInput
  }

  /**
   * news_analysis_results findUniqueOrThrow
   */
  export type news_analysis_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_results to fetch.
     */
    where: news_analysis_resultsWhereUniqueInput
  }

  /**
   * news_analysis_results findFirst
   */
  export type news_analysis_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_results to fetch.
     */
    where?: news_analysis_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_results to fetch.
     */
    orderBy?: news_analysis_resultsOrderByWithRelationInput | news_analysis_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_analysis_results.
     */
    cursor?: news_analysis_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_analysis_results.
     */
    distinct?: News_analysis_resultsScalarFieldEnum | News_analysis_resultsScalarFieldEnum[]
  }

  /**
   * news_analysis_results findFirstOrThrow
   */
  export type news_analysis_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_results to fetch.
     */
    where?: news_analysis_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_results to fetch.
     */
    orderBy?: news_analysis_resultsOrderByWithRelationInput | news_analysis_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_analysis_results.
     */
    cursor?: news_analysis_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_analysis_results.
     */
    distinct?: News_analysis_resultsScalarFieldEnum | News_analysis_resultsScalarFieldEnum[]
  }

  /**
   * news_analysis_results findMany
   */
  export type news_analysis_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * Filter, which news_analysis_results to fetch.
     */
    where?: news_analysis_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_analysis_results to fetch.
     */
    orderBy?: news_analysis_resultsOrderByWithRelationInput | news_analysis_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing news_analysis_results.
     */
    cursor?: news_analysis_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_analysis_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_analysis_results.
     */
    skip?: number
    distinct?: News_analysis_resultsScalarFieldEnum | News_analysis_resultsScalarFieldEnum[]
  }

  /**
   * news_analysis_results create
   */
  export type news_analysis_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * The data needed to create a news_analysis_results.
     */
    data: XOR<news_analysis_resultsCreateInput, news_analysis_resultsUncheckedCreateInput>
  }

  /**
   * news_analysis_results createMany
   */
  export type news_analysis_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many news_analysis_results.
     */
    data: news_analysis_resultsCreateManyInput | news_analysis_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * news_analysis_results createManyAndReturn
   */
  export type news_analysis_resultsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * The data used to create many news_analysis_results.
     */
    data: news_analysis_resultsCreateManyInput | news_analysis_resultsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * news_analysis_results update
   */
  export type news_analysis_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * The data needed to update a news_analysis_results.
     */
    data: XOR<news_analysis_resultsUpdateInput, news_analysis_resultsUncheckedUpdateInput>
    /**
     * Choose, which news_analysis_results to update.
     */
    where: news_analysis_resultsWhereUniqueInput
  }

  /**
   * news_analysis_results updateMany
   */
  export type news_analysis_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update news_analysis_results.
     */
    data: XOR<news_analysis_resultsUpdateManyMutationInput, news_analysis_resultsUncheckedUpdateManyInput>
    /**
     * Filter which news_analysis_results to update
     */
    where?: news_analysis_resultsWhereInput
    /**
     * Limit how many news_analysis_results to update.
     */
    limit?: number
  }

  /**
   * news_analysis_results updateManyAndReturn
   */
  export type news_analysis_resultsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * The data used to update news_analysis_results.
     */
    data: XOR<news_analysis_resultsUpdateManyMutationInput, news_analysis_resultsUncheckedUpdateManyInput>
    /**
     * Filter which news_analysis_results to update
     */
    where?: news_analysis_resultsWhereInput
    /**
     * Limit how many news_analysis_results to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * news_analysis_results upsert
   */
  export type news_analysis_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * The filter to search for the news_analysis_results to update in case it exists.
     */
    where: news_analysis_resultsWhereUniqueInput
    /**
     * In case the news_analysis_results found by the `where` argument doesn't exist, create a new news_analysis_results with this data.
     */
    create: XOR<news_analysis_resultsCreateInput, news_analysis_resultsUncheckedCreateInput>
    /**
     * In case the news_analysis_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<news_analysis_resultsUpdateInput, news_analysis_resultsUncheckedUpdateInput>
  }

  /**
   * news_analysis_results delete
   */
  export type news_analysis_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
    /**
     * Filter which news_analysis_results to delete.
     */
    where: news_analysis_resultsWhereUniqueInput
  }

  /**
   * news_analysis_results deleteMany
   */
  export type news_analysis_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_analysis_results to delete
     */
    where?: news_analysis_resultsWhereInput
    /**
     * Limit how many news_analysis_results to delete.
     */
    limit?: number
  }

  /**
   * news_analysis_results without action
   */
  export type news_analysis_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_analysis_results
     */
    select?: news_analysis_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news_analysis_results
     */
    omit?: news_analysis_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_analysis_resultsInclude<ExtArgs> | null
  }


  /**
   * Model prompt_templates
   */

  export type AggregatePrompt_templates = {
    _count: Prompt_templatesCountAggregateOutputType | null
    _min: Prompt_templatesMinAggregateOutputType | null
    _max: Prompt_templatesMaxAggregateOutputType | null
  }

  export type Prompt_templatesMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    template: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Prompt_templatesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    template: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Prompt_templatesCountAggregateOutputType = {
    id: number
    name: number
    type: number
    template: number
    variables: number
    is_active: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Prompt_templatesMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    template?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Prompt_templatesMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    template?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Prompt_templatesCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    template?: true
    variables?: true
    is_active?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Prompt_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prompt_templates to aggregate.
     */
    where?: prompt_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prompt_templates to fetch.
     */
    orderBy?: prompt_templatesOrderByWithRelationInput | prompt_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prompt_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prompt_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prompt_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prompt_templates
    **/
    _count?: true | Prompt_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prompt_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prompt_templatesMaxAggregateInputType
  }

  export type GetPrompt_templatesAggregateType<T extends Prompt_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrompt_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrompt_templates[P]>
      : GetScalarType<T[P], AggregatePrompt_templates[P]>
  }




  export type prompt_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prompt_templatesWhereInput
    orderBy?: prompt_templatesOrderByWithAggregationInput | prompt_templatesOrderByWithAggregationInput[]
    by: Prompt_templatesScalarFieldEnum[] | Prompt_templatesScalarFieldEnum
    having?: prompt_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prompt_templatesCountAggregateInputType | true
    _min?: Prompt_templatesMinAggregateInputType
    _max?: Prompt_templatesMaxAggregateInputType
  }

  export type Prompt_templatesGroupByOutputType = {
    id: string
    name: string
    type: string
    template: string
    variables: JsonValue
    is_active: boolean | null
    metadata: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    _count: Prompt_templatesCountAggregateOutputType | null
    _min: Prompt_templatesMinAggregateOutputType | null
    _max: Prompt_templatesMaxAggregateOutputType | null
  }

  type GetPrompt_templatesGroupByPayload<T extends prompt_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prompt_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prompt_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prompt_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Prompt_templatesGroupByOutputType[P]>
        }
      >
    >


  export type prompt_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    template?: boolean
    variables?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["prompt_templates"]>

  export type prompt_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    template?: boolean
    variables?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["prompt_templates"]>

  export type prompt_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    template?: boolean
    variables?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["prompt_templates"]>

  export type prompt_templatesSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    template?: boolean
    variables?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type prompt_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "template" | "variables" | "is_active" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["prompt_templates"]>

  export type $prompt_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prompt_templates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      template: string
      variables: Prisma.JsonValue
      is_active: boolean | null
      metadata: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["prompt_templates"]>
    composites: {}
  }

  type prompt_templatesGetPayload<S extends boolean | null | undefined | prompt_templatesDefaultArgs> = $Result.GetResult<Prisma.$prompt_templatesPayload, S>

  type prompt_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<prompt_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Prompt_templatesCountAggregateInputType | true
    }

  export interface prompt_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prompt_templates'], meta: { name: 'prompt_templates' } }
    /**
     * Find zero or one Prompt_templates that matches the filter.
     * @param {prompt_templatesFindUniqueArgs} args - Arguments to find a Prompt_templates
     * @example
     * // Get one Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prompt_templatesFindUniqueArgs>(args: SelectSubset<T, prompt_templatesFindUniqueArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prompt_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {prompt_templatesFindUniqueOrThrowArgs} args - Arguments to find a Prompt_templates
     * @example
     * // Get one Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prompt_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, prompt_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prompt_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prompt_templatesFindFirstArgs} args - Arguments to find a Prompt_templates
     * @example
     * // Get one Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prompt_templatesFindFirstArgs>(args?: SelectSubset<T, prompt_templatesFindFirstArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prompt_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prompt_templatesFindFirstOrThrowArgs} args - Arguments to find a Prompt_templates
     * @example
     * // Get one Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prompt_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, prompt_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prompt_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prompt_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.findMany()
     * 
     * // Get first 10 Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prompt_templatesWithIdOnly = await prisma.prompt_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prompt_templatesFindManyArgs>(args?: SelectSubset<T, prompt_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prompt_templates.
     * @param {prompt_templatesCreateArgs} args - Arguments to create a Prompt_templates.
     * @example
     * // Create one Prompt_templates
     * const Prompt_templates = await prisma.prompt_templates.create({
     *   data: {
     *     // ... data to create a Prompt_templates
     *   }
     * })
     * 
     */
    create<T extends prompt_templatesCreateArgs>(args: SelectSubset<T, prompt_templatesCreateArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prompt_templates.
     * @param {prompt_templatesCreateManyArgs} args - Arguments to create many Prompt_templates.
     * @example
     * // Create many Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prompt_templatesCreateManyArgs>(args?: SelectSubset<T, prompt_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prompt_templates and returns the data saved in the database.
     * @param {prompt_templatesCreateManyAndReturnArgs} args - Arguments to create many Prompt_templates.
     * @example
     * // Create many Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prompt_templates and only return the `id`
     * const prompt_templatesWithIdOnly = await prisma.prompt_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prompt_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, prompt_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prompt_templates.
     * @param {prompt_templatesDeleteArgs} args - Arguments to delete one Prompt_templates.
     * @example
     * // Delete one Prompt_templates
     * const Prompt_templates = await prisma.prompt_templates.delete({
     *   where: {
     *     // ... filter to delete one Prompt_templates
     *   }
     * })
     * 
     */
    delete<T extends prompt_templatesDeleteArgs>(args: SelectSubset<T, prompt_templatesDeleteArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prompt_templates.
     * @param {prompt_templatesUpdateArgs} args - Arguments to update one Prompt_templates.
     * @example
     * // Update one Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prompt_templatesUpdateArgs>(args: SelectSubset<T, prompt_templatesUpdateArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prompt_templates.
     * @param {prompt_templatesDeleteManyArgs} args - Arguments to filter Prompt_templates to delete.
     * @example
     * // Delete a few Prompt_templates
     * const { count } = await prisma.prompt_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prompt_templatesDeleteManyArgs>(args?: SelectSubset<T, prompt_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompt_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prompt_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prompt_templatesUpdateManyArgs>(args: SelectSubset<T, prompt_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompt_templates and returns the data updated in the database.
     * @param {prompt_templatesUpdateManyAndReturnArgs} args - Arguments to update many Prompt_templates.
     * @example
     * // Update many Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prompt_templates and only return the `id`
     * const prompt_templatesWithIdOnly = await prisma.prompt_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends prompt_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, prompt_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prompt_templates.
     * @param {prompt_templatesUpsertArgs} args - Arguments to update or create a Prompt_templates.
     * @example
     * // Update or create a Prompt_templates
     * const prompt_templates = await prisma.prompt_templates.upsert({
     *   create: {
     *     // ... data to create a Prompt_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prompt_templates we want to update
     *   }
     * })
     */
    upsert<T extends prompt_templatesUpsertArgs>(args: SelectSubset<T, prompt_templatesUpsertArgs<ExtArgs>>): Prisma__prompt_templatesClient<$Result.GetResult<Prisma.$prompt_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prompt_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prompt_templatesCountArgs} args - Arguments to filter Prompt_templates to count.
     * @example
     * // Count the number of Prompt_templates
     * const count = await prisma.prompt_templates.count({
     *   where: {
     *     // ... the filter for the Prompt_templates we want to count
     *   }
     * })
    **/
    count<T extends prompt_templatesCountArgs>(
      args?: Subset<T, prompt_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prompt_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prompt_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prompt_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prompt_templatesAggregateArgs>(args: Subset<T, Prompt_templatesAggregateArgs>): Prisma.PrismaPromise<GetPrompt_templatesAggregateType<T>>

    /**
     * Group by Prompt_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prompt_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prompt_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prompt_templatesGroupByArgs['orderBy'] }
        : { orderBy?: prompt_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prompt_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrompt_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prompt_templates model
   */
  readonly fields: prompt_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prompt_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prompt_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prompt_templates model
   */
  interface prompt_templatesFieldRefs {
    readonly id: FieldRef<"prompt_templates", 'String'>
    readonly name: FieldRef<"prompt_templates", 'String'>
    readonly type: FieldRef<"prompt_templates", 'String'>
    readonly template: FieldRef<"prompt_templates", 'String'>
    readonly variables: FieldRef<"prompt_templates", 'Json'>
    readonly is_active: FieldRef<"prompt_templates", 'Boolean'>
    readonly metadata: FieldRef<"prompt_templates", 'Json'>
    readonly created_at: FieldRef<"prompt_templates", 'DateTime'>
    readonly updated_at: FieldRef<"prompt_templates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prompt_templates findUnique
   */
  export type prompt_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * Filter, which prompt_templates to fetch.
     */
    where: prompt_templatesWhereUniqueInput
  }

  /**
   * prompt_templates findUniqueOrThrow
   */
  export type prompt_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * Filter, which prompt_templates to fetch.
     */
    where: prompt_templatesWhereUniqueInput
  }

  /**
   * prompt_templates findFirst
   */
  export type prompt_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * Filter, which prompt_templates to fetch.
     */
    where?: prompt_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prompt_templates to fetch.
     */
    orderBy?: prompt_templatesOrderByWithRelationInput | prompt_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prompt_templates.
     */
    cursor?: prompt_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prompt_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prompt_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prompt_templates.
     */
    distinct?: Prompt_templatesScalarFieldEnum | Prompt_templatesScalarFieldEnum[]
  }

  /**
   * prompt_templates findFirstOrThrow
   */
  export type prompt_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * Filter, which prompt_templates to fetch.
     */
    where?: prompt_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prompt_templates to fetch.
     */
    orderBy?: prompt_templatesOrderByWithRelationInput | prompt_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prompt_templates.
     */
    cursor?: prompt_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prompt_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prompt_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prompt_templates.
     */
    distinct?: Prompt_templatesScalarFieldEnum | Prompt_templatesScalarFieldEnum[]
  }

  /**
   * prompt_templates findMany
   */
  export type prompt_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * Filter, which prompt_templates to fetch.
     */
    where?: prompt_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prompt_templates to fetch.
     */
    orderBy?: prompt_templatesOrderByWithRelationInput | prompt_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prompt_templates.
     */
    cursor?: prompt_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prompt_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prompt_templates.
     */
    skip?: number
    distinct?: Prompt_templatesScalarFieldEnum | Prompt_templatesScalarFieldEnum[]
  }

  /**
   * prompt_templates create
   */
  export type prompt_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * The data needed to create a prompt_templates.
     */
    data: XOR<prompt_templatesCreateInput, prompt_templatesUncheckedCreateInput>
  }

  /**
   * prompt_templates createMany
   */
  export type prompt_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prompt_templates.
     */
    data: prompt_templatesCreateManyInput | prompt_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prompt_templates createManyAndReturn
   */
  export type prompt_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many prompt_templates.
     */
    data: prompt_templatesCreateManyInput | prompt_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prompt_templates update
   */
  export type prompt_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * The data needed to update a prompt_templates.
     */
    data: XOR<prompt_templatesUpdateInput, prompt_templatesUncheckedUpdateInput>
    /**
     * Choose, which prompt_templates to update.
     */
    where: prompt_templatesWhereUniqueInput
  }

  /**
   * prompt_templates updateMany
   */
  export type prompt_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prompt_templates.
     */
    data: XOR<prompt_templatesUpdateManyMutationInput, prompt_templatesUncheckedUpdateManyInput>
    /**
     * Filter which prompt_templates to update
     */
    where?: prompt_templatesWhereInput
    /**
     * Limit how many prompt_templates to update.
     */
    limit?: number
  }

  /**
   * prompt_templates updateManyAndReturn
   */
  export type prompt_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * The data used to update prompt_templates.
     */
    data: XOR<prompt_templatesUpdateManyMutationInput, prompt_templatesUncheckedUpdateManyInput>
    /**
     * Filter which prompt_templates to update
     */
    where?: prompt_templatesWhereInput
    /**
     * Limit how many prompt_templates to update.
     */
    limit?: number
  }

  /**
   * prompt_templates upsert
   */
  export type prompt_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * The filter to search for the prompt_templates to update in case it exists.
     */
    where: prompt_templatesWhereUniqueInput
    /**
     * In case the prompt_templates found by the `where` argument doesn't exist, create a new prompt_templates with this data.
     */
    create: XOR<prompt_templatesCreateInput, prompt_templatesUncheckedCreateInput>
    /**
     * In case the prompt_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prompt_templatesUpdateInput, prompt_templatesUncheckedUpdateInput>
  }

  /**
   * prompt_templates delete
   */
  export type prompt_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
    /**
     * Filter which prompt_templates to delete.
     */
    where: prompt_templatesWhereUniqueInput
  }

  /**
   * prompt_templates deleteMany
   */
  export type prompt_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prompt_templates to delete
     */
    where?: prompt_templatesWhereInput
    /**
     * Limit how many prompt_templates to delete.
     */
    limit?: number
  }

  /**
   * prompt_templates without action
   */
  export type prompt_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prompt_templates
     */
    select?: prompt_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prompt_templates
     */
    omit?: prompt_templatesOmit<ExtArgs> | null
  }


  /**
   * Model viral_analysis_logs
   */

  export type AggregateViral_analysis_logs = {
    _count: Viral_analysis_logsCountAggregateOutputType | null
    _avg: Viral_analysis_logsAvgAggregateOutputType | null
    _sum: Viral_analysis_logsSumAggregateOutputType | null
    _min: Viral_analysis_logsMinAggregateOutputType | null
    _max: Viral_analysis_logsMaxAggregateOutputType | null
  }

  export type Viral_analysis_logsAvgAggregateOutputType = {
    tokens: number | null
    duration: number | null
  }

  export type Viral_analysis_logsSumAggregateOutputType = {
    tokens: number | null
    duration: number | null
  }

  export type Viral_analysis_logsMinAggregateOutputType = {
    id: string | null
    model: string | null
    phase: string | null
    prompt: string | null
    tokens: number | null
    duration: number | null
    success: boolean | null
    error: string | null
    created_at: Date | null
  }

  export type Viral_analysis_logsMaxAggregateOutputType = {
    id: string | null
    model: string | null
    phase: string | null
    prompt: string | null
    tokens: number | null
    duration: number | null
    success: boolean | null
    error: string | null
    created_at: Date | null
  }

  export type Viral_analysis_logsCountAggregateOutputType = {
    id: number
    model: number
    phase: number
    prompt: number
    response: number
    tokens: number
    duration: number
    success: number
    error: number
    created_at: number
    _all: number
  }


  export type Viral_analysis_logsAvgAggregateInputType = {
    tokens?: true
    duration?: true
  }

  export type Viral_analysis_logsSumAggregateInputType = {
    tokens?: true
    duration?: true
  }

  export type Viral_analysis_logsMinAggregateInputType = {
    id?: true
    model?: true
    phase?: true
    prompt?: true
    tokens?: true
    duration?: true
    success?: true
    error?: true
    created_at?: true
  }

  export type Viral_analysis_logsMaxAggregateInputType = {
    id?: true
    model?: true
    phase?: true
    prompt?: true
    tokens?: true
    duration?: true
    success?: true
    error?: true
    created_at?: true
  }

  export type Viral_analysis_logsCountAggregateInputType = {
    id?: true
    model?: true
    phase?: true
    prompt?: true
    response?: true
    tokens?: true
    duration?: true
    success?: true
    error?: true
    created_at?: true
    _all?: true
  }

  export type Viral_analysis_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_analysis_logs to aggregate.
     */
    where?: viral_analysis_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_analysis_logs to fetch.
     */
    orderBy?: viral_analysis_logsOrderByWithRelationInput | viral_analysis_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viral_analysis_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_analysis_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_analysis_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viral_analysis_logs
    **/
    _count?: true | Viral_analysis_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Viral_analysis_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Viral_analysis_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Viral_analysis_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Viral_analysis_logsMaxAggregateInputType
  }

  export type GetViral_analysis_logsAggregateType<T extends Viral_analysis_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateViral_analysis_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViral_analysis_logs[P]>
      : GetScalarType<T[P], AggregateViral_analysis_logs[P]>
  }




  export type viral_analysis_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viral_analysis_logsWhereInput
    orderBy?: viral_analysis_logsOrderByWithAggregationInput | viral_analysis_logsOrderByWithAggregationInput[]
    by: Viral_analysis_logsScalarFieldEnum[] | Viral_analysis_logsScalarFieldEnum
    having?: viral_analysis_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Viral_analysis_logsCountAggregateInputType | true
    _avg?: Viral_analysis_logsAvgAggregateInputType
    _sum?: Viral_analysis_logsSumAggregateInputType
    _min?: Viral_analysis_logsMinAggregateInputType
    _max?: Viral_analysis_logsMaxAggregateInputType
  }

  export type Viral_analysis_logsGroupByOutputType = {
    id: string
    model: string
    phase: string
    prompt: string
    response: JsonValue
    tokens: number | null
    duration: number | null
    success: boolean
    error: string | null
    created_at: Date | null
    _count: Viral_analysis_logsCountAggregateOutputType | null
    _avg: Viral_analysis_logsAvgAggregateOutputType | null
    _sum: Viral_analysis_logsSumAggregateOutputType | null
    _min: Viral_analysis_logsMinAggregateOutputType | null
    _max: Viral_analysis_logsMaxAggregateOutputType | null
  }

  type GetViral_analysis_logsGroupByPayload<T extends viral_analysis_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Viral_analysis_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Viral_analysis_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Viral_analysis_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Viral_analysis_logsGroupByOutputType[P]>
        }
      >
    >


  export type viral_analysis_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    phase?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    success?: boolean
    error?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["viral_analysis_logs"]>

  export type viral_analysis_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    phase?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    success?: boolean
    error?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["viral_analysis_logs"]>

  export type viral_analysis_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    phase?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    success?: boolean
    error?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["viral_analysis_logs"]>

  export type viral_analysis_logsSelectScalar = {
    id?: boolean
    model?: boolean
    phase?: boolean
    prompt?: boolean
    response?: boolean
    tokens?: boolean
    duration?: boolean
    success?: boolean
    error?: boolean
    created_at?: boolean
  }

  export type viral_analysis_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "model" | "phase" | "prompt" | "response" | "tokens" | "duration" | "success" | "error" | "created_at", ExtArgs["result"]["viral_analysis_logs"]>

  export type $viral_analysis_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viral_analysis_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      model: string
      phase: string
      prompt: string
      response: Prisma.JsonValue
      tokens: number | null
      duration: number | null
      success: boolean
      error: string | null
      created_at: Date | null
    }, ExtArgs["result"]["viral_analysis_logs"]>
    composites: {}
  }

  type viral_analysis_logsGetPayload<S extends boolean | null | undefined | viral_analysis_logsDefaultArgs> = $Result.GetResult<Prisma.$viral_analysis_logsPayload, S>

  type viral_analysis_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<viral_analysis_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Viral_analysis_logsCountAggregateInputType | true
    }

  export interface viral_analysis_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viral_analysis_logs'], meta: { name: 'viral_analysis_logs' } }
    /**
     * Find zero or one Viral_analysis_logs that matches the filter.
     * @param {viral_analysis_logsFindUniqueArgs} args - Arguments to find a Viral_analysis_logs
     * @example
     * // Get one Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viral_analysis_logsFindUniqueArgs>(args: SelectSubset<T, viral_analysis_logsFindUniqueArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Viral_analysis_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {viral_analysis_logsFindUniqueOrThrowArgs} args - Arguments to find a Viral_analysis_logs
     * @example
     * // Get one Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viral_analysis_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, viral_analysis_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_analysis_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_analysis_logsFindFirstArgs} args - Arguments to find a Viral_analysis_logs
     * @example
     * // Get one Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viral_analysis_logsFindFirstArgs>(args?: SelectSubset<T, viral_analysis_logsFindFirstArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_analysis_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_analysis_logsFindFirstOrThrowArgs} args - Arguments to find a Viral_analysis_logs
     * @example
     * // Get one Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viral_analysis_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, viral_analysis_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viral_analysis_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_analysis_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.findMany()
     * 
     * // Get first 10 Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viral_analysis_logsWithIdOnly = await prisma.viral_analysis_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends viral_analysis_logsFindManyArgs>(args?: SelectSubset<T, viral_analysis_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Viral_analysis_logs.
     * @param {viral_analysis_logsCreateArgs} args - Arguments to create a Viral_analysis_logs.
     * @example
     * // Create one Viral_analysis_logs
     * const Viral_analysis_logs = await prisma.viral_analysis_logs.create({
     *   data: {
     *     // ... data to create a Viral_analysis_logs
     *   }
     * })
     * 
     */
    create<T extends viral_analysis_logsCreateArgs>(args: SelectSubset<T, viral_analysis_logsCreateArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viral_analysis_logs.
     * @param {viral_analysis_logsCreateManyArgs} args - Arguments to create many Viral_analysis_logs.
     * @example
     * // Create many Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viral_analysis_logsCreateManyArgs>(args?: SelectSubset<T, viral_analysis_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viral_analysis_logs and returns the data saved in the database.
     * @param {viral_analysis_logsCreateManyAndReturnArgs} args - Arguments to create many Viral_analysis_logs.
     * @example
     * // Create many Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viral_analysis_logs and only return the `id`
     * const viral_analysis_logsWithIdOnly = await prisma.viral_analysis_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends viral_analysis_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, viral_analysis_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Viral_analysis_logs.
     * @param {viral_analysis_logsDeleteArgs} args - Arguments to delete one Viral_analysis_logs.
     * @example
     * // Delete one Viral_analysis_logs
     * const Viral_analysis_logs = await prisma.viral_analysis_logs.delete({
     *   where: {
     *     // ... filter to delete one Viral_analysis_logs
     *   }
     * })
     * 
     */
    delete<T extends viral_analysis_logsDeleteArgs>(args: SelectSubset<T, viral_analysis_logsDeleteArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Viral_analysis_logs.
     * @param {viral_analysis_logsUpdateArgs} args - Arguments to update one Viral_analysis_logs.
     * @example
     * // Update one Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viral_analysis_logsUpdateArgs>(args: SelectSubset<T, viral_analysis_logsUpdateArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viral_analysis_logs.
     * @param {viral_analysis_logsDeleteManyArgs} args - Arguments to filter Viral_analysis_logs to delete.
     * @example
     * // Delete a few Viral_analysis_logs
     * const { count } = await prisma.viral_analysis_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viral_analysis_logsDeleteManyArgs>(args?: SelectSubset<T, viral_analysis_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_analysis_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_analysis_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viral_analysis_logsUpdateManyArgs>(args: SelectSubset<T, viral_analysis_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_analysis_logs and returns the data updated in the database.
     * @param {viral_analysis_logsUpdateManyAndReturnArgs} args - Arguments to update many Viral_analysis_logs.
     * @example
     * // Update many Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viral_analysis_logs and only return the `id`
     * const viral_analysis_logsWithIdOnly = await prisma.viral_analysis_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends viral_analysis_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, viral_analysis_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Viral_analysis_logs.
     * @param {viral_analysis_logsUpsertArgs} args - Arguments to update or create a Viral_analysis_logs.
     * @example
     * // Update or create a Viral_analysis_logs
     * const viral_analysis_logs = await prisma.viral_analysis_logs.upsert({
     *   create: {
     *     // ... data to create a Viral_analysis_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viral_analysis_logs we want to update
     *   }
     * })
     */
    upsert<T extends viral_analysis_logsUpsertArgs>(args: SelectSubset<T, viral_analysis_logsUpsertArgs<ExtArgs>>): Prisma__viral_analysis_logsClient<$Result.GetResult<Prisma.$viral_analysis_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viral_analysis_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_analysis_logsCountArgs} args - Arguments to filter Viral_analysis_logs to count.
     * @example
     * // Count the number of Viral_analysis_logs
     * const count = await prisma.viral_analysis_logs.count({
     *   where: {
     *     // ... the filter for the Viral_analysis_logs we want to count
     *   }
     * })
    **/
    count<T extends viral_analysis_logsCountArgs>(
      args?: Subset<T, viral_analysis_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Viral_analysis_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viral_analysis_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Viral_analysis_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Viral_analysis_logsAggregateArgs>(args: Subset<T, Viral_analysis_logsAggregateArgs>): Prisma.PrismaPromise<GetViral_analysis_logsAggregateType<T>>

    /**
     * Group by Viral_analysis_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_analysis_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viral_analysis_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viral_analysis_logsGroupByArgs['orderBy'] }
        : { orderBy?: viral_analysis_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viral_analysis_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViral_analysis_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viral_analysis_logs model
   */
  readonly fields: viral_analysis_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viral_analysis_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viral_analysis_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viral_analysis_logs model
   */
  interface viral_analysis_logsFieldRefs {
    readonly id: FieldRef<"viral_analysis_logs", 'String'>
    readonly model: FieldRef<"viral_analysis_logs", 'String'>
    readonly phase: FieldRef<"viral_analysis_logs", 'String'>
    readonly prompt: FieldRef<"viral_analysis_logs", 'String'>
    readonly response: FieldRef<"viral_analysis_logs", 'Json'>
    readonly tokens: FieldRef<"viral_analysis_logs", 'Int'>
    readonly duration: FieldRef<"viral_analysis_logs", 'Int'>
    readonly success: FieldRef<"viral_analysis_logs", 'Boolean'>
    readonly error: FieldRef<"viral_analysis_logs", 'String'>
    readonly created_at: FieldRef<"viral_analysis_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * viral_analysis_logs findUnique
   */
  export type viral_analysis_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * Filter, which viral_analysis_logs to fetch.
     */
    where: viral_analysis_logsWhereUniqueInput
  }

  /**
   * viral_analysis_logs findUniqueOrThrow
   */
  export type viral_analysis_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * Filter, which viral_analysis_logs to fetch.
     */
    where: viral_analysis_logsWhereUniqueInput
  }

  /**
   * viral_analysis_logs findFirst
   */
  export type viral_analysis_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * Filter, which viral_analysis_logs to fetch.
     */
    where?: viral_analysis_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_analysis_logs to fetch.
     */
    orderBy?: viral_analysis_logsOrderByWithRelationInput | viral_analysis_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_analysis_logs.
     */
    cursor?: viral_analysis_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_analysis_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_analysis_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_analysis_logs.
     */
    distinct?: Viral_analysis_logsScalarFieldEnum | Viral_analysis_logsScalarFieldEnum[]
  }

  /**
   * viral_analysis_logs findFirstOrThrow
   */
  export type viral_analysis_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * Filter, which viral_analysis_logs to fetch.
     */
    where?: viral_analysis_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_analysis_logs to fetch.
     */
    orderBy?: viral_analysis_logsOrderByWithRelationInput | viral_analysis_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_analysis_logs.
     */
    cursor?: viral_analysis_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_analysis_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_analysis_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_analysis_logs.
     */
    distinct?: Viral_analysis_logsScalarFieldEnum | Viral_analysis_logsScalarFieldEnum[]
  }

  /**
   * viral_analysis_logs findMany
   */
  export type viral_analysis_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * Filter, which viral_analysis_logs to fetch.
     */
    where?: viral_analysis_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_analysis_logs to fetch.
     */
    orderBy?: viral_analysis_logsOrderByWithRelationInput | viral_analysis_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viral_analysis_logs.
     */
    cursor?: viral_analysis_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_analysis_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_analysis_logs.
     */
    skip?: number
    distinct?: Viral_analysis_logsScalarFieldEnum | Viral_analysis_logsScalarFieldEnum[]
  }

  /**
   * viral_analysis_logs create
   */
  export type viral_analysis_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a viral_analysis_logs.
     */
    data: XOR<viral_analysis_logsCreateInput, viral_analysis_logsUncheckedCreateInput>
  }

  /**
   * viral_analysis_logs createMany
   */
  export type viral_analysis_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viral_analysis_logs.
     */
    data: viral_analysis_logsCreateManyInput | viral_analysis_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_analysis_logs createManyAndReturn
   */
  export type viral_analysis_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * The data used to create many viral_analysis_logs.
     */
    data: viral_analysis_logsCreateManyInput | viral_analysis_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_analysis_logs update
   */
  export type viral_analysis_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a viral_analysis_logs.
     */
    data: XOR<viral_analysis_logsUpdateInput, viral_analysis_logsUncheckedUpdateInput>
    /**
     * Choose, which viral_analysis_logs to update.
     */
    where: viral_analysis_logsWhereUniqueInput
  }

  /**
   * viral_analysis_logs updateMany
   */
  export type viral_analysis_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viral_analysis_logs.
     */
    data: XOR<viral_analysis_logsUpdateManyMutationInput, viral_analysis_logsUncheckedUpdateManyInput>
    /**
     * Filter which viral_analysis_logs to update
     */
    where?: viral_analysis_logsWhereInput
    /**
     * Limit how many viral_analysis_logs to update.
     */
    limit?: number
  }

  /**
   * viral_analysis_logs updateManyAndReturn
   */
  export type viral_analysis_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * The data used to update viral_analysis_logs.
     */
    data: XOR<viral_analysis_logsUpdateManyMutationInput, viral_analysis_logsUncheckedUpdateManyInput>
    /**
     * Filter which viral_analysis_logs to update
     */
    where?: viral_analysis_logsWhereInput
    /**
     * Limit how many viral_analysis_logs to update.
     */
    limit?: number
  }

  /**
   * viral_analysis_logs upsert
   */
  export type viral_analysis_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the viral_analysis_logs to update in case it exists.
     */
    where: viral_analysis_logsWhereUniqueInput
    /**
     * In case the viral_analysis_logs found by the `where` argument doesn't exist, create a new viral_analysis_logs with this data.
     */
    create: XOR<viral_analysis_logsCreateInput, viral_analysis_logsUncheckedCreateInput>
    /**
     * In case the viral_analysis_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viral_analysis_logsUpdateInput, viral_analysis_logsUncheckedUpdateInput>
  }

  /**
   * viral_analysis_logs delete
   */
  export type viral_analysis_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
    /**
     * Filter which viral_analysis_logs to delete.
     */
    where: viral_analysis_logsWhereUniqueInput
  }

  /**
   * viral_analysis_logs deleteMany
   */
  export type viral_analysis_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_analysis_logs to delete
     */
    where?: viral_analysis_logsWhereInput
    /**
     * Limit how many viral_analysis_logs to delete.
     */
    limit?: number
  }

  /**
   * viral_analysis_logs without action
   */
  export type viral_analysis_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_analysis_logs
     */
    select?: viral_analysis_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_analysis_logs
     */
    omit?: viral_analysis_logsOmit<ExtArgs> | null
  }


  /**
   * Model viral_config
   */

  export type AggregateViral_config = {
    _count: Viral_configCountAggregateOutputType | null
    _min: Viral_configMinAggregateOutputType | null
    _max: Viral_configMaxAggregateOutputType | null
  }

  export type Viral_configMinAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_configMaxAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_configCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Viral_configMinAggregateInputType = {
    id?: true
    key?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_configMaxAggregateInputType = {
    id?: true
    key?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_configCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Viral_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_config to aggregate.
     */
    where?: viral_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_configs to fetch.
     */
    orderBy?: viral_configOrderByWithRelationInput | viral_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viral_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viral_configs
    **/
    _count?: true | Viral_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Viral_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Viral_configMaxAggregateInputType
  }

  export type GetViral_configAggregateType<T extends Viral_configAggregateArgs> = {
        [P in keyof T & keyof AggregateViral_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViral_config[P]>
      : GetScalarType<T[P], AggregateViral_config[P]>
  }




  export type viral_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viral_configWhereInput
    orderBy?: viral_configOrderByWithAggregationInput | viral_configOrderByWithAggregationInput[]
    by: Viral_configScalarFieldEnum[] | Viral_configScalarFieldEnum
    having?: viral_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Viral_configCountAggregateInputType | true
    _min?: Viral_configMinAggregateInputType
    _max?: Viral_configMaxAggregateInputType
  }

  export type Viral_configGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Viral_configCountAggregateOutputType | null
    _min: Viral_configMinAggregateOutputType | null
    _max: Viral_configMaxAggregateOutputType | null
  }

  type GetViral_configGroupByPayload<T extends viral_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Viral_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Viral_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Viral_configGroupByOutputType[P]>
            : GetScalarType<T[P], Viral_configGroupByOutputType[P]>
        }
      >
    >


  export type viral_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["viral_config"]>

  export type viral_configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["viral_config"]>

  export type viral_configSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["viral_config"]>

  export type viral_configSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type viral_configOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "created_at" | "updated_at", ExtArgs["result"]["viral_config"]>

  export type $viral_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viral_config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      description: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["viral_config"]>
    composites: {}
  }

  type viral_configGetPayload<S extends boolean | null | undefined | viral_configDefaultArgs> = $Result.GetResult<Prisma.$viral_configPayload, S>

  type viral_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<viral_configFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Viral_configCountAggregateInputType | true
    }

  export interface viral_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viral_config'], meta: { name: 'viral_config' } }
    /**
     * Find zero or one Viral_config that matches the filter.
     * @param {viral_configFindUniqueArgs} args - Arguments to find a Viral_config
     * @example
     * // Get one Viral_config
     * const viral_config = await prisma.viral_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viral_configFindUniqueArgs>(args: SelectSubset<T, viral_configFindUniqueArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Viral_config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {viral_configFindUniqueOrThrowArgs} args - Arguments to find a Viral_config
     * @example
     * // Get one Viral_config
     * const viral_config = await prisma.viral_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viral_configFindUniqueOrThrowArgs>(args: SelectSubset<T, viral_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_configFindFirstArgs} args - Arguments to find a Viral_config
     * @example
     * // Get one Viral_config
     * const viral_config = await prisma.viral_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viral_configFindFirstArgs>(args?: SelectSubset<T, viral_configFindFirstArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_configFindFirstOrThrowArgs} args - Arguments to find a Viral_config
     * @example
     * // Get one Viral_config
     * const viral_config = await prisma.viral_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viral_configFindFirstOrThrowArgs>(args?: SelectSubset<T, viral_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viral_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viral_configs
     * const viral_configs = await prisma.viral_config.findMany()
     * 
     * // Get first 10 Viral_configs
     * const viral_configs = await prisma.viral_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viral_configWithIdOnly = await prisma.viral_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends viral_configFindManyArgs>(args?: SelectSubset<T, viral_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Viral_config.
     * @param {viral_configCreateArgs} args - Arguments to create a Viral_config.
     * @example
     * // Create one Viral_config
     * const Viral_config = await prisma.viral_config.create({
     *   data: {
     *     // ... data to create a Viral_config
     *   }
     * })
     * 
     */
    create<T extends viral_configCreateArgs>(args: SelectSubset<T, viral_configCreateArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viral_configs.
     * @param {viral_configCreateManyArgs} args - Arguments to create many Viral_configs.
     * @example
     * // Create many Viral_configs
     * const viral_config = await prisma.viral_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viral_configCreateManyArgs>(args?: SelectSubset<T, viral_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viral_configs and returns the data saved in the database.
     * @param {viral_configCreateManyAndReturnArgs} args - Arguments to create many Viral_configs.
     * @example
     * // Create many Viral_configs
     * const viral_config = await prisma.viral_config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viral_configs and only return the `id`
     * const viral_configWithIdOnly = await prisma.viral_config.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends viral_configCreateManyAndReturnArgs>(args?: SelectSubset<T, viral_configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Viral_config.
     * @param {viral_configDeleteArgs} args - Arguments to delete one Viral_config.
     * @example
     * // Delete one Viral_config
     * const Viral_config = await prisma.viral_config.delete({
     *   where: {
     *     // ... filter to delete one Viral_config
     *   }
     * })
     * 
     */
    delete<T extends viral_configDeleteArgs>(args: SelectSubset<T, viral_configDeleteArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Viral_config.
     * @param {viral_configUpdateArgs} args - Arguments to update one Viral_config.
     * @example
     * // Update one Viral_config
     * const viral_config = await prisma.viral_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viral_configUpdateArgs>(args: SelectSubset<T, viral_configUpdateArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viral_configs.
     * @param {viral_configDeleteManyArgs} args - Arguments to filter Viral_configs to delete.
     * @example
     * // Delete a few Viral_configs
     * const { count } = await prisma.viral_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viral_configDeleteManyArgs>(args?: SelectSubset<T, viral_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viral_configs
     * const viral_config = await prisma.viral_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viral_configUpdateManyArgs>(args: SelectSubset<T, viral_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_configs and returns the data updated in the database.
     * @param {viral_configUpdateManyAndReturnArgs} args - Arguments to update many Viral_configs.
     * @example
     * // Update many Viral_configs
     * const viral_config = await prisma.viral_config.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viral_configs and only return the `id`
     * const viral_configWithIdOnly = await prisma.viral_config.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends viral_configUpdateManyAndReturnArgs>(args: SelectSubset<T, viral_configUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Viral_config.
     * @param {viral_configUpsertArgs} args - Arguments to update or create a Viral_config.
     * @example
     * // Update or create a Viral_config
     * const viral_config = await prisma.viral_config.upsert({
     *   create: {
     *     // ... data to create a Viral_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viral_config we want to update
     *   }
     * })
     */
    upsert<T extends viral_configUpsertArgs>(args: SelectSubset<T, viral_configUpsertArgs<ExtArgs>>): Prisma__viral_configClient<$Result.GetResult<Prisma.$viral_configPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viral_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_configCountArgs} args - Arguments to filter Viral_configs to count.
     * @example
     * // Count the number of Viral_configs
     * const count = await prisma.viral_config.count({
     *   where: {
     *     // ... the filter for the Viral_configs we want to count
     *   }
     * })
    **/
    count<T extends viral_configCountArgs>(
      args?: Subset<T, viral_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Viral_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viral_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Viral_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Viral_configAggregateArgs>(args: Subset<T, Viral_configAggregateArgs>): Prisma.PrismaPromise<GetViral_configAggregateType<T>>

    /**
     * Group by Viral_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viral_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viral_configGroupByArgs['orderBy'] }
        : { orderBy?: viral_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viral_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViral_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viral_config model
   */
  readonly fields: viral_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viral_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viral_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viral_config model
   */
  interface viral_configFieldRefs {
    readonly id: FieldRef<"viral_config", 'String'>
    readonly key: FieldRef<"viral_config", 'String'>
    readonly value: FieldRef<"viral_config", 'Json'>
    readonly description: FieldRef<"viral_config", 'String'>
    readonly created_at: FieldRef<"viral_config", 'DateTime'>
    readonly updated_at: FieldRef<"viral_config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * viral_config findUnique
   */
  export type viral_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * Filter, which viral_config to fetch.
     */
    where: viral_configWhereUniqueInput
  }

  /**
   * viral_config findUniqueOrThrow
   */
  export type viral_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * Filter, which viral_config to fetch.
     */
    where: viral_configWhereUniqueInput
  }

  /**
   * viral_config findFirst
   */
  export type viral_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * Filter, which viral_config to fetch.
     */
    where?: viral_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_configs to fetch.
     */
    orderBy?: viral_configOrderByWithRelationInput | viral_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_configs.
     */
    cursor?: viral_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_configs.
     */
    distinct?: Viral_configScalarFieldEnum | Viral_configScalarFieldEnum[]
  }

  /**
   * viral_config findFirstOrThrow
   */
  export type viral_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * Filter, which viral_config to fetch.
     */
    where?: viral_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_configs to fetch.
     */
    orderBy?: viral_configOrderByWithRelationInput | viral_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_configs.
     */
    cursor?: viral_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_configs.
     */
    distinct?: Viral_configScalarFieldEnum | Viral_configScalarFieldEnum[]
  }

  /**
   * viral_config findMany
   */
  export type viral_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * Filter, which viral_configs to fetch.
     */
    where?: viral_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_configs to fetch.
     */
    orderBy?: viral_configOrderByWithRelationInput | viral_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viral_configs.
     */
    cursor?: viral_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_configs.
     */
    skip?: number
    distinct?: Viral_configScalarFieldEnum | Viral_configScalarFieldEnum[]
  }

  /**
   * viral_config create
   */
  export type viral_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * The data needed to create a viral_config.
     */
    data: XOR<viral_configCreateInput, viral_configUncheckedCreateInput>
  }

  /**
   * viral_config createMany
   */
  export type viral_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viral_configs.
     */
    data: viral_configCreateManyInput | viral_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_config createManyAndReturn
   */
  export type viral_configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * The data used to create many viral_configs.
     */
    data: viral_configCreateManyInput | viral_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_config update
   */
  export type viral_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * The data needed to update a viral_config.
     */
    data: XOR<viral_configUpdateInput, viral_configUncheckedUpdateInput>
    /**
     * Choose, which viral_config to update.
     */
    where: viral_configWhereUniqueInput
  }

  /**
   * viral_config updateMany
   */
  export type viral_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viral_configs.
     */
    data: XOR<viral_configUpdateManyMutationInput, viral_configUncheckedUpdateManyInput>
    /**
     * Filter which viral_configs to update
     */
    where?: viral_configWhereInput
    /**
     * Limit how many viral_configs to update.
     */
    limit?: number
  }

  /**
   * viral_config updateManyAndReturn
   */
  export type viral_configUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * The data used to update viral_configs.
     */
    data: XOR<viral_configUpdateManyMutationInput, viral_configUncheckedUpdateManyInput>
    /**
     * Filter which viral_configs to update
     */
    where?: viral_configWhereInput
    /**
     * Limit how many viral_configs to update.
     */
    limit?: number
  }

  /**
   * viral_config upsert
   */
  export type viral_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * The filter to search for the viral_config to update in case it exists.
     */
    where: viral_configWhereUniqueInput
    /**
     * In case the viral_config found by the `where` argument doesn't exist, create a new viral_config with this data.
     */
    create: XOR<viral_configCreateInput, viral_configUncheckedCreateInput>
    /**
     * In case the viral_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viral_configUpdateInput, viral_configUncheckedUpdateInput>
  }

  /**
   * viral_config delete
   */
  export type viral_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
    /**
     * Filter which viral_config to delete.
     */
    where: viral_configWhereUniqueInput
  }

  /**
   * viral_config deleteMany
   */
  export type viral_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_configs to delete
     */
    where?: viral_configWhereInput
    /**
     * Limit how many viral_configs to delete.
     */
    limit?: number
  }

  /**
   * viral_config without action
   */
  export type viral_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_config
     */
    select?: viral_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_config
     */
    omit?: viral_configOmit<ExtArgs> | null
  }


  /**
   * Model viral_opportunities
   */

  export type AggregateViral_opportunities = {
    _count: Viral_opportunitiesCountAggregateOutputType | null
    _avg: Viral_opportunitiesAvgAggregateOutputType | null
    _sum: Viral_opportunitiesSumAggregateOutputType | null
    _min: Viral_opportunitiesMinAggregateOutputType | null
    _max: Viral_opportunitiesMaxAggregateOutputType | null
  }

  export type Viral_opportunitiesAvgAggregateOutputType = {
    viral_score: number | null
    time_window: number | null
  }

  export type Viral_opportunitiesSumAggregateOutputType = {
    viral_score: number | null
    time_window: number | null
  }

  export type Viral_opportunitiesMinAggregateOutputType = {
    id: string | null
    topic: string | null
    platform: string | null
    viral_score: number | null
    time_window: number | null
    angle: string | null
    status: string | null
    analyzed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_opportunitiesMaxAggregateOutputType = {
    id: string | null
    topic: string | null
    platform: string | null
    viral_score: number | null
    time_window: number | null
    angle: string | null
    status: string | null
    analyzed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_opportunitiesCountAggregateOutputType = {
    id: number
    topic: number
    platform: number
    viral_score: number
    time_window: number
    angle: number
    keywords: number
    source_data: number
    status: number
    analyzed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Viral_opportunitiesAvgAggregateInputType = {
    viral_score?: true
    time_window?: true
  }

  export type Viral_opportunitiesSumAggregateInputType = {
    viral_score?: true
    time_window?: true
  }

  export type Viral_opportunitiesMinAggregateInputType = {
    id?: true
    topic?: true
    platform?: true
    viral_score?: true
    time_window?: true
    angle?: true
    status?: true
    analyzed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_opportunitiesMaxAggregateInputType = {
    id?: true
    topic?: true
    platform?: true
    viral_score?: true
    time_window?: true
    angle?: true
    status?: true
    analyzed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_opportunitiesCountAggregateInputType = {
    id?: true
    topic?: true
    platform?: true
    viral_score?: true
    time_window?: true
    angle?: true
    keywords?: true
    source_data?: true
    status?: true
    analyzed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Viral_opportunitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_opportunities to aggregate.
     */
    where?: viral_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_opportunities to fetch.
     */
    orderBy?: viral_opportunitiesOrderByWithRelationInput | viral_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viral_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viral_opportunities
    **/
    _count?: true | Viral_opportunitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Viral_opportunitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Viral_opportunitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Viral_opportunitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Viral_opportunitiesMaxAggregateInputType
  }

  export type GetViral_opportunitiesAggregateType<T extends Viral_opportunitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateViral_opportunities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViral_opportunities[P]>
      : GetScalarType<T[P], AggregateViral_opportunities[P]>
  }




  export type viral_opportunitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viral_opportunitiesWhereInput
    orderBy?: viral_opportunitiesOrderByWithAggregationInput | viral_opportunitiesOrderByWithAggregationInput[]
    by: Viral_opportunitiesScalarFieldEnum[] | Viral_opportunitiesScalarFieldEnum
    having?: viral_opportunitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Viral_opportunitiesCountAggregateInputType | true
    _avg?: Viral_opportunitiesAvgAggregateInputType
    _sum?: Viral_opportunitiesSumAggregateInputType
    _min?: Viral_opportunitiesMinAggregateInputType
    _max?: Viral_opportunitiesMaxAggregateInputType
  }

  export type Viral_opportunitiesGroupByOutputType = {
    id: string
    topic: string
    platform: string
    viral_score: number
    time_window: number
    angle: string
    keywords: string[]
    source_data: JsonValue | null
    status: string
    analyzed_at: Date
    created_at: Date | null
    updated_at: Date | null
    _count: Viral_opportunitiesCountAggregateOutputType | null
    _avg: Viral_opportunitiesAvgAggregateOutputType | null
    _sum: Viral_opportunitiesSumAggregateOutputType | null
    _min: Viral_opportunitiesMinAggregateOutputType | null
    _max: Viral_opportunitiesMaxAggregateOutputType | null
  }

  type GetViral_opportunitiesGroupByPayload<T extends viral_opportunitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Viral_opportunitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Viral_opportunitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Viral_opportunitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Viral_opportunitiesGroupByOutputType[P]>
        }
      >
    >


  export type viral_opportunitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    platform?: boolean
    viral_score?: boolean
    time_window?: boolean
    angle?: boolean
    keywords?: boolean
    source_data?: boolean
    status?: boolean
    analyzed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_posts?: boolean | viral_opportunities$viral_postsArgs<ExtArgs>
    _count?: boolean | Viral_opportunitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_opportunities"]>

  export type viral_opportunitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    platform?: boolean
    viral_score?: boolean
    time_window?: boolean
    angle?: boolean
    keywords?: boolean
    source_data?: boolean
    status?: boolean
    analyzed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["viral_opportunities"]>

  export type viral_opportunitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    platform?: boolean
    viral_score?: boolean
    time_window?: boolean
    angle?: boolean
    keywords?: boolean
    source_data?: boolean
    status?: boolean
    analyzed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["viral_opportunities"]>

  export type viral_opportunitiesSelectScalar = {
    id?: boolean
    topic?: boolean
    platform?: boolean
    viral_score?: boolean
    time_window?: boolean
    angle?: boolean
    keywords?: boolean
    source_data?: boolean
    status?: boolean
    analyzed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type viral_opportunitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "topic" | "platform" | "viral_score" | "time_window" | "angle" | "keywords" | "source_data" | "status" | "analyzed_at" | "created_at" | "updated_at", ExtArgs["result"]["viral_opportunities"]>
  export type viral_opportunitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_posts?: boolean | viral_opportunities$viral_postsArgs<ExtArgs>
    _count?: boolean | Viral_opportunitiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type viral_opportunitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type viral_opportunitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $viral_opportunitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viral_opportunities"
    objects: {
      viral_posts: Prisma.$viral_postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topic: string
      platform: string
      viral_score: number
      time_window: number
      angle: string
      keywords: string[]
      source_data: Prisma.JsonValue | null
      status: string
      analyzed_at: Date
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["viral_opportunities"]>
    composites: {}
  }

  type viral_opportunitiesGetPayload<S extends boolean | null | undefined | viral_opportunitiesDefaultArgs> = $Result.GetResult<Prisma.$viral_opportunitiesPayload, S>

  type viral_opportunitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<viral_opportunitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Viral_opportunitiesCountAggregateInputType | true
    }

  export interface viral_opportunitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viral_opportunities'], meta: { name: 'viral_opportunities' } }
    /**
     * Find zero or one Viral_opportunities that matches the filter.
     * @param {viral_opportunitiesFindUniqueArgs} args - Arguments to find a Viral_opportunities
     * @example
     * // Get one Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viral_opportunitiesFindUniqueArgs>(args: SelectSubset<T, viral_opportunitiesFindUniqueArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Viral_opportunities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {viral_opportunitiesFindUniqueOrThrowArgs} args - Arguments to find a Viral_opportunities
     * @example
     * // Get one Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viral_opportunitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, viral_opportunitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_opportunitiesFindFirstArgs} args - Arguments to find a Viral_opportunities
     * @example
     * // Get one Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viral_opportunitiesFindFirstArgs>(args?: SelectSubset<T, viral_opportunitiesFindFirstArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_opportunities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_opportunitiesFindFirstOrThrowArgs} args - Arguments to find a Viral_opportunities
     * @example
     * // Get one Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viral_opportunitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, viral_opportunitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viral_opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_opportunitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.findMany()
     * 
     * // Get first 10 Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viral_opportunitiesWithIdOnly = await prisma.viral_opportunities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends viral_opportunitiesFindManyArgs>(args?: SelectSubset<T, viral_opportunitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Viral_opportunities.
     * @param {viral_opportunitiesCreateArgs} args - Arguments to create a Viral_opportunities.
     * @example
     * // Create one Viral_opportunities
     * const Viral_opportunities = await prisma.viral_opportunities.create({
     *   data: {
     *     // ... data to create a Viral_opportunities
     *   }
     * })
     * 
     */
    create<T extends viral_opportunitiesCreateArgs>(args: SelectSubset<T, viral_opportunitiesCreateArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viral_opportunities.
     * @param {viral_opportunitiesCreateManyArgs} args - Arguments to create many Viral_opportunities.
     * @example
     * // Create many Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viral_opportunitiesCreateManyArgs>(args?: SelectSubset<T, viral_opportunitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viral_opportunities and returns the data saved in the database.
     * @param {viral_opportunitiesCreateManyAndReturnArgs} args - Arguments to create many Viral_opportunities.
     * @example
     * // Create many Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viral_opportunities and only return the `id`
     * const viral_opportunitiesWithIdOnly = await prisma.viral_opportunities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends viral_opportunitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, viral_opportunitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Viral_opportunities.
     * @param {viral_opportunitiesDeleteArgs} args - Arguments to delete one Viral_opportunities.
     * @example
     * // Delete one Viral_opportunities
     * const Viral_opportunities = await prisma.viral_opportunities.delete({
     *   where: {
     *     // ... filter to delete one Viral_opportunities
     *   }
     * })
     * 
     */
    delete<T extends viral_opportunitiesDeleteArgs>(args: SelectSubset<T, viral_opportunitiesDeleteArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Viral_opportunities.
     * @param {viral_opportunitiesUpdateArgs} args - Arguments to update one Viral_opportunities.
     * @example
     * // Update one Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viral_opportunitiesUpdateArgs>(args: SelectSubset<T, viral_opportunitiesUpdateArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viral_opportunities.
     * @param {viral_opportunitiesDeleteManyArgs} args - Arguments to filter Viral_opportunities to delete.
     * @example
     * // Delete a few Viral_opportunities
     * const { count } = await prisma.viral_opportunities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viral_opportunitiesDeleteManyArgs>(args?: SelectSubset<T, viral_opportunitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_opportunitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viral_opportunitiesUpdateManyArgs>(args: SelectSubset<T, viral_opportunitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_opportunities and returns the data updated in the database.
     * @param {viral_opportunitiesUpdateManyAndReturnArgs} args - Arguments to update many Viral_opportunities.
     * @example
     * // Update many Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viral_opportunities and only return the `id`
     * const viral_opportunitiesWithIdOnly = await prisma.viral_opportunities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends viral_opportunitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, viral_opportunitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Viral_opportunities.
     * @param {viral_opportunitiesUpsertArgs} args - Arguments to update or create a Viral_opportunities.
     * @example
     * // Update or create a Viral_opportunities
     * const viral_opportunities = await prisma.viral_opportunities.upsert({
     *   create: {
     *     // ... data to create a Viral_opportunities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viral_opportunities we want to update
     *   }
     * })
     */
    upsert<T extends viral_opportunitiesUpsertArgs>(args: SelectSubset<T, viral_opportunitiesUpsertArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viral_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_opportunitiesCountArgs} args - Arguments to filter Viral_opportunities to count.
     * @example
     * // Count the number of Viral_opportunities
     * const count = await prisma.viral_opportunities.count({
     *   where: {
     *     // ... the filter for the Viral_opportunities we want to count
     *   }
     * })
    **/
    count<T extends viral_opportunitiesCountArgs>(
      args?: Subset<T, viral_opportunitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Viral_opportunitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viral_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Viral_opportunitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Viral_opportunitiesAggregateArgs>(args: Subset<T, Viral_opportunitiesAggregateArgs>): Prisma.PrismaPromise<GetViral_opportunitiesAggregateType<T>>

    /**
     * Group by Viral_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_opportunitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viral_opportunitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viral_opportunitiesGroupByArgs['orderBy'] }
        : { orderBy?: viral_opportunitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viral_opportunitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViral_opportunitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viral_opportunities model
   */
  readonly fields: viral_opportunitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viral_opportunities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viral_opportunitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viral_posts<T extends viral_opportunities$viral_postsArgs<ExtArgs> = {}>(args?: Subset<T, viral_opportunities$viral_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viral_opportunities model
   */
  interface viral_opportunitiesFieldRefs {
    readonly id: FieldRef<"viral_opportunities", 'String'>
    readonly topic: FieldRef<"viral_opportunities", 'String'>
    readonly platform: FieldRef<"viral_opportunities", 'String'>
    readonly viral_score: FieldRef<"viral_opportunities", 'Float'>
    readonly time_window: FieldRef<"viral_opportunities", 'Int'>
    readonly angle: FieldRef<"viral_opportunities", 'String'>
    readonly keywords: FieldRef<"viral_opportunities", 'String[]'>
    readonly source_data: FieldRef<"viral_opportunities", 'Json'>
    readonly status: FieldRef<"viral_opportunities", 'String'>
    readonly analyzed_at: FieldRef<"viral_opportunities", 'DateTime'>
    readonly created_at: FieldRef<"viral_opportunities", 'DateTime'>
    readonly updated_at: FieldRef<"viral_opportunities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * viral_opportunities findUnique
   */
  export type viral_opportunitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * Filter, which viral_opportunities to fetch.
     */
    where: viral_opportunitiesWhereUniqueInput
  }

  /**
   * viral_opportunities findUniqueOrThrow
   */
  export type viral_opportunitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * Filter, which viral_opportunities to fetch.
     */
    where: viral_opportunitiesWhereUniqueInput
  }

  /**
   * viral_opportunities findFirst
   */
  export type viral_opportunitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * Filter, which viral_opportunities to fetch.
     */
    where?: viral_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_opportunities to fetch.
     */
    orderBy?: viral_opportunitiesOrderByWithRelationInput | viral_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_opportunities.
     */
    cursor?: viral_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_opportunities.
     */
    distinct?: Viral_opportunitiesScalarFieldEnum | Viral_opportunitiesScalarFieldEnum[]
  }

  /**
   * viral_opportunities findFirstOrThrow
   */
  export type viral_opportunitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * Filter, which viral_opportunities to fetch.
     */
    where?: viral_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_opportunities to fetch.
     */
    orderBy?: viral_opportunitiesOrderByWithRelationInput | viral_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_opportunities.
     */
    cursor?: viral_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_opportunities.
     */
    distinct?: Viral_opportunitiesScalarFieldEnum | Viral_opportunitiesScalarFieldEnum[]
  }

  /**
   * viral_opportunities findMany
   */
  export type viral_opportunitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * Filter, which viral_opportunities to fetch.
     */
    where?: viral_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_opportunities to fetch.
     */
    orderBy?: viral_opportunitiesOrderByWithRelationInput | viral_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viral_opportunities.
     */
    cursor?: viral_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_opportunities.
     */
    skip?: number
    distinct?: Viral_opportunitiesScalarFieldEnum | Viral_opportunitiesScalarFieldEnum[]
  }

  /**
   * viral_opportunities create
   */
  export type viral_opportunitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a viral_opportunities.
     */
    data: XOR<viral_opportunitiesCreateInput, viral_opportunitiesUncheckedCreateInput>
  }

  /**
   * viral_opportunities createMany
   */
  export type viral_opportunitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viral_opportunities.
     */
    data: viral_opportunitiesCreateManyInput | viral_opportunitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_opportunities createManyAndReturn
   */
  export type viral_opportunitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * The data used to create many viral_opportunities.
     */
    data: viral_opportunitiesCreateManyInput | viral_opportunitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_opportunities update
   */
  export type viral_opportunitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a viral_opportunities.
     */
    data: XOR<viral_opportunitiesUpdateInput, viral_opportunitiesUncheckedUpdateInput>
    /**
     * Choose, which viral_opportunities to update.
     */
    where: viral_opportunitiesWhereUniqueInput
  }

  /**
   * viral_opportunities updateMany
   */
  export type viral_opportunitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viral_opportunities.
     */
    data: XOR<viral_opportunitiesUpdateManyMutationInput, viral_opportunitiesUncheckedUpdateManyInput>
    /**
     * Filter which viral_opportunities to update
     */
    where?: viral_opportunitiesWhereInput
    /**
     * Limit how many viral_opportunities to update.
     */
    limit?: number
  }

  /**
   * viral_opportunities updateManyAndReturn
   */
  export type viral_opportunitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * The data used to update viral_opportunities.
     */
    data: XOR<viral_opportunitiesUpdateManyMutationInput, viral_opportunitiesUncheckedUpdateManyInput>
    /**
     * Filter which viral_opportunities to update
     */
    where?: viral_opportunitiesWhereInput
    /**
     * Limit how many viral_opportunities to update.
     */
    limit?: number
  }

  /**
   * viral_opportunities upsert
   */
  export type viral_opportunitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the viral_opportunities to update in case it exists.
     */
    where: viral_opportunitiesWhereUniqueInput
    /**
     * In case the viral_opportunities found by the `where` argument doesn't exist, create a new viral_opportunities with this data.
     */
    create: XOR<viral_opportunitiesCreateInput, viral_opportunitiesUncheckedCreateInput>
    /**
     * In case the viral_opportunities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viral_opportunitiesUpdateInput, viral_opportunitiesUncheckedUpdateInput>
  }

  /**
   * viral_opportunities delete
   */
  export type viral_opportunitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
    /**
     * Filter which viral_opportunities to delete.
     */
    where: viral_opportunitiesWhereUniqueInput
  }

  /**
   * viral_opportunities deleteMany
   */
  export type viral_opportunitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_opportunities to delete
     */
    where?: viral_opportunitiesWhereInput
    /**
     * Limit how many viral_opportunities to delete.
     */
    limit?: number
  }

  /**
   * viral_opportunities.viral_posts
   */
  export type viral_opportunities$viral_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    where?: viral_postsWhereInput
    orderBy?: viral_postsOrderByWithRelationInput | viral_postsOrderByWithRelationInput[]
    cursor?: viral_postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Viral_postsScalarFieldEnum | Viral_postsScalarFieldEnum[]
  }

  /**
   * viral_opportunities without action
   */
  export type viral_opportunitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_opportunities
     */
    select?: viral_opportunitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_opportunities
     */
    omit?: viral_opportunitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_opportunitiesInclude<ExtArgs> | null
  }


  /**
   * Model viral_post_performance
   */

  export type AggregateViral_post_performance = {
    _count: Viral_post_performanceCountAggregateOutputType | null
    _avg: Viral_post_performanceAvgAggregateOutputType | null
    _sum: Viral_post_performanceSumAggregateOutputType | null
    _min: Viral_post_performanceMinAggregateOutputType | null
    _max: Viral_post_performanceMaxAggregateOutputType | null
  }

  export type Viral_post_performanceAvgAggregateOutputType = {
    impressions_30m: number | null
    likes_30m: number | null
    retweets_30m: number | null
    comments_30m: number | null
    impressions_1h: number | null
    likes_1h: number | null
    retweets_1h: number | null
    comments_1h: number | null
    impressions_24h: number | null
    likes_24h: number | null
    retweets_24h: number | null
    comments_24h: number | null
    followers_24h: number | null
    engagement_rate: number | null
    viral_coefficient: number | null
  }

  export type Viral_post_performanceSumAggregateOutputType = {
    impressions_30m: number | null
    likes_30m: number | null
    retweets_30m: number | null
    comments_30m: number | null
    impressions_1h: number | null
    likes_1h: number | null
    retweets_1h: number | null
    comments_1h: number | null
    impressions_24h: number | null
    likes_24h: number | null
    retweets_24h: number | null
    comments_24h: number | null
    followers_24h: number | null
    engagement_rate: number | null
    viral_coefficient: number | null
  }

  export type Viral_post_performanceMinAggregateOutputType = {
    id: string | null
    post_id: string | null
    impressions_30m: number | null
    likes_30m: number | null
    retweets_30m: number | null
    comments_30m: number | null
    impressions_1h: number | null
    likes_1h: number | null
    retweets_1h: number | null
    comments_1h: number | null
    impressions_24h: number | null
    likes_24h: number | null
    retweets_24h: number | null
    comments_24h: number | null
    followers_24h: number | null
    engagement_rate: number | null
    viral_coefficient: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_post_performanceMaxAggregateOutputType = {
    id: string | null
    post_id: string | null
    impressions_30m: number | null
    likes_30m: number | null
    retweets_30m: number | null
    comments_30m: number | null
    impressions_1h: number | null
    likes_1h: number | null
    retweets_1h: number | null
    comments_1h: number | null
    impressions_24h: number | null
    likes_24h: number | null
    retweets_24h: number | null
    comments_24h: number | null
    followers_24h: number | null
    engagement_rate: number | null
    viral_coefficient: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_post_performanceCountAggregateOutputType = {
    id: number
    post_id: number
    impressions_30m: number
    likes_30m: number
    retweets_30m: number
    comments_30m: number
    impressions_1h: number
    likes_1h: number
    retweets_1h: number
    comments_1h: number
    impressions_24h: number
    likes_24h: number
    retweets_24h: number
    comments_24h: number
    followers_24h: number
    engagement_rate: number
    viral_coefficient: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Viral_post_performanceAvgAggregateInputType = {
    impressions_30m?: true
    likes_30m?: true
    retweets_30m?: true
    comments_30m?: true
    impressions_1h?: true
    likes_1h?: true
    retweets_1h?: true
    comments_1h?: true
    impressions_24h?: true
    likes_24h?: true
    retweets_24h?: true
    comments_24h?: true
    followers_24h?: true
    engagement_rate?: true
    viral_coefficient?: true
  }

  export type Viral_post_performanceSumAggregateInputType = {
    impressions_30m?: true
    likes_30m?: true
    retweets_30m?: true
    comments_30m?: true
    impressions_1h?: true
    likes_1h?: true
    retweets_1h?: true
    comments_1h?: true
    impressions_24h?: true
    likes_24h?: true
    retweets_24h?: true
    comments_24h?: true
    followers_24h?: true
    engagement_rate?: true
    viral_coefficient?: true
  }

  export type Viral_post_performanceMinAggregateInputType = {
    id?: true
    post_id?: true
    impressions_30m?: true
    likes_30m?: true
    retweets_30m?: true
    comments_30m?: true
    impressions_1h?: true
    likes_1h?: true
    retweets_1h?: true
    comments_1h?: true
    impressions_24h?: true
    likes_24h?: true
    retweets_24h?: true
    comments_24h?: true
    followers_24h?: true
    engagement_rate?: true
    viral_coefficient?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_post_performanceMaxAggregateInputType = {
    id?: true
    post_id?: true
    impressions_30m?: true
    likes_30m?: true
    retweets_30m?: true
    comments_30m?: true
    impressions_1h?: true
    likes_1h?: true
    retweets_1h?: true
    comments_1h?: true
    impressions_24h?: true
    likes_24h?: true
    retweets_24h?: true
    comments_24h?: true
    followers_24h?: true
    engagement_rate?: true
    viral_coefficient?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_post_performanceCountAggregateInputType = {
    id?: true
    post_id?: true
    impressions_30m?: true
    likes_30m?: true
    retweets_30m?: true
    comments_30m?: true
    impressions_1h?: true
    likes_1h?: true
    retweets_1h?: true
    comments_1h?: true
    impressions_24h?: true
    likes_24h?: true
    retweets_24h?: true
    comments_24h?: true
    followers_24h?: true
    engagement_rate?: true
    viral_coefficient?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Viral_post_performanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_post_performance to aggregate.
     */
    where?: viral_post_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_post_performances to fetch.
     */
    orderBy?: viral_post_performanceOrderByWithRelationInput | viral_post_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viral_post_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_post_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_post_performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viral_post_performances
    **/
    _count?: true | Viral_post_performanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Viral_post_performanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Viral_post_performanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Viral_post_performanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Viral_post_performanceMaxAggregateInputType
  }

  export type GetViral_post_performanceAggregateType<T extends Viral_post_performanceAggregateArgs> = {
        [P in keyof T & keyof AggregateViral_post_performance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViral_post_performance[P]>
      : GetScalarType<T[P], AggregateViral_post_performance[P]>
  }




  export type viral_post_performanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viral_post_performanceWhereInput
    orderBy?: viral_post_performanceOrderByWithAggregationInput | viral_post_performanceOrderByWithAggregationInput[]
    by: Viral_post_performanceScalarFieldEnum[] | Viral_post_performanceScalarFieldEnum
    having?: viral_post_performanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Viral_post_performanceCountAggregateInputType | true
    _avg?: Viral_post_performanceAvgAggregateInputType
    _sum?: Viral_post_performanceSumAggregateInputType
    _min?: Viral_post_performanceMinAggregateInputType
    _max?: Viral_post_performanceMaxAggregateInputType
  }

  export type Viral_post_performanceGroupByOutputType = {
    id: string
    post_id: string
    impressions_30m: number | null
    likes_30m: number | null
    retweets_30m: number | null
    comments_30m: number | null
    impressions_1h: number | null
    likes_1h: number | null
    retweets_1h: number | null
    comments_1h: number | null
    impressions_24h: number | null
    likes_24h: number | null
    retweets_24h: number | null
    comments_24h: number | null
    followers_24h: number | null
    engagement_rate: number | null
    viral_coefficient: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Viral_post_performanceCountAggregateOutputType | null
    _avg: Viral_post_performanceAvgAggregateOutputType | null
    _sum: Viral_post_performanceSumAggregateOutputType | null
    _min: Viral_post_performanceMinAggregateOutputType | null
    _max: Viral_post_performanceMaxAggregateOutputType | null
  }

  type GetViral_post_performanceGroupByPayload<T extends viral_post_performanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Viral_post_performanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Viral_post_performanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Viral_post_performanceGroupByOutputType[P]>
            : GetScalarType<T[P], Viral_post_performanceGroupByOutputType[P]>
        }
      >
    >


  export type viral_post_performanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    impressions_30m?: boolean
    likes_30m?: boolean
    retweets_30m?: boolean
    comments_30m?: boolean
    impressions_1h?: boolean
    likes_1h?: boolean
    retweets_1h?: boolean
    comments_1h?: boolean
    impressions_24h?: boolean
    likes_24h?: boolean
    retweets_24h?: boolean
    comments_24h?: boolean
    followers_24h?: boolean
    engagement_rate?: boolean
    viral_coefficient?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_posts?: boolean | viral_postsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_post_performance"]>

  export type viral_post_performanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    impressions_30m?: boolean
    likes_30m?: boolean
    retweets_30m?: boolean
    comments_30m?: boolean
    impressions_1h?: boolean
    likes_1h?: boolean
    retweets_1h?: boolean
    comments_1h?: boolean
    impressions_24h?: boolean
    likes_24h?: boolean
    retweets_24h?: boolean
    comments_24h?: boolean
    followers_24h?: boolean
    engagement_rate?: boolean
    viral_coefficient?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_posts?: boolean | viral_postsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_post_performance"]>

  export type viral_post_performanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    impressions_30m?: boolean
    likes_30m?: boolean
    retweets_30m?: boolean
    comments_30m?: boolean
    impressions_1h?: boolean
    likes_1h?: boolean
    retweets_1h?: boolean
    comments_1h?: boolean
    impressions_24h?: boolean
    likes_24h?: boolean
    retweets_24h?: boolean
    comments_24h?: boolean
    followers_24h?: boolean
    engagement_rate?: boolean
    viral_coefficient?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_posts?: boolean | viral_postsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_post_performance"]>

  export type viral_post_performanceSelectScalar = {
    id?: boolean
    post_id?: boolean
    impressions_30m?: boolean
    likes_30m?: boolean
    retweets_30m?: boolean
    comments_30m?: boolean
    impressions_1h?: boolean
    likes_1h?: boolean
    retweets_1h?: boolean
    comments_1h?: boolean
    impressions_24h?: boolean
    likes_24h?: boolean
    retweets_24h?: boolean
    comments_24h?: boolean
    followers_24h?: boolean
    engagement_rate?: boolean
    viral_coefficient?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type viral_post_performanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "impressions_30m" | "likes_30m" | "retweets_30m" | "comments_30m" | "impressions_1h" | "likes_1h" | "retweets_1h" | "comments_1h" | "impressions_24h" | "likes_24h" | "retweets_24h" | "comments_24h" | "followers_24h" | "engagement_rate" | "viral_coefficient" | "created_at" | "updated_at", ExtArgs["result"]["viral_post_performance"]>
  export type viral_post_performanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_posts?: boolean | viral_postsDefaultArgs<ExtArgs>
  }
  export type viral_post_performanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_posts?: boolean | viral_postsDefaultArgs<ExtArgs>
  }
  export type viral_post_performanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_posts?: boolean | viral_postsDefaultArgs<ExtArgs>
  }

  export type $viral_post_performancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viral_post_performance"
    objects: {
      viral_posts: Prisma.$viral_postsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      post_id: string
      impressions_30m: number | null
      likes_30m: number | null
      retweets_30m: number | null
      comments_30m: number | null
      impressions_1h: number | null
      likes_1h: number | null
      retweets_1h: number | null
      comments_1h: number | null
      impressions_24h: number | null
      likes_24h: number | null
      retweets_24h: number | null
      comments_24h: number | null
      followers_24h: number | null
      engagement_rate: number | null
      viral_coefficient: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["viral_post_performance"]>
    composites: {}
  }

  type viral_post_performanceGetPayload<S extends boolean | null | undefined | viral_post_performanceDefaultArgs> = $Result.GetResult<Prisma.$viral_post_performancePayload, S>

  type viral_post_performanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<viral_post_performanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Viral_post_performanceCountAggregateInputType | true
    }

  export interface viral_post_performanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viral_post_performance'], meta: { name: 'viral_post_performance' } }
    /**
     * Find zero or one Viral_post_performance that matches the filter.
     * @param {viral_post_performanceFindUniqueArgs} args - Arguments to find a Viral_post_performance
     * @example
     * // Get one Viral_post_performance
     * const viral_post_performance = await prisma.viral_post_performance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viral_post_performanceFindUniqueArgs>(args: SelectSubset<T, viral_post_performanceFindUniqueArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Viral_post_performance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {viral_post_performanceFindUniqueOrThrowArgs} args - Arguments to find a Viral_post_performance
     * @example
     * // Get one Viral_post_performance
     * const viral_post_performance = await prisma.viral_post_performance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viral_post_performanceFindUniqueOrThrowArgs>(args: SelectSubset<T, viral_post_performanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_post_performance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_post_performanceFindFirstArgs} args - Arguments to find a Viral_post_performance
     * @example
     * // Get one Viral_post_performance
     * const viral_post_performance = await prisma.viral_post_performance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viral_post_performanceFindFirstArgs>(args?: SelectSubset<T, viral_post_performanceFindFirstArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_post_performance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_post_performanceFindFirstOrThrowArgs} args - Arguments to find a Viral_post_performance
     * @example
     * // Get one Viral_post_performance
     * const viral_post_performance = await prisma.viral_post_performance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viral_post_performanceFindFirstOrThrowArgs>(args?: SelectSubset<T, viral_post_performanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viral_post_performances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_post_performanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viral_post_performances
     * const viral_post_performances = await prisma.viral_post_performance.findMany()
     * 
     * // Get first 10 Viral_post_performances
     * const viral_post_performances = await prisma.viral_post_performance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viral_post_performanceWithIdOnly = await prisma.viral_post_performance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends viral_post_performanceFindManyArgs>(args?: SelectSubset<T, viral_post_performanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Viral_post_performance.
     * @param {viral_post_performanceCreateArgs} args - Arguments to create a Viral_post_performance.
     * @example
     * // Create one Viral_post_performance
     * const Viral_post_performance = await prisma.viral_post_performance.create({
     *   data: {
     *     // ... data to create a Viral_post_performance
     *   }
     * })
     * 
     */
    create<T extends viral_post_performanceCreateArgs>(args: SelectSubset<T, viral_post_performanceCreateArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viral_post_performances.
     * @param {viral_post_performanceCreateManyArgs} args - Arguments to create many Viral_post_performances.
     * @example
     * // Create many Viral_post_performances
     * const viral_post_performance = await prisma.viral_post_performance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viral_post_performanceCreateManyArgs>(args?: SelectSubset<T, viral_post_performanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viral_post_performances and returns the data saved in the database.
     * @param {viral_post_performanceCreateManyAndReturnArgs} args - Arguments to create many Viral_post_performances.
     * @example
     * // Create many Viral_post_performances
     * const viral_post_performance = await prisma.viral_post_performance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viral_post_performances and only return the `id`
     * const viral_post_performanceWithIdOnly = await prisma.viral_post_performance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends viral_post_performanceCreateManyAndReturnArgs>(args?: SelectSubset<T, viral_post_performanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Viral_post_performance.
     * @param {viral_post_performanceDeleteArgs} args - Arguments to delete one Viral_post_performance.
     * @example
     * // Delete one Viral_post_performance
     * const Viral_post_performance = await prisma.viral_post_performance.delete({
     *   where: {
     *     // ... filter to delete one Viral_post_performance
     *   }
     * })
     * 
     */
    delete<T extends viral_post_performanceDeleteArgs>(args: SelectSubset<T, viral_post_performanceDeleteArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Viral_post_performance.
     * @param {viral_post_performanceUpdateArgs} args - Arguments to update one Viral_post_performance.
     * @example
     * // Update one Viral_post_performance
     * const viral_post_performance = await prisma.viral_post_performance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viral_post_performanceUpdateArgs>(args: SelectSubset<T, viral_post_performanceUpdateArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viral_post_performances.
     * @param {viral_post_performanceDeleteManyArgs} args - Arguments to filter Viral_post_performances to delete.
     * @example
     * // Delete a few Viral_post_performances
     * const { count } = await prisma.viral_post_performance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viral_post_performanceDeleteManyArgs>(args?: SelectSubset<T, viral_post_performanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_post_performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_post_performanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viral_post_performances
     * const viral_post_performance = await prisma.viral_post_performance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viral_post_performanceUpdateManyArgs>(args: SelectSubset<T, viral_post_performanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_post_performances and returns the data updated in the database.
     * @param {viral_post_performanceUpdateManyAndReturnArgs} args - Arguments to update many Viral_post_performances.
     * @example
     * // Update many Viral_post_performances
     * const viral_post_performance = await prisma.viral_post_performance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viral_post_performances and only return the `id`
     * const viral_post_performanceWithIdOnly = await prisma.viral_post_performance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends viral_post_performanceUpdateManyAndReturnArgs>(args: SelectSubset<T, viral_post_performanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Viral_post_performance.
     * @param {viral_post_performanceUpsertArgs} args - Arguments to update or create a Viral_post_performance.
     * @example
     * // Update or create a Viral_post_performance
     * const viral_post_performance = await prisma.viral_post_performance.upsert({
     *   create: {
     *     // ... data to create a Viral_post_performance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viral_post_performance we want to update
     *   }
     * })
     */
    upsert<T extends viral_post_performanceUpsertArgs>(args: SelectSubset<T, viral_post_performanceUpsertArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viral_post_performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_post_performanceCountArgs} args - Arguments to filter Viral_post_performances to count.
     * @example
     * // Count the number of Viral_post_performances
     * const count = await prisma.viral_post_performance.count({
     *   where: {
     *     // ... the filter for the Viral_post_performances we want to count
     *   }
     * })
    **/
    count<T extends viral_post_performanceCountArgs>(
      args?: Subset<T, viral_post_performanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Viral_post_performanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viral_post_performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Viral_post_performanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Viral_post_performanceAggregateArgs>(args: Subset<T, Viral_post_performanceAggregateArgs>): Prisma.PrismaPromise<GetViral_post_performanceAggregateType<T>>

    /**
     * Group by Viral_post_performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_post_performanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viral_post_performanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viral_post_performanceGroupByArgs['orderBy'] }
        : { orderBy?: viral_post_performanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viral_post_performanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViral_post_performanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viral_post_performance model
   */
  readonly fields: viral_post_performanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viral_post_performance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viral_post_performanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viral_posts<T extends viral_postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viral_postsDefaultArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viral_post_performance model
   */
  interface viral_post_performanceFieldRefs {
    readonly id: FieldRef<"viral_post_performance", 'String'>
    readonly post_id: FieldRef<"viral_post_performance", 'String'>
    readonly impressions_30m: FieldRef<"viral_post_performance", 'Int'>
    readonly likes_30m: FieldRef<"viral_post_performance", 'Int'>
    readonly retweets_30m: FieldRef<"viral_post_performance", 'Int'>
    readonly comments_30m: FieldRef<"viral_post_performance", 'Int'>
    readonly impressions_1h: FieldRef<"viral_post_performance", 'Int'>
    readonly likes_1h: FieldRef<"viral_post_performance", 'Int'>
    readonly retweets_1h: FieldRef<"viral_post_performance", 'Int'>
    readonly comments_1h: FieldRef<"viral_post_performance", 'Int'>
    readonly impressions_24h: FieldRef<"viral_post_performance", 'Int'>
    readonly likes_24h: FieldRef<"viral_post_performance", 'Int'>
    readonly retweets_24h: FieldRef<"viral_post_performance", 'Int'>
    readonly comments_24h: FieldRef<"viral_post_performance", 'Int'>
    readonly followers_24h: FieldRef<"viral_post_performance", 'Int'>
    readonly engagement_rate: FieldRef<"viral_post_performance", 'Float'>
    readonly viral_coefficient: FieldRef<"viral_post_performance", 'Float'>
    readonly created_at: FieldRef<"viral_post_performance", 'DateTime'>
    readonly updated_at: FieldRef<"viral_post_performance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * viral_post_performance findUnique
   */
  export type viral_post_performanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * Filter, which viral_post_performance to fetch.
     */
    where: viral_post_performanceWhereUniqueInput
  }

  /**
   * viral_post_performance findUniqueOrThrow
   */
  export type viral_post_performanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * Filter, which viral_post_performance to fetch.
     */
    where: viral_post_performanceWhereUniqueInput
  }

  /**
   * viral_post_performance findFirst
   */
  export type viral_post_performanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * Filter, which viral_post_performance to fetch.
     */
    where?: viral_post_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_post_performances to fetch.
     */
    orderBy?: viral_post_performanceOrderByWithRelationInput | viral_post_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_post_performances.
     */
    cursor?: viral_post_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_post_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_post_performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_post_performances.
     */
    distinct?: Viral_post_performanceScalarFieldEnum | Viral_post_performanceScalarFieldEnum[]
  }

  /**
   * viral_post_performance findFirstOrThrow
   */
  export type viral_post_performanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * Filter, which viral_post_performance to fetch.
     */
    where?: viral_post_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_post_performances to fetch.
     */
    orderBy?: viral_post_performanceOrderByWithRelationInput | viral_post_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_post_performances.
     */
    cursor?: viral_post_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_post_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_post_performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_post_performances.
     */
    distinct?: Viral_post_performanceScalarFieldEnum | Viral_post_performanceScalarFieldEnum[]
  }

  /**
   * viral_post_performance findMany
   */
  export type viral_post_performanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * Filter, which viral_post_performances to fetch.
     */
    where?: viral_post_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_post_performances to fetch.
     */
    orderBy?: viral_post_performanceOrderByWithRelationInput | viral_post_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viral_post_performances.
     */
    cursor?: viral_post_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_post_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_post_performances.
     */
    skip?: number
    distinct?: Viral_post_performanceScalarFieldEnum | Viral_post_performanceScalarFieldEnum[]
  }

  /**
   * viral_post_performance create
   */
  export type viral_post_performanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * The data needed to create a viral_post_performance.
     */
    data: XOR<viral_post_performanceCreateInput, viral_post_performanceUncheckedCreateInput>
  }

  /**
   * viral_post_performance createMany
   */
  export type viral_post_performanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viral_post_performances.
     */
    data: viral_post_performanceCreateManyInput | viral_post_performanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_post_performance createManyAndReturn
   */
  export type viral_post_performanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * The data used to create many viral_post_performances.
     */
    data: viral_post_performanceCreateManyInput | viral_post_performanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * viral_post_performance update
   */
  export type viral_post_performanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * The data needed to update a viral_post_performance.
     */
    data: XOR<viral_post_performanceUpdateInput, viral_post_performanceUncheckedUpdateInput>
    /**
     * Choose, which viral_post_performance to update.
     */
    where: viral_post_performanceWhereUniqueInput
  }

  /**
   * viral_post_performance updateMany
   */
  export type viral_post_performanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viral_post_performances.
     */
    data: XOR<viral_post_performanceUpdateManyMutationInput, viral_post_performanceUncheckedUpdateManyInput>
    /**
     * Filter which viral_post_performances to update
     */
    where?: viral_post_performanceWhereInput
    /**
     * Limit how many viral_post_performances to update.
     */
    limit?: number
  }

  /**
   * viral_post_performance updateManyAndReturn
   */
  export type viral_post_performanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * The data used to update viral_post_performances.
     */
    data: XOR<viral_post_performanceUpdateManyMutationInput, viral_post_performanceUncheckedUpdateManyInput>
    /**
     * Filter which viral_post_performances to update
     */
    where?: viral_post_performanceWhereInput
    /**
     * Limit how many viral_post_performances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * viral_post_performance upsert
   */
  export type viral_post_performanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * The filter to search for the viral_post_performance to update in case it exists.
     */
    where: viral_post_performanceWhereUniqueInput
    /**
     * In case the viral_post_performance found by the `where` argument doesn't exist, create a new viral_post_performance with this data.
     */
    create: XOR<viral_post_performanceCreateInput, viral_post_performanceUncheckedCreateInput>
    /**
     * In case the viral_post_performance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viral_post_performanceUpdateInput, viral_post_performanceUncheckedUpdateInput>
  }

  /**
   * viral_post_performance delete
   */
  export type viral_post_performanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    /**
     * Filter which viral_post_performance to delete.
     */
    where: viral_post_performanceWhereUniqueInput
  }

  /**
   * viral_post_performance deleteMany
   */
  export type viral_post_performanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_post_performances to delete
     */
    where?: viral_post_performanceWhereInput
    /**
     * Limit how many viral_post_performances to delete.
     */
    limit?: number
  }

  /**
   * viral_post_performance without action
   */
  export type viral_post_performanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
  }


  /**
   * Model viral_posts
   */

  export type AggregateViral_posts = {
    _count: Viral_postsCountAggregateOutputType | null
    _min: Viral_postsMinAggregateOutputType | null
    _max: Viral_postsMaxAggregateOutputType | null
  }

  export type Viral_postsMinAggregateOutputType = {
    id: string | null
    opportunity_id: string | null
    concept_type: string | null
    content: string | null
    visual_guide: string | null
    post_type: string | null
    platform: string | null
    scheduled_at: Date | null
    posted_at: Date | null
    post_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_postsMaxAggregateOutputType = {
    id: string | null
    opportunity_id: string | null
    concept_type: string | null
    content: string | null
    visual_guide: string | null
    post_type: string | null
    platform: string | null
    scheduled_at: Date | null
    posted_at: Date | null
    post_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Viral_postsCountAggregateOutputType = {
    id: number
    opportunity_id: number
    concept_type: number
    content: number
    thread_content: number
    visual_guide: number
    hashtags: number
    post_type: number
    platform: number
    scheduled_at: number
    posted_at: number
    post_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Viral_postsMinAggregateInputType = {
    id?: true
    opportunity_id?: true
    concept_type?: true
    content?: true
    visual_guide?: true
    post_type?: true
    platform?: true
    scheduled_at?: true
    posted_at?: true
    post_url?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_postsMaxAggregateInputType = {
    id?: true
    opportunity_id?: true
    concept_type?: true
    content?: true
    visual_guide?: true
    post_type?: true
    platform?: true
    scheduled_at?: true
    posted_at?: true
    post_url?: true
    created_at?: true
    updated_at?: true
  }

  export type Viral_postsCountAggregateInputType = {
    id?: true
    opportunity_id?: true
    concept_type?: true
    content?: true
    thread_content?: true
    visual_guide?: true
    hashtags?: true
    post_type?: true
    platform?: true
    scheduled_at?: true
    posted_at?: true
    post_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Viral_postsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_posts to aggregate.
     */
    where?: viral_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_posts to fetch.
     */
    orderBy?: viral_postsOrderByWithRelationInput | viral_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viral_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viral_posts
    **/
    _count?: true | Viral_postsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Viral_postsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Viral_postsMaxAggregateInputType
  }

  export type GetViral_postsAggregateType<T extends Viral_postsAggregateArgs> = {
        [P in keyof T & keyof AggregateViral_posts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViral_posts[P]>
      : GetScalarType<T[P], AggregateViral_posts[P]>
  }




  export type viral_postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viral_postsWhereInput
    orderBy?: viral_postsOrderByWithAggregationInput | viral_postsOrderByWithAggregationInput[]
    by: Viral_postsScalarFieldEnum[] | Viral_postsScalarFieldEnum
    having?: viral_postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Viral_postsCountAggregateInputType | true
    _min?: Viral_postsMinAggregateInputType
    _max?: Viral_postsMaxAggregateInputType
  }

  export type Viral_postsGroupByOutputType = {
    id: string
    opportunity_id: string
    concept_type: string
    content: string
    thread_content: JsonValue | null
    visual_guide: string | null
    hashtags: string[]
    post_type: string
    platform: string
    scheduled_at: Date | null
    posted_at: Date | null
    post_url: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Viral_postsCountAggregateOutputType | null
    _min: Viral_postsMinAggregateOutputType | null
    _max: Viral_postsMaxAggregateOutputType | null
  }

  type GetViral_postsGroupByPayload<T extends viral_postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Viral_postsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Viral_postsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Viral_postsGroupByOutputType[P]>
            : GetScalarType<T[P], Viral_postsGroupByOutputType[P]>
        }
      >
    >


  export type viral_postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunity_id?: boolean
    concept_type?: boolean
    content?: boolean
    thread_content?: boolean
    visual_guide?: boolean
    hashtags?: boolean
    post_type?: boolean
    platform?: boolean
    scheduled_at?: boolean
    posted_at?: boolean
    post_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_post_performance?: boolean | viral_posts$viral_post_performanceArgs<ExtArgs>
    viral_opportunities?: boolean | viral_opportunitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_posts"]>

  export type viral_postsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunity_id?: boolean
    concept_type?: boolean
    content?: boolean
    thread_content?: boolean
    visual_guide?: boolean
    hashtags?: boolean
    post_type?: boolean
    platform?: boolean
    scheduled_at?: boolean
    posted_at?: boolean
    post_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_opportunities?: boolean | viral_opportunitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_posts"]>

  export type viral_postsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunity_id?: boolean
    concept_type?: boolean
    content?: boolean
    thread_content?: boolean
    visual_guide?: boolean
    hashtags?: boolean
    post_type?: boolean
    platform?: boolean
    scheduled_at?: boolean
    posted_at?: boolean
    post_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    viral_opportunities?: boolean | viral_opportunitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viral_posts"]>

  export type viral_postsSelectScalar = {
    id?: boolean
    opportunity_id?: boolean
    concept_type?: boolean
    content?: boolean
    thread_content?: boolean
    visual_guide?: boolean
    hashtags?: boolean
    post_type?: boolean
    platform?: boolean
    scheduled_at?: boolean
    posted_at?: boolean
    post_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type viral_postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "opportunity_id" | "concept_type" | "content" | "thread_content" | "visual_guide" | "hashtags" | "post_type" | "platform" | "scheduled_at" | "posted_at" | "post_url" | "created_at" | "updated_at", ExtArgs["result"]["viral_posts"]>
  export type viral_postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_post_performance?: boolean | viral_posts$viral_post_performanceArgs<ExtArgs>
    viral_opportunities?: boolean | viral_opportunitiesDefaultArgs<ExtArgs>
  }
  export type viral_postsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_opportunities?: boolean | viral_opportunitiesDefaultArgs<ExtArgs>
  }
  export type viral_postsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viral_opportunities?: boolean | viral_opportunitiesDefaultArgs<ExtArgs>
  }

  export type $viral_postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viral_posts"
    objects: {
      viral_post_performance: Prisma.$viral_post_performancePayload<ExtArgs> | null
      viral_opportunities: Prisma.$viral_opportunitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      opportunity_id: string
      concept_type: string
      content: string
      thread_content: Prisma.JsonValue | null
      visual_guide: string | null
      hashtags: string[]
      post_type: string
      platform: string
      scheduled_at: Date | null
      posted_at: Date | null
      post_url: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["viral_posts"]>
    composites: {}
  }

  type viral_postsGetPayload<S extends boolean | null | undefined | viral_postsDefaultArgs> = $Result.GetResult<Prisma.$viral_postsPayload, S>

  type viral_postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<viral_postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Viral_postsCountAggregateInputType | true
    }

  export interface viral_postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viral_posts'], meta: { name: 'viral_posts' } }
    /**
     * Find zero or one Viral_posts that matches the filter.
     * @param {viral_postsFindUniqueArgs} args - Arguments to find a Viral_posts
     * @example
     * // Get one Viral_posts
     * const viral_posts = await prisma.viral_posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viral_postsFindUniqueArgs>(args: SelectSubset<T, viral_postsFindUniqueArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Viral_posts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {viral_postsFindUniqueOrThrowArgs} args - Arguments to find a Viral_posts
     * @example
     * // Get one Viral_posts
     * const viral_posts = await prisma.viral_posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viral_postsFindUniqueOrThrowArgs>(args: SelectSubset<T, viral_postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_postsFindFirstArgs} args - Arguments to find a Viral_posts
     * @example
     * // Get one Viral_posts
     * const viral_posts = await prisma.viral_posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viral_postsFindFirstArgs>(args?: SelectSubset<T, viral_postsFindFirstArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viral_posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_postsFindFirstOrThrowArgs} args - Arguments to find a Viral_posts
     * @example
     * // Get one Viral_posts
     * const viral_posts = await prisma.viral_posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viral_postsFindFirstOrThrowArgs>(args?: SelectSubset<T, viral_postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viral_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_postsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viral_posts
     * const viral_posts = await prisma.viral_posts.findMany()
     * 
     * // Get first 10 Viral_posts
     * const viral_posts = await prisma.viral_posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viral_postsWithIdOnly = await prisma.viral_posts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends viral_postsFindManyArgs>(args?: SelectSubset<T, viral_postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Viral_posts.
     * @param {viral_postsCreateArgs} args - Arguments to create a Viral_posts.
     * @example
     * // Create one Viral_posts
     * const Viral_posts = await prisma.viral_posts.create({
     *   data: {
     *     // ... data to create a Viral_posts
     *   }
     * })
     * 
     */
    create<T extends viral_postsCreateArgs>(args: SelectSubset<T, viral_postsCreateArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viral_posts.
     * @param {viral_postsCreateManyArgs} args - Arguments to create many Viral_posts.
     * @example
     * // Create many Viral_posts
     * const viral_posts = await prisma.viral_posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viral_postsCreateManyArgs>(args?: SelectSubset<T, viral_postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viral_posts and returns the data saved in the database.
     * @param {viral_postsCreateManyAndReturnArgs} args - Arguments to create many Viral_posts.
     * @example
     * // Create many Viral_posts
     * const viral_posts = await prisma.viral_posts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viral_posts and only return the `id`
     * const viral_postsWithIdOnly = await prisma.viral_posts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends viral_postsCreateManyAndReturnArgs>(args?: SelectSubset<T, viral_postsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Viral_posts.
     * @param {viral_postsDeleteArgs} args - Arguments to delete one Viral_posts.
     * @example
     * // Delete one Viral_posts
     * const Viral_posts = await prisma.viral_posts.delete({
     *   where: {
     *     // ... filter to delete one Viral_posts
     *   }
     * })
     * 
     */
    delete<T extends viral_postsDeleteArgs>(args: SelectSubset<T, viral_postsDeleteArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Viral_posts.
     * @param {viral_postsUpdateArgs} args - Arguments to update one Viral_posts.
     * @example
     * // Update one Viral_posts
     * const viral_posts = await prisma.viral_posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viral_postsUpdateArgs>(args: SelectSubset<T, viral_postsUpdateArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viral_posts.
     * @param {viral_postsDeleteManyArgs} args - Arguments to filter Viral_posts to delete.
     * @example
     * // Delete a few Viral_posts
     * const { count } = await prisma.viral_posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viral_postsDeleteManyArgs>(args?: SelectSubset<T, viral_postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viral_posts
     * const viral_posts = await prisma.viral_posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viral_postsUpdateManyArgs>(args: SelectSubset<T, viral_postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viral_posts and returns the data updated in the database.
     * @param {viral_postsUpdateManyAndReturnArgs} args - Arguments to update many Viral_posts.
     * @example
     * // Update many Viral_posts
     * const viral_posts = await prisma.viral_posts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viral_posts and only return the `id`
     * const viral_postsWithIdOnly = await prisma.viral_posts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends viral_postsUpdateManyAndReturnArgs>(args: SelectSubset<T, viral_postsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Viral_posts.
     * @param {viral_postsUpsertArgs} args - Arguments to update or create a Viral_posts.
     * @example
     * // Update or create a Viral_posts
     * const viral_posts = await prisma.viral_posts.upsert({
     *   create: {
     *     // ... data to create a Viral_posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viral_posts we want to update
     *   }
     * })
     */
    upsert<T extends viral_postsUpsertArgs>(args: SelectSubset<T, viral_postsUpsertArgs<ExtArgs>>): Prisma__viral_postsClient<$Result.GetResult<Prisma.$viral_postsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viral_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_postsCountArgs} args - Arguments to filter Viral_posts to count.
     * @example
     * // Count the number of Viral_posts
     * const count = await prisma.viral_posts.count({
     *   where: {
     *     // ... the filter for the Viral_posts we want to count
     *   }
     * })
    **/
    count<T extends viral_postsCountArgs>(
      args?: Subset<T, viral_postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Viral_postsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viral_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Viral_postsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Viral_postsAggregateArgs>(args: Subset<T, Viral_postsAggregateArgs>): Prisma.PrismaPromise<GetViral_postsAggregateType<T>>

    /**
     * Group by Viral_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viral_postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viral_postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viral_postsGroupByArgs['orderBy'] }
        : { orderBy?: viral_postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viral_postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViral_postsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viral_posts model
   */
  readonly fields: viral_postsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viral_posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viral_postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viral_post_performance<T extends viral_posts$viral_post_performanceArgs<ExtArgs> = {}>(args?: Subset<T, viral_posts$viral_post_performanceArgs<ExtArgs>>): Prisma__viral_post_performanceClient<$Result.GetResult<Prisma.$viral_post_performancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    viral_opportunities<T extends viral_opportunitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viral_opportunitiesDefaultArgs<ExtArgs>>): Prisma__viral_opportunitiesClient<$Result.GetResult<Prisma.$viral_opportunitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viral_posts model
   */
  interface viral_postsFieldRefs {
    readonly id: FieldRef<"viral_posts", 'String'>
    readonly opportunity_id: FieldRef<"viral_posts", 'String'>
    readonly concept_type: FieldRef<"viral_posts", 'String'>
    readonly content: FieldRef<"viral_posts", 'String'>
    readonly thread_content: FieldRef<"viral_posts", 'Json'>
    readonly visual_guide: FieldRef<"viral_posts", 'String'>
    readonly hashtags: FieldRef<"viral_posts", 'String[]'>
    readonly post_type: FieldRef<"viral_posts", 'String'>
    readonly platform: FieldRef<"viral_posts", 'String'>
    readonly scheduled_at: FieldRef<"viral_posts", 'DateTime'>
    readonly posted_at: FieldRef<"viral_posts", 'DateTime'>
    readonly post_url: FieldRef<"viral_posts", 'String'>
    readonly created_at: FieldRef<"viral_posts", 'DateTime'>
    readonly updated_at: FieldRef<"viral_posts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * viral_posts findUnique
   */
  export type viral_postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * Filter, which viral_posts to fetch.
     */
    where: viral_postsWhereUniqueInput
  }

  /**
   * viral_posts findUniqueOrThrow
   */
  export type viral_postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * Filter, which viral_posts to fetch.
     */
    where: viral_postsWhereUniqueInput
  }

  /**
   * viral_posts findFirst
   */
  export type viral_postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * Filter, which viral_posts to fetch.
     */
    where?: viral_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_posts to fetch.
     */
    orderBy?: viral_postsOrderByWithRelationInput | viral_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_posts.
     */
    cursor?: viral_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_posts.
     */
    distinct?: Viral_postsScalarFieldEnum | Viral_postsScalarFieldEnum[]
  }

  /**
   * viral_posts findFirstOrThrow
   */
  export type viral_postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * Filter, which viral_posts to fetch.
     */
    where?: viral_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_posts to fetch.
     */
    orderBy?: viral_postsOrderByWithRelationInput | viral_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viral_posts.
     */
    cursor?: viral_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viral_posts.
     */
    distinct?: Viral_postsScalarFieldEnum | Viral_postsScalarFieldEnum[]
  }

  /**
   * viral_posts findMany
   */
  export type viral_postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * Filter, which viral_posts to fetch.
     */
    where?: viral_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viral_posts to fetch.
     */
    orderBy?: viral_postsOrderByWithRelationInput | viral_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viral_posts.
     */
    cursor?: viral_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viral_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viral_posts.
     */
    skip?: number
    distinct?: Viral_postsScalarFieldEnum | Viral_postsScalarFieldEnum[]
  }

  /**
   * viral_posts create
   */
  export type viral_postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * The data needed to create a viral_posts.
     */
    data: XOR<viral_postsCreateInput, viral_postsUncheckedCreateInput>
  }

  /**
   * viral_posts createMany
   */
  export type viral_postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viral_posts.
     */
    data: viral_postsCreateManyInput | viral_postsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viral_posts createManyAndReturn
   */
  export type viral_postsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * The data used to create many viral_posts.
     */
    data: viral_postsCreateManyInput | viral_postsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * viral_posts update
   */
  export type viral_postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * The data needed to update a viral_posts.
     */
    data: XOR<viral_postsUpdateInput, viral_postsUncheckedUpdateInput>
    /**
     * Choose, which viral_posts to update.
     */
    where: viral_postsWhereUniqueInput
  }

  /**
   * viral_posts updateMany
   */
  export type viral_postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viral_posts.
     */
    data: XOR<viral_postsUpdateManyMutationInput, viral_postsUncheckedUpdateManyInput>
    /**
     * Filter which viral_posts to update
     */
    where?: viral_postsWhereInput
    /**
     * Limit how many viral_posts to update.
     */
    limit?: number
  }

  /**
   * viral_posts updateManyAndReturn
   */
  export type viral_postsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * The data used to update viral_posts.
     */
    data: XOR<viral_postsUpdateManyMutationInput, viral_postsUncheckedUpdateManyInput>
    /**
     * Filter which viral_posts to update
     */
    where?: viral_postsWhereInput
    /**
     * Limit how many viral_posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * viral_posts upsert
   */
  export type viral_postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * The filter to search for the viral_posts to update in case it exists.
     */
    where: viral_postsWhereUniqueInput
    /**
     * In case the viral_posts found by the `where` argument doesn't exist, create a new viral_posts with this data.
     */
    create: XOR<viral_postsCreateInput, viral_postsUncheckedCreateInput>
    /**
     * In case the viral_posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viral_postsUpdateInput, viral_postsUncheckedUpdateInput>
  }

  /**
   * viral_posts delete
   */
  export type viral_postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
    /**
     * Filter which viral_posts to delete.
     */
    where: viral_postsWhereUniqueInput
  }

  /**
   * viral_posts deleteMany
   */
  export type viral_postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viral_posts to delete
     */
    where?: viral_postsWhereInput
    /**
     * Limit how many viral_posts to delete.
     */
    limit?: number
  }

  /**
   * viral_posts.viral_post_performance
   */
  export type viral_posts$viral_post_performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_post_performance
     */
    select?: viral_post_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_post_performance
     */
    omit?: viral_post_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_post_performanceInclude<ExtArgs> | null
    where?: viral_post_performanceWhereInput
  }

  /**
   * viral_posts without action
   */
  export type viral_postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viral_posts
     */
    select?: viral_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the viral_posts
     */
    omit?: viral_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viral_postsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BuzzPostScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    content: 'content',
    authorUsername: 'authorUsername',
    authorId: 'authorId',
    likesCount: 'likesCount',
    retweetsCount: 'retweetsCount',
    repliesCount: 'repliesCount',
    impressionsCount: 'impressionsCount',
    postedAt: 'postedAt',
    collectedAt: 'collectedAt',
    url: 'url',
    theme: 'theme',
    language: 'language',
    mediaUrls: 'mediaUrls',
    hashtags: 'hashtags',
    chromaId: 'chromaId',
    authorFollowers: 'authorFollowers',
    authorFollowing: 'authorFollowing',
    authorVerified: 'authorVerified'
  };

  export type BuzzPostScalarFieldEnum = (typeof BuzzPostScalarFieldEnum)[keyof typeof BuzzPostScalarFieldEnum]


  export const BuzzConfigScalarFieldEnum: {
    id: 'id',
    keywords: 'keywords',
    accounts: 'accounts',
    minEngagement: 'minEngagement',
    minImpressions: 'minImpressions',
    collectInterval: 'collectInterval',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuzzConfigScalarFieldEnum = (typeof BuzzConfigScalarFieldEnum)[keyof typeof BuzzConfigScalarFieldEnum]


  export const ScheduledPostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    scheduledTime: 'scheduledTime',
    status: 'status',
    postType: 'postType',
    refPostId: 'refPostId',
    templateType: 'templateType',
    aiGenerated: 'aiGenerated',
    aiPrompt: 'aiPrompt',
    editedContent: 'editedContent',
    postedAt: 'postedAt',
    postResult: 'postResult',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledPostScalarFieldEnum = (typeof ScheduledPostScalarFieldEnum)[keyof typeof ScheduledPostScalarFieldEnum]


  export const PostAnalyticsScalarFieldEnum: {
    id: 'id',
    scheduled_post_id: 'scheduled_post_id',
    impressions: 'impressions',
    likes: 'likes',
    retweets: 'retweets',
    replies: 'replies',
    profileClicks: 'profileClicks',
    link_clicks: 'link_clicks',
    measured_at: 'measured_at',
    engagementRate: 'engagementRate',
    ai_analysis: 'ai_analysis'
  };

  export type PostAnalyticsScalarFieldEnum = (typeof PostAnalyticsScalarFieldEnum)[keyof typeof PostAnalyticsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    twitterId: 'twitterId',
    username: 'username',
    name: 'name',
    email: 'email',
    image: 'image',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenSecret: 'tokenSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    created_at: 'created_at'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NewsSourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    type: 'type',
    category: 'category',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type NewsSourceScalarFieldEnum = (typeof NewsSourceScalarFieldEnum)[keyof typeof NewsSourceScalarFieldEnum]


  export const NewsArticleScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    title: 'title',
    summary: 'summary',
    content: 'content',
    url: 'url',
    publishedAt: 'publishedAt',
    category: 'category',
    importance: 'importance',
    processed: 'processed',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type NewsArticleScalarFieldEnum = (typeof NewsArticleScalarFieldEnum)[keyof typeof NewsArticleScalarFieldEnum]


  export const NewsThreadScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    metadata: 'metadata',
    scheduledAt: 'scheduledAt',
    title: 'title',
    postedAt: 'postedAt'
  };

  export type NewsThreadScalarFieldEnum = (typeof NewsThreadScalarFieldEnum)[keyof typeof NewsThreadScalarFieldEnum]


  export const NewsThreadItemScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    articleId: 'articleId',
    tweet_id: 'tweet_id',
    parent_tweet_id: 'parent_tweet_id',
    posted_at: 'posted_at',
    content: 'content',
    metadata: 'metadata',
    position: 'position'
  };

  export type NewsThreadItemScalarFieldEnum = (typeof NewsThreadItemScalarFieldEnum)[keyof typeof NewsThreadItemScalarFieldEnum]


  export const NewsAnalysisScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    category: 'category',
    summary: 'summary',
    japanese_summary: 'japanese_summary',
    key_points: 'key_points',
    impact: 'impact',
    analyzed_by: 'analyzed_by',
    createdAt: 'createdAt',
    updated_at: 'updated_at'
  };

  export type NewsAnalysisScalarFieldEnum = (typeof NewsAnalysisScalarFieldEnum)[keyof typeof NewsAnalysisScalarFieldEnum]


  export const JobQueueScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    payload: 'payload',
    result: 'result',
    error: 'error',
    progress: 'progress',
    total: 'total',
    started_at: 'started_at',
    ended_at: 'ended_at',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobQueueScalarFieldEnum = (typeof JobQueueScalarFieldEnum)[keyof typeof JobQueueScalarFieldEnum]


  export const ApiTaskScalarFieldEnum: {
    id: 'id',
    type: 'type',
    sessionId: 'sessionId',
    phase_number: 'phase_number',
    step_name: 'step_name',
    request: 'request',
    status: 'status',
    retry_count: 'retry_count',
    response: 'response',
    error: 'error',
    createdAt: 'createdAt',
    started_at: 'started_at',
    completed_at: 'completed_at',
    taskType: 'taskType'
  };

  export type ApiTaskScalarFieldEnum = (typeof ApiTaskScalarFieldEnum)[keyof typeof ApiTaskScalarFieldEnum]


  export const CollectionPresetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    query: 'query',
    keywords: 'keywords',
    minLikes: 'minLikes',
    minRetweets: 'minRetweets',
    language: 'language',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionPresetScalarFieldEnum = (typeof CollectionPresetScalarFieldEnum)[keyof typeof CollectionPresetScalarFieldEnum]


  export const WatchlistUserScalarFieldEnum: {
    id: 'id',
    twitterId: 'twitterId',
    username: 'username',
    displayName: 'displayName',
    profile_image: 'profile_image',
    bio: 'bio',
    followers_count: 'followers_count',
    category: 'category',
    notes: 'notes',
    priority: 'priority',
    is_following: 'is_following',
    added_at: 'added_at',
    lastChecked: 'lastChecked',
    userId: 'userId'
  };

  export type WatchlistUserScalarFieldEnum = (typeof WatchlistUserScalarFieldEnum)[keyof typeof WatchlistUserScalarFieldEnum]


  export const WatchlistTweetScalarFieldEnum: {
    id: 'id',
    tweetId: 'tweetId',
    watchlistUserId: 'watchlistUserId',
    content: 'content',
    likes_count: 'likes_count',
    retweets_count: 'retweets_count',
    replies_count: 'replies_count',
    impressions_count: 'impressions_count',
    has_replied: 'has_replied',
    has_quoted: 'has_quoted',
    posted_at: 'posted_at',
    collectedAt: 'collectedAt',
    url: 'url',
    media_urls: 'media_urls'
  };

  export type WatchlistTweetScalarFieldEnum = (typeof WatchlistTweetScalarFieldEnum)[keyof typeof WatchlistTweetScalarFieldEnum]


  export const InteractionHistoryScalarFieldEnum: {
    id: 'id',
    type: 'type',
    source_tweet_id: 'source_tweet_id',
    target_tweet_id: 'target_tweet_id',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type InteractionHistoryScalarFieldEnum = (typeof InteractionHistoryScalarFieldEnum)[keyof typeof InteractionHistoryScalarFieldEnum]


  export const PerplexityReportScalarFieldEnum: {
    id: 'id',
    query: 'query',
    focus: 'focus',
    rawAnalysis: 'rawAnalysis',
    trends: 'trends',
    insights: 'insights',
    personal_angles: 'personal_angles',
    buzz_prediction: 'buzz_prediction',
    recommendations: 'recommendations',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type PerplexityReportScalarFieldEnum = (typeof PerplexityReportScalarFieldEnum)[keyof typeof PerplexityReportScalarFieldEnum]


  export const CotSessionScalarFieldEnum: {
    id: 'id',
    theme: 'theme',
    style: 'style',
    platform: 'platform',
    status: 'status',
    currentPhase: 'currentPhase',
    currentStep: 'currentStep',
    lastError: 'lastError',
    retryCount: 'retryCount',
    nextRetryAt: 'nextRetryAt',
    totalTokens: 'totalTokens',
    totalDuration: 'totalDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    metadata: 'metadata'
  };

  export type CotSessionScalarFieldEnum = (typeof CotSessionScalarFieldEnum)[keyof typeof CotSessionScalarFieldEnum]


  export const CotPhaseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    phaseNumber: 'phaseNumber',
    thinkPrompt: 'thinkPrompt',
    thinkResult: 'thinkResult',
    thinkTokens: 'thinkTokens',
    thinkAt: 'thinkAt',
    executeResult: 'executeResult',
    executeDuration: 'executeDuration',
    executeAt: 'executeAt',
    integratePrompt: 'integratePrompt',
    integrateResult: 'integrateResult',
    integrateTokens: 'integrateTokens',
    integrateAt: 'integrateAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CotPhaseScalarFieldEnum = (typeof CotPhaseScalarFieldEnum)[keyof typeof CotPhaseScalarFieldEnum]


  export const CotDraftScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    conceptNumber: 'conceptNumber',
    title: 'title',
    hook: 'hook',
    angle: 'angle',
    format: 'format',
    content: 'content',
    thread_content: 'thread_content',
    visualGuide: 'visualGuide',
    timing: 'timing',
    hashtags: 'hashtags',
    newsSource: 'newsSource',
    sourceUrl: 'sourceUrl',
    kpis: 'kpis',
    riskAssessment: 'riskAssessment',
    optimizationTips: 'optimizationTips',
    status: 'status',
    editedContent: 'editedContent',
    scheduledAt: 'scheduledAt',
    postedAt: 'postedAt',
    postId: 'postId',
    viralScore: 'viralScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CotDraftScalarFieldEnum = (typeof CotDraftScalarFieldEnum)[keyof typeof CotDraftScalarFieldEnum]


  export const CotDraftPerformanceScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    likes30m: 'likes30m',
    retweets30m: 'retweets30m',
    replies30m: 'replies30m',
    impressions30m: 'impressions30m',
    likes1h: 'likes1h',
    retweets1h: 'retweets1h',
    replies1h: 'replies1h',
    impressions1h: 'impressions1h',
    likes24h: 'likes24h',
    retweets24h: 'retweets24h',
    replies24h: 'replies24h',
    impressions24h: 'impressions24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    lastUpdateAt: 'lastUpdateAt'
  };

  export type CotDraftPerformanceScalarFieldEnum = (typeof CotDraftPerformanceScalarFieldEnum)[keyof typeof CotDraftPerformanceScalarFieldEnum]


  export const ScheduledRetweetScalarFieldEnum: {
    id: 'id',
    originalPostId: 'originalPostId',
    originalContent: 'originalContent',
    scheduledAt: 'scheduledAt',
    status: 'status',
    rtStrategy: 'rtStrategy',
    addComment: 'addComment',
    commentText: 'commentText',
    viralDraftId: 'viralDraftId',
    cotDraftId: 'cotDraftId',
    executedAt: 'executedAt',
    rtPostId: 'rtPostId',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledRetweetScalarFieldEnum = (typeof ScheduledRetweetScalarFieldEnum)[keyof typeof ScheduledRetweetScalarFieldEnum]


  export const UnifiedPerformanceScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    contentType: 'contentType',
    metrics30m: 'metrics30m',
    metrics1h: 'metrics1h',
    metrics24h: 'metrics24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    updatedAt: 'updatedAt'
  };

  export type UnifiedPerformanceScalarFieldEnum = (typeof UnifiedPerformanceScalarFieldEnum)[keyof typeof UnifiedPerformanceScalarFieldEnum]


  export const NewsViralRelationScalarFieldEnum: {
    id: 'id',
    newsId: 'newsId',
    sessionId: 'sessionId',
    relevanceScore: 'relevanceScore',
    usedInContent: 'usedInContent',
    createdAt: 'createdAt'
  };

  export type NewsViralRelationScalarFieldEnum = (typeof NewsViralRelationScalarFieldEnum)[keyof typeof NewsViralRelationScalarFieldEnum]


  export const SessionActivityLogScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    sessionType: 'sessionType',
    activityType: 'activityType',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type SessionActivityLogScalarFieldEnum = (typeof SessionActivityLogScalarFieldEnum)[keyof typeof SessionActivityLogScalarFieldEnum]


  export const ApiErrorLogScalarFieldEnum: {
    id: 'id',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    errorMessage: 'errorMessage',
    stackTrace: 'stackTrace',
    requestBody: 'requestBody',
    requestHeaders: 'requestHeaders',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type ApiErrorLogScalarFieldEnum = (typeof ApiErrorLogScalarFieldEnum)[keyof typeof ApiErrorLogScalarFieldEnum]


  export const ViralSessionScalarFieldEnum: {
    id: 'id',
    theme: 'theme',
    platform: 'platform',
    style: 'style',
    status: 'status',
    createdAt: 'createdAt',
    topics: 'topics',
    concepts: 'concepts',
    selectedIds: 'selectedIds',
    contents: 'contents',
    characterProfileId: 'characterProfileId',
    voiceStyleMode: 'voiceStyleMode'
  };

  export type ViralSessionScalarFieldEnum = (typeof ViralSessionScalarFieldEnum)[keyof typeof ViralSessionScalarFieldEnum]


  export const ViralDraftV2ScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    conceptId: 'conceptId',
    title: 'title',
    content: 'content',
    hashtags: 'hashtags',
    visualNote: 'visualNote',
    status: 'status',
    scheduledAt: 'scheduledAt',
    postedAt: 'postedAt',
    tweetId: 'tweetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    characterId: 'characterId',
    characterNote: 'characterNote',
    sourceUrl: 'sourceUrl',
    news_article_id: 'news_article_id'
  };

  export type ViralDraftV2ScalarFieldEnum = (typeof ViralDraftV2ScalarFieldEnum)[keyof typeof ViralDraftV2ScalarFieldEnum]


  export const ViralDraftPerformanceScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    likes30m: 'likes30m',
    retweets30m: 'retweets30m',
    replies30m: 'replies30m',
    impressions30m: 'impressions30m',
    likes1h: 'likes1h',
    retweets1h: 'retweets1h',
    replies1h: 'replies1h',
    impressions1h: 'impressions1h',
    likes24h: 'likes24h',
    retweets24h: 'retweets24h',
    replies24h: 'replies24h',
    impressions24h: 'impressions24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    updatedAt: 'updatedAt'
  };

  export type ViralDraftPerformanceScalarFieldEnum = (typeof ViralDraftPerformanceScalarFieldEnum)[keyof typeof ViralDraftPerformanceScalarFieldEnum]


  export const CharacterProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    display_name: 'display_name',
    age: 'age',
    gender: 'gender',
    occupation: 'occupation',
    catchphrase: 'catchphrase',
    personality: 'personality',
    speaking_style: 'speaking_style',
    expertise: 'expertise',
    backstory: 'backstory',
    philosophy: 'philosophy',
    tone: 'tone',
    voiceStyle: 'voiceStyle',
    emoji_style: 'emoji_style',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    preferredNewsCategories: 'preferredNewsCategories',
    newsCommentStyle: 'newsCommentStyle',
    topicExpertise: 'topicExpertise'
  };

  export type CharacterProfileScalarFieldEnum = (typeof CharacterProfileScalarFieldEnum)[keyof typeof CharacterProfileScalarFieldEnum]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    provider: 'provider',
    provider_account_id: 'provider_account_id',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const Ai_patternsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    prompt_template: 'prompt_template',
    example_output: 'example_output',
    success_rate: 'success_rate',
    usage_count: 'usage_count',
    created_at: 'created_at'
  };

  export type Ai_patternsScalarFieldEnum = (typeof Ai_patternsScalarFieldEnum)[keyof typeof Ai_patternsScalarFieldEnum]


  export const Content_draftsScalarFieldEnum: {
    id: 'id',
    analysis_id: 'analysis_id',
    concept_type: 'concept_type',
    category: 'category',
    title: 'title',
    content: 'content',
    edited_content: 'edited_content',
    explanation: 'explanation',
    buzz_factors: 'buzz_factors',
    target_audience: 'target_audience',
    estimated_engagement: 'estimated_engagement',
    hashtags: 'hashtags',
    visual_guide: 'visual_guide',
    platform: 'platform',
    format: 'format',
    status: 'status',
    editor_notes: 'editor_notes',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Content_draftsScalarFieldEnum = (typeof Content_draftsScalarFieldEnum)[keyof typeof Content_draftsScalarFieldEnum]


  export const Gpt_analysesScalarFieldEnum: {
    id: 'id',
    analysis_type: 'analysis_type',
    prompt: 'prompt',
    response: 'response',
    tokens: 'tokens',
    duration: 'duration',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Gpt_analysesScalarFieldEnum = (typeof Gpt_analysesScalarFieldEnum)[keyof typeof Gpt_analysesScalarFieldEnum]


  export const News_analysis_jobsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    started_at: 'started_at',
    completed_at: 'completed_at',
    error: 'error',
    result: 'result',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type News_analysis_jobsScalarFieldEnum = (typeof News_analysis_jobsScalarFieldEnum)[keyof typeof News_analysis_jobsScalarFieldEnum]


  export const News_analysis_resultsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    article_id: 'article_id',
    importance_score: 'importance_score',
    category: 'category',
    summary_ja: 'summary_ja',
    key_points: 'key_points',
    impact_assessment: 'impact_assessment',
    expert_perspective: 'expert_perspective',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type News_analysis_resultsScalarFieldEnum = (typeof News_analysis_resultsScalarFieldEnum)[keyof typeof News_analysis_resultsScalarFieldEnum]


  export const Prompt_templatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    template: 'template',
    variables: 'variables',
    is_active: 'is_active',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Prompt_templatesScalarFieldEnum = (typeof Prompt_templatesScalarFieldEnum)[keyof typeof Prompt_templatesScalarFieldEnum]


  export const Viral_analysis_logsScalarFieldEnum: {
    id: 'id',
    model: 'model',
    phase: 'phase',
    prompt: 'prompt',
    response: 'response',
    tokens: 'tokens',
    duration: 'duration',
    success: 'success',
    error: 'error',
    created_at: 'created_at'
  };

  export type Viral_analysis_logsScalarFieldEnum = (typeof Viral_analysis_logsScalarFieldEnum)[keyof typeof Viral_analysis_logsScalarFieldEnum]


  export const Viral_configScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Viral_configScalarFieldEnum = (typeof Viral_configScalarFieldEnum)[keyof typeof Viral_configScalarFieldEnum]


  export const Viral_opportunitiesScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    platform: 'platform',
    viral_score: 'viral_score',
    time_window: 'time_window',
    angle: 'angle',
    keywords: 'keywords',
    source_data: 'source_data',
    status: 'status',
    analyzed_at: 'analyzed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Viral_opportunitiesScalarFieldEnum = (typeof Viral_opportunitiesScalarFieldEnum)[keyof typeof Viral_opportunitiesScalarFieldEnum]


  export const Viral_post_performanceScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    impressions_30m: 'impressions_30m',
    likes_30m: 'likes_30m',
    retweets_30m: 'retweets_30m',
    comments_30m: 'comments_30m',
    impressions_1h: 'impressions_1h',
    likes_1h: 'likes_1h',
    retweets_1h: 'retweets_1h',
    comments_1h: 'comments_1h',
    impressions_24h: 'impressions_24h',
    likes_24h: 'likes_24h',
    retweets_24h: 'retweets_24h',
    comments_24h: 'comments_24h',
    followers_24h: 'followers_24h',
    engagement_rate: 'engagement_rate',
    viral_coefficient: 'viral_coefficient',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Viral_post_performanceScalarFieldEnum = (typeof Viral_post_performanceScalarFieldEnum)[keyof typeof Viral_post_performanceScalarFieldEnum]


  export const Viral_postsScalarFieldEnum: {
    id: 'id',
    opportunity_id: 'opportunity_id',
    concept_type: 'concept_type',
    content: 'content',
    thread_content: 'thread_content',
    visual_guide: 'visual_guide',
    hashtags: 'hashtags',
    post_type: 'post_type',
    platform: 'platform',
    scheduled_at: 'scheduled_at',
    posted_at: 'posted_at',
    post_url: 'post_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Viral_postsScalarFieldEnum = (typeof Viral_postsScalarFieldEnum)[keyof typeof Viral_postsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CotSessionStatus'
   */
  export type EnumCotSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotSessionStatus'>
    


  /**
   * Reference to a field of type 'CotSessionStatus[]'
   */
  export type ListEnumCotSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotSessionStatus[]'>
    


  /**
   * Reference to a field of type 'CotPhaseStep'
   */
  export type EnumCotPhaseStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStep'>
    


  /**
   * Reference to a field of type 'CotPhaseStep[]'
   */
  export type ListEnumCotPhaseStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStep[]'>
    


  /**
   * Reference to a field of type 'CotPhaseStatus'
   */
  export type EnumCotPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStatus'>
    


  /**
   * Reference to a field of type 'CotPhaseStatus[]'
   */
  export type ListEnumCotPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStatus[]'>
    


  /**
   * Reference to a field of type 'CotDraftStatus'
   */
  export type EnumCotDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotDraftStatus'>
    


  /**
   * Reference to a field of type 'CotDraftStatus[]'
   */
  export type ListEnumCotDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotDraftStatus[]'>
    


  /**
   * Reference to a field of type 'RTStatus'
   */
  export type EnumRTStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RTStatus'>
    


  /**
   * Reference to a field of type 'RTStatus[]'
   */
  export type ListEnumRTStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RTStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    
  /**
   * Deep Input Types
   */


  export type BuzzPostWhereInput = {
    AND?: BuzzPostWhereInput | BuzzPostWhereInput[]
    OR?: BuzzPostWhereInput[]
    NOT?: BuzzPostWhereInput | BuzzPostWhereInput[]
    id?: StringFilter<"BuzzPost"> | string
    postId?: StringFilter<"BuzzPost"> | string
    content?: StringFilter<"BuzzPost"> | string
    authorUsername?: StringFilter<"BuzzPost"> | string
    authorId?: StringFilter<"BuzzPost"> | string
    likesCount?: IntFilter<"BuzzPost"> | number
    retweetsCount?: IntFilter<"BuzzPost"> | number
    repliesCount?: IntFilter<"BuzzPost"> | number
    impressionsCount?: IntFilter<"BuzzPost"> | number
    postedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    url?: StringFilter<"BuzzPost"> | string
    theme?: StringFilter<"BuzzPost"> | string
    language?: StringFilter<"BuzzPost"> | string
    mediaUrls?: JsonFilter<"BuzzPost">
    hashtags?: JsonFilter<"BuzzPost">
    chromaId?: StringNullableFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableFilter<"BuzzPost"> | boolean | null
    scheduledPosts?: ScheduledPostListRelationFilter
  }

  export type BuzzPostOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrderInput | SortOrder
    authorFollowers?: SortOrderInput | SortOrder
    authorFollowing?: SortOrderInput | SortOrder
    authorVerified?: SortOrderInput | SortOrder
    scheduledPosts?: ScheduledPostOrderByRelationAggregateInput
  }

  export type BuzzPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId?: string
    AND?: BuzzPostWhereInput | BuzzPostWhereInput[]
    OR?: BuzzPostWhereInput[]
    NOT?: BuzzPostWhereInput | BuzzPostWhereInput[]
    content?: StringFilter<"BuzzPost"> | string
    authorUsername?: StringFilter<"BuzzPost"> | string
    authorId?: StringFilter<"BuzzPost"> | string
    likesCount?: IntFilter<"BuzzPost"> | number
    retweetsCount?: IntFilter<"BuzzPost"> | number
    repliesCount?: IntFilter<"BuzzPost"> | number
    impressionsCount?: IntFilter<"BuzzPost"> | number
    postedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    url?: StringFilter<"BuzzPost"> | string
    theme?: StringFilter<"BuzzPost"> | string
    language?: StringFilter<"BuzzPost"> | string
    mediaUrls?: JsonFilter<"BuzzPost">
    hashtags?: JsonFilter<"BuzzPost">
    chromaId?: StringNullableFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableFilter<"BuzzPost"> | boolean | null
    scheduledPosts?: ScheduledPostListRelationFilter
  }, "id" | "postId">

  export type BuzzPostOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrderInput | SortOrder
    authorFollowers?: SortOrderInput | SortOrder
    authorFollowing?: SortOrderInput | SortOrder
    authorVerified?: SortOrderInput | SortOrder
    _count?: BuzzPostCountOrderByAggregateInput
    _avg?: BuzzPostAvgOrderByAggregateInput
    _max?: BuzzPostMaxOrderByAggregateInput
    _min?: BuzzPostMinOrderByAggregateInput
    _sum?: BuzzPostSumOrderByAggregateInput
  }

  export type BuzzPostScalarWhereWithAggregatesInput = {
    AND?: BuzzPostScalarWhereWithAggregatesInput | BuzzPostScalarWhereWithAggregatesInput[]
    OR?: BuzzPostScalarWhereWithAggregatesInput[]
    NOT?: BuzzPostScalarWhereWithAggregatesInput | BuzzPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuzzPost"> | string
    postId?: StringWithAggregatesFilter<"BuzzPost"> | string
    content?: StringWithAggregatesFilter<"BuzzPost"> | string
    authorUsername?: StringWithAggregatesFilter<"BuzzPost"> | string
    authorId?: StringWithAggregatesFilter<"BuzzPost"> | string
    likesCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    retweetsCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    repliesCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    impressionsCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    postedAt?: DateTimeWithAggregatesFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeWithAggregatesFilter<"BuzzPost"> | Date | string
    url?: StringWithAggregatesFilter<"BuzzPost"> | string
    theme?: StringWithAggregatesFilter<"BuzzPost"> | string
    language?: StringWithAggregatesFilter<"BuzzPost"> | string
    mediaUrls?: JsonWithAggregatesFilter<"BuzzPost">
    hashtags?: JsonWithAggregatesFilter<"BuzzPost">
    chromaId?: StringNullableWithAggregatesFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableWithAggregatesFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableWithAggregatesFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableWithAggregatesFilter<"BuzzPost"> | boolean | null
  }

  export type BuzzConfigWhereInput = {
    AND?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    OR?: BuzzConfigWhereInput[]
    NOT?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    id?: StringFilter<"BuzzConfig"> | string
    keywords?: StringNullableListFilter<"BuzzConfig">
    accounts?: StringNullableListFilter<"BuzzConfig">
    minEngagement?: IntFilter<"BuzzConfig"> | number
    minImpressions?: IntFilter<"BuzzConfig"> | number
    collectInterval?: IntFilter<"BuzzConfig"> | number
    enabled?: BoolFilter<"BuzzConfig"> | boolean
    createdAt?: DateTimeFilter<"BuzzConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BuzzConfig"> | Date | string
  }

  export type BuzzConfigOrderByWithRelationInput = {
    id?: SortOrder
    keywords?: SortOrder
    accounts?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    OR?: BuzzConfigWhereInput[]
    NOT?: BuzzConfigWhereInput | BuzzConfigWhereInput[]
    keywords?: StringNullableListFilter<"BuzzConfig">
    accounts?: StringNullableListFilter<"BuzzConfig">
    minEngagement?: IntFilter<"BuzzConfig"> | number
    minImpressions?: IntFilter<"BuzzConfig"> | number
    collectInterval?: IntFilter<"BuzzConfig"> | number
    enabled?: BoolFilter<"BuzzConfig"> | boolean
    createdAt?: DateTimeFilter<"BuzzConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BuzzConfig"> | Date | string
  }, "id">

  export type BuzzConfigOrderByWithAggregationInput = {
    id?: SortOrder
    keywords?: SortOrder
    accounts?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuzzConfigCountOrderByAggregateInput
    _avg?: BuzzConfigAvgOrderByAggregateInput
    _max?: BuzzConfigMaxOrderByAggregateInput
    _min?: BuzzConfigMinOrderByAggregateInput
    _sum?: BuzzConfigSumOrderByAggregateInput
  }

  export type BuzzConfigScalarWhereWithAggregatesInput = {
    AND?: BuzzConfigScalarWhereWithAggregatesInput | BuzzConfigScalarWhereWithAggregatesInput[]
    OR?: BuzzConfigScalarWhereWithAggregatesInput[]
    NOT?: BuzzConfigScalarWhereWithAggregatesInput | BuzzConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuzzConfig"> | string
    keywords?: StringNullableListFilter<"BuzzConfig">
    accounts?: StringNullableListFilter<"BuzzConfig">
    minEngagement?: IntWithAggregatesFilter<"BuzzConfig"> | number
    minImpressions?: IntWithAggregatesFilter<"BuzzConfig"> | number
    collectInterval?: IntWithAggregatesFilter<"BuzzConfig"> | number
    enabled?: BoolWithAggregatesFilter<"BuzzConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BuzzConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuzzConfig"> | Date | string
  }

  export type ScheduledPostWhereInput = {
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    post_analytics?: PostAnalyticsListRelationFilter
    refPost?: XOR<BuzzPostNullableScalarRelationFilter, BuzzPostWhereInput> | null
  }

  export type ScheduledPostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrderInput | SortOrder
    templateType?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post_analytics?: PostAnalyticsOrderByRelationAggregateInput
    refPost?: BuzzPostOrderByWithRelationInput
  }

  export type ScheduledPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    post_analytics?: PostAnalyticsListRelationFilter
    refPost?: XOR<BuzzPostNullableScalarRelationFilter, BuzzPostWhereInput> | null
  }, "id">

  export type ScheduledPostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrderInput | SortOrder
    templateType?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledPostCountOrderByAggregateInput
    _max?: ScheduledPostMaxOrderByAggregateInput
    _min?: ScheduledPostMinOrderByAggregateInput
  }

  export type ScheduledPostScalarWhereWithAggregatesInput = {
    AND?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    OR?: ScheduledPostScalarWhereWithAggregatesInput[]
    NOT?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledPost"> | string
    content?: StringWithAggregatesFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusWithAggregatesFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeWithAggregatesFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolWithAggregatesFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableWithAggregatesFilter<"ScheduledPost">
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
  }

  export type PostAnalyticsWhereInput = {
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    id?: StringFilter<"PostAnalytics"> | string
    scheduled_post_id?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    link_clicks?: IntFilter<"PostAnalytics"> | number
    measured_at?: DateTimeFilter<"PostAnalytics"> | Date | string
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    ai_analysis?: StringNullableFilter<"PostAnalytics"> | string | null
    scheduled_posts?: XOR<ScheduledPostScalarRelationFilter, ScheduledPostWhereInput>
  }

  export type PostAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    scheduled_post_id?: SortOrder
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    measured_at?: SortOrder
    engagementRate?: SortOrder
    ai_analysis?: SortOrderInput | SortOrder
    scheduled_posts?: ScheduledPostOrderByWithRelationInput
  }

  export type PostAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    scheduled_post_id?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    link_clicks?: IntFilter<"PostAnalytics"> | number
    measured_at?: DateTimeFilter<"PostAnalytics"> | Date | string
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    ai_analysis?: StringNullableFilter<"PostAnalytics"> | string | null
    scheduled_posts?: XOR<ScheduledPostScalarRelationFilter, ScheduledPostWhereInput>
  }, "id">

  export type PostAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    scheduled_post_id?: SortOrder
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    measured_at?: SortOrder
    engagementRate?: SortOrder
    ai_analysis?: SortOrderInput | SortOrder
    _count?: PostAnalyticsCountOrderByAggregateInput
    _avg?: PostAnalyticsAvgOrderByAggregateInput
    _max?: PostAnalyticsMaxOrderByAggregateInput
    _min?: PostAnalyticsMinOrderByAggregateInput
    _sum?: PostAnalyticsSumOrderByAggregateInput
  }

  export type PostAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PostAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostAnalytics"> | string
    scheduled_post_id?: StringWithAggregatesFilter<"PostAnalytics"> | string
    impressions?: IntWithAggregatesFilter<"PostAnalytics"> | number
    likes?: IntWithAggregatesFilter<"PostAnalytics"> | number
    retweets?: IntWithAggregatesFilter<"PostAnalytics"> | number
    replies?: IntWithAggregatesFilter<"PostAnalytics"> | number
    profileClicks?: IntWithAggregatesFilter<"PostAnalytics"> | number
    link_clicks?: IntWithAggregatesFilter<"PostAnalytics"> | number
    measured_at?: DateTimeWithAggregatesFilter<"PostAnalytics"> | Date | string
    engagementRate?: FloatWithAggregatesFilter<"PostAnalytics"> | number
    ai_analysis?: StringNullableWithAggregatesFilter<"PostAnalytics"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    twitterId?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    accessToken?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    tokenSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountsListRelationFilter
    sessions?: SessionListRelationFilter
    watchlistUsers?: WatchlistUserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    watchlistUsers?: WatchlistUserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    twitterId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    accessToken?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    tokenSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountsListRelationFilter
    sessions?: SessionListRelationFilter
    watchlistUsers?: WatchlistUserListRelationFilter
  }, "id" | "twitterId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    twitterId?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    accessToken?: StringWithAggregatesFilter<"User"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    tokenSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    created_at?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    created_at?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    created_at?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NewsSourceWhereInput = {
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    id?: StringFilter<"NewsSource"> | string
    name?: StringFilter<"NewsSource"> | string
    url?: StringFilter<"NewsSource"> | string
    type?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    active?: BoolFilter<"NewsSource"> | boolean
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    articles?: NewsArticleListRelationFilter
  }

  export type NewsSourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    articles?: NewsArticleOrderByRelationAggregateInput
  }

  export type NewsSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    name?: StringFilter<"NewsSource"> | string
    url?: StringFilter<"NewsSource"> | string
    type?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    active?: BoolFilter<"NewsSource"> | boolean
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    articles?: NewsArticleListRelationFilter
  }, "id">

  export type NewsSourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: NewsSourceCountOrderByAggregateInput
    _max?: NewsSourceMaxOrderByAggregateInput
    _min?: NewsSourceMinOrderByAggregateInput
  }

  export type NewsSourceScalarWhereWithAggregatesInput = {
    AND?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    OR?: NewsSourceScalarWhereWithAggregatesInput[]
    NOT?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsSource"> | string
    name?: StringWithAggregatesFilter<"NewsSource"> | string
    url?: StringWithAggregatesFilter<"NewsSource"> | string
    type?: StringWithAggregatesFilter<"NewsSource"> | string
    category?: StringWithAggregatesFilter<"NewsSource"> | string
    active?: BoolWithAggregatesFilter<"NewsSource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsSource"> | Date | string
  }

  export type NewsArticleWhereInput = {
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    summary?: StringFilter<"NewsArticle"> | string
    content?: StringFilter<"NewsArticle"> | string
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
    analysis?: XOR<NewsAnalysisNullableScalarRelationFilter, NewsAnalysisWhereInput> | null
    news_analysis_results?: News_analysis_resultsListRelationFilter
    source?: XOR<NewsSourceScalarRelationFilter, NewsSourceWhereInput>
    newsThreadItems?: NewsThreadItemListRelationFilter
  }

  export type NewsArticleOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrderInput | SortOrder
    importance?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    analysis?: NewsAnalysisOrderByWithRelationInput
    news_analysis_results?: news_analysis_resultsOrderByRelationAggregateInput
    source?: NewsSourceOrderByWithRelationInput
    newsThreadItems?: NewsThreadItemOrderByRelationAggregateInput
  }

  export type NewsArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    summary?: StringFilter<"NewsArticle"> | string
    content?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
    analysis?: XOR<NewsAnalysisNullableScalarRelationFilter, NewsAnalysisWhereInput> | null
    news_analysis_results?: News_analysis_resultsListRelationFilter
    source?: XOR<NewsSourceScalarRelationFilter, NewsSourceWhereInput>
    newsThreadItems?: NewsThreadItemListRelationFilter
  }, "id" | "url">

  export type NewsArticleOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrderInput | SortOrder
    importance?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NewsArticleCountOrderByAggregateInput
    _avg?: NewsArticleAvgOrderByAggregateInput
    _max?: NewsArticleMaxOrderByAggregateInput
    _min?: NewsArticleMinOrderByAggregateInput
    _sum?: NewsArticleSumOrderByAggregateInput
  }

  export type NewsArticleScalarWhereWithAggregatesInput = {
    AND?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    OR?: NewsArticleScalarWhereWithAggregatesInput[]
    NOT?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsArticle"> | string
    sourceId?: StringWithAggregatesFilter<"NewsArticle"> | string
    title?: StringWithAggregatesFilter<"NewsArticle"> | string
    summary?: StringWithAggregatesFilter<"NewsArticle"> | string
    content?: StringWithAggregatesFilter<"NewsArticle"> | string
    url?: StringWithAggregatesFilter<"NewsArticle"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    category?: StringNullableWithAggregatesFilter<"NewsArticle"> | string | null
    importance?: FloatNullableWithAggregatesFilter<"NewsArticle"> | number | null
    processed?: BoolWithAggregatesFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsArticle">
  }

  export type NewsThreadWhereInput = {
    AND?: NewsThreadWhereInput | NewsThreadWhereInput[]
    OR?: NewsThreadWhereInput[]
    NOT?: NewsThreadWhereInput | NewsThreadWhereInput[]
    id?: StringFilter<"NewsThread"> | string
    status?: StringFilter<"NewsThread"> | string
    createdAt?: DateTimeFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableFilter<"NewsThread">
    scheduledAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    title?: StringFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    items?: NewsThreadItemListRelationFilter
  }

  export type NewsThreadOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    title?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    items?: NewsThreadItemOrderByRelationAggregateInput
  }

  export type NewsThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsThreadWhereInput | NewsThreadWhereInput[]
    OR?: NewsThreadWhereInput[]
    NOT?: NewsThreadWhereInput | NewsThreadWhereInput[]
    status?: StringFilter<"NewsThread"> | string
    createdAt?: DateTimeFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableFilter<"NewsThread">
    scheduledAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    title?: StringFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    items?: NewsThreadItemListRelationFilter
  }, "id">

  export type NewsThreadOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    title?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    _count?: NewsThreadCountOrderByAggregateInput
    _max?: NewsThreadMaxOrderByAggregateInput
    _min?: NewsThreadMinOrderByAggregateInput
  }

  export type NewsThreadScalarWhereWithAggregatesInput = {
    AND?: NewsThreadScalarWhereWithAggregatesInput | NewsThreadScalarWhereWithAggregatesInput[]
    OR?: NewsThreadScalarWhereWithAggregatesInput[]
    NOT?: NewsThreadScalarWhereWithAggregatesInput | NewsThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsThread"> | string
    status?: StringWithAggregatesFilter<"NewsThread"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsThread">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"NewsThread"> | Date | string | null
    title?: StringWithAggregatesFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableWithAggregatesFilter<"NewsThread"> | Date | string | null
  }

  export type NewsThreadItemWhereInput = {
    AND?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    OR?: NewsThreadItemWhereInput[]
    NOT?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    id?: StringFilter<"NewsThreadItem"> | string
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringNullableFilter<"NewsThreadItem"> | string | null
    tweet_id?: StringNullableFilter<"NewsThreadItem"> | string | null
    parent_tweet_id?: StringNullableFilter<"NewsThreadItem"> | string | null
    posted_at?: DateTimeNullableFilter<"NewsThreadItem"> | Date | string | null
    content?: StringFilter<"NewsThreadItem"> | string
    metadata?: JsonNullableFilter<"NewsThreadItem">
    position?: IntFilter<"NewsThreadItem"> | number
    article?: XOR<NewsArticleNullableScalarRelationFilter, NewsArticleWhereInput> | null
    thread?: XOR<NewsThreadScalarRelationFilter, NewsThreadWhereInput>
  }

  export type NewsThreadItemOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrderInput | SortOrder
    tweet_id?: SortOrderInput | SortOrder
    parent_tweet_id?: SortOrderInput | SortOrder
    posted_at?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    position?: SortOrder
    article?: NewsArticleOrderByWithRelationInput
    thread?: NewsThreadOrderByWithRelationInput
  }

  export type NewsThreadItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    OR?: NewsThreadItemWhereInput[]
    NOT?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringNullableFilter<"NewsThreadItem"> | string | null
    tweet_id?: StringNullableFilter<"NewsThreadItem"> | string | null
    parent_tweet_id?: StringNullableFilter<"NewsThreadItem"> | string | null
    posted_at?: DateTimeNullableFilter<"NewsThreadItem"> | Date | string | null
    content?: StringFilter<"NewsThreadItem"> | string
    metadata?: JsonNullableFilter<"NewsThreadItem">
    position?: IntFilter<"NewsThreadItem"> | number
    article?: XOR<NewsArticleNullableScalarRelationFilter, NewsArticleWhereInput> | null
    thread?: XOR<NewsThreadScalarRelationFilter, NewsThreadWhereInput>
  }, "id">

  export type NewsThreadItemOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrderInput | SortOrder
    tweet_id?: SortOrderInput | SortOrder
    parent_tweet_id?: SortOrderInput | SortOrder
    posted_at?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    position?: SortOrder
    _count?: NewsThreadItemCountOrderByAggregateInput
    _avg?: NewsThreadItemAvgOrderByAggregateInput
    _max?: NewsThreadItemMaxOrderByAggregateInput
    _min?: NewsThreadItemMinOrderByAggregateInput
    _sum?: NewsThreadItemSumOrderByAggregateInput
  }

  export type NewsThreadItemScalarWhereWithAggregatesInput = {
    AND?: NewsThreadItemScalarWhereWithAggregatesInput | NewsThreadItemScalarWhereWithAggregatesInput[]
    OR?: NewsThreadItemScalarWhereWithAggregatesInput[]
    NOT?: NewsThreadItemScalarWhereWithAggregatesInput | NewsThreadItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    threadId?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    articleId?: StringNullableWithAggregatesFilter<"NewsThreadItem"> | string | null
    tweet_id?: StringNullableWithAggregatesFilter<"NewsThreadItem"> | string | null
    parent_tweet_id?: StringNullableWithAggregatesFilter<"NewsThreadItem"> | string | null
    posted_at?: DateTimeNullableWithAggregatesFilter<"NewsThreadItem"> | Date | string | null
    content?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsThreadItem">
    position?: IntWithAggregatesFilter<"NewsThreadItem"> | number
  }

  export type NewsAnalysisWhereInput = {
    AND?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    OR?: NewsAnalysisWhereInput[]
    NOT?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    id?: StringFilter<"NewsAnalysis"> | string
    articleId?: StringFilter<"NewsAnalysis"> | string
    category?: StringFilter<"NewsAnalysis"> | string
    summary?: StringFilter<"NewsAnalysis"> | string
    japanese_summary?: StringFilter<"NewsAnalysis"> | string
    key_points?: StringNullableListFilter<"NewsAnalysis">
    impact?: StringFilter<"NewsAnalysis"> | string
    analyzed_by?: StringFilter<"NewsAnalysis"> | string
    createdAt?: DateTimeFilter<"NewsAnalysis"> | Date | string
    updated_at?: DateTimeFilter<"NewsAnalysis"> | Date | string
    article?: XOR<NewsArticleScalarRelationFilter, NewsArticleWhereInput>
  }

  export type NewsAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    japanese_summary?: SortOrder
    key_points?: SortOrder
    impact?: SortOrder
    analyzed_by?: SortOrder
    createdAt?: SortOrder
    updated_at?: SortOrder
    article?: NewsArticleOrderByWithRelationInput
  }

  export type NewsAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    articleId?: string
    AND?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    OR?: NewsAnalysisWhereInput[]
    NOT?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    category?: StringFilter<"NewsAnalysis"> | string
    summary?: StringFilter<"NewsAnalysis"> | string
    japanese_summary?: StringFilter<"NewsAnalysis"> | string
    key_points?: StringNullableListFilter<"NewsAnalysis">
    impact?: StringFilter<"NewsAnalysis"> | string
    analyzed_by?: StringFilter<"NewsAnalysis"> | string
    createdAt?: DateTimeFilter<"NewsAnalysis"> | Date | string
    updated_at?: DateTimeFilter<"NewsAnalysis"> | Date | string
    article?: XOR<NewsArticleScalarRelationFilter, NewsArticleWhereInput>
  }, "id" | "articleId">

  export type NewsAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    japanese_summary?: SortOrder
    key_points?: SortOrder
    impact?: SortOrder
    analyzed_by?: SortOrder
    createdAt?: SortOrder
    updated_at?: SortOrder
    _count?: NewsAnalysisCountOrderByAggregateInput
    _max?: NewsAnalysisMaxOrderByAggregateInput
    _min?: NewsAnalysisMinOrderByAggregateInput
  }

  export type NewsAnalysisScalarWhereWithAggregatesInput = {
    AND?: NewsAnalysisScalarWhereWithAggregatesInput | NewsAnalysisScalarWhereWithAggregatesInput[]
    OR?: NewsAnalysisScalarWhereWithAggregatesInput[]
    NOT?: NewsAnalysisScalarWhereWithAggregatesInput | NewsAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    articleId?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    category?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    summary?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    japanese_summary?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    key_points?: StringNullableListFilter<"NewsAnalysis">
    impact?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    analyzed_by?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsAnalysis"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"NewsAnalysis"> | Date | string
  }

  export type JobQueueWhereInput = {
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    id?: StringFilter<"JobQueue"> | string
    type?: StringFilter<"JobQueue"> | string
    status?: StringFilter<"JobQueue"> | string
    payload?: JsonNullableFilter<"JobQueue">
    result?: JsonNullableFilter<"JobQueue">
    error?: StringNullableFilter<"JobQueue"> | string | null
    progress?: IntFilter<"JobQueue"> | number
    total?: IntNullableFilter<"JobQueue"> | number | null
    started_at?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeFilter<"JobQueue"> | Date | string
  }

  export type JobQueueOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    progress?: SortOrder
    total?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    ended_at?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    type?: StringFilter<"JobQueue"> | string
    status?: StringFilter<"JobQueue"> | string
    payload?: JsonNullableFilter<"JobQueue">
    result?: JsonNullableFilter<"JobQueue">
    error?: StringNullableFilter<"JobQueue"> | string | null
    progress?: IntFilter<"JobQueue"> | number
    total?: IntNullableFilter<"JobQueue"> | number | null
    started_at?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeFilter<"JobQueue"> | Date | string
  }, "id">

  export type JobQueueOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    progress?: SortOrder
    total?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    ended_at?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobQueueCountOrderByAggregateInput
    _avg?: JobQueueAvgOrderByAggregateInput
    _max?: JobQueueMaxOrderByAggregateInput
    _min?: JobQueueMinOrderByAggregateInput
    _sum?: JobQueueSumOrderByAggregateInput
  }

  export type JobQueueScalarWhereWithAggregatesInput = {
    AND?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    OR?: JobQueueScalarWhereWithAggregatesInput[]
    NOT?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobQueue"> | string
    type?: StringWithAggregatesFilter<"JobQueue"> | string
    status?: StringWithAggregatesFilter<"JobQueue"> | string
    payload?: JsonNullableWithAggregatesFilter<"JobQueue">
    result?: JsonNullableWithAggregatesFilter<"JobQueue">
    error?: StringNullableWithAggregatesFilter<"JobQueue"> | string | null
    progress?: IntWithAggregatesFilter<"JobQueue"> | number
    total?: IntNullableWithAggregatesFilter<"JobQueue"> | number | null
    started_at?: DateTimeNullableWithAggregatesFilter<"JobQueue"> | Date | string | null
    ended_at?: DateTimeNullableWithAggregatesFilter<"JobQueue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
  }

  export type ApiTaskWhereInput = {
    AND?: ApiTaskWhereInput | ApiTaskWhereInput[]
    OR?: ApiTaskWhereInput[]
    NOT?: ApiTaskWhereInput | ApiTaskWhereInput[]
    id?: StringFilter<"ApiTask"> | string
    type?: StringFilter<"ApiTask"> | string
    sessionId?: StringFilter<"ApiTask"> | string
    phase_number?: IntFilter<"ApiTask"> | number
    step_name?: StringFilter<"ApiTask"> | string
    request?: JsonFilter<"ApiTask">
    status?: StringFilter<"ApiTask"> | string
    retry_count?: IntFilter<"ApiTask"> | number
    response?: JsonNullableFilter<"ApiTask">
    error?: StringNullableFilter<"ApiTask"> | string | null
    createdAt?: DateTimeFilter<"ApiTask"> | Date | string
    started_at?: DateTimeNullableFilter<"ApiTask"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"ApiTask"> | Date | string | null
    taskType?: StringFilter<"ApiTask"> | string
  }

  export type ApiTaskOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    sessionId?: SortOrder
    phase_number?: SortOrder
    step_name?: SortOrder
    request?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    taskType?: SortOrder
  }

  export type ApiTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiTaskWhereInput | ApiTaskWhereInput[]
    OR?: ApiTaskWhereInput[]
    NOT?: ApiTaskWhereInput | ApiTaskWhereInput[]
    type?: StringFilter<"ApiTask"> | string
    sessionId?: StringFilter<"ApiTask"> | string
    phase_number?: IntFilter<"ApiTask"> | number
    step_name?: StringFilter<"ApiTask"> | string
    request?: JsonFilter<"ApiTask">
    status?: StringFilter<"ApiTask"> | string
    retry_count?: IntFilter<"ApiTask"> | number
    response?: JsonNullableFilter<"ApiTask">
    error?: StringNullableFilter<"ApiTask"> | string | null
    createdAt?: DateTimeFilter<"ApiTask"> | Date | string
    started_at?: DateTimeNullableFilter<"ApiTask"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"ApiTask"> | Date | string | null
    taskType?: StringFilter<"ApiTask"> | string
  }, "id">

  export type ApiTaskOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    sessionId?: SortOrder
    phase_number?: SortOrder
    step_name?: SortOrder
    request?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    taskType?: SortOrder
    _count?: ApiTaskCountOrderByAggregateInput
    _avg?: ApiTaskAvgOrderByAggregateInput
    _max?: ApiTaskMaxOrderByAggregateInput
    _min?: ApiTaskMinOrderByAggregateInput
    _sum?: ApiTaskSumOrderByAggregateInput
  }

  export type ApiTaskScalarWhereWithAggregatesInput = {
    AND?: ApiTaskScalarWhereWithAggregatesInput | ApiTaskScalarWhereWithAggregatesInput[]
    OR?: ApiTaskScalarWhereWithAggregatesInput[]
    NOT?: ApiTaskScalarWhereWithAggregatesInput | ApiTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiTask"> | string
    type?: StringWithAggregatesFilter<"ApiTask"> | string
    sessionId?: StringWithAggregatesFilter<"ApiTask"> | string
    phase_number?: IntWithAggregatesFilter<"ApiTask"> | number
    step_name?: StringWithAggregatesFilter<"ApiTask"> | string
    request?: JsonWithAggregatesFilter<"ApiTask">
    status?: StringWithAggregatesFilter<"ApiTask"> | string
    retry_count?: IntWithAggregatesFilter<"ApiTask"> | number
    response?: JsonNullableWithAggregatesFilter<"ApiTask">
    error?: StringNullableWithAggregatesFilter<"ApiTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiTask"> | Date | string
    started_at?: DateTimeNullableWithAggregatesFilter<"ApiTask"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"ApiTask"> | Date | string | null
    taskType?: StringWithAggregatesFilter<"ApiTask"> | string
  }

  export type CollectionPresetWhereInput = {
    AND?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    OR?: CollectionPresetWhereInput[]
    NOT?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    id?: StringFilter<"CollectionPreset"> | string
    name?: StringFilter<"CollectionPreset"> | string
    description?: StringNullableFilter<"CollectionPreset"> | string | null
    query?: StringFilter<"CollectionPreset"> | string
    keywords?: StringNullableListFilter<"CollectionPreset">
    minLikes?: IntFilter<"CollectionPreset"> | number
    minRetweets?: IntFilter<"CollectionPreset"> | number
    language?: StringFilter<"CollectionPreset"> | string
    category?: StringFilter<"CollectionPreset"> | string
    isActive?: BoolFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionPreset"> | Date | string
  }

  export type CollectionPresetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    query?: SortOrder
    keywords?: SortOrder
    minLikes?: SortOrder
    minRetweets?: SortOrder
    language?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    OR?: CollectionPresetWhereInput[]
    NOT?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    name?: StringFilter<"CollectionPreset"> | string
    description?: StringNullableFilter<"CollectionPreset"> | string | null
    query?: StringFilter<"CollectionPreset"> | string
    keywords?: StringNullableListFilter<"CollectionPreset">
    minLikes?: IntFilter<"CollectionPreset"> | number
    minRetweets?: IntFilter<"CollectionPreset"> | number
    language?: StringFilter<"CollectionPreset"> | string
    category?: StringFilter<"CollectionPreset"> | string
    isActive?: BoolFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionPreset"> | Date | string
  }, "id">

  export type CollectionPresetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    query?: SortOrder
    keywords?: SortOrder
    minLikes?: SortOrder
    minRetweets?: SortOrder
    language?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionPresetCountOrderByAggregateInput
    _avg?: CollectionPresetAvgOrderByAggregateInput
    _max?: CollectionPresetMaxOrderByAggregateInput
    _min?: CollectionPresetMinOrderByAggregateInput
    _sum?: CollectionPresetSumOrderByAggregateInput
  }

  export type CollectionPresetScalarWhereWithAggregatesInput = {
    AND?: CollectionPresetScalarWhereWithAggregatesInput | CollectionPresetScalarWhereWithAggregatesInput[]
    OR?: CollectionPresetScalarWhereWithAggregatesInput[]
    NOT?: CollectionPresetScalarWhereWithAggregatesInput | CollectionPresetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionPreset"> | string
    name?: StringWithAggregatesFilter<"CollectionPreset"> | string
    description?: StringNullableWithAggregatesFilter<"CollectionPreset"> | string | null
    query?: StringWithAggregatesFilter<"CollectionPreset"> | string
    keywords?: StringNullableListFilter<"CollectionPreset">
    minLikes?: IntWithAggregatesFilter<"CollectionPreset"> | number
    minRetweets?: IntWithAggregatesFilter<"CollectionPreset"> | number
    language?: StringWithAggregatesFilter<"CollectionPreset"> | string
    category?: StringWithAggregatesFilter<"CollectionPreset"> | string
    isActive?: BoolWithAggregatesFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionPreset"> | Date | string
  }

  export type WatchlistUserWhereInput = {
    AND?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    OR?: WatchlistUserWhereInput[]
    NOT?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    id?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    profile_image?: StringNullableFilter<"WatchlistUser"> | string | null
    bio?: StringNullableFilter<"WatchlistUser"> | string | null
    followers_count?: IntFilter<"WatchlistUser"> | number
    category?: StringNullableListFilter<"WatchlistUser">
    notes?: StringNullableFilter<"WatchlistUser"> | string | null
    priority?: IntFilter<"WatchlistUser"> | number
    is_following?: BoolFilter<"WatchlistUser"> | boolean
    added_at?: DateTimeFilter<"WatchlistUser"> | Date | string
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    userId?: StringFilter<"WatchlistUser"> | string
    tweets?: WatchlistTweetListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WatchlistUserOrderByWithRelationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    followers_count?: SortOrder
    category?: SortOrder
    notes?: SortOrderInput | SortOrder
    priority?: SortOrder
    is_following?: SortOrder
    added_at?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    userId?: SortOrder
    tweets?: WatchlistTweetOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type WatchlistUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    twitterId?: string
    userId_username?: WatchlistUserUserIdUsernameCompoundUniqueInput
    AND?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    OR?: WatchlistUserWhereInput[]
    NOT?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    profile_image?: StringNullableFilter<"WatchlistUser"> | string | null
    bio?: StringNullableFilter<"WatchlistUser"> | string | null
    followers_count?: IntFilter<"WatchlistUser"> | number
    category?: StringNullableListFilter<"WatchlistUser">
    notes?: StringNullableFilter<"WatchlistUser"> | string | null
    priority?: IntFilter<"WatchlistUser"> | number
    is_following?: BoolFilter<"WatchlistUser"> | boolean
    added_at?: DateTimeFilter<"WatchlistUser"> | Date | string
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    userId?: StringFilter<"WatchlistUser"> | string
    tweets?: WatchlistTweetListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "twitterId" | "userId_username">

  export type WatchlistUserOrderByWithAggregationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    followers_count?: SortOrder
    category?: SortOrder
    notes?: SortOrderInput | SortOrder
    priority?: SortOrder
    is_following?: SortOrder
    added_at?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: WatchlistUserCountOrderByAggregateInput
    _avg?: WatchlistUserAvgOrderByAggregateInput
    _max?: WatchlistUserMaxOrderByAggregateInput
    _min?: WatchlistUserMinOrderByAggregateInput
    _sum?: WatchlistUserSumOrderByAggregateInput
  }

  export type WatchlistUserScalarWhereWithAggregatesInput = {
    AND?: WatchlistUserScalarWhereWithAggregatesInput | WatchlistUserScalarWhereWithAggregatesInput[]
    OR?: WatchlistUserScalarWhereWithAggregatesInput[]
    NOT?: WatchlistUserScalarWhereWithAggregatesInput | WatchlistUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistUser"> | string
    twitterId?: StringWithAggregatesFilter<"WatchlistUser"> | string
    username?: StringWithAggregatesFilter<"WatchlistUser"> | string
    displayName?: StringWithAggregatesFilter<"WatchlistUser"> | string
    profile_image?: StringNullableWithAggregatesFilter<"WatchlistUser"> | string | null
    bio?: StringNullableWithAggregatesFilter<"WatchlistUser"> | string | null
    followers_count?: IntWithAggregatesFilter<"WatchlistUser"> | number
    category?: StringNullableListFilter<"WatchlistUser">
    notes?: StringNullableWithAggregatesFilter<"WatchlistUser"> | string | null
    priority?: IntWithAggregatesFilter<"WatchlistUser"> | number
    is_following?: BoolWithAggregatesFilter<"WatchlistUser"> | boolean
    added_at?: DateTimeWithAggregatesFilter<"WatchlistUser"> | Date | string
    lastChecked?: DateTimeNullableWithAggregatesFilter<"WatchlistUser"> | Date | string | null
    userId?: StringWithAggregatesFilter<"WatchlistUser"> | string
  }

  export type WatchlistTweetWhereInput = {
    AND?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    OR?: WatchlistTweetWhereInput[]
    NOT?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    id?: StringFilter<"WatchlistTweet"> | string
    tweetId?: StringFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    likes_count?: IntFilter<"WatchlistTweet"> | number
    retweets_count?: IntFilter<"WatchlistTweet"> | number
    replies_count?: IntFilter<"WatchlistTweet"> | number
    impressions_count?: IntFilter<"WatchlistTweet"> | number
    has_replied?: BoolFilter<"WatchlistTweet"> | boolean
    has_quoted?: BoolFilter<"WatchlistTweet"> | boolean
    posted_at?: DateTimeFilter<"WatchlistTweet"> | Date | string
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    url?: StringFilter<"WatchlistTweet"> | string
    media_urls?: JsonNullableFilter<"WatchlistTweet">
    watchlistUser?: XOR<WatchlistUserScalarRelationFilter, WatchlistUserWhereInput>
  }

  export type WatchlistTweetOrderByWithRelationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    watchlistUserId?: SortOrder
    content?: SortOrder
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
    has_replied?: SortOrder
    has_quoted?: SortOrder
    posted_at?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    media_urls?: SortOrderInput | SortOrder
    watchlistUser?: WatchlistUserOrderByWithRelationInput
  }

  export type WatchlistTweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tweetId?: string
    AND?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    OR?: WatchlistTweetWhereInput[]
    NOT?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    likes_count?: IntFilter<"WatchlistTweet"> | number
    retweets_count?: IntFilter<"WatchlistTweet"> | number
    replies_count?: IntFilter<"WatchlistTweet"> | number
    impressions_count?: IntFilter<"WatchlistTweet"> | number
    has_replied?: BoolFilter<"WatchlistTweet"> | boolean
    has_quoted?: BoolFilter<"WatchlistTweet"> | boolean
    posted_at?: DateTimeFilter<"WatchlistTweet"> | Date | string
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    url?: StringFilter<"WatchlistTweet"> | string
    media_urls?: JsonNullableFilter<"WatchlistTweet">
    watchlistUser?: XOR<WatchlistUserScalarRelationFilter, WatchlistUserWhereInput>
  }, "id" | "tweetId">

  export type WatchlistTweetOrderByWithAggregationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    watchlistUserId?: SortOrder
    content?: SortOrder
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
    has_replied?: SortOrder
    has_quoted?: SortOrder
    posted_at?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    media_urls?: SortOrderInput | SortOrder
    _count?: WatchlistTweetCountOrderByAggregateInput
    _avg?: WatchlistTweetAvgOrderByAggregateInput
    _max?: WatchlistTweetMaxOrderByAggregateInput
    _min?: WatchlistTweetMinOrderByAggregateInput
    _sum?: WatchlistTweetSumOrderByAggregateInput
  }

  export type WatchlistTweetScalarWhereWithAggregatesInput = {
    AND?: WatchlistTweetScalarWhereWithAggregatesInput | WatchlistTweetScalarWhereWithAggregatesInput[]
    OR?: WatchlistTweetScalarWhereWithAggregatesInput[]
    NOT?: WatchlistTweetScalarWhereWithAggregatesInput | WatchlistTweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    tweetId?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    content?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    likes_count?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    retweets_count?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    replies_count?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    impressions_count?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    has_replied?: BoolWithAggregatesFilter<"WatchlistTweet"> | boolean
    has_quoted?: BoolWithAggregatesFilter<"WatchlistTweet"> | boolean
    posted_at?: DateTimeWithAggregatesFilter<"WatchlistTweet"> | Date | string
    collectedAt?: DateTimeWithAggregatesFilter<"WatchlistTweet"> | Date | string
    url?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    media_urls?: JsonNullableWithAggregatesFilter<"WatchlistTweet">
  }

  export type InteractionHistoryWhereInput = {
    AND?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    OR?: InteractionHistoryWhereInput[]
    NOT?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    id?: StringFilter<"InteractionHistory"> | string
    type?: StringFilter<"InteractionHistory"> | string
    source_tweet_id?: StringFilter<"InteractionHistory"> | string
    target_tweet_id?: StringNullableFilter<"InteractionHistory"> | string | null
    content?: StringNullableFilter<"InteractionHistory"> | string | null
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
  }

  export type InteractionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    source_tweet_id?: SortOrder
    target_tweet_id?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    OR?: InteractionHistoryWhereInput[]
    NOT?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    type?: StringFilter<"InteractionHistory"> | string
    source_tweet_id?: StringFilter<"InteractionHistory"> | string
    target_tweet_id?: StringNullableFilter<"InteractionHistory"> | string | null
    content?: StringNullableFilter<"InteractionHistory"> | string | null
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
  }, "id">

  export type InteractionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    source_tweet_id?: SortOrder
    target_tweet_id?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InteractionHistoryCountOrderByAggregateInput
    _max?: InteractionHistoryMaxOrderByAggregateInput
    _min?: InteractionHistoryMinOrderByAggregateInput
  }

  export type InteractionHistoryScalarWhereWithAggregatesInput = {
    AND?: InteractionHistoryScalarWhereWithAggregatesInput | InteractionHistoryScalarWhereWithAggregatesInput[]
    OR?: InteractionHistoryScalarWhereWithAggregatesInput[]
    NOT?: InteractionHistoryScalarWhereWithAggregatesInput | InteractionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InteractionHistory"> | string
    type?: StringWithAggregatesFilter<"InteractionHistory"> | string
    source_tweet_id?: StringWithAggregatesFilter<"InteractionHistory"> | string
    target_tweet_id?: StringNullableWithAggregatesFilter<"InteractionHistory"> | string | null
    content?: StringNullableWithAggregatesFilter<"InteractionHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InteractionHistory"> | Date | string
  }

  export type PerplexityReportWhereInput = {
    AND?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    OR?: PerplexityReportWhereInput[]
    NOT?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    id?: StringFilter<"PerplexityReport"> | string
    query?: StringFilter<"PerplexityReport"> | string
    focus?: StringFilter<"PerplexityReport"> | string
    rawAnalysis?: StringFilter<"PerplexityReport"> | string
    trends?: JsonFilter<"PerplexityReport">
    insights?: JsonFilter<"PerplexityReport">
    personal_angles?: JsonFilter<"PerplexityReport">
    buzz_prediction?: FloatFilter<"PerplexityReport"> | number
    recommendations?: JsonFilter<"PerplexityReport">
    metadata?: JsonFilter<"PerplexityReport">
    createdAt?: DateTimeFilter<"PerplexityReport"> | Date | string
  }

  export type PerplexityReportOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    personal_angles?: SortOrder
    buzz_prediction?: SortOrder
    recommendations?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    OR?: PerplexityReportWhereInput[]
    NOT?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    query?: StringFilter<"PerplexityReport"> | string
    focus?: StringFilter<"PerplexityReport"> | string
    rawAnalysis?: StringFilter<"PerplexityReport"> | string
    trends?: JsonFilter<"PerplexityReport">
    insights?: JsonFilter<"PerplexityReport">
    personal_angles?: JsonFilter<"PerplexityReport">
    buzz_prediction?: FloatFilter<"PerplexityReport"> | number
    recommendations?: JsonFilter<"PerplexityReport">
    metadata?: JsonFilter<"PerplexityReport">
    createdAt?: DateTimeFilter<"PerplexityReport"> | Date | string
  }, "id">

  export type PerplexityReportOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    personal_angles?: SortOrder
    buzz_prediction?: SortOrder
    recommendations?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: PerplexityReportCountOrderByAggregateInput
    _avg?: PerplexityReportAvgOrderByAggregateInput
    _max?: PerplexityReportMaxOrderByAggregateInput
    _min?: PerplexityReportMinOrderByAggregateInput
    _sum?: PerplexityReportSumOrderByAggregateInput
  }

  export type PerplexityReportScalarWhereWithAggregatesInput = {
    AND?: PerplexityReportScalarWhereWithAggregatesInput | PerplexityReportScalarWhereWithAggregatesInput[]
    OR?: PerplexityReportScalarWhereWithAggregatesInput[]
    NOT?: PerplexityReportScalarWhereWithAggregatesInput | PerplexityReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerplexityReport"> | string
    query?: StringWithAggregatesFilter<"PerplexityReport"> | string
    focus?: StringWithAggregatesFilter<"PerplexityReport"> | string
    rawAnalysis?: StringWithAggregatesFilter<"PerplexityReport"> | string
    trends?: JsonWithAggregatesFilter<"PerplexityReport">
    insights?: JsonWithAggregatesFilter<"PerplexityReport">
    personal_angles?: JsonWithAggregatesFilter<"PerplexityReport">
    buzz_prediction?: FloatWithAggregatesFilter<"PerplexityReport"> | number
    recommendations?: JsonWithAggregatesFilter<"PerplexityReport">
    metadata?: JsonWithAggregatesFilter<"PerplexityReport">
    createdAt?: DateTimeWithAggregatesFilter<"PerplexityReport"> | Date | string
  }

  export type CotSessionWhereInput = {
    AND?: CotSessionWhereInput | CotSessionWhereInput[]
    OR?: CotSessionWhereInput[]
    NOT?: CotSessionWhereInput | CotSessionWhereInput[]
    id?: StringFilter<"CotSession"> | string
    theme?: StringFilter<"CotSession"> | string
    style?: StringFilter<"CotSession"> | string
    platform?: StringFilter<"CotSession"> | string
    status?: EnumCotSessionStatusFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableFilter<"CotSession"> | string | null
    retryCount?: IntFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    totalTokens?: IntFilter<"CotSession"> | number
    totalDuration?: IntFilter<"CotSession"> | number
    createdAt?: DateTimeFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    metadata?: JsonNullableFilter<"CotSession">
    drafts?: CotDraftListRelationFilter
    phases?: CotPhaseListRelationFilter
  }

  export type CotSessionOrderByWithRelationInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    drafts?: CotDraftOrderByRelationAggregateInput
    phases?: CotPhaseOrderByRelationAggregateInput
  }

  export type CotSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CotSessionWhereInput | CotSessionWhereInput[]
    OR?: CotSessionWhereInput[]
    NOT?: CotSessionWhereInput | CotSessionWhereInput[]
    theme?: StringFilter<"CotSession"> | string
    style?: StringFilter<"CotSession"> | string
    platform?: StringFilter<"CotSession"> | string
    status?: EnumCotSessionStatusFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableFilter<"CotSession"> | string | null
    retryCount?: IntFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    totalTokens?: IntFilter<"CotSession"> | number
    totalDuration?: IntFilter<"CotSession"> | number
    createdAt?: DateTimeFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    metadata?: JsonNullableFilter<"CotSession">
    drafts?: CotDraftListRelationFilter
    phases?: CotPhaseListRelationFilter
  }, "id">

  export type CotSessionOrderByWithAggregationInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CotSessionCountOrderByAggregateInput
    _avg?: CotSessionAvgOrderByAggregateInput
    _max?: CotSessionMaxOrderByAggregateInput
    _min?: CotSessionMinOrderByAggregateInput
    _sum?: CotSessionSumOrderByAggregateInput
  }

  export type CotSessionScalarWhereWithAggregatesInput = {
    AND?: CotSessionScalarWhereWithAggregatesInput | CotSessionScalarWhereWithAggregatesInput[]
    OR?: CotSessionScalarWhereWithAggregatesInput[]
    NOT?: CotSessionScalarWhereWithAggregatesInput | CotSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotSession"> | string
    theme?: StringWithAggregatesFilter<"CotSession"> | string
    style?: StringWithAggregatesFilter<"CotSession"> | string
    platform?: StringWithAggregatesFilter<"CotSession"> | string
    status?: EnumCotSessionStatusWithAggregatesFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntWithAggregatesFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepWithAggregatesFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableWithAggregatesFilter<"CotSession"> | string | null
    retryCount?: IntWithAggregatesFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"CotSession"> | Date | string | null
    totalTokens?: IntWithAggregatesFilter<"CotSession"> | number
    totalDuration?: IntWithAggregatesFilter<"CotSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CotSession"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CotSession">
  }

  export type CotPhaseWhereInput = {
    AND?: CotPhaseWhereInput | CotPhaseWhereInput[]
    OR?: CotPhaseWhereInput[]
    NOT?: CotPhaseWhereInput | CotPhaseWhereInput[]
    id?: StringFilter<"CotPhase"> | string
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
    session?: XOR<CotSessionScalarRelationFilter, CotSessionWhereInput>
  }

  export type CotPhaseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrderInput | SortOrder
    thinkResult?: SortOrderInput | SortOrder
    thinkTokens?: SortOrderInput | SortOrder
    thinkAt?: SortOrderInput | SortOrder
    executeResult?: SortOrderInput | SortOrder
    executeDuration?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    integratePrompt?: SortOrderInput | SortOrder
    integrateResult?: SortOrderInput | SortOrder
    integrateTokens?: SortOrderInput | SortOrder
    integrateAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: CotSessionOrderByWithRelationInput
  }

  export type CotPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_phaseNumber?: CotPhaseSessionIdPhaseNumberCompoundUniqueInput
    AND?: CotPhaseWhereInput | CotPhaseWhereInput[]
    OR?: CotPhaseWhereInput[]
    NOT?: CotPhaseWhereInput | CotPhaseWhereInput[]
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
    session?: XOR<CotSessionScalarRelationFilter, CotSessionWhereInput>
  }, "id" | "sessionId_phaseNumber">

  export type CotPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrderInput | SortOrder
    thinkResult?: SortOrderInput | SortOrder
    thinkTokens?: SortOrderInput | SortOrder
    thinkAt?: SortOrderInput | SortOrder
    executeResult?: SortOrderInput | SortOrder
    executeDuration?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    integratePrompt?: SortOrderInput | SortOrder
    integrateResult?: SortOrderInput | SortOrder
    integrateTokens?: SortOrderInput | SortOrder
    integrateAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CotPhaseCountOrderByAggregateInput
    _avg?: CotPhaseAvgOrderByAggregateInput
    _max?: CotPhaseMaxOrderByAggregateInput
    _min?: CotPhaseMinOrderByAggregateInput
    _sum?: CotPhaseSumOrderByAggregateInput
  }

  export type CotPhaseScalarWhereWithAggregatesInput = {
    AND?: CotPhaseScalarWhereWithAggregatesInput | CotPhaseScalarWhereWithAggregatesInput[]
    OR?: CotPhaseScalarWhereWithAggregatesInput[]
    NOT?: CotPhaseScalarWhereWithAggregatesInput | CotPhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotPhase"> | string
    sessionId?: StringWithAggregatesFilter<"CotPhase"> | string
    phaseNumber?: IntWithAggregatesFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableWithAggregatesFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    thinkTokens?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    executeDuration?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableWithAggregatesFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    integrateTokens?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusWithAggregatesFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotPhase"> | Date | string
  }

  export type CotDraftWhereInput = {
    AND?: CotDraftWhereInput | CotDraftWhereInput[]
    OR?: CotDraftWhereInput[]
    NOT?: CotDraftWhereInput | CotDraftWhereInput[]
    id?: StringFilter<"CotDraft"> | string
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    thread_content?: JsonNullableFilter<"CotDraft">
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
    performance?: XOR<CotDraftPerformanceNullableScalarRelationFilter, CotDraftPerformanceWhereInput> | null
    session?: XOR<CotSessionScalarRelationFilter, CotSessionWhereInput>
  }

  export type CotDraftOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    thread_content?: SortOrderInput | SortOrder
    visualGuide?: SortOrderInput | SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    kpis?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    optimizationTips?: SortOrderInput | SortOrder
    status?: SortOrder
    editedContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    performance?: CotDraftPerformanceOrderByWithRelationInput
    session?: CotSessionOrderByWithRelationInput
  }

  export type CotDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_conceptNumber?: CotDraftSessionIdConceptNumberCompoundUniqueInput
    AND?: CotDraftWhereInput | CotDraftWhereInput[]
    OR?: CotDraftWhereInput[]
    NOT?: CotDraftWhereInput | CotDraftWhereInput[]
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    thread_content?: JsonNullableFilter<"CotDraft">
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
    performance?: XOR<CotDraftPerformanceNullableScalarRelationFilter, CotDraftPerformanceWhereInput> | null
    session?: XOR<CotSessionScalarRelationFilter, CotSessionWhereInput>
  }, "id" | "sessionId_conceptNumber">

  export type CotDraftOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    thread_content?: SortOrderInput | SortOrder
    visualGuide?: SortOrderInput | SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    kpis?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    optimizationTips?: SortOrderInput | SortOrder
    status?: SortOrder
    editedContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CotDraftCountOrderByAggregateInput
    _avg?: CotDraftAvgOrderByAggregateInput
    _max?: CotDraftMaxOrderByAggregateInput
    _min?: CotDraftMinOrderByAggregateInput
    _sum?: CotDraftSumOrderByAggregateInput
  }

  export type CotDraftScalarWhereWithAggregatesInput = {
    AND?: CotDraftScalarWhereWithAggregatesInput | CotDraftScalarWhereWithAggregatesInput[]
    OR?: CotDraftScalarWhereWithAggregatesInput[]
    NOT?: CotDraftScalarWhereWithAggregatesInput | CotDraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotDraft"> | string
    sessionId?: StringWithAggregatesFilter<"CotDraft"> | string
    conceptNumber?: IntWithAggregatesFilter<"CotDraft"> | number
    title?: StringWithAggregatesFilter<"CotDraft"> | string
    hook?: StringWithAggregatesFilter<"CotDraft"> | string
    angle?: StringWithAggregatesFilter<"CotDraft"> | string
    format?: StringWithAggregatesFilter<"CotDraft"> | string
    content?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    thread_content?: JsonNullableWithAggregatesFilter<"CotDraft">
    visualGuide?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    timing?: StringWithAggregatesFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    kpis?: JsonNullableWithAggregatesFilter<"CotDraft">
    riskAssessment?: JsonNullableWithAggregatesFilter<"CotDraft">
    optimizationTips?: JsonNullableWithAggregatesFilter<"CotDraft">
    status?: EnumCotDraftStatusWithAggregatesFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableWithAggregatesFilter<"CotDraft"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotDraft"> | Date | string
  }

  export type CotDraftPerformanceWhereInput = {
    AND?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    OR?: CotDraftPerformanceWhereInput[]
    NOT?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    id?: StringFilter<"CotDraftPerformance"> | string
    draftId?: StringFilter<"CotDraftPerformance"> | string
    likes30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    draft?: XOR<CotDraftScalarRelationFilter, CotDraftWhereInput>
  }

  export type CotDraftPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
    draft?: CotDraftOrderByWithRelationInput
  }

  export type CotDraftPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId?: string
    AND?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    OR?: CotDraftPerformanceWhereInput[]
    NOT?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    likes30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    draft?: XOR<CotDraftScalarRelationFilter, CotDraftWhereInput>
  }, "id" | "draftId">

  export type CotDraftPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
    _count?: CotDraftPerformanceCountOrderByAggregateInput
    _avg?: CotDraftPerformanceAvgOrderByAggregateInput
    _max?: CotDraftPerformanceMaxOrderByAggregateInput
    _min?: CotDraftPerformanceMinOrderByAggregateInput
    _sum?: CotDraftPerformanceSumOrderByAggregateInput
  }

  export type CotDraftPerformanceScalarWhereWithAggregatesInput = {
    AND?: CotDraftPerformanceScalarWhereWithAggregatesInput | CotDraftPerformanceScalarWhereWithAggregatesInput[]
    OR?: CotDraftPerformanceScalarWhereWithAggregatesInput[]
    NOT?: CotDraftPerformanceScalarWhereWithAggregatesInput | CotDraftPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotDraftPerformance"> | string
    draftId?: StringWithAggregatesFilter<"CotDraftPerformance"> | string
    likes30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeWithAggregatesFilter<"CotDraftPerformance"> | Date | string
  }

  export type ScheduledRetweetWhereInput = {
    AND?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    OR?: ScheduledRetweetWhereInput[]
    NOT?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    id?: StringFilter<"ScheduledRetweet"> | string
    originalPostId?: StringFilter<"ScheduledRetweet"> | string
    originalContent?: StringFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringFilter<"ScheduledRetweet"> | string
    addComment?: BoolFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
  }

  export type ScheduledRetweetOrderByWithRelationInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrderInput | SortOrder
    viralDraftId?: SortOrderInput | SortOrder
    cotDraftId?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    rtPostId?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledRetweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    OR?: ScheduledRetweetWhereInput[]
    NOT?: ScheduledRetweetWhereInput | ScheduledRetweetWhereInput[]
    originalPostId?: StringFilter<"ScheduledRetweet"> | string
    originalContent?: StringFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringFilter<"ScheduledRetweet"> | string
    addComment?: BoolFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRetweet"> | Date | string
  }, "id">

  export type ScheduledRetweetOrderByWithAggregationInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrderInput | SortOrder
    viralDraftId?: SortOrderInput | SortOrder
    cotDraftId?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    rtPostId?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledRetweetCountOrderByAggregateInput
    _max?: ScheduledRetweetMaxOrderByAggregateInput
    _min?: ScheduledRetweetMinOrderByAggregateInput
  }

  export type ScheduledRetweetScalarWhereWithAggregatesInput = {
    AND?: ScheduledRetweetScalarWhereWithAggregatesInput | ScheduledRetweetScalarWhereWithAggregatesInput[]
    OR?: ScheduledRetweetScalarWhereWithAggregatesInput[]
    NOT?: ScheduledRetweetScalarWhereWithAggregatesInput | ScheduledRetweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    originalPostId?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    originalContent?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"ScheduledRetweet"> | Date | string
    status?: EnumRTStatusWithAggregatesFilter<"ScheduledRetweet"> | $Enums.RTStatus
    rtStrategy?: StringWithAggregatesFilter<"ScheduledRetweet"> | string
    addComment?: BoolWithAggregatesFilter<"ScheduledRetweet"> | boolean
    commentText?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    viralDraftId?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    cotDraftId?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    executedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledRetweet"> | Date | string | null
    rtPostId?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    error?: StringNullableWithAggregatesFilter<"ScheduledRetweet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledRetweet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledRetweet"> | Date | string
  }

  export type UnifiedPerformanceWhereInput = {
    AND?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    OR?: UnifiedPerformanceWhereInput[]
    NOT?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    id?: StringFilter<"UnifiedPerformance"> | string
    contentId?: StringFilter<"UnifiedPerformance"> | string
    contentType?: StringFilter<"UnifiedPerformance"> | string
    metrics30m?: JsonNullableFilter<"UnifiedPerformance">
    metrics1h?: JsonNullableFilter<"UnifiedPerformance">
    metrics24h?: JsonNullableFilter<"UnifiedPerformance">
    engagementRate?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    collectedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
  }

  export type UnifiedPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    metrics30m?: SortOrderInput | SortOrder
    metrics1h?: SortOrderInput | SortOrder
    metrics24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId?: string
    AND?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    OR?: UnifiedPerformanceWhereInput[]
    NOT?: UnifiedPerformanceWhereInput | UnifiedPerformanceWhereInput[]
    contentType?: StringFilter<"UnifiedPerformance"> | string
    metrics30m?: JsonNullableFilter<"UnifiedPerformance">
    metrics1h?: JsonNullableFilter<"UnifiedPerformance">
    metrics24h?: JsonNullableFilter<"UnifiedPerformance">
    engagementRate?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"UnifiedPerformance"> | number | null
    collectedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedPerformance"> | Date | string
  }, "id" | "contentId">

  export type UnifiedPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    metrics30m?: SortOrderInput | SortOrder
    metrics1h?: SortOrderInput | SortOrder
    metrics24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnifiedPerformanceCountOrderByAggregateInput
    _avg?: UnifiedPerformanceAvgOrderByAggregateInput
    _max?: UnifiedPerformanceMaxOrderByAggregateInput
    _min?: UnifiedPerformanceMinOrderByAggregateInput
    _sum?: UnifiedPerformanceSumOrderByAggregateInput
  }

  export type UnifiedPerformanceScalarWhereWithAggregatesInput = {
    AND?: UnifiedPerformanceScalarWhereWithAggregatesInput | UnifiedPerformanceScalarWhereWithAggregatesInput[]
    OR?: UnifiedPerformanceScalarWhereWithAggregatesInput[]
    NOT?: UnifiedPerformanceScalarWhereWithAggregatesInput | UnifiedPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnifiedPerformance"> | string
    contentId?: StringWithAggregatesFilter<"UnifiedPerformance"> | string
    contentType?: StringWithAggregatesFilter<"UnifiedPerformance"> | string
    metrics30m?: JsonNullableWithAggregatesFilter<"UnifiedPerformance">
    metrics1h?: JsonNullableWithAggregatesFilter<"UnifiedPerformance">
    metrics24h?: JsonNullableWithAggregatesFilter<"UnifiedPerformance">
    engagementRate?: FloatNullableWithAggregatesFilter<"UnifiedPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"UnifiedPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"UnifiedPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnifiedPerformance"> | Date | string
  }

  export type NewsViralRelationWhereInput = {
    AND?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    OR?: NewsViralRelationWhereInput[]
    NOT?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    id?: StringFilter<"NewsViralRelation"> | string
    newsId?: StringFilter<"NewsViralRelation"> | string
    sessionId?: StringFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeFilter<"NewsViralRelation"> | Date | string
  }

  export type NewsViralRelationOrderByWithRelationInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    newsId_sessionId?: NewsViralRelationNewsIdSessionIdCompoundUniqueInput
    AND?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    OR?: NewsViralRelationWhereInput[]
    NOT?: NewsViralRelationWhereInput | NewsViralRelationWhereInput[]
    newsId?: StringFilter<"NewsViralRelation"> | string
    sessionId?: StringFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeFilter<"NewsViralRelation"> | Date | string
  }, "id" | "newsId_sessionId">

  export type NewsViralRelationOrderByWithAggregationInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
    _count?: NewsViralRelationCountOrderByAggregateInput
    _avg?: NewsViralRelationAvgOrderByAggregateInput
    _max?: NewsViralRelationMaxOrderByAggregateInput
    _min?: NewsViralRelationMinOrderByAggregateInput
    _sum?: NewsViralRelationSumOrderByAggregateInput
  }

  export type NewsViralRelationScalarWhereWithAggregatesInput = {
    AND?: NewsViralRelationScalarWhereWithAggregatesInput | NewsViralRelationScalarWhereWithAggregatesInput[]
    OR?: NewsViralRelationScalarWhereWithAggregatesInput[]
    NOT?: NewsViralRelationScalarWhereWithAggregatesInput | NewsViralRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsViralRelation"> | string
    newsId?: StringWithAggregatesFilter<"NewsViralRelation"> | string
    sessionId?: StringWithAggregatesFilter<"NewsViralRelation"> | string
    relevanceScore?: FloatNullableWithAggregatesFilter<"NewsViralRelation"> | number | null
    usedInContent?: BoolWithAggregatesFilter<"NewsViralRelation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsViralRelation"> | Date | string
  }

  export type SessionActivityLogWhereInput = {
    AND?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    OR?: SessionActivityLogWhereInput[]
    NOT?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    id?: StringFilter<"SessionActivityLog"> | string
    sessionId?: StringFilter<"SessionActivityLog"> | string
    sessionType?: StringFilter<"SessionActivityLog"> | string
    activityType?: StringFilter<"SessionActivityLog"> | string
    details?: JsonNullableFilter<"SessionActivityLog">
    createdAt?: DateTimeFilter<"SessionActivityLog"> | Date | string
  }

  export type SessionActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SessionActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    OR?: SessionActivityLogWhereInput[]
    NOT?: SessionActivityLogWhereInput | SessionActivityLogWhereInput[]
    sessionId?: StringFilter<"SessionActivityLog"> | string
    sessionType?: StringFilter<"SessionActivityLog"> | string
    activityType?: StringFilter<"SessionActivityLog"> | string
    details?: JsonNullableFilter<"SessionActivityLog">
    createdAt?: DateTimeFilter<"SessionActivityLog"> | Date | string
  }, "id">

  export type SessionActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionActivityLogCountOrderByAggregateInput
    _max?: SessionActivityLogMaxOrderByAggregateInput
    _min?: SessionActivityLogMinOrderByAggregateInput
  }

  export type SessionActivityLogScalarWhereWithAggregatesInput = {
    AND?: SessionActivityLogScalarWhereWithAggregatesInput | SessionActivityLogScalarWhereWithAggregatesInput[]
    OR?: SessionActivityLogScalarWhereWithAggregatesInput[]
    NOT?: SessionActivityLogScalarWhereWithAggregatesInput | SessionActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    sessionId?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    sessionType?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    activityType?: StringWithAggregatesFilter<"SessionActivityLog"> | string
    details?: JsonNullableWithAggregatesFilter<"SessionActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"SessionActivityLog"> | Date | string
  }

  export type ApiErrorLogWhereInput = {
    AND?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    OR?: ApiErrorLogWhereInput[]
    NOT?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    id?: StringFilter<"ApiErrorLog"> | string
    endpoint?: StringFilter<"ApiErrorLog"> | string
    method?: StringFilter<"ApiErrorLog"> | string
    statusCode?: IntFilter<"ApiErrorLog"> | number
    errorMessage?: StringNullableFilter<"ApiErrorLog"> | string | null
    stackTrace?: StringNullableFilter<"ApiErrorLog"> | string | null
    requestBody?: JsonNullableFilter<"ApiErrorLog">
    requestHeaders?: JsonNullableFilter<"ApiErrorLog">
    userAgent?: StringNullableFilter<"ApiErrorLog"> | string | null
    ipAddress?: StringNullableFilter<"ApiErrorLog"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorLog"> | Date | string
  }

  export type ApiErrorLogOrderByWithRelationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    stackTrace?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    OR?: ApiErrorLogWhereInput[]
    NOT?: ApiErrorLogWhereInput | ApiErrorLogWhereInput[]
    endpoint?: StringFilter<"ApiErrorLog"> | string
    method?: StringFilter<"ApiErrorLog"> | string
    statusCode?: IntFilter<"ApiErrorLog"> | number
    errorMessage?: StringNullableFilter<"ApiErrorLog"> | string | null
    stackTrace?: StringNullableFilter<"ApiErrorLog"> | string | null
    requestBody?: JsonNullableFilter<"ApiErrorLog">
    requestHeaders?: JsonNullableFilter<"ApiErrorLog">
    userAgent?: StringNullableFilter<"ApiErrorLog"> | string | null
    ipAddress?: StringNullableFilter<"ApiErrorLog"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorLog"> | Date | string
  }, "id">

  export type ApiErrorLogOrderByWithAggregationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    stackTrace?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiErrorLogCountOrderByAggregateInput
    _avg?: ApiErrorLogAvgOrderByAggregateInput
    _max?: ApiErrorLogMaxOrderByAggregateInput
    _min?: ApiErrorLogMinOrderByAggregateInput
    _sum?: ApiErrorLogSumOrderByAggregateInput
  }

  export type ApiErrorLogScalarWhereWithAggregatesInput = {
    AND?: ApiErrorLogScalarWhereWithAggregatesInput | ApiErrorLogScalarWhereWithAggregatesInput[]
    OR?: ApiErrorLogScalarWhereWithAggregatesInput[]
    NOT?: ApiErrorLogScalarWhereWithAggregatesInput | ApiErrorLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiErrorLog"> | string
    endpoint?: StringWithAggregatesFilter<"ApiErrorLog"> | string
    method?: StringWithAggregatesFilter<"ApiErrorLog"> | string
    statusCode?: IntWithAggregatesFilter<"ApiErrorLog"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    stackTrace?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    requestBody?: JsonNullableWithAggregatesFilter<"ApiErrorLog">
    requestHeaders?: JsonNullableWithAggregatesFilter<"ApiErrorLog">
    userAgent?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ApiErrorLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiErrorLog"> | Date | string
  }

  export type ViralSessionWhereInput = {
    AND?: ViralSessionWhereInput | ViralSessionWhereInput[]
    OR?: ViralSessionWhereInput[]
    NOT?: ViralSessionWhereInput | ViralSessionWhereInput[]
    id?: StringFilter<"ViralSession"> | string
    theme?: StringFilter<"ViralSession"> | string
    platform?: StringFilter<"ViralSession"> | string
    style?: StringFilter<"ViralSession"> | string
    status?: StringFilter<"ViralSession"> | string
    createdAt?: DateTimeFilter<"ViralSession"> | Date | string
    topics?: JsonNullableFilter<"ViralSession">
    concepts?: JsonNullableFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableFilter<"ViralSession">
    characterProfileId?: StringNullableFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableFilter<"ViralSession"> | string | null
    drafts?: ViralDraftV2ListRelationFilter
  }

  export type ViralSessionOrderByWithRelationInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    topics?: SortOrderInput | SortOrder
    concepts?: SortOrderInput | SortOrder
    selectedIds?: SortOrder
    contents?: SortOrderInput | SortOrder
    characterProfileId?: SortOrderInput | SortOrder
    voiceStyleMode?: SortOrderInput | SortOrder
    drafts?: ViralDraftV2OrderByRelationAggregateInput
  }

  export type ViralSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViralSessionWhereInput | ViralSessionWhereInput[]
    OR?: ViralSessionWhereInput[]
    NOT?: ViralSessionWhereInput | ViralSessionWhereInput[]
    theme?: StringFilter<"ViralSession"> | string
    platform?: StringFilter<"ViralSession"> | string
    style?: StringFilter<"ViralSession"> | string
    status?: StringFilter<"ViralSession"> | string
    createdAt?: DateTimeFilter<"ViralSession"> | Date | string
    topics?: JsonNullableFilter<"ViralSession">
    concepts?: JsonNullableFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableFilter<"ViralSession">
    characterProfileId?: StringNullableFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableFilter<"ViralSession"> | string | null
    drafts?: ViralDraftV2ListRelationFilter
  }, "id">

  export type ViralSessionOrderByWithAggregationInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    topics?: SortOrderInput | SortOrder
    concepts?: SortOrderInput | SortOrder
    selectedIds?: SortOrder
    contents?: SortOrderInput | SortOrder
    characterProfileId?: SortOrderInput | SortOrder
    voiceStyleMode?: SortOrderInput | SortOrder
    _count?: ViralSessionCountOrderByAggregateInput
    _max?: ViralSessionMaxOrderByAggregateInput
    _min?: ViralSessionMinOrderByAggregateInput
  }

  export type ViralSessionScalarWhereWithAggregatesInput = {
    AND?: ViralSessionScalarWhereWithAggregatesInput | ViralSessionScalarWhereWithAggregatesInput[]
    OR?: ViralSessionScalarWhereWithAggregatesInput[]
    NOT?: ViralSessionScalarWhereWithAggregatesInput | ViralSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViralSession"> | string
    theme?: StringWithAggregatesFilter<"ViralSession"> | string
    platform?: StringWithAggregatesFilter<"ViralSession"> | string
    style?: StringWithAggregatesFilter<"ViralSession"> | string
    status?: StringWithAggregatesFilter<"ViralSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ViralSession"> | Date | string
    topics?: JsonNullableWithAggregatesFilter<"ViralSession">
    concepts?: JsonNullableWithAggregatesFilter<"ViralSession">
    selectedIds?: StringNullableListFilter<"ViralSession">
    contents?: JsonNullableWithAggregatesFilter<"ViralSession">
    characterProfileId?: StringNullableWithAggregatesFilter<"ViralSession"> | string | null
    voiceStyleMode?: StringNullableWithAggregatesFilter<"ViralSession"> | string | null
  }

  export type ViralDraftV2WhereInput = {
    AND?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    OR?: ViralDraftV2WhereInput[]
    NOT?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    id?: StringFilter<"ViralDraftV2"> | string
    sessionId?: StringFilter<"ViralDraftV2"> | string
    conceptId?: StringFilter<"ViralDraftV2"> | string
    title?: StringFilter<"ViralDraftV2"> | string
    content?: StringFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    status?: StringFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    characterId?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableFilter<"ViralDraftV2"> | string | null
    news_article_id?: StringNullableFilter<"ViralDraftV2"> | string | null
    performance?: XOR<ViralDraftPerformanceNullableScalarRelationFilter, ViralDraftPerformanceWhereInput> | null
    session?: XOR<ViralSessionScalarRelationFilter, ViralSessionWhereInput>
  }

  export type ViralDraftV2OrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    hashtags?: SortOrder
    visualNote?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    tweetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterId?: SortOrderInput | SortOrder
    characterNote?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    news_article_id?: SortOrderInput | SortOrder
    performance?: ViralDraftPerformanceOrderByWithRelationInput
    session?: ViralSessionOrderByWithRelationInput
  }

  export type ViralDraftV2WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    OR?: ViralDraftV2WhereInput[]
    NOT?: ViralDraftV2WhereInput | ViralDraftV2WhereInput[]
    sessionId?: StringFilter<"ViralDraftV2"> | string
    conceptId?: StringFilter<"ViralDraftV2"> | string
    title?: StringFilter<"ViralDraftV2"> | string
    content?: StringFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    status?: StringFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    characterId?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableFilter<"ViralDraftV2"> | string | null
    news_article_id?: StringNullableFilter<"ViralDraftV2"> | string | null
    performance?: XOR<ViralDraftPerformanceNullableScalarRelationFilter, ViralDraftPerformanceWhereInput> | null
    session?: XOR<ViralSessionScalarRelationFilter, ViralSessionWhereInput>
  }, "id">

  export type ViralDraftV2OrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    hashtags?: SortOrder
    visualNote?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    tweetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterId?: SortOrderInput | SortOrder
    characterNote?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    news_article_id?: SortOrderInput | SortOrder
    _count?: ViralDraftV2CountOrderByAggregateInput
    _max?: ViralDraftV2MaxOrderByAggregateInput
    _min?: ViralDraftV2MinOrderByAggregateInput
  }

  export type ViralDraftV2ScalarWhereWithAggregatesInput = {
    AND?: ViralDraftV2ScalarWhereWithAggregatesInput | ViralDraftV2ScalarWhereWithAggregatesInput[]
    OR?: ViralDraftV2ScalarWhereWithAggregatesInput[]
    NOT?: ViralDraftV2ScalarWhereWithAggregatesInput | ViralDraftV2ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    sessionId?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    conceptId?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    title?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    content?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    status?: StringWithAggregatesFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViralDraftV2"> | Date | string
    characterId?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
    news_article_id?: StringNullableWithAggregatesFilter<"ViralDraftV2"> | string | null
  }

  export type ViralDraftPerformanceWhereInput = {
    AND?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    OR?: ViralDraftPerformanceWhereInput[]
    NOT?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    id?: StringFilter<"ViralDraftPerformance"> | string
    draftId?: StringFilter<"ViralDraftPerformance"> | string
    likes30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    draft?: XOR<ViralDraftV2ScalarRelationFilter, ViralDraftV2WhereInput>
  }

  export type ViralDraftPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    draft?: ViralDraftV2OrderByWithRelationInput
  }

  export type ViralDraftPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId?: string
    AND?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    OR?: ViralDraftPerformanceWhereInput[]
    NOT?: ViralDraftPerformanceWhereInput | ViralDraftPerformanceWhereInput[]
    likes30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"ViralDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"ViralDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftPerformance"> | Date | string
    draft?: XOR<ViralDraftV2ScalarRelationFilter, ViralDraftV2WhereInput>
  }, "id" | "draftId">

  export type ViralDraftPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ViralDraftPerformanceCountOrderByAggregateInput
    _avg?: ViralDraftPerformanceAvgOrderByAggregateInput
    _max?: ViralDraftPerformanceMaxOrderByAggregateInput
    _min?: ViralDraftPerformanceMinOrderByAggregateInput
    _sum?: ViralDraftPerformanceSumOrderByAggregateInput
  }

  export type ViralDraftPerformanceScalarWhereWithAggregatesInput = {
    AND?: ViralDraftPerformanceScalarWhereWithAggregatesInput | ViralDraftPerformanceScalarWhereWithAggregatesInput[]
    OR?: ViralDraftPerformanceScalarWhereWithAggregatesInput[]
    NOT?: ViralDraftPerformanceScalarWhereWithAggregatesInput | ViralDraftPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViralDraftPerformance"> | string
    draftId?: StringWithAggregatesFilter<"ViralDraftPerformance"> | string
    likes30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    retweets30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    replies30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    impressions30m?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    likes1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    retweets1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    replies1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    impressions1h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    likes24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    retweets24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    replies24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    impressions24h?: IntNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    engagementRate?: FloatNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"ViralDraftPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"ViralDraftPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViralDraftPerformance"> | Date | string
  }

  export type CharacterProfileWhereInput = {
    AND?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    OR?: CharacterProfileWhereInput[]
    NOT?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    id?: StringFilter<"CharacterProfile"> | string
    name?: StringFilter<"CharacterProfile"> | string
    display_name?: StringFilter<"CharacterProfile"> | string
    age?: IntFilter<"CharacterProfile"> | number
    gender?: EnumGenderFilter<"CharacterProfile"> | $Enums.Gender
    occupation?: StringFilter<"CharacterProfile"> | string
    catchphrase?: StringFilter<"CharacterProfile"> | string
    personality?: StringFilter<"CharacterProfile"> | string
    speaking_style?: StringFilter<"CharacterProfile"> | string
    expertise?: StringFilter<"CharacterProfile"> | string
    backstory?: StringFilter<"CharacterProfile"> | string
    philosophy?: StringNullableFilter<"CharacterProfile"> | string | null
    tone?: StringFilter<"CharacterProfile"> | string
    voiceStyle?: JsonFilter<"CharacterProfile">
    emoji_style?: StringFilter<"CharacterProfile"> | string
    createdAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableFilter<"CharacterProfile">
    topicExpertise?: JsonNullableFilter<"CharacterProfile">
  }

  export type CharacterProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    occupation?: SortOrder
    catchphrase?: SortOrder
    personality?: SortOrder
    speaking_style?: SortOrder
    expertise?: SortOrder
    backstory?: SortOrder
    philosophy?: SortOrderInput | SortOrder
    tone?: SortOrder
    voiceStyle?: SortOrder
    emoji_style?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredNewsCategories?: SortOrder
    newsCommentStyle?: SortOrderInput | SortOrder
    topicExpertise?: SortOrderInput | SortOrder
  }

  export type CharacterProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    OR?: CharacterProfileWhereInput[]
    NOT?: CharacterProfileWhereInput | CharacterProfileWhereInput[]
    display_name?: StringFilter<"CharacterProfile"> | string
    age?: IntFilter<"CharacterProfile"> | number
    gender?: EnumGenderFilter<"CharacterProfile"> | $Enums.Gender
    occupation?: StringFilter<"CharacterProfile"> | string
    catchphrase?: StringFilter<"CharacterProfile"> | string
    personality?: StringFilter<"CharacterProfile"> | string
    speaking_style?: StringFilter<"CharacterProfile"> | string
    expertise?: StringFilter<"CharacterProfile"> | string
    backstory?: StringFilter<"CharacterProfile"> | string
    philosophy?: StringNullableFilter<"CharacterProfile"> | string | null
    tone?: StringFilter<"CharacterProfile"> | string
    voiceStyle?: JsonFilter<"CharacterProfile">
    emoji_style?: StringFilter<"CharacterProfile"> | string
    createdAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableFilter<"CharacterProfile">
    topicExpertise?: JsonNullableFilter<"CharacterProfile">
  }, "id" | "name">

  export type CharacterProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    occupation?: SortOrder
    catchphrase?: SortOrder
    personality?: SortOrder
    speaking_style?: SortOrder
    expertise?: SortOrder
    backstory?: SortOrder
    philosophy?: SortOrderInput | SortOrder
    tone?: SortOrder
    voiceStyle?: SortOrder
    emoji_style?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredNewsCategories?: SortOrder
    newsCommentStyle?: SortOrderInput | SortOrder
    topicExpertise?: SortOrderInput | SortOrder
    _count?: CharacterProfileCountOrderByAggregateInput
    _avg?: CharacterProfileAvgOrderByAggregateInput
    _max?: CharacterProfileMaxOrderByAggregateInput
    _min?: CharacterProfileMinOrderByAggregateInput
    _sum?: CharacterProfileSumOrderByAggregateInput
  }

  export type CharacterProfileScalarWhereWithAggregatesInput = {
    AND?: CharacterProfileScalarWhereWithAggregatesInput | CharacterProfileScalarWhereWithAggregatesInput[]
    OR?: CharacterProfileScalarWhereWithAggregatesInput[]
    NOT?: CharacterProfileScalarWhereWithAggregatesInput | CharacterProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterProfile"> | string
    name?: StringWithAggregatesFilter<"CharacterProfile"> | string
    display_name?: StringWithAggregatesFilter<"CharacterProfile"> | string
    age?: IntWithAggregatesFilter<"CharacterProfile"> | number
    gender?: EnumGenderWithAggregatesFilter<"CharacterProfile"> | $Enums.Gender
    occupation?: StringWithAggregatesFilter<"CharacterProfile"> | string
    catchphrase?: StringWithAggregatesFilter<"CharacterProfile"> | string
    personality?: StringWithAggregatesFilter<"CharacterProfile"> | string
    speaking_style?: StringWithAggregatesFilter<"CharacterProfile"> | string
    expertise?: StringWithAggregatesFilter<"CharacterProfile"> | string
    backstory?: StringWithAggregatesFilter<"CharacterProfile"> | string
    philosophy?: StringNullableWithAggregatesFilter<"CharacterProfile"> | string | null
    tone?: StringWithAggregatesFilter<"CharacterProfile"> | string
    voiceStyle?: JsonWithAggregatesFilter<"CharacterProfile">
    emoji_style?: StringWithAggregatesFilter<"CharacterProfile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CharacterProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterProfile"> | Date | string
    preferredNewsCategories?: StringNullableListFilter<"CharacterProfile">
    newsCommentStyle?: JsonNullableWithAggregatesFilter<"CharacterProfile">
    topicExpertise?: JsonNullableWithAggregatesFilter<"CharacterProfile">
  }

  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: StringFilter<"accounts"> | string
    user_id?: StringFilter<"accounts"> | string
    type?: StringFilter<"accounts"> | string
    provider?: StringFilter<"accounts"> | string
    provider_account_id?: StringFilter<"accounts"> | string
    refresh_token?: StringNullableFilter<"accounts"> | string | null
    access_token?: StringNullableFilter<"accounts"> | string | null
    expires_at?: IntNullableFilter<"accounts"> | number | null
    token_type?: StringNullableFilter<"accounts"> | string | null
    scope?: StringNullableFilter<"accounts"> | string | null
    id_token?: StringNullableFilter<"accounts"> | string | null
    session_state?: StringNullableFilter<"accounts"> | string | null
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_provider_account_id?: accountsProviderProvider_account_idCompoundUniqueInput
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    user_id?: StringFilter<"accounts"> | string
    type?: StringFilter<"accounts"> | string
    provider?: StringFilter<"accounts"> | string
    provider_account_id?: StringFilter<"accounts"> | string
    refresh_token?: StringNullableFilter<"accounts"> | string | null
    access_token?: StringNullableFilter<"accounts"> | string | null
    expires_at?: IntNullableFilter<"accounts"> | number | null
    token_type?: StringNullableFilter<"accounts"> | string | null
    scope?: StringNullableFilter<"accounts"> | string | null
    id_token?: StringNullableFilter<"accounts"> | string | null
    session_state?: StringNullableFilter<"accounts"> | string | null
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_provider_account_id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"accounts"> | string
    user_id?: StringWithAggregatesFilter<"accounts"> | string
    type?: StringWithAggregatesFilter<"accounts"> | string
    provider?: StringWithAggregatesFilter<"accounts"> | string
    provider_account_id?: StringWithAggregatesFilter<"accounts"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    scope?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"accounts"> | string | null
  }

  export type ai_patternsWhereInput = {
    AND?: ai_patternsWhereInput | ai_patternsWhereInput[]
    OR?: ai_patternsWhereInput[]
    NOT?: ai_patternsWhereInput | ai_patternsWhereInput[]
    id?: StringFilter<"ai_patterns"> | string
    name?: StringFilter<"ai_patterns"> | string
    description?: StringFilter<"ai_patterns"> | string
    prompt_template?: StringFilter<"ai_patterns"> | string
    example_output?: StringFilter<"ai_patterns"> | string
    success_rate?: FloatFilter<"ai_patterns"> | number
    usage_count?: IntFilter<"ai_patterns"> | number
    created_at?: DateTimeFilter<"ai_patterns"> | Date | string
  }

  export type ai_patternsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt_template?: SortOrder
    example_output?: SortOrder
    success_rate?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
  }

  export type ai_patternsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ai_patternsWhereInput | ai_patternsWhereInput[]
    OR?: ai_patternsWhereInput[]
    NOT?: ai_patternsWhereInput | ai_patternsWhereInput[]
    name?: StringFilter<"ai_patterns"> | string
    description?: StringFilter<"ai_patterns"> | string
    prompt_template?: StringFilter<"ai_patterns"> | string
    example_output?: StringFilter<"ai_patterns"> | string
    success_rate?: FloatFilter<"ai_patterns"> | number
    usage_count?: IntFilter<"ai_patterns"> | number
    created_at?: DateTimeFilter<"ai_patterns"> | Date | string
  }, "id">

  export type ai_patternsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt_template?: SortOrder
    example_output?: SortOrder
    success_rate?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
    _count?: ai_patternsCountOrderByAggregateInput
    _avg?: ai_patternsAvgOrderByAggregateInput
    _max?: ai_patternsMaxOrderByAggregateInput
    _min?: ai_patternsMinOrderByAggregateInput
    _sum?: ai_patternsSumOrderByAggregateInput
  }

  export type ai_patternsScalarWhereWithAggregatesInput = {
    AND?: ai_patternsScalarWhereWithAggregatesInput | ai_patternsScalarWhereWithAggregatesInput[]
    OR?: ai_patternsScalarWhereWithAggregatesInput[]
    NOT?: ai_patternsScalarWhereWithAggregatesInput | ai_patternsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ai_patterns"> | string
    name?: StringWithAggregatesFilter<"ai_patterns"> | string
    description?: StringWithAggregatesFilter<"ai_patterns"> | string
    prompt_template?: StringWithAggregatesFilter<"ai_patterns"> | string
    example_output?: StringWithAggregatesFilter<"ai_patterns"> | string
    success_rate?: FloatWithAggregatesFilter<"ai_patterns"> | number
    usage_count?: IntWithAggregatesFilter<"ai_patterns"> | number
    created_at?: DateTimeWithAggregatesFilter<"ai_patterns"> | Date | string
  }

  export type content_draftsWhereInput = {
    AND?: content_draftsWhereInput | content_draftsWhereInput[]
    OR?: content_draftsWhereInput[]
    NOT?: content_draftsWhereInput | content_draftsWhereInput[]
    id?: UuidFilter<"content_drafts"> | string
    analysis_id?: UuidFilter<"content_drafts"> | string
    concept_type?: StringFilter<"content_drafts"> | string
    category?: StringFilter<"content_drafts"> | string
    title?: StringFilter<"content_drafts"> | string
    content?: StringFilter<"content_drafts"> | string
    edited_content?: StringNullableFilter<"content_drafts"> | string | null
    explanation?: StringNullableFilter<"content_drafts"> | string | null
    buzz_factors?: JsonNullableFilter<"content_drafts">
    target_audience?: StringNullableFilter<"content_drafts"> | string | null
    estimated_engagement?: JsonNullableFilter<"content_drafts">
    hashtags?: JsonNullableFilter<"content_drafts">
    visual_guide?: StringNullableFilter<"content_drafts"> | string | null
    platform?: StringNullableFilter<"content_drafts"> | string | null
    format?: StringNullableFilter<"content_drafts"> | string | null
    status?: StringNullableFilter<"content_drafts"> | string | null
    editor_notes?: StringNullableFilter<"content_drafts"> | string | null
    metadata?: JsonNullableFilter<"content_drafts">
    created_at?: DateTimeNullableFilter<"content_drafts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"content_drafts"> | Date | string | null
    gpt_analyses?: XOR<Gpt_analysesScalarRelationFilter, gpt_analysesWhereInput>
  }

  export type content_draftsOrderByWithRelationInput = {
    id?: SortOrder
    analysis_id?: SortOrder
    concept_type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    edited_content?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    buzz_factors?: SortOrderInput | SortOrder
    target_audience?: SortOrderInput | SortOrder
    estimated_engagement?: SortOrderInput | SortOrder
    hashtags?: SortOrderInput | SortOrder
    visual_guide?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    editor_notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    gpt_analyses?: gpt_analysesOrderByWithRelationInput
  }

  export type content_draftsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: content_draftsWhereInput | content_draftsWhereInput[]
    OR?: content_draftsWhereInput[]
    NOT?: content_draftsWhereInput | content_draftsWhereInput[]
    analysis_id?: UuidFilter<"content_drafts"> | string
    concept_type?: StringFilter<"content_drafts"> | string
    category?: StringFilter<"content_drafts"> | string
    title?: StringFilter<"content_drafts"> | string
    content?: StringFilter<"content_drafts"> | string
    edited_content?: StringNullableFilter<"content_drafts"> | string | null
    explanation?: StringNullableFilter<"content_drafts"> | string | null
    buzz_factors?: JsonNullableFilter<"content_drafts">
    target_audience?: StringNullableFilter<"content_drafts"> | string | null
    estimated_engagement?: JsonNullableFilter<"content_drafts">
    hashtags?: JsonNullableFilter<"content_drafts">
    visual_guide?: StringNullableFilter<"content_drafts"> | string | null
    platform?: StringNullableFilter<"content_drafts"> | string | null
    format?: StringNullableFilter<"content_drafts"> | string | null
    status?: StringNullableFilter<"content_drafts"> | string | null
    editor_notes?: StringNullableFilter<"content_drafts"> | string | null
    metadata?: JsonNullableFilter<"content_drafts">
    created_at?: DateTimeNullableFilter<"content_drafts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"content_drafts"> | Date | string | null
    gpt_analyses?: XOR<Gpt_analysesScalarRelationFilter, gpt_analysesWhereInput>
  }, "id">

  export type content_draftsOrderByWithAggregationInput = {
    id?: SortOrder
    analysis_id?: SortOrder
    concept_type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    edited_content?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    buzz_factors?: SortOrderInput | SortOrder
    target_audience?: SortOrderInput | SortOrder
    estimated_engagement?: SortOrderInput | SortOrder
    hashtags?: SortOrderInput | SortOrder
    visual_guide?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    editor_notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: content_draftsCountOrderByAggregateInput
    _max?: content_draftsMaxOrderByAggregateInput
    _min?: content_draftsMinOrderByAggregateInput
  }

  export type content_draftsScalarWhereWithAggregatesInput = {
    AND?: content_draftsScalarWhereWithAggregatesInput | content_draftsScalarWhereWithAggregatesInput[]
    OR?: content_draftsScalarWhereWithAggregatesInput[]
    NOT?: content_draftsScalarWhereWithAggregatesInput | content_draftsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"content_drafts"> | string
    analysis_id?: UuidWithAggregatesFilter<"content_drafts"> | string
    concept_type?: StringWithAggregatesFilter<"content_drafts"> | string
    category?: StringWithAggregatesFilter<"content_drafts"> | string
    title?: StringWithAggregatesFilter<"content_drafts"> | string
    content?: StringWithAggregatesFilter<"content_drafts"> | string
    edited_content?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    explanation?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    buzz_factors?: JsonNullableWithAggregatesFilter<"content_drafts">
    target_audience?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    estimated_engagement?: JsonNullableWithAggregatesFilter<"content_drafts">
    hashtags?: JsonNullableWithAggregatesFilter<"content_drafts">
    visual_guide?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    platform?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    format?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    status?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    editor_notes?: StringNullableWithAggregatesFilter<"content_drafts"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"content_drafts">
    created_at?: DateTimeNullableWithAggregatesFilter<"content_drafts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"content_drafts"> | Date | string | null
  }

  export type gpt_analysesWhereInput = {
    AND?: gpt_analysesWhereInput | gpt_analysesWhereInput[]
    OR?: gpt_analysesWhereInput[]
    NOT?: gpt_analysesWhereInput | gpt_analysesWhereInput[]
    id?: UuidFilter<"gpt_analyses"> | string
    analysis_type?: StringFilter<"gpt_analyses"> | string
    prompt?: StringFilter<"gpt_analyses"> | string
    response?: JsonFilter<"gpt_analyses">
    tokens?: IntNullableFilter<"gpt_analyses"> | number | null
    duration?: IntNullableFilter<"gpt_analyses"> | number | null
    metadata?: JsonNullableFilter<"gpt_analyses">
    created_at?: DateTimeNullableFilter<"gpt_analyses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"gpt_analyses"> | Date | string | null
    content_drafts?: Content_draftsListRelationFilter
  }

  export type gpt_analysesOrderByWithRelationInput = {
    id?: SortOrder
    analysis_type?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    tokens?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    content_drafts?: content_draftsOrderByRelationAggregateInput
  }

  export type gpt_analysesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: gpt_analysesWhereInput | gpt_analysesWhereInput[]
    OR?: gpt_analysesWhereInput[]
    NOT?: gpt_analysesWhereInput | gpt_analysesWhereInput[]
    analysis_type?: StringFilter<"gpt_analyses"> | string
    prompt?: StringFilter<"gpt_analyses"> | string
    response?: JsonFilter<"gpt_analyses">
    tokens?: IntNullableFilter<"gpt_analyses"> | number | null
    duration?: IntNullableFilter<"gpt_analyses"> | number | null
    metadata?: JsonNullableFilter<"gpt_analyses">
    created_at?: DateTimeNullableFilter<"gpt_analyses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"gpt_analyses"> | Date | string | null
    content_drafts?: Content_draftsListRelationFilter
  }, "id">

  export type gpt_analysesOrderByWithAggregationInput = {
    id?: SortOrder
    analysis_type?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    tokens?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: gpt_analysesCountOrderByAggregateInput
    _avg?: gpt_analysesAvgOrderByAggregateInput
    _max?: gpt_analysesMaxOrderByAggregateInput
    _min?: gpt_analysesMinOrderByAggregateInput
    _sum?: gpt_analysesSumOrderByAggregateInput
  }

  export type gpt_analysesScalarWhereWithAggregatesInput = {
    AND?: gpt_analysesScalarWhereWithAggregatesInput | gpt_analysesScalarWhereWithAggregatesInput[]
    OR?: gpt_analysesScalarWhereWithAggregatesInput[]
    NOT?: gpt_analysesScalarWhereWithAggregatesInput | gpt_analysesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"gpt_analyses"> | string
    analysis_type?: StringWithAggregatesFilter<"gpt_analyses"> | string
    prompt?: StringWithAggregatesFilter<"gpt_analyses"> | string
    response?: JsonWithAggregatesFilter<"gpt_analyses">
    tokens?: IntNullableWithAggregatesFilter<"gpt_analyses"> | number | null
    duration?: IntNullableWithAggregatesFilter<"gpt_analyses"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"gpt_analyses">
    created_at?: DateTimeNullableWithAggregatesFilter<"gpt_analyses"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"gpt_analyses"> | Date | string | null
  }

  export type news_analysis_jobsWhereInput = {
    AND?: news_analysis_jobsWhereInput | news_analysis_jobsWhereInput[]
    OR?: news_analysis_jobsWhereInput[]
    NOT?: news_analysis_jobsWhereInput | news_analysis_jobsWhereInput[]
    id?: StringFilter<"news_analysis_jobs"> | string
    type?: StringFilter<"news_analysis_jobs"> | string
    status?: StringFilter<"news_analysis_jobs"> | string
    started_at?: DateTimeNullableFilter<"news_analysis_jobs"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"news_analysis_jobs"> | Date | string | null
    error?: StringNullableFilter<"news_analysis_jobs"> | string | null
    result?: JsonNullableFilter<"news_analysis_jobs">
    metadata?: JsonNullableFilter<"news_analysis_jobs">
    created_at?: DateTimeFilter<"news_analysis_jobs"> | Date | string
    updated_at?: DateTimeFilter<"news_analysis_jobs"> | Date | string
    news_analysis_results?: News_analysis_resultsListRelationFilter
  }

  export type news_analysis_jobsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    news_analysis_results?: news_analysis_resultsOrderByRelationAggregateInput
  }

  export type news_analysis_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: news_analysis_jobsWhereInput | news_analysis_jobsWhereInput[]
    OR?: news_analysis_jobsWhereInput[]
    NOT?: news_analysis_jobsWhereInput | news_analysis_jobsWhereInput[]
    type?: StringFilter<"news_analysis_jobs"> | string
    status?: StringFilter<"news_analysis_jobs"> | string
    started_at?: DateTimeNullableFilter<"news_analysis_jobs"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"news_analysis_jobs"> | Date | string | null
    error?: StringNullableFilter<"news_analysis_jobs"> | string | null
    result?: JsonNullableFilter<"news_analysis_jobs">
    metadata?: JsonNullableFilter<"news_analysis_jobs">
    created_at?: DateTimeFilter<"news_analysis_jobs"> | Date | string
    updated_at?: DateTimeFilter<"news_analysis_jobs"> | Date | string
    news_analysis_results?: News_analysis_resultsListRelationFilter
  }, "id">

  export type news_analysis_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: news_analysis_jobsCountOrderByAggregateInput
    _max?: news_analysis_jobsMaxOrderByAggregateInput
    _min?: news_analysis_jobsMinOrderByAggregateInput
  }

  export type news_analysis_jobsScalarWhereWithAggregatesInput = {
    AND?: news_analysis_jobsScalarWhereWithAggregatesInput | news_analysis_jobsScalarWhereWithAggregatesInput[]
    OR?: news_analysis_jobsScalarWhereWithAggregatesInput[]
    NOT?: news_analysis_jobsScalarWhereWithAggregatesInput | news_analysis_jobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"news_analysis_jobs"> | string
    type?: StringWithAggregatesFilter<"news_analysis_jobs"> | string
    status?: StringWithAggregatesFilter<"news_analysis_jobs"> | string
    started_at?: DateTimeNullableWithAggregatesFilter<"news_analysis_jobs"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"news_analysis_jobs"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"news_analysis_jobs"> | string | null
    result?: JsonNullableWithAggregatesFilter<"news_analysis_jobs">
    metadata?: JsonNullableWithAggregatesFilter<"news_analysis_jobs">
    created_at?: DateTimeWithAggregatesFilter<"news_analysis_jobs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"news_analysis_jobs"> | Date | string
  }

  export type news_analysis_resultsWhereInput = {
    AND?: news_analysis_resultsWhereInput | news_analysis_resultsWhereInput[]
    OR?: news_analysis_resultsWhereInput[]
    NOT?: news_analysis_resultsWhereInput | news_analysis_resultsWhereInput[]
    id?: StringFilter<"news_analysis_results"> | string
    job_id?: StringFilter<"news_analysis_results"> | string
    article_id?: StringFilter<"news_analysis_results"> | string
    importance_score?: FloatFilter<"news_analysis_results"> | number
    category?: StringFilter<"news_analysis_results"> | string
    summary_ja?: StringFilter<"news_analysis_results"> | string
    key_points?: JsonFilter<"news_analysis_results">
    impact_assessment?: StringFilter<"news_analysis_results"> | string
    expert_perspective?: StringNullableFilter<"news_analysis_results"> | string | null
    metadata?: JsonNullableFilter<"news_analysis_results">
    created_at?: DateTimeFilter<"news_analysis_results"> | Date | string
    news_articles?: XOR<NewsArticleScalarRelationFilter, NewsArticleWhereInput>
    news_analysis_jobs?: XOR<News_analysis_jobsScalarRelationFilter, news_analysis_jobsWhereInput>
  }

  export type news_analysis_resultsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    article_id?: SortOrder
    importance_score?: SortOrder
    category?: SortOrder
    summary_ja?: SortOrder
    key_points?: SortOrder
    impact_assessment?: SortOrder
    expert_perspective?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    news_articles?: NewsArticleOrderByWithRelationInput
    news_analysis_jobs?: news_analysis_jobsOrderByWithRelationInput
  }

  export type news_analysis_resultsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: news_analysis_resultsWhereInput | news_analysis_resultsWhereInput[]
    OR?: news_analysis_resultsWhereInput[]
    NOT?: news_analysis_resultsWhereInput | news_analysis_resultsWhereInput[]
    job_id?: StringFilter<"news_analysis_results"> | string
    article_id?: StringFilter<"news_analysis_results"> | string
    importance_score?: FloatFilter<"news_analysis_results"> | number
    category?: StringFilter<"news_analysis_results"> | string
    summary_ja?: StringFilter<"news_analysis_results"> | string
    key_points?: JsonFilter<"news_analysis_results">
    impact_assessment?: StringFilter<"news_analysis_results"> | string
    expert_perspective?: StringNullableFilter<"news_analysis_results"> | string | null
    metadata?: JsonNullableFilter<"news_analysis_results">
    created_at?: DateTimeFilter<"news_analysis_results"> | Date | string
    news_articles?: XOR<NewsArticleScalarRelationFilter, NewsArticleWhereInput>
    news_analysis_jobs?: XOR<News_analysis_jobsScalarRelationFilter, news_analysis_jobsWhereInput>
  }, "id">

  export type news_analysis_resultsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    article_id?: SortOrder
    importance_score?: SortOrder
    category?: SortOrder
    summary_ja?: SortOrder
    key_points?: SortOrder
    impact_assessment?: SortOrder
    expert_perspective?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: news_analysis_resultsCountOrderByAggregateInput
    _avg?: news_analysis_resultsAvgOrderByAggregateInput
    _max?: news_analysis_resultsMaxOrderByAggregateInput
    _min?: news_analysis_resultsMinOrderByAggregateInput
    _sum?: news_analysis_resultsSumOrderByAggregateInput
  }

  export type news_analysis_resultsScalarWhereWithAggregatesInput = {
    AND?: news_analysis_resultsScalarWhereWithAggregatesInput | news_analysis_resultsScalarWhereWithAggregatesInput[]
    OR?: news_analysis_resultsScalarWhereWithAggregatesInput[]
    NOT?: news_analysis_resultsScalarWhereWithAggregatesInput | news_analysis_resultsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"news_analysis_results"> | string
    job_id?: StringWithAggregatesFilter<"news_analysis_results"> | string
    article_id?: StringWithAggregatesFilter<"news_analysis_results"> | string
    importance_score?: FloatWithAggregatesFilter<"news_analysis_results"> | number
    category?: StringWithAggregatesFilter<"news_analysis_results"> | string
    summary_ja?: StringWithAggregatesFilter<"news_analysis_results"> | string
    key_points?: JsonWithAggregatesFilter<"news_analysis_results">
    impact_assessment?: StringWithAggregatesFilter<"news_analysis_results"> | string
    expert_perspective?: StringNullableWithAggregatesFilter<"news_analysis_results"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"news_analysis_results">
    created_at?: DateTimeWithAggregatesFilter<"news_analysis_results"> | Date | string
  }

  export type prompt_templatesWhereInput = {
    AND?: prompt_templatesWhereInput | prompt_templatesWhereInput[]
    OR?: prompt_templatesWhereInput[]
    NOT?: prompt_templatesWhereInput | prompt_templatesWhereInput[]
    id?: UuidFilter<"prompt_templates"> | string
    name?: StringFilter<"prompt_templates"> | string
    type?: StringFilter<"prompt_templates"> | string
    template?: StringFilter<"prompt_templates"> | string
    variables?: JsonFilter<"prompt_templates">
    is_active?: BoolNullableFilter<"prompt_templates"> | boolean | null
    metadata?: JsonNullableFilter<"prompt_templates">
    created_at?: DateTimeNullableFilter<"prompt_templates"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"prompt_templates"> | Date | string | null
  }

  export type prompt_templatesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    is_active?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type prompt_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: prompt_templatesWhereInput | prompt_templatesWhereInput[]
    OR?: prompt_templatesWhereInput[]
    NOT?: prompt_templatesWhereInput | prompt_templatesWhereInput[]
    name?: StringFilter<"prompt_templates"> | string
    type?: StringFilter<"prompt_templates"> | string
    template?: StringFilter<"prompt_templates"> | string
    variables?: JsonFilter<"prompt_templates">
    is_active?: BoolNullableFilter<"prompt_templates"> | boolean | null
    metadata?: JsonNullableFilter<"prompt_templates">
    created_at?: DateTimeNullableFilter<"prompt_templates"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"prompt_templates"> | Date | string | null
  }, "id">

  export type prompt_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    is_active?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: prompt_templatesCountOrderByAggregateInput
    _max?: prompt_templatesMaxOrderByAggregateInput
    _min?: prompt_templatesMinOrderByAggregateInput
  }

  export type prompt_templatesScalarWhereWithAggregatesInput = {
    AND?: prompt_templatesScalarWhereWithAggregatesInput | prompt_templatesScalarWhereWithAggregatesInput[]
    OR?: prompt_templatesScalarWhereWithAggregatesInput[]
    NOT?: prompt_templatesScalarWhereWithAggregatesInput | prompt_templatesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"prompt_templates"> | string
    name?: StringWithAggregatesFilter<"prompt_templates"> | string
    type?: StringWithAggregatesFilter<"prompt_templates"> | string
    template?: StringWithAggregatesFilter<"prompt_templates"> | string
    variables?: JsonWithAggregatesFilter<"prompt_templates">
    is_active?: BoolNullableWithAggregatesFilter<"prompt_templates"> | boolean | null
    metadata?: JsonNullableWithAggregatesFilter<"prompt_templates">
    created_at?: DateTimeNullableWithAggregatesFilter<"prompt_templates"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"prompt_templates"> | Date | string | null
  }

  export type viral_analysis_logsWhereInput = {
    AND?: viral_analysis_logsWhereInput | viral_analysis_logsWhereInput[]
    OR?: viral_analysis_logsWhereInput[]
    NOT?: viral_analysis_logsWhereInput | viral_analysis_logsWhereInput[]
    id?: UuidFilter<"viral_analysis_logs"> | string
    model?: StringFilter<"viral_analysis_logs"> | string
    phase?: StringFilter<"viral_analysis_logs"> | string
    prompt?: StringFilter<"viral_analysis_logs"> | string
    response?: JsonFilter<"viral_analysis_logs">
    tokens?: IntNullableFilter<"viral_analysis_logs"> | number | null
    duration?: IntNullableFilter<"viral_analysis_logs"> | number | null
    success?: BoolFilter<"viral_analysis_logs"> | boolean
    error?: StringNullableFilter<"viral_analysis_logs"> | string | null
    created_at?: DateTimeNullableFilter<"viral_analysis_logs"> | Date | string | null
  }

  export type viral_analysis_logsOrderByWithRelationInput = {
    id?: SortOrder
    model?: SortOrder
    phase?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    tokens?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type viral_analysis_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: viral_analysis_logsWhereInput | viral_analysis_logsWhereInput[]
    OR?: viral_analysis_logsWhereInput[]
    NOT?: viral_analysis_logsWhereInput | viral_analysis_logsWhereInput[]
    model?: StringFilter<"viral_analysis_logs"> | string
    phase?: StringFilter<"viral_analysis_logs"> | string
    prompt?: StringFilter<"viral_analysis_logs"> | string
    response?: JsonFilter<"viral_analysis_logs">
    tokens?: IntNullableFilter<"viral_analysis_logs"> | number | null
    duration?: IntNullableFilter<"viral_analysis_logs"> | number | null
    success?: BoolFilter<"viral_analysis_logs"> | boolean
    error?: StringNullableFilter<"viral_analysis_logs"> | string | null
    created_at?: DateTimeNullableFilter<"viral_analysis_logs"> | Date | string | null
  }, "id">

  export type viral_analysis_logsOrderByWithAggregationInput = {
    id?: SortOrder
    model?: SortOrder
    phase?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    tokens?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: viral_analysis_logsCountOrderByAggregateInput
    _avg?: viral_analysis_logsAvgOrderByAggregateInput
    _max?: viral_analysis_logsMaxOrderByAggregateInput
    _min?: viral_analysis_logsMinOrderByAggregateInput
    _sum?: viral_analysis_logsSumOrderByAggregateInput
  }

  export type viral_analysis_logsScalarWhereWithAggregatesInput = {
    AND?: viral_analysis_logsScalarWhereWithAggregatesInput | viral_analysis_logsScalarWhereWithAggregatesInput[]
    OR?: viral_analysis_logsScalarWhereWithAggregatesInput[]
    NOT?: viral_analysis_logsScalarWhereWithAggregatesInput | viral_analysis_logsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"viral_analysis_logs"> | string
    model?: StringWithAggregatesFilter<"viral_analysis_logs"> | string
    phase?: StringWithAggregatesFilter<"viral_analysis_logs"> | string
    prompt?: StringWithAggregatesFilter<"viral_analysis_logs"> | string
    response?: JsonWithAggregatesFilter<"viral_analysis_logs">
    tokens?: IntNullableWithAggregatesFilter<"viral_analysis_logs"> | number | null
    duration?: IntNullableWithAggregatesFilter<"viral_analysis_logs"> | number | null
    success?: BoolWithAggregatesFilter<"viral_analysis_logs"> | boolean
    error?: StringNullableWithAggregatesFilter<"viral_analysis_logs"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"viral_analysis_logs"> | Date | string | null
  }

  export type viral_configWhereInput = {
    AND?: viral_configWhereInput | viral_configWhereInput[]
    OR?: viral_configWhereInput[]
    NOT?: viral_configWhereInput | viral_configWhereInput[]
    id?: UuidFilter<"viral_config"> | string
    key?: StringFilter<"viral_config"> | string
    value?: JsonFilter<"viral_config">
    description?: StringNullableFilter<"viral_config"> | string | null
    created_at?: DateTimeNullableFilter<"viral_config"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_config"> | Date | string | null
  }

  export type viral_configOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type viral_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: viral_configWhereInput | viral_configWhereInput[]
    OR?: viral_configWhereInput[]
    NOT?: viral_configWhereInput | viral_configWhereInput[]
    value?: JsonFilter<"viral_config">
    description?: StringNullableFilter<"viral_config"> | string | null
    created_at?: DateTimeNullableFilter<"viral_config"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_config"> | Date | string | null
  }, "id" | "key">

  export type viral_configOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: viral_configCountOrderByAggregateInput
    _max?: viral_configMaxOrderByAggregateInput
    _min?: viral_configMinOrderByAggregateInput
  }

  export type viral_configScalarWhereWithAggregatesInput = {
    AND?: viral_configScalarWhereWithAggregatesInput | viral_configScalarWhereWithAggregatesInput[]
    OR?: viral_configScalarWhereWithAggregatesInput[]
    NOT?: viral_configScalarWhereWithAggregatesInput | viral_configScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"viral_config"> | string
    key?: StringWithAggregatesFilter<"viral_config"> | string
    value?: JsonWithAggregatesFilter<"viral_config">
    description?: StringNullableWithAggregatesFilter<"viral_config"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"viral_config"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"viral_config"> | Date | string | null
  }

  export type viral_opportunitiesWhereInput = {
    AND?: viral_opportunitiesWhereInput | viral_opportunitiesWhereInput[]
    OR?: viral_opportunitiesWhereInput[]
    NOT?: viral_opportunitiesWhereInput | viral_opportunitiesWhereInput[]
    id?: UuidFilter<"viral_opportunities"> | string
    topic?: StringFilter<"viral_opportunities"> | string
    platform?: StringFilter<"viral_opportunities"> | string
    viral_score?: FloatFilter<"viral_opportunities"> | number
    time_window?: IntFilter<"viral_opportunities"> | number
    angle?: StringFilter<"viral_opportunities"> | string
    keywords?: StringNullableListFilter<"viral_opportunities">
    source_data?: JsonNullableFilter<"viral_opportunities">
    status?: StringFilter<"viral_opportunities"> | string
    analyzed_at?: DateTimeFilter<"viral_opportunities"> | Date | string
    created_at?: DateTimeNullableFilter<"viral_opportunities"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_opportunities"> | Date | string | null
    viral_posts?: Viral_postsListRelationFilter
  }

  export type viral_opportunitiesOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    platform?: SortOrder
    viral_score?: SortOrder
    time_window?: SortOrder
    angle?: SortOrder
    keywords?: SortOrder
    source_data?: SortOrderInput | SortOrder
    status?: SortOrder
    analyzed_at?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    viral_posts?: viral_postsOrderByRelationAggregateInput
  }

  export type viral_opportunitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: viral_opportunitiesWhereInput | viral_opportunitiesWhereInput[]
    OR?: viral_opportunitiesWhereInput[]
    NOT?: viral_opportunitiesWhereInput | viral_opportunitiesWhereInput[]
    topic?: StringFilter<"viral_opportunities"> | string
    platform?: StringFilter<"viral_opportunities"> | string
    viral_score?: FloatFilter<"viral_opportunities"> | number
    time_window?: IntFilter<"viral_opportunities"> | number
    angle?: StringFilter<"viral_opportunities"> | string
    keywords?: StringNullableListFilter<"viral_opportunities">
    source_data?: JsonNullableFilter<"viral_opportunities">
    status?: StringFilter<"viral_opportunities"> | string
    analyzed_at?: DateTimeFilter<"viral_opportunities"> | Date | string
    created_at?: DateTimeNullableFilter<"viral_opportunities"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_opportunities"> | Date | string | null
    viral_posts?: Viral_postsListRelationFilter
  }, "id">

  export type viral_opportunitiesOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    platform?: SortOrder
    viral_score?: SortOrder
    time_window?: SortOrder
    angle?: SortOrder
    keywords?: SortOrder
    source_data?: SortOrderInput | SortOrder
    status?: SortOrder
    analyzed_at?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: viral_opportunitiesCountOrderByAggregateInput
    _avg?: viral_opportunitiesAvgOrderByAggregateInput
    _max?: viral_opportunitiesMaxOrderByAggregateInput
    _min?: viral_opportunitiesMinOrderByAggregateInput
    _sum?: viral_opportunitiesSumOrderByAggregateInput
  }

  export type viral_opportunitiesScalarWhereWithAggregatesInput = {
    AND?: viral_opportunitiesScalarWhereWithAggregatesInput | viral_opportunitiesScalarWhereWithAggregatesInput[]
    OR?: viral_opportunitiesScalarWhereWithAggregatesInput[]
    NOT?: viral_opportunitiesScalarWhereWithAggregatesInput | viral_opportunitiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"viral_opportunities"> | string
    topic?: StringWithAggregatesFilter<"viral_opportunities"> | string
    platform?: StringWithAggregatesFilter<"viral_opportunities"> | string
    viral_score?: FloatWithAggregatesFilter<"viral_opportunities"> | number
    time_window?: IntWithAggregatesFilter<"viral_opportunities"> | number
    angle?: StringWithAggregatesFilter<"viral_opportunities"> | string
    keywords?: StringNullableListFilter<"viral_opportunities">
    source_data?: JsonNullableWithAggregatesFilter<"viral_opportunities">
    status?: StringWithAggregatesFilter<"viral_opportunities"> | string
    analyzed_at?: DateTimeWithAggregatesFilter<"viral_opportunities"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"viral_opportunities"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"viral_opportunities"> | Date | string | null
  }

  export type viral_post_performanceWhereInput = {
    AND?: viral_post_performanceWhereInput | viral_post_performanceWhereInput[]
    OR?: viral_post_performanceWhereInput[]
    NOT?: viral_post_performanceWhereInput | viral_post_performanceWhereInput[]
    id?: UuidFilter<"viral_post_performance"> | string
    post_id?: UuidFilter<"viral_post_performance"> | string
    impressions_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    likes_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    retweets_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    comments_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    impressions_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    likes_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    retweets_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    comments_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    impressions_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    likes_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    retweets_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    comments_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    followers_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    engagement_rate?: FloatNullableFilter<"viral_post_performance"> | number | null
    viral_coefficient?: FloatNullableFilter<"viral_post_performance"> | number | null
    created_at?: DateTimeNullableFilter<"viral_post_performance"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_post_performance"> | Date | string | null
    viral_posts?: XOR<Viral_postsScalarRelationFilter, viral_postsWhereInput>
  }

  export type viral_post_performanceOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrder
    impressions_30m?: SortOrderInput | SortOrder
    likes_30m?: SortOrderInput | SortOrder
    retweets_30m?: SortOrderInput | SortOrder
    comments_30m?: SortOrderInput | SortOrder
    impressions_1h?: SortOrderInput | SortOrder
    likes_1h?: SortOrderInput | SortOrder
    retweets_1h?: SortOrderInput | SortOrder
    comments_1h?: SortOrderInput | SortOrder
    impressions_24h?: SortOrderInput | SortOrder
    likes_24h?: SortOrderInput | SortOrder
    retweets_24h?: SortOrderInput | SortOrder
    comments_24h?: SortOrderInput | SortOrder
    followers_24h?: SortOrderInput | SortOrder
    engagement_rate?: SortOrderInput | SortOrder
    viral_coefficient?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    viral_posts?: viral_postsOrderByWithRelationInput
  }

  export type viral_post_performanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    post_id?: string
    AND?: viral_post_performanceWhereInput | viral_post_performanceWhereInput[]
    OR?: viral_post_performanceWhereInput[]
    NOT?: viral_post_performanceWhereInput | viral_post_performanceWhereInput[]
    impressions_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    likes_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    retweets_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    comments_30m?: IntNullableFilter<"viral_post_performance"> | number | null
    impressions_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    likes_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    retweets_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    comments_1h?: IntNullableFilter<"viral_post_performance"> | number | null
    impressions_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    likes_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    retweets_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    comments_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    followers_24h?: IntNullableFilter<"viral_post_performance"> | number | null
    engagement_rate?: FloatNullableFilter<"viral_post_performance"> | number | null
    viral_coefficient?: FloatNullableFilter<"viral_post_performance"> | number | null
    created_at?: DateTimeNullableFilter<"viral_post_performance"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_post_performance"> | Date | string | null
    viral_posts?: XOR<Viral_postsScalarRelationFilter, viral_postsWhereInput>
  }, "id" | "post_id">

  export type viral_post_performanceOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrder
    impressions_30m?: SortOrderInput | SortOrder
    likes_30m?: SortOrderInput | SortOrder
    retweets_30m?: SortOrderInput | SortOrder
    comments_30m?: SortOrderInput | SortOrder
    impressions_1h?: SortOrderInput | SortOrder
    likes_1h?: SortOrderInput | SortOrder
    retweets_1h?: SortOrderInput | SortOrder
    comments_1h?: SortOrderInput | SortOrder
    impressions_24h?: SortOrderInput | SortOrder
    likes_24h?: SortOrderInput | SortOrder
    retweets_24h?: SortOrderInput | SortOrder
    comments_24h?: SortOrderInput | SortOrder
    followers_24h?: SortOrderInput | SortOrder
    engagement_rate?: SortOrderInput | SortOrder
    viral_coefficient?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: viral_post_performanceCountOrderByAggregateInput
    _avg?: viral_post_performanceAvgOrderByAggregateInput
    _max?: viral_post_performanceMaxOrderByAggregateInput
    _min?: viral_post_performanceMinOrderByAggregateInput
    _sum?: viral_post_performanceSumOrderByAggregateInput
  }

  export type viral_post_performanceScalarWhereWithAggregatesInput = {
    AND?: viral_post_performanceScalarWhereWithAggregatesInput | viral_post_performanceScalarWhereWithAggregatesInput[]
    OR?: viral_post_performanceScalarWhereWithAggregatesInput[]
    NOT?: viral_post_performanceScalarWhereWithAggregatesInput | viral_post_performanceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"viral_post_performance"> | string
    post_id?: UuidWithAggregatesFilter<"viral_post_performance"> | string
    impressions_30m?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    likes_30m?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    retweets_30m?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    comments_30m?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    impressions_1h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    likes_1h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    retweets_1h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    comments_1h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    impressions_24h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    likes_24h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    retweets_24h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    comments_24h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    followers_24h?: IntNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    engagement_rate?: FloatNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    viral_coefficient?: FloatNullableWithAggregatesFilter<"viral_post_performance"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"viral_post_performance"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"viral_post_performance"> | Date | string | null
  }

  export type viral_postsWhereInput = {
    AND?: viral_postsWhereInput | viral_postsWhereInput[]
    OR?: viral_postsWhereInput[]
    NOT?: viral_postsWhereInput | viral_postsWhereInput[]
    id?: UuidFilter<"viral_posts"> | string
    opportunity_id?: UuidFilter<"viral_posts"> | string
    concept_type?: StringFilter<"viral_posts"> | string
    content?: StringFilter<"viral_posts"> | string
    thread_content?: JsonNullableFilter<"viral_posts">
    visual_guide?: StringNullableFilter<"viral_posts"> | string | null
    hashtags?: StringNullableListFilter<"viral_posts">
    post_type?: StringFilter<"viral_posts"> | string
    platform?: StringFilter<"viral_posts"> | string
    scheduled_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    posted_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    post_url?: StringNullableFilter<"viral_posts"> | string | null
    created_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    viral_post_performance?: XOR<Viral_post_performanceNullableScalarRelationFilter, viral_post_performanceWhereInput> | null
    viral_opportunities?: XOR<Viral_opportunitiesScalarRelationFilter, viral_opportunitiesWhereInput>
  }

  export type viral_postsOrderByWithRelationInput = {
    id?: SortOrder
    opportunity_id?: SortOrder
    concept_type?: SortOrder
    content?: SortOrder
    thread_content?: SortOrderInput | SortOrder
    visual_guide?: SortOrderInput | SortOrder
    hashtags?: SortOrder
    post_type?: SortOrder
    platform?: SortOrder
    scheduled_at?: SortOrderInput | SortOrder
    posted_at?: SortOrderInput | SortOrder
    post_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    viral_post_performance?: viral_post_performanceOrderByWithRelationInput
    viral_opportunities?: viral_opportunitiesOrderByWithRelationInput
  }

  export type viral_postsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: viral_postsWhereInput | viral_postsWhereInput[]
    OR?: viral_postsWhereInput[]
    NOT?: viral_postsWhereInput | viral_postsWhereInput[]
    opportunity_id?: UuidFilter<"viral_posts"> | string
    concept_type?: StringFilter<"viral_posts"> | string
    content?: StringFilter<"viral_posts"> | string
    thread_content?: JsonNullableFilter<"viral_posts">
    visual_guide?: StringNullableFilter<"viral_posts"> | string | null
    hashtags?: StringNullableListFilter<"viral_posts">
    post_type?: StringFilter<"viral_posts"> | string
    platform?: StringFilter<"viral_posts"> | string
    scheduled_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    posted_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    post_url?: StringNullableFilter<"viral_posts"> | string | null
    created_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    viral_post_performance?: XOR<Viral_post_performanceNullableScalarRelationFilter, viral_post_performanceWhereInput> | null
    viral_opportunities?: XOR<Viral_opportunitiesScalarRelationFilter, viral_opportunitiesWhereInput>
  }, "id">

  export type viral_postsOrderByWithAggregationInput = {
    id?: SortOrder
    opportunity_id?: SortOrder
    concept_type?: SortOrder
    content?: SortOrder
    thread_content?: SortOrderInput | SortOrder
    visual_guide?: SortOrderInput | SortOrder
    hashtags?: SortOrder
    post_type?: SortOrder
    platform?: SortOrder
    scheduled_at?: SortOrderInput | SortOrder
    posted_at?: SortOrderInput | SortOrder
    post_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: viral_postsCountOrderByAggregateInput
    _max?: viral_postsMaxOrderByAggregateInput
    _min?: viral_postsMinOrderByAggregateInput
  }

  export type viral_postsScalarWhereWithAggregatesInput = {
    AND?: viral_postsScalarWhereWithAggregatesInput | viral_postsScalarWhereWithAggregatesInput[]
    OR?: viral_postsScalarWhereWithAggregatesInput[]
    NOT?: viral_postsScalarWhereWithAggregatesInput | viral_postsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"viral_posts"> | string
    opportunity_id?: UuidWithAggregatesFilter<"viral_posts"> | string
    concept_type?: StringWithAggregatesFilter<"viral_posts"> | string
    content?: StringWithAggregatesFilter<"viral_posts"> | string
    thread_content?: JsonNullableWithAggregatesFilter<"viral_posts">
    visual_guide?: StringNullableWithAggregatesFilter<"viral_posts"> | string | null
    hashtags?: StringNullableListFilter<"viral_posts">
    post_type?: StringWithAggregatesFilter<"viral_posts"> | string
    platform?: StringWithAggregatesFilter<"viral_posts"> | string
    scheduled_at?: DateTimeNullableWithAggregatesFilter<"viral_posts"> | Date | string | null
    posted_at?: DateTimeNullableWithAggregatesFilter<"viral_posts"> | Date | string | null
    post_url?: StringNullableWithAggregatesFilter<"viral_posts"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"viral_posts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"viral_posts"> | Date | string | null
  }

  export type BuzzPostCreateInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
    scheduledPosts?: ScheduledPostCreateNestedManyWithoutRefPostInput
  }

  export type BuzzPostUncheckedCreateInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
    scheduledPosts?: ScheduledPostUncheckedCreateNestedManyWithoutRefPostInput
  }

  export type BuzzPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduledPosts?: ScheduledPostUpdateManyWithoutRefPostNestedInput
  }

  export type BuzzPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduledPosts?: ScheduledPostUncheckedUpdateManyWithoutRefPostNestedInput
  }

  export type BuzzPostCreateManyInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzConfigCreateInput = {
    id: string
    keywords?: BuzzConfigCreatekeywordsInput | string[]
    accounts?: BuzzConfigCreateaccountsInput | string[]
    minEngagement?: number
    minImpressions?: number
    collectInterval?: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzConfigUncheckedCreateInput = {
    id: string
    keywords?: BuzzConfigCreatekeywordsInput | string[]
    accounts?: BuzzConfigCreateaccountsInput | string[]
    minEngagement?: number
    minImpressions?: number
    collectInterval?: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzConfigCreateManyInput = {
    id: string
    keywords?: BuzzConfigCreatekeywordsInput | string[]
    accounts?: BuzzConfigCreateaccountsInput | string[]
    minEngagement?: number
    minImpressions?: number
    collectInterval?: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywords?: BuzzConfigUpdatekeywordsInput | string[]
    accounts?: BuzzConfigUpdateaccountsInput | string[]
    minEngagement?: IntFieldUpdateOperationsInput | number
    minImpressions?: IntFieldUpdateOperationsInput | number
    collectInterval?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostCreateInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post_analytics?: PostAnalyticsCreateNestedManyWithoutScheduled_postsInput
    refPost?: BuzzPostCreateNestedOneWithoutScheduledPostsInput
  }

  export type ScheduledPostUncheckedCreateInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post_analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutScheduled_postsInput
  }

  export type ScheduledPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_analytics?: PostAnalyticsUpdateManyWithoutScheduled_postsNestedInput
    refPost?: BuzzPostUpdateOneWithoutScheduledPostsNestedInput
  }

  export type ScheduledPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_analytics?: PostAnalyticsUncheckedUpdateManyWithoutScheduled_postsNestedInput
  }

  export type ScheduledPostCreateManyInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateInput = {
    id?: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at?: Date | string
    engagementRate: number
    ai_analysis?: string | null
    scheduled_posts: ScheduledPostCreateNestedOneWithoutPost_analyticsInput
  }

  export type PostAnalyticsUncheckedCreateInput = {
    id?: string
    scheduled_post_id: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at?: Date | string
    engagementRate: number
    ai_analysis?: string | null
  }

  export type PostAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_posts?: ScheduledPostUpdateOneRequiredWithoutPost_analyticsNestedInput
  }

  export type PostAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_post_id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostAnalyticsCreateManyInput = {
    id?: string
    scheduled_post_id: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at?: Date | string
    engagementRate: number
    ai_analysis?: string | null
  }

  export type PostAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_post_id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: accountsCreateNestedManyWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: accountsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUpdateManyWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    created_at?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    created_at?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    category: string
    active?: boolean
    createdAt?: Date | string
    articles?: NewsArticleCreateNestedManyWithoutSourceInput
  }

  export type NewsSourceUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    category: string
    active?: boolean
    createdAt?: Date | string
    articles?: NewsArticleUncheckedCreateNestedManyWithoutSourceInput
  }

  export type NewsSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: NewsArticleUpdateManyWithoutSourceNestedInput
  }

  export type NewsSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: NewsArticleUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type NewsSourceCreateManyInput = {
    id?: string
    name: string
    url: string
    type: string
    category: string
    active?: boolean
    createdAt?: Date | string
  }

  export type NewsSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleCreateInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    news_analysis_results?: news_analysis_resultsCreateNestedManyWithoutNews_articlesInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateInput = {
    id?: string
    sourceId: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    news_analysis_results?: news_analysis_resultsUncheckedCreateNestedManyWithoutNews_articlesInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    news_analysis_results?: news_analysis_resultsUpdateManyWithoutNews_articlesNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    news_analysis_results?: news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleCreateManyInput = {
    id?: string
    sourceId: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsThreadCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
    items?: NewsThreadItemCreateNestedManyWithoutThreadInput
  }

  export type NewsThreadUncheckedCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
    items?: NewsThreadItemUncheckedCreateNestedManyWithoutThreadInput
  }

  export type NewsThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: NewsThreadItemUpdateManyWithoutThreadNestedInput
  }

  export type NewsThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: NewsThreadItemUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type NewsThreadCreateManyInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadItemCreateInput = {
    id?: string
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
    article?: NewsArticleCreateNestedOneWithoutNewsThreadItemsInput
    thread: NewsThreadCreateNestedOneWithoutItemsInput
  }

  export type NewsThreadItemUncheckedCreateInput = {
    id?: string
    threadId: string
    articleId?: string | null
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type NewsThreadItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    article?: NewsArticleUpdateOneWithoutNewsThreadItemsNestedInput
    thread?: NewsThreadUpdateOneRequiredWithoutItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type NewsThreadItemCreateManyInput = {
    id?: string
    threadId: string
    articleId?: string | null
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type NewsThreadItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type NewsThreadItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type NewsAnalysisCreateInput = {
    id?: string
    category: string
    summary: string
    japanese_summary: string
    key_points?: NewsAnalysisCreatekey_pointsInput | string[]
    impact: string
    analyzed_by: string
    createdAt?: Date | string
    updated_at: Date | string
    article: NewsArticleCreateNestedOneWithoutAnalysisInput
  }

  export type NewsAnalysisUncheckedCreateInput = {
    id?: string
    articleId: string
    category: string
    summary: string
    japanese_summary: string
    key_points?: NewsAnalysisCreatekey_pointsInput | string[]
    impact: string
    analyzed_by: string
    createdAt?: Date | string
    updated_at: Date | string
  }

  export type NewsAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    japanese_summary?: StringFieldUpdateOperationsInput | string
    key_points?: NewsAnalysisUpdatekey_pointsInput | string[]
    impact?: StringFieldUpdateOperationsInput | string
    analyzed_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: NewsArticleUpdateOneRequiredWithoutAnalysisNestedInput
  }

  export type NewsAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    japanese_summary?: StringFieldUpdateOperationsInput | string
    key_points?: NewsAnalysisUpdatekey_pointsInput | string[]
    impact?: StringFieldUpdateOperationsInput | string
    analyzed_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisCreateManyInput = {
    id?: string
    articleId: string
    category: string
    summary: string
    japanese_summary: string
    key_points?: NewsAnalysisCreatekey_pointsInput | string[]
    impact: string
    analyzed_by: string
    createdAt?: Date | string
    updated_at: Date | string
  }

  export type NewsAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    japanese_summary?: StringFieldUpdateOperationsInput | string
    key_points?: NewsAnalysisUpdatekey_pointsInput | string[]
    impact?: StringFieldUpdateOperationsInput | string
    analyzed_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    japanese_summary?: StringFieldUpdateOperationsInput | string
    key_points?: NewsAnalysisUpdatekey_pointsInput | string[]
    impact?: StringFieldUpdateOperationsInput | string
    analyzed_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueCreateInput = {
    id?: string
    type: string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    progress?: number
    total?: number | null
    started_at?: Date | string | null
    ended_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUncheckedCreateInput = {
    id?: string
    type: string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    progress?: number
    total?: number | null
    started_at?: Date | string | null
    ended_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    total?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    total?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueCreateManyInput = {
    id?: string
    type: string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    progress?: number
    total?: number | null
    started_at?: Date | string | null
    ended_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    total?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    total?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTaskCreateInput = {
    id?: string
    type: string
    sessionId: string
    phase_number: number
    step_name: string
    request: JsonNullValueInput | InputJsonValue
    status?: string
    retry_count?: number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    taskType?: string
  }

  export type ApiTaskUncheckedCreateInput = {
    id?: string
    type: string
    sessionId: string
    phase_number: number
    step_name: string
    request: JsonNullValueInput | InputJsonValue
    status?: string
    retry_count?: number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    taskType?: string
  }

  export type ApiTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phase_number?: IntFieldUpdateOperationsInput | number
    step_name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
  }

  export type ApiTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phase_number?: IntFieldUpdateOperationsInput | number
    step_name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
  }

  export type ApiTaskCreateManyInput = {
    id?: string
    type: string
    sessionId: string
    phase_number: number
    step_name: string
    request: JsonNullValueInput | InputJsonValue
    status?: string
    retry_count?: number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    taskType?: string
  }

  export type ApiTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phase_number?: IntFieldUpdateOperationsInput | number
    step_name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
  }

  export type ApiTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phase_number?: IntFieldUpdateOperationsInput | number
    step_name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
  }

  export type CollectionPresetCreateInput = {
    id?: string
    name: string
    description?: string | null
    query: string
    keywords?: CollectionPresetCreatekeywordsInput | string[]
    minLikes?: number
    minRetweets?: number
    language?: string
    category: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    query: string
    keywords?: CollectionPresetCreatekeywordsInput | string[]
    minLikes?: number
    minRetweets?: number
    language?: string
    category: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    keywords?: CollectionPresetUpdatekeywordsInput | string[]
    minLikes?: IntFieldUpdateOperationsInput | number
    minRetweets?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    keywords?: CollectionPresetUpdatekeywordsInput | string[]
    minLikes?: IntFieldUpdateOperationsInput | number
    minRetweets?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    query: string
    keywords?: CollectionPresetCreatekeywordsInput | string[]
    minLikes?: number
    minRetweets?: number
    language?: string
    category: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    keywords?: CollectionPresetUpdatekeywordsInput | string[]
    minLikes?: IntFieldUpdateOperationsInput | number
    minRetweets?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    keywords?: CollectionPresetUpdatekeywordsInput | string[]
    minLikes?: IntFieldUpdateOperationsInput | number
    minRetweets?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserCreateInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
    user: UserCreateNestedOneWithoutWatchlistUsersInput
  }

  export type WatchlistUserUncheckedCreateInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    userId: string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
  }

  export type WatchlistUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserCreateManyInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    userId: string
  }

  export type WatchlistUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchlistUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WatchlistTweetCreateInput = {
    id?: string
    tweetId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied?: boolean
    has_quoted?: boolean
    posted_at: Date | string
    collectedAt?: Date | string
    url: string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
    watchlistUser: WatchlistUserCreateNestedOneWithoutTweetsInput
  }

  export type WatchlistTweetUncheckedCreateInput = {
    id?: string
    tweetId: string
    watchlistUserId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied?: boolean
    has_quoted?: boolean
    posted_at: Date | string
    collectedAt?: Date | string
    url: string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
    watchlistUser?: WatchlistUserUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type WatchlistTweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetCreateManyInput = {
    id?: string
    tweetId: string
    watchlistUserId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied?: boolean
    has_quoted?: boolean
    posted_at: Date | string
    collectedAt?: Date | string
    url: string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InteractionHistoryCreateInput = {
    id?: string
    type: string
    source_tweet_id: string
    target_tweet_id?: string | null
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionHistoryUncheckedCreateInput = {
    id?: string
    type: string
    source_tweet_id: string
    target_tweet_id?: string | null
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source_tweet_id?: StringFieldUpdateOperationsInput | string
    target_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source_tweet_id?: StringFieldUpdateOperationsInput | string
    target_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryCreateManyInput = {
    id?: string
    type: string
    source_tweet_id: string
    target_tweet_id?: string | null
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source_tweet_id?: StringFieldUpdateOperationsInput | string
    target_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source_tweet_id?: StringFieldUpdateOperationsInput | string
    target_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportCreateInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    personal_angles: JsonNullValueInput | InputJsonValue
    buzz_prediction: number
    recommendations: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUncheckedCreateInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    personal_angles: JsonNullValueInput | InputJsonValue
    buzz_prediction: number
    recommendations: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    personal_angles?: JsonNullValueInput | InputJsonValue
    buzz_prediction?: FloatFieldUpdateOperationsInput | number
    recommendations?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    personal_angles?: JsonNullValueInput | InputJsonValue
    buzz_prediction?: FloatFieldUpdateOperationsInput | number
    recommendations?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportCreateManyInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    personal_angles: JsonNullValueInput | InputJsonValue
    buzz_prediction: number
    recommendations: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    personal_angles?: JsonNullValueInput | InputJsonValue
    buzz_prediction?: FloatFieldUpdateOperationsInput | number
    recommendations?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    personal_angles?: JsonNullValueInput | InputJsonValue
    buzz_prediction?: FloatFieldUpdateOperationsInput | number
    recommendations?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotSessionCreateInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftCreateNestedManyWithoutSessionInput
    phases?: CotPhaseCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftUncheckedCreateNestedManyWithoutSessionInput
    phases?: CotPhaseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftUpdateManyWithoutSessionNestedInput
    phases?: CotPhaseUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftUncheckedUpdateManyWithoutSessionNestedInput
    phases?: CotPhaseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionCreateManyInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CotSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CotSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CotPhaseCreateInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutPhasesInput
  }

  export type CotPhaseUncheckedCreateInput = {
    id?: string
    sessionId: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type CotPhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseCreateManyInput = {
    id?: string
    sessionId: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftCreateInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
    session: CotSessionCreateNestedOneWithoutDraftsInput
  }

  export type CotDraftUncheckedCreateInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type CotDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type CotDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftCreateManyInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceCreateInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
    draft: CotDraftCreateNestedOneWithoutPerformanceInput
  }

  export type CotDraftPerformanceUncheckedCreateInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: CotDraftUpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type CotDraftPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceCreateManyInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetCreateInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUncheckedCreateInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetCreateManyInput = {
    id?: string
    originalPostId: string
    originalContent: string
    scheduledAt: Date | string
    status?: $Enums.RTStatus
    rtStrategy: string
    addComment?: boolean
    commentText?: string | null
    viralDraftId?: string | null
    cotDraftId?: string | null
    executedAt?: Date | string | null
    rtPostId?: string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledRetweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRetweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    originalContent?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRTStatusFieldUpdateOperationsInput | $Enums.RTStatus
    rtStrategy?: StringFieldUpdateOperationsInput | string
    addComment?: BoolFieldUpdateOperationsInput | boolean
    commentText?: NullableStringFieldUpdateOperationsInput | string | null
    viralDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    cotDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rtPostId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceCreateInput = {
    id?: string
    contentId: string
    contentType: string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedPerformanceUncheckedCreateInput = {
    id?: string
    contentId: string
    contentType: string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceCreateManyInput = {
    id?: string
    contentId: string
    contentType: string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    metrics30m?: NullableJsonNullValueInput | InputJsonValue
    metrics1h?: NullableJsonNullValueInput | InputJsonValue
    metrics24h?: NullableJsonNullValueInput | InputJsonValue
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationCreateInput = {
    id?: string
    newsId: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationUncheckedCreateInput = {
    id?: string
    newsId: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationCreateManyInput = {
    id?: string
    newsId: string
    sessionId: string
    relevanceScore?: number | null
    usedInContent?: boolean
    createdAt?: Date | string
  }

  export type NewsViralRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsViralRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    usedInContent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogCreateInput = {
    id?: string
    sessionId: string
    sessionType: string
    activityType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionActivityLogUncheckedCreateInput = {
    id?: string
    sessionId: string
    sessionType: string
    activityType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogCreateManyInput = {
    id?: string
    sessionId: string
    sessionType: string
    activityType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage?: string | null
    stackTrace?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApiErrorLogUncheckedCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage?: string | null
    stackTrace?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApiErrorLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogCreateManyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    errorMessage?: string | null
    stackTrace?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApiErrorLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralSessionCreateInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    drafts?: ViralDraftV2CreateNestedManyWithoutSessionInput
  }

  export type ViralSessionUncheckedCreateInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: string | null
    voiceStyleMode?: string | null
    drafts?: ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput
  }

  export type ViralSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    drafts?: ViralDraftV2UpdateManyWithoutSessionNestedInput
  }

  export type ViralSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
    drafts?: ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ViralSessionCreateManyInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: string | null
    voiceStyleMode?: string | null
  }

  export type ViralSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViralSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViralDraftV2CreateInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
    performance?: ViralDraftPerformanceCreateNestedOneWithoutDraftInput
    session: ViralSessionCreateNestedOneWithoutDraftsInput
  }

  export type ViralDraftV2UncheckedCreateInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
    performance?: ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type ViralDraftV2UpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
    performance?: ViralDraftPerformanceUpdateOneWithoutDraftNestedInput
    session?: ViralSessionUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type ViralDraftV2UncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
    performance?: ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type ViralDraftV2CreateManyInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
  }

  export type ViralDraftV2UpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViralDraftV2UncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViralDraftPerformanceCreateInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
    draft: ViralDraftV2CreateNestedOneWithoutPerformanceInput
  }

  export type ViralDraftPerformanceUncheckedCreateInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: ViralDraftV2UpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type ViralDraftPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceCreateManyInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterProfileCreateInput = {
    id?: string
    name: string
    display_name: string
    age: number
    gender: $Enums.Gender
    occupation: string
    catchphrase: string
    personality: string
    speaking_style: string
    expertise: string
    backstory: string
    philosophy?: string | null
    tone: string
    voiceStyle: JsonNullValueInput | InputJsonValue
    emoji_style: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUncheckedCreateInput = {
    id?: string
    name: string
    display_name: string
    age: number
    gender: $Enums.Gender
    occupation: string
    catchphrase: string
    personality: string
    speaking_style: string
    expertise: string
    backstory: string
    philosophy?: string | null
    tone: string
    voiceStyle: JsonNullValueInput | InputJsonValue
    emoji_style: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    occupation?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    speaking_style?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    voiceStyle?: JsonNullValueInput | InputJsonValue
    emoji_style?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    occupation?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    speaking_style?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    voiceStyle?: JsonNullValueInput | InputJsonValue
    emoji_style?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileCreateManyInput = {
    id?: string
    name: string
    display_name: string
    age: number
    gender: $Enums.Gender
    occupation: string
    catchphrase: string
    personality: string
    speaking_style: string
    expertise: string
    backstory: string
    philosophy?: string | null
    tone: string
    voiceStyle: JsonNullValueInput | InputJsonValue
    emoji_style: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredNewsCategories?: CharacterProfileCreatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    occupation?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    speaking_style?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    voiceStyle?: JsonNullValueInput | InputJsonValue
    emoji_style?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CharacterProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    occupation?: StringFieldUpdateOperationsInput | string
    catchphrase?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    speaking_style?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    philosophy?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    voiceStyle?: JsonNullValueInput | InputJsonValue
    emoji_style?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredNewsCategories?: CharacterProfileUpdatepreferredNewsCategoriesInput | string[]
    newsCommentStyle?: NullableJsonNullValueInput | InputJsonValue
    topicExpertise?: NullableJsonNullValueInput | InputJsonValue
  }

  export type accountsCreateInput = {
    id?: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    users: UserCreateNestedOneWithoutAccountsInput
  }

  export type accountsUncheckedCreateInput = {
    id?: string
    user_id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type accountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountsCreateManyInput = {
    id?: string
    user_id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type accountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ai_patternsCreateInput = {
    id: string
    name: string
    description: string
    prompt_template: string
    example_output: string
    success_rate?: number
    usage_count?: number
    created_at?: Date | string
  }

  export type ai_patternsUncheckedCreateInput = {
    id: string
    name: string
    description: string
    prompt_template: string
    example_output: string
    success_rate?: number
    usage_count?: number
    created_at?: Date | string
  }

  export type ai_patternsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prompt_template?: StringFieldUpdateOperationsInput | string
    example_output?: StringFieldUpdateOperationsInput | string
    success_rate?: FloatFieldUpdateOperationsInput | number
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_patternsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prompt_template?: StringFieldUpdateOperationsInput | string
    example_output?: StringFieldUpdateOperationsInput | string
    success_rate?: FloatFieldUpdateOperationsInput | number
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_patternsCreateManyInput = {
    id: string
    name: string
    description: string
    prompt_template: string
    example_output: string
    success_rate?: number
    usage_count?: number
    created_at?: Date | string
  }

  export type ai_patternsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prompt_template?: StringFieldUpdateOperationsInput | string
    example_output?: StringFieldUpdateOperationsInput | string
    success_rate?: FloatFieldUpdateOperationsInput | number
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_patternsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prompt_template?: StringFieldUpdateOperationsInput | string
    example_output?: StringFieldUpdateOperationsInput | string
    success_rate?: FloatFieldUpdateOperationsInput | number
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type content_draftsCreateInput = {
    id?: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content?: string | null
    explanation?: string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    platform?: string | null
    format?: string | null
    status?: string | null
    editor_notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    gpt_analyses: gpt_analysesCreateNestedOneWithoutContent_draftsInput
  }

  export type content_draftsUncheckedCreateInput = {
    id?: string
    analysis_id: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content?: string | null
    explanation?: string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    platform?: string | null
    format?: string | null
    status?: string | null
    editor_notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type content_draftsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gpt_analyses?: gpt_analysesUpdateOneRequiredWithoutContent_draftsNestedInput
  }

  export type content_draftsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type content_draftsCreateManyInput = {
    id?: string
    analysis_id: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content?: string | null
    explanation?: string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    platform?: string | null
    format?: string | null
    status?: string | null
    editor_notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type content_draftsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type content_draftsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gpt_analysesCreateInput = {
    id?: string
    analysis_type: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_drafts?: content_draftsCreateNestedManyWithoutGpt_analysesInput
  }

  export type gpt_analysesUncheckedCreateInput = {
    id?: string
    analysis_type: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_drafts?: content_draftsUncheckedCreateNestedManyWithoutGpt_analysesInput
  }

  export type gpt_analysesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_type?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_drafts?: content_draftsUpdateManyWithoutGpt_analysesNestedInput
  }

  export type gpt_analysesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_type?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_drafts?: content_draftsUncheckedUpdateManyWithoutGpt_analysesNestedInput
  }

  export type gpt_analysesCreateManyInput = {
    id?: string
    analysis_type: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gpt_analysesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_type?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gpt_analysesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_type?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_analysis_jobsCreateInput = {
    id?: string
    type: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    news_analysis_results?: news_analysis_resultsCreateNestedManyWithoutNews_analysis_jobsInput
  }

  export type news_analysis_jobsUncheckedCreateInput = {
    id?: string
    type: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    news_analysis_results?: news_analysis_resultsUncheckedCreateNestedManyWithoutNews_analysis_jobsInput
  }

  export type news_analysis_jobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    news_analysis_results?: news_analysis_resultsUpdateManyWithoutNews_analysis_jobsNestedInput
  }

  export type news_analysis_jobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    news_analysis_results?: news_analysis_resultsUncheckedUpdateManyWithoutNews_analysis_jobsNestedInput
  }

  export type news_analysis_jobsCreateManyInput = {
    id?: string
    type: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type news_analysis_jobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_jobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_resultsCreateInput = {
    id?: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    news_articles: NewsArticleCreateNestedOneWithoutNews_analysis_resultsInput
    news_analysis_jobs: news_analysis_jobsCreateNestedOneWithoutNews_analysis_resultsInput
  }

  export type news_analysis_resultsUncheckedCreateInput = {
    id?: string
    job_id: string
    article_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type news_analysis_resultsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    news_articles?: NewsArticleUpdateOneRequiredWithoutNews_analysis_resultsNestedInput
    news_analysis_jobs?: news_analysis_jobsUpdateOneRequiredWithoutNews_analysis_resultsNestedInput
  }

  export type news_analysis_resultsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_resultsCreateManyInput = {
    id?: string
    job_id: string
    article_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type news_analysis_resultsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_resultsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prompt_templatesCreateInput = {
    id?: string
    name: string
    type: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type prompt_templatesUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type prompt_templatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prompt_templatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prompt_templatesCreateManyInput = {
    id?: string
    name: string
    type: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type prompt_templatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prompt_templatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_analysis_logsCreateInput = {
    id?: string
    model: string
    phase: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    success: boolean
    error?: string | null
    created_at?: Date | string | null
  }

  export type viral_analysis_logsUncheckedCreateInput = {
    id?: string
    model: string
    phase: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    success: boolean
    error?: string | null
    created_at?: Date | string | null
  }

  export type viral_analysis_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_analysis_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_analysis_logsCreateManyInput = {
    id?: string
    model: string
    phase: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    success: boolean
    error?: string | null
    created_at?: Date | string | null
  }

  export type viral_analysis_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_analysis_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_configCreateInput = {
    id?: string
    key: string
    value?: JsonNullValueInput | InputJsonValue
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_configUncheckedCreateInput = {
    id?: string
    key: string
    value?: JsonNullValueInput | InputJsonValue
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_configUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_configUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_configCreateManyInput = {
    id?: string
    key: string
    value?: JsonNullValueInput | InputJsonValue
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_configUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_configUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_opportunitiesCreateInput = {
    id?: string
    topic: string
    platform: string
    viral_score: number
    time_window: number
    angle: string
    keywords?: viral_opportunitiesCreatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status: string
    analyzed_at: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_posts?: viral_postsCreateNestedManyWithoutViral_opportunitiesInput
  }

  export type viral_opportunitiesUncheckedCreateInput = {
    id?: string
    topic: string
    platform: string
    viral_score: number
    time_window: number
    angle: string
    keywords?: viral_opportunitiesCreatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status: string
    analyzed_at: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_posts?: viral_postsUncheckedCreateNestedManyWithoutViral_opportunitiesInput
  }

  export type viral_opportunitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    viral_score?: FloatFieldUpdateOperationsInput | number
    time_window?: IntFieldUpdateOperationsInput | number
    angle?: StringFieldUpdateOperationsInput | string
    keywords?: viral_opportunitiesUpdatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    analyzed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_posts?: viral_postsUpdateManyWithoutViral_opportunitiesNestedInput
  }

  export type viral_opportunitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    viral_score?: FloatFieldUpdateOperationsInput | number
    time_window?: IntFieldUpdateOperationsInput | number
    angle?: StringFieldUpdateOperationsInput | string
    keywords?: viral_opportunitiesUpdatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    analyzed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_posts?: viral_postsUncheckedUpdateManyWithoutViral_opportunitiesNestedInput
  }

  export type viral_opportunitiesCreateManyInput = {
    id?: string
    topic: string
    platform: string
    viral_score: number
    time_window: number
    angle: string
    keywords?: viral_opportunitiesCreatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status: string
    analyzed_at: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_opportunitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    viral_score?: FloatFieldUpdateOperationsInput | number
    time_window?: IntFieldUpdateOperationsInput | number
    angle?: StringFieldUpdateOperationsInput | string
    keywords?: viral_opportunitiesUpdatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    analyzed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_opportunitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    viral_score?: FloatFieldUpdateOperationsInput | number
    time_window?: IntFieldUpdateOperationsInput | number
    angle?: StringFieldUpdateOperationsInput | string
    keywords?: viral_opportunitiesUpdatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    analyzed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_post_performanceCreateInput = {
    id?: string
    impressions_30m?: number | null
    likes_30m?: number | null
    retweets_30m?: number | null
    comments_30m?: number | null
    impressions_1h?: number | null
    likes_1h?: number | null
    retweets_1h?: number | null
    comments_1h?: number | null
    impressions_24h?: number | null
    likes_24h?: number | null
    retweets_24h?: number | null
    comments_24h?: number | null
    followers_24h?: number | null
    engagement_rate?: number | null
    viral_coefficient?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_posts: viral_postsCreateNestedOneWithoutViral_post_performanceInput
  }

  export type viral_post_performanceUncheckedCreateInput = {
    id?: string
    post_id: string
    impressions_30m?: number | null
    likes_30m?: number | null
    retweets_30m?: number | null
    comments_30m?: number | null
    impressions_1h?: number | null
    likes_1h?: number | null
    retweets_1h?: number | null
    comments_1h?: number | null
    impressions_24h?: number | null
    likes_24h?: number | null
    retweets_24h?: number | null
    comments_24h?: number | null
    followers_24h?: number | null
    engagement_rate?: number | null
    viral_coefficient?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_post_performanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions_30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes_30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_30m?: NullableIntFieldUpdateOperationsInput | number | null
    comments_30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_1h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_24h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_24h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_24h?: NullableIntFieldUpdateOperationsInput | number | null
    followers_24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagement_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    viral_coefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_posts?: viral_postsUpdateOneRequiredWithoutViral_post_performanceNestedInput
  }

  export type viral_post_performanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: StringFieldUpdateOperationsInput | string
    impressions_30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes_30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_30m?: NullableIntFieldUpdateOperationsInput | number | null
    comments_30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_1h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_24h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_24h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_24h?: NullableIntFieldUpdateOperationsInput | number | null
    followers_24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagement_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    viral_coefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_post_performanceCreateManyInput = {
    id?: string
    post_id: string
    impressions_30m?: number | null
    likes_30m?: number | null
    retweets_30m?: number | null
    comments_30m?: number | null
    impressions_1h?: number | null
    likes_1h?: number | null
    retweets_1h?: number | null
    comments_1h?: number | null
    impressions_24h?: number | null
    likes_24h?: number | null
    retweets_24h?: number | null
    comments_24h?: number | null
    followers_24h?: number | null
    engagement_rate?: number | null
    viral_coefficient?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_post_performanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions_30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes_30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_30m?: NullableIntFieldUpdateOperationsInput | number | null
    comments_30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_1h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_24h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_24h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_24h?: NullableIntFieldUpdateOperationsInput | number | null
    followers_24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagement_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    viral_coefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_post_performanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: StringFieldUpdateOperationsInput | string
    impressions_30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes_30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_30m?: NullableIntFieldUpdateOperationsInput | number | null
    comments_30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_1h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_24h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_24h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_24h?: NullableIntFieldUpdateOperationsInput | number | null
    followers_24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagement_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    viral_coefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_postsCreateInput = {
    id?: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_post_performance?: viral_post_performanceCreateNestedOneWithoutViral_postsInput
    viral_opportunities: viral_opportunitiesCreateNestedOneWithoutViral_postsInput
  }

  export type viral_postsUncheckedCreateInput = {
    id?: string
    opportunity_id: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_post_performance?: viral_post_performanceUncheckedCreateNestedOneWithoutViral_postsInput
  }

  export type viral_postsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_post_performance?: viral_post_performanceUpdateOneWithoutViral_postsNestedInput
    viral_opportunities?: viral_opportunitiesUpdateOneRequiredWithoutViral_postsNestedInput
  }

  export type viral_postsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunity_id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_post_performance?: viral_post_performanceUncheckedUpdateOneWithoutViral_postsNestedInput
  }

  export type viral_postsCreateManyInput = {
    id?: string
    opportunity_id: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_postsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_postsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunity_id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ScheduledPostListRelationFilter = {
    every?: ScheduledPostWhereInput
    some?: ScheduledPostWhereInput
    none?: ScheduledPostWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ScheduledPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuzzPostCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostAvgOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
  }

  export type BuzzPostMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostSumOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BuzzConfigCountOrderByAggregateInput = {
    id?: SortOrder
    keywords?: SortOrder
    accounts?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigAvgOrderByAggregateInput = {
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
  }

  export type BuzzConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigMinOrderByAggregateInput = {
    id?: SortOrder
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuzzConfigSumOrderByAggregateInput = {
    minEngagement?: SortOrder
    minImpressions?: SortOrder
    collectInterval?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PostAnalyticsListRelationFilter = {
    every?: PostAnalyticsWhereInput
    some?: PostAnalyticsWhereInput
    none?: PostAnalyticsWhereInput
  }

  export type BuzzPostNullableScalarRelationFilter = {
    is?: BuzzPostWhereInput | null
    isNot?: BuzzPostWhereInput | null
  }

  export type PostAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledPostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    postResult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ScheduledPostScalarRelationFilter = {
    is?: ScheduledPostWhereInput
    isNot?: ScheduledPostWhereInput
  }

  export type PostAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    scheduled_post_id?: SortOrder
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    measured_at?: SortOrder
    engagementRate?: SortOrder
    ai_analysis?: SortOrder
  }

  export type PostAnalyticsAvgOrderByAggregateInput = {
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    engagementRate?: SortOrder
  }

  export type PostAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduled_post_id?: SortOrder
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    measured_at?: SortOrder
    engagementRate?: SortOrder
    ai_analysis?: SortOrder
  }

  export type PostAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    scheduled_post_id?: SortOrder
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    measured_at?: SortOrder
    engagementRate?: SortOrder
    ai_analysis?: SortOrder
  }

  export type PostAnalyticsSumOrderByAggregateInput = {
    impressions?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    link_clicks?: SortOrder
    engagementRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AccountsListRelationFilter = {
    every?: accountsWhereInput
    some?: accountsWhereInput
    none?: accountsWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type WatchlistUserListRelationFilter = {
    every?: WatchlistUserWhereInput
    some?: WatchlistUserWhereInput
    none?: WatchlistUserWhereInput
  }

  export type accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    created_at?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    created_at?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    created_at?: SortOrder
  }

  export type NewsArticleListRelationFilter = {
    every?: NewsArticleWhereInput
    some?: NewsArticleWhereInput
    none?: NewsArticleWhereInput
  }

  export type NewsArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsSourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NewsAnalysisNullableScalarRelationFilter = {
    is?: NewsAnalysisWhereInput | null
    isNot?: NewsAnalysisWhereInput | null
  }

  export type News_analysis_resultsListRelationFilter = {
    every?: news_analysis_resultsWhereInput
    some?: news_analysis_resultsWhereInput
    none?: news_analysis_resultsWhereInput
  }

  export type NewsSourceScalarRelationFilter = {
    is?: NewsSourceWhereInput
    isNot?: NewsSourceWhereInput
  }

  export type NewsThreadItemListRelationFilter = {
    every?: NewsThreadItemWhereInput
    some?: NewsThreadItemWhereInput
    none?: NewsThreadItemWhereInput
  }

  export type news_analysis_resultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsThreadItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsArticleCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type NewsArticleAvgOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type NewsArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleSumOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NewsThreadCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsArticleNullableScalarRelationFilter = {
    is?: NewsArticleWhereInput | null
    isNot?: NewsArticleWhereInput | null
  }

  export type NewsThreadScalarRelationFilter = {
    is?: NewsThreadWhereInput
    isNot?: NewsThreadWhereInput
  }

  export type NewsThreadItemCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    tweet_id?: SortOrder
    parent_tweet_id?: SortOrder
    posted_at?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    position?: SortOrder
  }

  export type NewsThreadItemAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type NewsThreadItemMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    tweet_id?: SortOrder
    parent_tweet_id?: SortOrder
    posted_at?: SortOrder
    content?: SortOrder
    position?: SortOrder
  }

  export type NewsThreadItemMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    tweet_id?: SortOrder
    parent_tweet_id?: SortOrder
    posted_at?: SortOrder
    content?: SortOrder
    position?: SortOrder
  }

  export type NewsThreadItemSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type NewsArticleScalarRelationFilter = {
    is?: NewsArticleWhereInput
    isNot?: NewsArticleWhereInput
  }

  export type NewsAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    japanese_summary?: SortOrder
    key_points?: SortOrder
    impact?: SortOrder
    analyzed_by?: SortOrder
    createdAt?: SortOrder
    updated_at?: SortOrder
  }

  export type NewsAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    japanese_summary?: SortOrder
    impact?: SortOrder
    analyzed_by?: SortOrder
    createdAt?: SortOrder
    updated_at?: SortOrder
  }

  export type NewsAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    japanese_summary?: SortOrder
    impact?: SortOrder
    analyzed_by?: SortOrder
    createdAt?: SortOrder
    updated_at?: SortOrder
  }

  export type JobQueueCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    result?: SortOrder
    error?: SortOrder
    progress?: SortOrder
    total?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueAvgOrderByAggregateInput = {
    progress?: SortOrder
    total?: SortOrder
  }

  export type JobQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    error?: SortOrder
    progress?: SortOrder
    total?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    error?: SortOrder
    progress?: SortOrder
    total?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueSumOrderByAggregateInput = {
    progress?: SortOrder
    total?: SortOrder
  }

  export type ApiTaskCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sessionId?: SortOrder
    phase_number?: SortOrder
    step_name?: SortOrder
    request?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    response?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    taskType?: SortOrder
  }

  export type ApiTaskAvgOrderByAggregateInput = {
    phase_number?: SortOrder
    retry_count?: SortOrder
  }

  export type ApiTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sessionId?: SortOrder
    phase_number?: SortOrder
    step_name?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    taskType?: SortOrder
  }

  export type ApiTaskMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sessionId?: SortOrder
    phase_number?: SortOrder
    step_name?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    taskType?: SortOrder
  }

  export type ApiTaskSumOrderByAggregateInput = {
    phase_number?: SortOrder
    retry_count?: SortOrder
  }

  export type CollectionPresetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    query?: SortOrder
    keywords?: SortOrder
    minLikes?: SortOrder
    minRetweets?: SortOrder
    language?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetAvgOrderByAggregateInput = {
    minLikes?: SortOrder
    minRetweets?: SortOrder
  }

  export type CollectionPresetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    query?: SortOrder
    minLikes?: SortOrder
    minRetweets?: SortOrder
    language?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    query?: SortOrder
    minLikes?: SortOrder
    minRetweets?: SortOrder
    language?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetSumOrderByAggregateInput = {
    minLikes?: SortOrder
    minRetweets?: SortOrder
  }

  export type WatchlistTweetListRelationFilter = {
    every?: WatchlistTweetWhereInput
    some?: WatchlistTweetWhereInput
    none?: WatchlistTweetWhereInput
  }

  export type WatchlistTweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistUserUserIdUsernameCompoundUniqueInput = {
    userId: string
    username: string
  }

  export type WatchlistUserCountOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    profile_image?: SortOrder
    bio?: SortOrder
    followers_count?: SortOrder
    category?: SortOrder
    notes?: SortOrder
    priority?: SortOrder
    is_following?: SortOrder
    added_at?: SortOrder
    lastChecked?: SortOrder
    userId?: SortOrder
  }

  export type WatchlistUserAvgOrderByAggregateInput = {
    followers_count?: SortOrder
    priority?: SortOrder
  }

  export type WatchlistUserMaxOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    profile_image?: SortOrder
    bio?: SortOrder
    followers_count?: SortOrder
    notes?: SortOrder
    priority?: SortOrder
    is_following?: SortOrder
    added_at?: SortOrder
    lastChecked?: SortOrder
    userId?: SortOrder
  }

  export type WatchlistUserMinOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    profile_image?: SortOrder
    bio?: SortOrder
    followers_count?: SortOrder
    notes?: SortOrder
    priority?: SortOrder
    is_following?: SortOrder
    added_at?: SortOrder
    lastChecked?: SortOrder
    userId?: SortOrder
  }

  export type WatchlistUserSumOrderByAggregateInput = {
    followers_count?: SortOrder
    priority?: SortOrder
  }

  export type WatchlistUserScalarRelationFilter = {
    is?: WatchlistUserWhereInput
    isNot?: WatchlistUserWhereInput
  }

  export type WatchlistTweetCountOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    watchlistUserId?: SortOrder
    content?: SortOrder
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
    has_replied?: SortOrder
    has_quoted?: SortOrder
    posted_at?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    media_urls?: SortOrder
  }

  export type WatchlistTweetAvgOrderByAggregateInput = {
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
  }

  export type WatchlistTweetMaxOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    watchlistUserId?: SortOrder
    content?: SortOrder
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
    has_replied?: SortOrder
    has_quoted?: SortOrder
    posted_at?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
  }

  export type WatchlistTweetMinOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    watchlistUserId?: SortOrder
    content?: SortOrder
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
    has_replied?: SortOrder
    has_quoted?: SortOrder
    posted_at?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
  }

  export type WatchlistTweetSumOrderByAggregateInput = {
    likes_count?: SortOrder
    retweets_count?: SortOrder
    replies_count?: SortOrder
    impressions_count?: SortOrder
  }

  export type InteractionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source_tweet_id?: SortOrder
    target_tweet_id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source_tweet_id?: SortOrder
    target_tweet_id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source_tweet_id?: SortOrder
    target_tweet_id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    personal_angles?: SortOrder
    buzz_prediction?: SortOrder
    recommendations?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportAvgOrderByAggregateInput = {
    buzz_prediction?: SortOrder
  }

  export type PerplexityReportMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    buzz_prediction?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    buzz_prediction?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportSumOrderByAggregateInput = {
    buzz_prediction?: SortOrder
  }

  export type EnumCotSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusFilter<$PrismaModel> | $Enums.CotSessionStatus
  }

  export type EnumCotPhaseStepFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepFilter<$PrismaModel> | $Enums.CotPhaseStep
  }

  export type CotDraftListRelationFilter = {
    every?: CotDraftWhereInput
    some?: CotDraftWhereInput
    none?: CotDraftWhereInput
  }

  export type CotPhaseListRelationFilter = {
    every?: CotPhaseWhereInput
    some?: CotPhaseWhereInput
    none?: CotPhaseWhereInput
  }

  export type CotDraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotSessionCountOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
  }

  export type CotSessionAvgOrderByAggregateInput = {
    currentPhase?: SortOrder
    retryCount?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
  }

  export type CotSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionMinOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionSumOrderByAggregateInput = {
    currentPhase?: SortOrder
    retryCount?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
  }

  export type EnumCotSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCotSessionStatusFilter<$PrismaModel>
  }

  export type EnumCotPhaseStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStepFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStepFilter<$PrismaModel>
  }

  export type EnumCotPhaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusFilter<$PrismaModel> | $Enums.CotPhaseStatus
  }

  export type CotSessionScalarRelationFilter = {
    is?: CotSessionWhereInput
    isNot?: CotSessionWhereInput
  }

  export type CotPhaseSessionIdPhaseNumberCompoundUniqueInput = {
    sessionId: string
    phaseNumber: number
  }

  export type CotPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkResult?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeResult?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateResult?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseAvgOrderByAggregateInput = {
    phaseNumber?: SortOrder
    thinkTokens?: SortOrder
    executeDuration?: SortOrder
    integrateTokens?: SortOrder
  }

  export type CotPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseSumOrderByAggregateInput = {
    phaseNumber?: SortOrder
    thinkTokens?: SortOrder
    executeDuration?: SortOrder
    integrateTokens?: SortOrder
  }

  export type EnumCotPhaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
  }

  export type EnumCotDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusFilter<$PrismaModel> | $Enums.CotDraftStatus
  }

  export type CotDraftPerformanceNullableScalarRelationFilter = {
    is?: CotDraftPerformanceWhereInput | null
    isNot?: CotDraftPerformanceWhereInput | null
  }

  export type CotDraftSessionIdConceptNumberCompoundUniqueInput = {
    sessionId: string
    conceptNumber: number
  }

  export type CotDraftCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    thread_content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    kpis?: SortOrder
    riskAssessment?: SortOrder
    optimizationTips?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftAvgOrderByAggregateInput = {
    conceptNumber?: SortOrder
    viralScore?: SortOrder
  }

  export type CotDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftSumOrderByAggregateInput = {
    conceptNumber?: SortOrder
    viralScore?: SortOrder
  }

  export type EnumCotDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotDraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumCotDraftStatusFilter<$PrismaModel>
  }

  export type CotDraftScalarRelationFilter = {
    is?: CotDraftWhereInput
    isNot?: CotDraftWhereInput
  }

  export type CotDraftPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceAvgOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type CotDraftPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceSumOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type EnumRTStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusFilter<$PrismaModel> | $Enums.RTStatus
  }

  export type ScheduledRetweetCountOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrder
    viralDraftId?: SortOrder
    cotDraftId?: SortOrder
    executedAt?: SortOrder
    rtPostId?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledRetweetMaxOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrder
    viralDraftId?: SortOrder
    cotDraftId?: SortOrder
    executedAt?: SortOrder
    rtPostId?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledRetweetMinOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    originalContent?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    rtStrategy?: SortOrder
    addComment?: SortOrder
    commentText?: SortOrder
    viralDraftId?: SortOrder
    cotDraftId?: SortOrder
    executedAt?: SortOrder
    rtPostId?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRTStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusWithAggregatesFilter<$PrismaModel> | $Enums.RTStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRTStatusFilter<$PrismaModel>
    _max?: NestedEnumRTStatusFilter<$PrismaModel>
  }

  export type UnifiedPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    metrics30m?: SortOrder
    metrics1h?: SortOrder
    metrics24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceAvgOrderByAggregateInput = {
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type UnifiedPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    contentType?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedPerformanceSumOrderByAggregateInput = {
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type NewsViralRelationNewsIdSessionIdCompoundUniqueInput = {
    newsId: string
    sessionId: string
  }

  export type NewsViralRelationCountOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationAvgOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type NewsViralRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationMinOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    sessionId?: SortOrder
    relevanceScore?: SortOrder
    usedInContent?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsViralRelationSumOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type SessionActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionType?: SortOrder
    activityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogCountOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrder
    stackTrace?: SortOrder
    requestBody?: SortOrder
    requestHeaders?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type ApiErrorLogMaxOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrder
    stackTrace?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogMinOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    errorMessage?: SortOrder
    stackTrace?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiErrorLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type ViralDraftV2ListRelationFilter = {
    every?: ViralDraftV2WhereInput
    some?: ViralDraftV2WhereInput
    none?: ViralDraftV2WhereInput
  }

  export type ViralDraftV2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViralSessionCountOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    topics?: SortOrder
    concepts?: SortOrder
    selectedIds?: SortOrder
    contents?: SortOrder
    characterProfileId?: SortOrder
    voiceStyleMode?: SortOrder
  }

  export type ViralSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrder
    voiceStyleMode?: SortOrder
  }

  export type ViralSessionMinOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    platform?: SortOrder
    style?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    characterProfileId?: SortOrder
    voiceStyleMode?: SortOrder
  }

  export type ViralDraftPerformanceNullableScalarRelationFilter = {
    is?: ViralDraftPerformanceWhereInput | null
    isNot?: ViralDraftPerformanceWhereInput | null
  }

  export type ViralSessionScalarRelationFilter = {
    is?: ViralSessionWhereInput
    isNot?: ViralSessionWhereInput
  }

  export type ViralDraftV2CountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    hashtags?: SortOrder
    visualNote?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterId?: SortOrder
    characterNote?: SortOrder
    sourceUrl?: SortOrder
    news_article_id?: SortOrder
  }

  export type ViralDraftV2MaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    visualNote?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterId?: SortOrder
    characterNote?: SortOrder
    sourceUrl?: SortOrder
    news_article_id?: SortOrder
  }

  export type ViralDraftV2MinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    visualNote?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterId?: SortOrder
    characterNote?: SortOrder
    sourceUrl?: SortOrder
    news_article_id?: SortOrder
  }

  export type ViralDraftV2ScalarRelationFilter = {
    is?: ViralDraftV2WhereInput
    isNot?: ViralDraftV2WhereInput
  }

  export type ViralDraftPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftPerformanceAvgOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type ViralDraftPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViralDraftPerformanceSumOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type CharacterProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    occupation?: SortOrder
    catchphrase?: SortOrder
    personality?: SortOrder
    speaking_style?: SortOrder
    expertise?: SortOrder
    backstory?: SortOrder
    philosophy?: SortOrder
    tone?: SortOrder
    voiceStyle?: SortOrder
    emoji_style?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredNewsCategories?: SortOrder
    newsCommentStyle?: SortOrder
    topicExpertise?: SortOrder
  }

  export type CharacterProfileAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type CharacterProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    occupation?: SortOrder
    catchphrase?: SortOrder
    personality?: SortOrder
    speaking_style?: SortOrder
    expertise?: SortOrder
    backstory?: SortOrder
    philosophy?: SortOrder
    tone?: SortOrder
    emoji_style?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    occupation?: SortOrder
    catchphrase?: SortOrder
    personality?: SortOrder
    speaking_style?: SortOrder
    expertise?: SortOrder
    backstory?: SortOrder
    philosophy?: SortOrder
    tone?: SortOrder
    emoji_style?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterProfileSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type accountsProviderProvider_account_idCompoundUniqueInput = {
    provider: string
    provider_account_id: string
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type ai_patternsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt_template?: SortOrder
    example_output?: SortOrder
    success_rate?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
  }

  export type ai_patternsAvgOrderByAggregateInput = {
    success_rate?: SortOrder
    usage_count?: SortOrder
  }

  export type ai_patternsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt_template?: SortOrder
    example_output?: SortOrder
    success_rate?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
  }

  export type ai_patternsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt_template?: SortOrder
    example_output?: SortOrder
    success_rate?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
  }

  export type ai_patternsSumOrderByAggregateInput = {
    success_rate?: SortOrder
    usage_count?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type Gpt_analysesScalarRelationFilter = {
    is?: gpt_analysesWhereInput
    isNot?: gpt_analysesWhereInput
  }

  export type content_draftsCountOrderByAggregateInput = {
    id?: SortOrder
    analysis_id?: SortOrder
    concept_type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    edited_content?: SortOrder
    explanation?: SortOrder
    buzz_factors?: SortOrder
    target_audience?: SortOrder
    estimated_engagement?: SortOrder
    hashtags?: SortOrder
    visual_guide?: SortOrder
    platform?: SortOrder
    format?: SortOrder
    status?: SortOrder
    editor_notes?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type content_draftsMaxOrderByAggregateInput = {
    id?: SortOrder
    analysis_id?: SortOrder
    concept_type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    edited_content?: SortOrder
    explanation?: SortOrder
    target_audience?: SortOrder
    visual_guide?: SortOrder
    platform?: SortOrder
    format?: SortOrder
    status?: SortOrder
    editor_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type content_draftsMinOrderByAggregateInput = {
    id?: SortOrder
    analysis_id?: SortOrder
    concept_type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    edited_content?: SortOrder
    explanation?: SortOrder
    target_audience?: SortOrder
    visual_guide?: SortOrder
    platform?: SortOrder
    format?: SortOrder
    status?: SortOrder
    editor_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Content_draftsListRelationFilter = {
    every?: content_draftsWhereInput
    some?: content_draftsWhereInput
    none?: content_draftsWhereInput
  }

  export type content_draftsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gpt_analysesCountOrderByAggregateInput = {
    id?: SortOrder
    analysis_type?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    tokens?: SortOrder
    duration?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type gpt_analysesAvgOrderByAggregateInput = {
    tokens?: SortOrder
    duration?: SortOrder
  }

  export type gpt_analysesMaxOrderByAggregateInput = {
    id?: SortOrder
    analysis_type?: SortOrder
    prompt?: SortOrder
    tokens?: SortOrder
    duration?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type gpt_analysesMinOrderByAggregateInput = {
    id?: SortOrder
    analysis_type?: SortOrder
    prompt?: SortOrder
    tokens?: SortOrder
    duration?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type gpt_analysesSumOrderByAggregateInput = {
    tokens?: SortOrder
    duration?: SortOrder
  }

  export type news_analysis_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    error?: SortOrder
    result?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type news_analysis_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type news_analysis_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type News_analysis_jobsScalarRelationFilter = {
    is?: news_analysis_jobsWhereInput
    isNot?: news_analysis_jobsWhereInput
  }

  export type news_analysis_resultsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    article_id?: SortOrder
    importance_score?: SortOrder
    category?: SortOrder
    summary_ja?: SortOrder
    key_points?: SortOrder
    impact_assessment?: SortOrder
    expert_perspective?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type news_analysis_resultsAvgOrderByAggregateInput = {
    importance_score?: SortOrder
  }

  export type news_analysis_resultsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    article_id?: SortOrder
    importance_score?: SortOrder
    category?: SortOrder
    summary_ja?: SortOrder
    impact_assessment?: SortOrder
    expert_perspective?: SortOrder
    created_at?: SortOrder
  }

  export type news_analysis_resultsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    article_id?: SortOrder
    importance_score?: SortOrder
    category?: SortOrder
    summary_ja?: SortOrder
    impact_assessment?: SortOrder
    expert_perspective?: SortOrder
    created_at?: SortOrder
  }

  export type news_analysis_resultsSumOrderByAggregateInput = {
    importance_score?: SortOrder
  }

  export type prompt_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type prompt_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type prompt_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_analysis_logsCountOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    phase?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    tokens?: SortOrder
    duration?: SortOrder
    success?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
  }

  export type viral_analysis_logsAvgOrderByAggregateInput = {
    tokens?: SortOrder
    duration?: SortOrder
  }

  export type viral_analysis_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    phase?: SortOrder
    prompt?: SortOrder
    tokens?: SortOrder
    duration?: SortOrder
    success?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
  }

  export type viral_analysis_logsMinOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    phase?: SortOrder
    prompt?: SortOrder
    tokens?: SortOrder
    duration?: SortOrder
    success?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
  }

  export type viral_analysis_logsSumOrderByAggregateInput = {
    tokens?: SortOrder
    duration?: SortOrder
  }

  export type viral_configCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_configMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_configMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Viral_postsListRelationFilter = {
    every?: viral_postsWhereInput
    some?: viral_postsWhereInput
    none?: viral_postsWhereInput
  }

  export type viral_postsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type viral_opportunitiesCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    platform?: SortOrder
    viral_score?: SortOrder
    time_window?: SortOrder
    angle?: SortOrder
    keywords?: SortOrder
    source_data?: SortOrder
    status?: SortOrder
    analyzed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_opportunitiesAvgOrderByAggregateInput = {
    viral_score?: SortOrder
    time_window?: SortOrder
  }

  export type viral_opportunitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    platform?: SortOrder
    viral_score?: SortOrder
    time_window?: SortOrder
    angle?: SortOrder
    status?: SortOrder
    analyzed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_opportunitiesMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    platform?: SortOrder
    viral_score?: SortOrder
    time_window?: SortOrder
    angle?: SortOrder
    status?: SortOrder
    analyzed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_opportunitiesSumOrderByAggregateInput = {
    viral_score?: SortOrder
    time_window?: SortOrder
  }

  export type Viral_postsScalarRelationFilter = {
    is?: viral_postsWhereInput
    isNot?: viral_postsWhereInput
  }

  export type viral_post_performanceCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    impressions_30m?: SortOrder
    likes_30m?: SortOrder
    retweets_30m?: SortOrder
    comments_30m?: SortOrder
    impressions_1h?: SortOrder
    likes_1h?: SortOrder
    retweets_1h?: SortOrder
    comments_1h?: SortOrder
    impressions_24h?: SortOrder
    likes_24h?: SortOrder
    retweets_24h?: SortOrder
    comments_24h?: SortOrder
    followers_24h?: SortOrder
    engagement_rate?: SortOrder
    viral_coefficient?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_post_performanceAvgOrderByAggregateInput = {
    impressions_30m?: SortOrder
    likes_30m?: SortOrder
    retweets_30m?: SortOrder
    comments_30m?: SortOrder
    impressions_1h?: SortOrder
    likes_1h?: SortOrder
    retweets_1h?: SortOrder
    comments_1h?: SortOrder
    impressions_24h?: SortOrder
    likes_24h?: SortOrder
    retweets_24h?: SortOrder
    comments_24h?: SortOrder
    followers_24h?: SortOrder
    engagement_rate?: SortOrder
    viral_coefficient?: SortOrder
  }

  export type viral_post_performanceMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    impressions_30m?: SortOrder
    likes_30m?: SortOrder
    retweets_30m?: SortOrder
    comments_30m?: SortOrder
    impressions_1h?: SortOrder
    likes_1h?: SortOrder
    retweets_1h?: SortOrder
    comments_1h?: SortOrder
    impressions_24h?: SortOrder
    likes_24h?: SortOrder
    retweets_24h?: SortOrder
    comments_24h?: SortOrder
    followers_24h?: SortOrder
    engagement_rate?: SortOrder
    viral_coefficient?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_post_performanceMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    impressions_30m?: SortOrder
    likes_30m?: SortOrder
    retweets_30m?: SortOrder
    comments_30m?: SortOrder
    impressions_1h?: SortOrder
    likes_1h?: SortOrder
    retweets_1h?: SortOrder
    comments_1h?: SortOrder
    impressions_24h?: SortOrder
    likes_24h?: SortOrder
    retweets_24h?: SortOrder
    comments_24h?: SortOrder
    followers_24h?: SortOrder
    engagement_rate?: SortOrder
    viral_coefficient?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_post_performanceSumOrderByAggregateInput = {
    impressions_30m?: SortOrder
    likes_30m?: SortOrder
    retweets_30m?: SortOrder
    comments_30m?: SortOrder
    impressions_1h?: SortOrder
    likes_1h?: SortOrder
    retweets_1h?: SortOrder
    comments_1h?: SortOrder
    impressions_24h?: SortOrder
    likes_24h?: SortOrder
    retweets_24h?: SortOrder
    comments_24h?: SortOrder
    followers_24h?: SortOrder
    engagement_rate?: SortOrder
    viral_coefficient?: SortOrder
  }

  export type Viral_post_performanceNullableScalarRelationFilter = {
    is?: viral_post_performanceWhereInput | null
    isNot?: viral_post_performanceWhereInput | null
  }

  export type Viral_opportunitiesScalarRelationFilter = {
    is?: viral_opportunitiesWhereInput
    isNot?: viral_opportunitiesWhereInput
  }

  export type viral_postsCountOrderByAggregateInput = {
    id?: SortOrder
    opportunity_id?: SortOrder
    concept_type?: SortOrder
    content?: SortOrder
    thread_content?: SortOrder
    visual_guide?: SortOrder
    hashtags?: SortOrder
    post_type?: SortOrder
    platform?: SortOrder
    scheduled_at?: SortOrder
    posted_at?: SortOrder
    post_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_postsMaxOrderByAggregateInput = {
    id?: SortOrder
    opportunity_id?: SortOrder
    concept_type?: SortOrder
    content?: SortOrder
    visual_guide?: SortOrder
    post_type?: SortOrder
    platform?: SortOrder
    scheduled_at?: SortOrder
    posted_at?: SortOrder
    post_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type viral_postsMinOrderByAggregateInput = {
    id?: SortOrder
    opportunity_id?: SortOrder
    concept_type?: SortOrder
    content?: SortOrder
    visual_guide?: SortOrder
    post_type?: SortOrder
    platform?: SortOrder
    scheduled_at?: SortOrder
    posted_at?: SortOrder
    post_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ScheduledPostCreateNestedManyWithoutRefPostInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
  }

  export type ScheduledPostUncheckedCreateNestedManyWithoutRefPostInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ScheduledPostUpdateManyWithoutRefPostNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    upsert?: ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput | ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    set?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    disconnect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    delete?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    update?: ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput | ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput[]
    updateMany?: ScheduledPostUpdateManyWithWhereWithoutRefPostInput | ScheduledPostUpdateManyWithWhereWithoutRefPostInput[]
    deleteMany?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
  }

  export type ScheduledPostUncheckedUpdateManyWithoutRefPostNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    upsert?: ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput | ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    set?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    disconnect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    delete?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    update?: ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput | ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput[]
    updateMany?: ScheduledPostUpdateManyWithWhereWithoutRefPostInput | ScheduledPostUpdateManyWithWhereWithoutRefPostInput[]
    deleteMany?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
  }

  export type BuzzConfigCreatekeywordsInput = {
    set: string[]
  }

  export type BuzzConfigCreateaccountsInput = {
    set: string[]
  }

  export type BuzzConfigUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BuzzConfigUpdateaccountsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PostAnalyticsCreateNestedManyWithoutScheduled_postsInput = {
    create?: XOR<PostAnalyticsCreateWithoutScheduled_postsInput, PostAnalyticsUncheckedCreateWithoutScheduled_postsInput> | PostAnalyticsCreateWithoutScheduled_postsInput[] | PostAnalyticsUncheckedCreateWithoutScheduled_postsInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutScheduled_postsInput | PostAnalyticsCreateOrConnectWithoutScheduled_postsInput[]
    createMany?: PostAnalyticsCreateManyScheduled_postsInputEnvelope
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
  }

  export type BuzzPostCreateNestedOneWithoutScheduledPostsInput = {
    create?: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    connectOrCreate?: BuzzPostCreateOrConnectWithoutScheduledPostsInput
    connect?: BuzzPostWhereUniqueInput
  }

  export type PostAnalyticsUncheckedCreateNestedManyWithoutScheduled_postsInput = {
    create?: XOR<PostAnalyticsCreateWithoutScheduled_postsInput, PostAnalyticsUncheckedCreateWithoutScheduled_postsInput> | PostAnalyticsCreateWithoutScheduled_postsInput[] | PostAnalyticsUncheckedCreateWithoutScheduled_postsInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutScheduled_postsInput | PostAnalyticsCreateOrConnectWithoutScheduled_postsInput[]
    createMany?: PostAnalyticsCreateManyScheduled_postsInputEnvelope
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PostAnalyticsUpdateManyWithoutScheduled_postsNestedInput = {
    create?: XOR<PostAnalyticsCreateWithoutScheduled_postsInput, PostAnalyticsUncheckedCreateWithoutScheduled_postsInput> | PostAnalyticsCreateWithoutScheduled_postsInput[] | PostAnalyticsUncheckedCreateWithoutScheduled_postsInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutScheduled_postsInput | PostAnalyticsCreateOrConnectWithoutScheduled_postsInput[]
    upsert?: PostAnalyticsUpsertWithWhereUniqueWithoutScheduled_postsInput | PostAnalyticsUpsertWithWhereUniqueWithoutScheduled_postsInput[]
    createMany?: PostAnalyticsCreateManyScheduled_postsInputEnvelope
    set?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    disconnect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    delete?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    update?: PostAnalyticsUpdateWithWhereUniqueWithoutScheduled_postsInput | PostAnalyticsUpdateWithWhereUniqueWithoutScheduled_postsInput[]
    updateMany?: PostAnalyticsUpdateManyWithWhereWithoutScheduled_postsInput | PostAnalyticsUpdateManyWithWhereWithoutScheduled_postsInput[]
    deleteMany?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
  }

  export type BuzzPostUpdateOneWithoutScheduledPostsNestedInput = {
    create?: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    connectOrCreate?: BuzzPostCreateOrConnectWithoutScheduledPostsInput
    upsert?: BuzzPostUpsertWithoutScheduledPostsInput
    disconnect?: BuzzPostWhereInput | boolean
    delete?: BuzzPostWhereInput | boolean
    connect?: BuzzPostWhereUniqueInput
    update?: XOR<XOR<BuzzPostUpdateToOneWithWhereWithoutScheduledPostsInput, BuzzPostUpdateWithoutScheduledPostsInput>, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
  }

  export type PostAnalyticsUncheckedUpdateManyWithoutScheduled_postsNestedInput = {
    create?: XOR<PostAnalyticsCreateWithoutScheduled_postsInput, PostAnalyticsUncheckedCreateWithoutScheduled_postsInput> | PostAnalyticsCreateWithoutScheduled_postsInput[] | PostAnalyticsUncheckedCreateWithoutScheduled_postsInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutScheduled_postsInput | PostAnalyticsCreateOrConnectWithoutScheduled_postsInput[]
    upsert?: PostAnalyticsUpsertWithWhereUniqueWithoutScheduled_postsInput | PostAnalyticsUpsertWithWhereUniqueWithoutScheduled_postsInput[]
    createMany?: PostAnalyticsCreateManyScheduled_postsInputEnvelope
    set?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    disconnect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    delete?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    update?: PostAnalyticsUpdateWithWhereUniqueWithoutScheduled_postsInput | PostAnalyticsUpdateWithWhereUniqueWithoutScheduled_postsInput[]
    updateMany?: PostAnalyticsUpdateManyWithWhereWithoutScheduled_postsInput | PostAnalyticsUpdateManyWithWhereWithoutScheduled_postsInput[]
    deleteMany?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
  }

  export type ScheduledPostCreateNestedOneWithoutPost_analyticsInput = {
    create?: XOR<ScheduledPostCreateWithoutPost_analyticsInput, ScheduledPostUncheckedCreateWithoutPost_analyticsInput>
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutPost_analyticsInput
    connect?: ScheduledPostWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ScheduledPostUpdateOneRequiredWithoutPost_analyticsNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutPost_analyticsInput, ScheduledPostUncheckedCreateWithoutPost_analyticsInput>
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutPost_analyticsInput
    upsert?: ScheduledPostUpsertWithoutPost_analyticsInput
    connect?: ScheduledPostWhereUniqueInput
    update?: XOR<XOR<ScheduledPostUpdateToOneWithWhereWithoutPost_analyticsInput, ScheduledPostUpdateWithoutPost_analyticsInput>, ScheduledPostUncheckedUpdateWithoutPost_analyticsInput>
  }

  export type accountsCreateNestedManyWithoutUsersInput = {
    create?: XOR<accountsCreateWithoutUsersInput, accountsUncheckedCreateWithoutUsersInput> | accountsCreateWithoutUsersInput[] | accountsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUsersInput | accountsCreateOrConnectWithoutUsersInput[]
    createMany?: accountsCreateManyUsersInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WatchlistUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
  }

  export type accountsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<accountsCreateWithoutUsersInput, accountsUncheckedCreateWithoutUsersInput> | accountsCreateWithoutUsersInput[] | accountsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUsersInput | accountsCreateOrConnectWithoutUsersInput[]
    createMany?: accountsCreateManyUsersInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WatchlistUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
  }

  export type accountsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<accountsCreateWithoutUsersInput, accountsUncheckedCreateWithoutUsersInput> | accountsCreateWithoutUsersInput[] | accountsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUsersInput | accountsCreateOrConnectWithoutUsersInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutUsersInput | accountsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: accountsCreateManyUsersInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutUsersInput | accountsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutUsersInput | accountsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WatchlistUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUserUpsertWithWhereUniqueWithoutUserInput | WatchlistUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    set?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    disconnect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    delete?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    update?: WatchlistUserUpdateWithWhereUniqueWithoutUserInput | WatchlistUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUserUpdateManyWithWhereWithoutUserInput | WatchlistUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
  }

  export type accountsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<accountsCreateWithoutUsersInput, accountsUncheckedCreateWithoutUsersInput> | accountsCreateWithoutUsersInput[] | accountsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUsersInput | accountsCreateOrConnectWithoutUsersInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutUsersInput | accountsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: accountsCreateManyUsersInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutUsersInput | accountsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutUsersInput | accountsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WatchlistUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUserUpsertWithWhereUniqueWithoutUserInput | WatchlistUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    set?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    disconnect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    delete?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    update?: WatchlistUserUpdateWithWhereUniqueWithoutUserInput | WatchlistUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUserUpdateManyWithWhereWithoutUserInput | WatchlistUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NewsArticleCreateNestedManyWithoutSourceInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
  }

  export type NewsArticleUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
  }

  export type NewsArticleUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    upsert?: NewsArticleUpsertWithWhereUniqueWithoutSourceInput | NewsArticleUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    set?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    disconnect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    delete?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    update?: NewsArticleUpdateWithWhereUniqueWithoutSourceInput | NewsArticleUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NewsArticleUpdateManyWithWhereWithoutSourceInput | NewsArticleUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
  }

  export type NewsArticleUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    upsert?: NewsArticleUpsertWithWhereUniqueWithoutSourceInput | NewsArticleUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    set?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    disconnect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    delete?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    update?: NewsArticleUpdateWithWhereUniqueWithoutSourceInput | NewsArticleUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NewsArticleUpdateManyWithWhereWithoutSourceInput | NewsArticleUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
  }

  export type NewsAnalysisCreateNestedOneWithoutArticleInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    connect?: NewsAnalysisWhereUniqueInput
  }

  export type news_analysis_resultsCreateNestedManyWithoutNews_articlesInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_articlesInput, news_analysis_resultsUncheckedCreateWithoutNews_articlesInput> | news_analysis_resultsCreateWithoutNews_articlesInput[] | news_analysis_resultsUncheckedCreateWithoutNews_articlesInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_articlesInput | news_analysis_resultsCreateOrConnectWithoutNews_articlesInput[]
    createMany?: news_analysis_resultsCreateManyNews_articlesInputEnvelope
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
  }

  export type NewsSourceCreateNestedOneWithoutArticlesInput = {
    create?: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: NewsSourceCreateOrConnectWithoutArticlesInput
    connect?: NewsSourceWhereUniqueInput
  }

  export type NewsThreadItemCreateNestedManyWithoutArticleInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    connect?: NewsAnalysisWhereUniqueInput
  }

  export type news_analysis_resultsUncheckedCreateNestedManyWithoutNews_articlesInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_articlesInput, news_analysis_resultsUncheckedCreateWithoutNews_articlesInput> | news_analysis_resultsCreateWithoutNews_articlesInput[] | news_analysis_resultsUncheckedCreateWithoutNews_articlesInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_articlesInput | news_analysis_resultsCreateOrConnectWithoutNews_articlesInput[]
    createMany?: news_analysis_resultsCreateManyNews_articlesInputEnvelope
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
  }

  export type NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NewsAnalysisUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    upsert?: NewsAnalysisUpsertWithoutArticleInput
    disconnect?: NewsAnalysisWhereInput | boolean
    delete?: NewsAnalysisWhereInput | boolean
    connect?: NewsAnalysisWhereUniqueInput
    update?: XOR<XOR<NewsAnalysisUpdateToOneWithWhereWithoutArticleInput, NewsAnalysisUpdateWithoutArticleInput>, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type news_analysis_resultsUpdateManyWithoutNews_articlesNestedInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_articlesInput, news_analysis_resultsUncheckedCreateWithoutNews_articlesInput> | news_analysis_resultsCreateWithoutNews_articlesInput[] | news_analysis_resultsUncheckedCreateWithoutNews_articlesInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_articlesInput | news_analysis_resultsCreateOrConnectWithoutNews_articlesInput[]
    upsert?: news_analysis_resultsUpsertWithWhereUniqueWithoutNews_articlesInput | news_analysis_resultsUpsertWithWhereUniqueWithoutNews_articlesInput[]
    createMany?: news_analysis_resultsCreateManyNews_articlesInputEnvelope
    set?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    disconnect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    delete?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    update?: news_analysis_resultsUpdateWithWhereUniqueWithoutNews_articlesInput | news_analysis_resultsUpdateWithWhereUniqueWithoutNews_articlesInput[]
    updateMany?: news_analysis_resultsUpdateManyWithWhereWithoutNews_articlesInput | news_analysis_resultsUpdateManyWithWhereWithoutNews_articlesInput[]
    deleteMany?: news_analysis_resultsScalarWhereInput | news_analysis_resultsScalarWhereInput[]
  }

  export type NewsSourceUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: NewsSourceCreateOrConnectWithoutArticlesInput
    upsert?: NewsSourceUpsertWithoutArticlesInput
    connect?: NewsSourceWhereUniqueInput
    update?: XOR<XOR<NewsSourceUpdateToOneWithWhereWithoutArticlesInput, NewsSourceUpdateWithoutArticlesInput>, NewsSourceUncheckedUpdateWithoutArticlesInput>
  }

  export type NewsThreadItemUpdateManyWithoutArticleNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput | NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput | NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutArticleInput | NewsThreadItemUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    upsert?: NewsAnalysisUpsertWithoutArticleInput
    disconnect?: NewsAnalysisWhereInput | boolean
    delete?: NewsAnalysisWhereInput | boolean
    connect?: NewsAnalysisWhereUniqueInput
    update?: XOR<XOR<NewsAnalysisUpdateToOneWithWhereWithoutArticleInput, NewsAnalysisUpdateWithoutArticleInput>, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesNestedInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_articlesInput, news_analysis_resultsUncheckedCreateWithoutNews_articlesInput> | news_analysis_resultsCreateWithoutNews_articlesInput[] | news_analysis_resultsUncheckedCreateWithoutNews_articlesInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_articlesInput | news_analysis_resultsCreateOrConnectWithoutNews_articlesInput[]
    upsert?: news_analysis_resultsUpsertWithWhereUniqueWithoutNews_articlesInput | news_analysis_resultsUpsertWithWhereUniqueWithoutNews_articlesInput[]
    createMany?: news_analysis_resultsCreateManyNews_articlesInputEnvelope
    set?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    disconnect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    delete?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    update?: news_analysis_resultsUpdateWithWhereUniqueWithoutNews_articlesInput | news_analysis_resultsUpdateWithWhereUniqueWithoutNews_articlesInput[]
    updateMany?: news_analysis_resultsUpdateManyWithWhereWithoutNews_articlesInput | news_analysis_resultsUpdateManyWithWhereWithoutNews_articlesInput[]
    deleteMany?: news_analysis_resultsScalarWhereInput | news_analysis_resultsScalarWhereInput[]
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput | NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput | NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutArticleInput | NewsThreadItemUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadItemCreateNestedManyWithoutThreadInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsThreadItemUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsThreadItemUpdateManyWithoutThreadNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput | NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput | NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutThreadInput | NewsThreadItemUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput | NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput | NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutThreadInput | NewsThreadItemUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsArticleCreateNestedOneWithoutNewsThreadItemsInput = {
    create?: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNewsThreadItemsInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type NewsThreadCreateNestedOneWithoutItemsInput = {
    create?: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NewsThreadCreateOrConnectWithoutItemsInput
    connect?: NewsThreadWhereUniqueInput
  }

  export type NewsArticleUpdateOneWithoutNewsThreadItemsNestedInput = {
    create?: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNewsThreadItemsInput
    upsert?: NewsArticleUpsertWithoutNewsThreadItemsInput
    disconnect?: NewsArticleWhereInput | boolean
    delete?: NewsArticleWhereInput | boolean
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutNewsThreadItemsInput, NewsArticleUpdateWithoutNewsThreadItemsInput>, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
  }

  export type NewsThreadUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NewsThreadCreateOrConnectWithoutItemsInput
    upsert?: NewsThreadUpsertWithoutItemsInput
    connect?: NewsThreadWhereUniqueInput
    update?: XOR<XOR<NewsThreadUpdateToOneWithWhereWithoutItemsInput, NewsThreadUpdateWithoutItemsInput>, NewsThreadUncheckedUpdateWithoutItemsInput>
  }

  export type NewsAnalysisCreatekey_pointsInput = {
    set: string[]
  }

  export type NewsArticleCreateNestedOneWithoutAnalysisInput = {
    create?: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutAnalysisInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type NewsAnalysisUpdatekey_pointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NewsArticleUpdateOneRequiredWithoutAnalysisNestedInput = {
    create?: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutAnalysisInput
    upsert?: NewsArticleUpsertWithoutAnalysisInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutAnalysisInput, NewsArticleUpdateWithoutAnalysisInput>, NewsArticleUncheckedUpdateWithoutAnalysisInput>
  }

  export type CollectionPresetCreatekeywordsInput = {
    set: string[]
  }

  export type CollectionPresetUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WatchlistUserCreatecategoryInput = {
    set: string[]
  }

  export type WatchlistTweetCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWatchlistUsersInput = {
    create?: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistUsersInput
    connect?: UserWhereUniqueInput
  }

  export type WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
  }

  export type WatchlistUserUpdatecategoryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    set?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    disconnect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    delete?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    update?: WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput | WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWatchlistUsersNestedInput = {
    create?: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistUsersInput
    upsert?: UserUpsertWithoutWatchlistUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchlistUsersInput, UserUpdateWithoutWatchlistUsersInput>, UserUncheckedUpdateWithoutWatchlistUsersInput>
  }

  export type WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    set?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    disconnect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    delete?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    update?: WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput | WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
  }

  export type WatchlistUserCreateNestedOneWithoutTweetsInput = {
    create?: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutTweetsInput
    connect?: WatchlistUserWhereUniqueInput
  }

  export type WatchlistUserUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutTweetsInput
    upsert?: WatchlistUserUpsertWithoutTweetsInput
    connect?: WatchlistUserWhereUniqueInput
    update?: XOR<XOR<WatchlistUserUpdateToOneWithWhereWithoutTweetsInput, WatchlistUserUpdateWithoutTweetsInput>, WatchlistUserUncheckedUpdateWithoutTweetsInput>
  }

  export type CotDraftCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
  }

  export type CotPhaseCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
  }

  export type CotDraftUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
  }

  export type CotPhaseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
  }

  export type EnumCotSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotSessionStatus
  }

  export type EnumCotPhaseStepFieldUpdateOperationsInput = {
    set?: $Enums.CotPhaseStep
  }

  export type CotDraftUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    upsert?: CotDraftUpsertWithWhereUniqueWithoutSessionInput | CotDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    set?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    disconnect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    delete?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    update?: CotDraftUpdateWithWhereUniqueWithoutSessionInput | CotDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotDraftUpdateManyWithWhereWithoutSessionInput | CotDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
  }

  export type CotPhaseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    upsert?: CotPhaseUpsertWithWhereUniqueWithoutSessionInput | CotPhaseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    set?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    disconnect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    delete?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    update?: CotPhaseUpdateWithWhereUniqueWithoutSessionInput | CotPhaseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotPhaseUpdateManyWithWhereWithoutSessionInput | CotPhaseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
  }

  export type CotDraftUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    upsert?: CotDraftUpsertWithWhereUniqueWithoutSessionInput | CotDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    set?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    disconnect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    delete?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    update?: CotDraftUpdateWithWhereUniqueWithoutSessionInput | CotDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotDraftUpdateManyWithWhereWithoutSessionInput | CotDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
  }

  export type CotPhaseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    upsert?: CotPhaseUpsertWithWhereUniqueWithoutSessionInput | CotPhaseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    set?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    disconnect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    delete?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    update?: CotPhaseUpdateWithWhereUniqueWithoutSessionInput | CotPhaseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotPhaseUpdateManyWithWhereWithoutSessionInput | CotPhaseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
  }

  export type CotSessionCreateNestedOneWithoutPhasesInput = {
    create?: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutPhasesInput
    connect?: CotSessionWhereUniqueInput
  }

  export type EnumCotPhaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotPhaseStatus
  }

  export type CotSessionUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutPhasesInput
    upsert?: CotSessionUpsertWithoutPhasesInput
    connect?: CotSessionWhereUniqueInput
    update?: XOR<XOR<CotSessionUpdateToOneWithWhereWithoutPhasesInput, CotSessionUpdateWithoutPhasesInput>, CotSessionUncheckedUpdateWithoutPhasesInput>
  }

  export type CotDraftCreatehashtagsInput = {
    set: string[]
  }

  export type CotDraftPerformanceCreateNestedOneWithoutDraftInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: CotDraftPerformanceWhereUniqueInput
  }

  export type CotSessionCreateNestedOneWithoutDraftsInput = {
    create?: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutDraftsInput
    connect?: CotSessionWhereUniqueInput
  }

  export type CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: CotDraftPerformanceWhereUniqueInput
  }

  export type CotDraftUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCotDraftStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotDraftStatus
  }

  export type CotDraftPerformanceUpdateOneWithoutDraftNestedInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: CotDraftPerformanceUpsertWithoutDraftInput
    disconnect?: CotDraftPerformanceWhereInput | boolean
    delete?: CotDraftPerformanceWhereInput | boolean
    connect?: CotDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, CotDraftPerformanceUpdateWithoutDraftInput>, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotSessionUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutDraftsInput
    upsert?: CotSessionUpsertWithoutDraftsInput
    connect?: CotSessionWhereUniqueInput
    update?: XOR<XOR<CotSessionUpdateToOneWithWhereWithoutDraftsInput, CotSessionUpdateWithoutDraftsInput>, CotSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: CotDraftPerformanceUpsertWithoutDraftInput
    disconnect?: CotDraftPerformanceWhereInput | boolean
    delete?: CotDraftPerformanceWhereInput | boolean
    connect?: CotDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, CotDraftPerformanceUpdateWithoutDraftInput>, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotDraftCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutPerformanceInput
    connect?: CotDraftWhereUniqueInput
  }

  export type CotDraftUpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutPerformanceInput
    upsert?: CotDraftUpsertWithoutPerformanceInput
    connect?: CotDraftWhereUniqueInput
    update?: XOR<XOR<CotDraftUpdateToOneWithWhereWithoutPerformanceInput, CotDraftUpdateWithoutPerformanceInput>, CotDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type EnumRTStatusFieldUpdateOperationsInput = {
    set?: $Enums.RTStatus
  }

  export type ViralSessionCreateselectedIdsInput = {
    set: string[]
  }

  export type ViralDraftV2CreateNestedManyWithoutSessionInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
  }

  export type ViralDraftV2UncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
  }

  export type ViralSessionUpdateselectedIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ViralDraftV2UpdateManyWithoutSessionNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    upsert?: ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput | ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    set?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    disconnect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    delete?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    update?: ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput | ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ViralDraftV2UpdateManyWithWhereWithoutSessionInput | ViralDraftV2UpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
  }

  export type ViralDraftV2UncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput> | ViralDraftV2CreateWithoutSessionInput[] | ViralDraftV2UncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutSessionInput | ViralDraftV2CreateOrConnectWithoutSessionInput[]
    upsert?: ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput | ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ViralDraftV2CreateManySessionInputEnvelope
    set?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    disconnect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    delete?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    connect?: ViralDraftV2WhereUniqueInput | ViralDraftV2WhereUniqueInput[]
    update?: ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput | ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ViralDraftV2UpdateManyWithWhereWithoutSessionInput | ViralDraftV2UpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
  }

  export type ViralDraftV2CreatehashtagsInput = {
    set: string[]
  }

  export type ViralDraftPerformanceCreateNestedOneWithoutDraftInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: ViralDraftPerformanceWhereUniqueInput
  }

  export type ViralSessionCreateNestedOneWithoutDraftsInput = {
    create?: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutDraftsInput
    connect?: ViralSessionWhereUniqueInput
  }

  export type ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: ViralDraftPerformanceWhereUniqueInput
  }

  export type ViralDraftV2UpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ViralDraftPerformanceUpdateOneWithoutDraftNestedInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: ViralDraftPerformanceUpsertWithoutDraftInput
    disconnect?: ViralDraftPerformanceWhereInput | boolean
    delete?: ViralDraftPerformanceWhereInput | boolean
    connect?: ViralDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<ViralDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, ViralDraftPerformanceUpdateWithoutDraftInput>, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ViralSessionUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: ViralSessionCreateOrConnectWithoutDraftsInput
    upsert?: ViralSessionUpsertWithoutDraftsInput
    connect?: ViralSessionWhereUniqueInput
    update?: XOR<XOR<ViralSessionUpdateToOneWithWhereWithoutDraftsInput, ViralSessionUpdateWithoutDraftsInput>, ViralSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput = {
    create?: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: ViralDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: ViralDraftPerformanceUpsertWithoutDraftInput
    disconnect?: ViralDraftPerformanceWhereInput | boolean
    delete?: ViralDraftPerformanceWhereInput | boolean
    connect?: ViralDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<ViralDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, ViralDraftPerformanceUpdateWithoutDraftInput>, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ViralDraftV2CreateNestedOneWithoutPerformanceInput = {
    create?: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutPerformanceInput
    connect?: ViralDraftV2WhereUniqueInput
  }

  export type ViralDraftV2UpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: ViralDraftV2CreateOrConnectWithoutPerformanceInput
    upsert?: ViralDraftV2UpsertWithoutPerformanceInput
    connect?: ViralDraftV2WhereUniqueInput
    update?: XOR<XOR<ViralDraftV2UpdateToOneWithWhereWithoutPerformanceInput, ViralDraftV2UpdateWithoutPerformanceInput>, ViralDraftV2UncheckedUpdateWithoutPerformanceInput>
  }

  export type CharacterProfileCreatepreferredNewsCategoriesInput = {
    set: string[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type CharacterProfileUpdatepreferredNewsCategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type gpt_analysesCreateNestedOneWithoutContent_draftsInput = {
    create?: XOR<gpt_analysesCreateWithoutContent_draftsInput, gpt_analysesUncheckedCreateWithoutContent_draftsInput>
    connectOrCreate?: gpt_analysesCreateOrConnectWithoutContent_draftsInput
    connect?: gpt_analysesWhereUniqueInput
  }

  export type gpt_analysesUpdateOneRequiredWithoutContent_draftsNestedInput = {
    create?: XOR<gpt_analysesCreateWithoutContent_draftsInput, gpt_analysesUncheckedCreateWithoutContent_draftsInput>
    connectOrCreate?: gpt_analysesCreateOrConnectWithoutContent_draftsInput
    upsert?: gpt_analysesUpsertWithoutContent_draftsInput
    connect?: gpt_analysesWhereUniqueInput
    update?: XOR<XOR<gpt_analysesUpdateToOneWithWhereWithoutContent_draftsInput, gpt_analysesUpdateWithoutContent_draftsInput>, gpt_analysesUncheckedUpdateWithoutContent_draftsInput>
  }

  export type content_draftsCreateNestedManyWithoutGpt_analysesInput = {
    create?: XOR<content_draftsCreateWithoutGpt_analysesInput, content_draftsUncheckedCreateWithoutGpt_analysesInput> | content_draftsCreateWithoutGpt_analysesInput[] | content_draftsUncheckedCreateWithoutGpt_analysesInput[]
    connectOrCreate?: content_draftsCreateOrConnectWithoutGpt_analysesInput | content_draftsCreateOrConnectWithoutGpt_analysesInput[]
    createMany?: content_draftsCreateManyGpt_analysesInputEnvelope
    connect?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
  }

  export type content_draftsUncheckedCreateNestedManyWithoutGpt_analysesInput = {
    create?: XOR<content_draftsCreateWithoutGpt_analysesInput, content_draftsUncheckedCreateWithoutGpt_analysesInput> | content_draftsCreateWithoutGpt_analysesInput[] | content_draftsUncheckedCreateWithoutGpt_analysesInput[]
    connectOrCreate?: content_draftsCreateOrConnectWithoutGpt_analysesInput | content_draftsCreateOrConnectWithoutGpt_analysesInput[]
    createMany?: content_draftsCreateManyGpt_analysesInputEnvelope
    connect?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
  }

  export type content_draftsUpdateManyWithoutGpt_analysesNestedInput = {
    create?: XOR<content_draftsCreateWithoutGpt_analysesInput, content_draftsUncheckedCreateWithoutGpt_analysesInput> | content_draftsCreateWithoutGpt_analysesInput[] | content_draftsUncheckedCreateWithoutGpt_analysesInput[]
    connectOrCreate?: content_draftsCreateOrConnectWithoutGpt_analysesInput | content_draftsCreateOrConnectWithoutGpt_analysesInput[]
    upsert?: content_draftsUpsertWithWhereUniqueWithoutGpt_analysesInput | content_draftsUpsertWithWhereUniqueWithoutGpt_analysesInput[]
    createMany?: content_draftsCreateManyGpt_analysesInputEnvelope
    set?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    disconnect?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    delete?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    connect?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    update?: content_draftsUpdateWithWhereUniqueWithoutGpt_analysesInput | content_draftsUpdateWithWhereUniqueWithoutGpt_analysesInput[]
    updateMany?: content_draftsUpdateManyWithWhereWithoutGpt_analysesInput | content_draftsUpdateManyWithWhereWithoutGpt_analysesInput[]
    deleteMany?: content_draftsScalarWhereInput | content_draftsScalarWhereInput[]
  }

  export type content_draftsUncheckedUpdateManyWithoutGpt_analysesNestedInput = {
    create?: XOR<content_draftsCreateWithoutGpt_analysesInput, content_draftsUncheckedCreateWithoutGpt_analysesInput> | content_draftsCreateWithoutGpt_analysesInput[] | content_draftsUncheckedCreateWithoutGpt_analysesInput[]
    connectOrCreate?: content_draftsCreateOrConnectWithoutGpt_analysesInput | content_draftsCreateOrConnectWithoutGpt_analysesInput[]
    upsert?: content_draftsUpsertWithWhereUniqueWithoutGpt_analysesInput | content_draftsUpsertWithWhereUniqueWithoutGpt_analysesInput[]
    createMany?: content_draftsCreateManyGpt_analysesInputEnvelope
    set?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    disconnect?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    delete?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    connect?: content_draftsWhereUniqueInput | content_draftsWhereUniqueInput[]
    update?: content_draftsUpdateWithWhereUniqueWithoutGpt_analysesInput | content_draftsUpdateWithWhereUniqueWithoutGpt_analysesInput[]
    updateMany?: content_draftsUpdateManyWithWhereWithoutGpt_analysesInput | content_draftsUpdateManyWithWhereWithoutGpt_analysesInput[]
    deleteMany?: content_draftsScalarWhereInput | content_draftsScalarWhereInput[]
  }

  export type news_analysis_resultsCreateNestedManyWithoutNews_analysis_jobsInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput> | news_analysis_resultsCreateWithoutNews_analysis_jobsInput[] | news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput | news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput[]
    createMany?: news_analysis_resultsCreateManyNews_analysis_jobsInputEnvelope
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
  }

  export type news_analysis_resultsUncheckedCreateNestedManyWithoutNews_analysis_jobsInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput> | news_analysis_resultsCreateWithoutNews_analysis_jobsInput[] | news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput | news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput[]
    createMany?: news_analysis_resultsCreateManyNews_analysis_jobsInputEnvelope
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
  }

  export type news_analysis_resultsUpdateManyWithoutNews_analysis_jobsNestedInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput> | news_analysis_resultsCreateWithoutNews_analysis_jobsInput[] | news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput | news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput[]
    upsert?: news_analysis_resultsUpsertWithWhereUniqueWithoutNews_analysis_jobsInput | news_analysis_resultsUpsertWithWhereUniqueWithoutNews_analysis_jobsInput[]
    createMany?: news_analysis_resultsCreateManyNews_analysis_jobsInputEnvelope
    set?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    disconnect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    delete?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    update?: news_analysis_resultsUpdateWithWhereUniqueWithoutNews_analysis_jobsInput | news_analysis_resultsUpdateWithWhereUniqueWithoutNews_analysis_jobsInput[]
    updateMany?: news_analysis_resultsUpdateManyWithWhereWithoutNews_analysis_jobsInput | news_analysis_resultsUpdateManyWithWhereWithoutNews_analysis_jobsInput[]
    deleteMany?: news_analysis_resultsScalarWhereInput | news_analysis_resultsScalarWhereInput[]
  }

  export type news_analysis_resultsUncheckedUpdateManyWithoutNews_analysis_jobsNestedInput = {
    create?: XOR<news_analysis_resultsCreateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput> | news_analysis_resultsCreateWithoutNews_analysis_jobsInput[] | news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput[]
    connectOrCreate?: news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput | news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput[]
    upsert?: news_analysis_resultsUpsertWithWhereUniqueWithoutNews_analysis_jobsInput | news_analysis_resultsUpsertWithWhereUniqueWithoutNews_analysis_jobsInput[]
    createMany?: news_analysis_resultsCreateManyNews_analysis_jobsInputEnvelope
    set?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    disconnect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    delete?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    connect?: news_analysis_resultsWhereUniqueInput | news_analysis_resultsWhereUniqueInput[]
    update?: news_analysis_resultsUpdateWithWhereUniqueWithoutNews_analysis_jobsInput | news_analysis_resultsUpdateWithWhereUniqueWithoutNews_analysis_jobsInput[]
    updateMany?: news_analysis_resultsUpdateManyWithWhereWithoutNews_analysis_jobsInput | news_analysis_resultsUpdateManyWithWhereWithoutNews_analysis_jobsInput[]
    deleteMany?: news_analysis_resultsScalarWhereInput | news_analysis_resultsScalarWhereInput[]
  }

  export type NewsArticleCreateNestedOneWithoutNews_analysis_resultsInput = {
    create?: XOR<NewsArticleCreateWithoutNews_analysis_resultsInput, NewsArticleUncheckedCreateWithoutNews_analysis_resultsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNews_analysis_resultsInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type news_analysis_jobsCreateNestedOneWithoutNews_analysis_resultsInput = {
    create?: XOR<news_analysis_jobsCreateWithoutNews_analysis_resultsInput, news_analysis_jobsUncheckedCreateWithoutNews_analysis_resultsInput>
    connectOrCreate?: news_analysis_jobsCreateOrConnectWithoutNews_analysis_resultsInput
    connect?: news_analysis_jobsWhereUniqueInput
  }

  export type NewsArticleUpdateOneRequiredWithoutNews_analysis_resultsNestedInput = {
    create?: XOR<NewsArticleCreateWithoutNews_analysis_resultsInput, NewsArticleUncheckedCreateWithoutNews_analysis_resultsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNews_analysis_resultsInput
    upsert?: NewsArticleUpsertWithoutNews_analysis_resultsInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutNews_analysis_resultsInput, NewsArticleUpdateWithoutNews_analysis_resultsInput>, NewsArticleUncheckedUpdateWithoutNews_analysis_resultsInput>
  }

  export type news_analysis_jobsUpdateOneRequiredWithoutNews_analysis_resultsNestedInput = {
    create?: XOR<news_analysis_jobsCreateWithoutNews_analysis_resultsInput, news_analysis_jobsUncheckedCreateWithoutNews_analysis_resultsInput>
    connectOrCreate?: news_analysis_jobsCreateOrConnectWithoutNews_analysis_resultsInput
    upsert?: news_analysis_jobsUpsertWithoutNews_analysis_resultsInput
    connect?: news_analysis_jobsWhereUniqueInput
    update?: XOR<XOR<news_analysis_jobsUpdateToOneWithWhereWithoutNews_analysis_resultsInput, news_analysis_jobsUpdateWithoutNews_analysis_resultsInput>, news_analysis_jobsUncheckedUpdateWithoutNews_analysis_resultsInput>
  }

  export type viral_opportunitiesCreatekeywordsInput = {
    set: string[]
  }

  export type viral_postsCreateNestedManyWithoutViral_opportunitiesInput = {
    create?: XOR<viral_postsCreateWithoutViral_opportunitiesInput, viral_postsUncheckedCreateWithoutViral_opportunitiesInput> | viral_postsCreateWithoutViral_opportunitiesInput[] | viral_postsUncheckedCreateWithoutViral_opportunitiesInput[]
    connectOrCreate?: viral_postsCreateOrConnectWithoutViral_opportunitiesInput | viral_postsCreateOrConnectWithoutViral_opportunitiesInput[]
    createMany?: viral_postsCreateManyViral_opportunitiesInputEnvelope
    connect?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
  }

  export type viral_postsUncheckedCreateNestedManyWithoutViral_opportunitiesInput = {
    create?: XOR<viral_postsCreateWithoutViral_opportunitiesInput, viral_postsUncheckedCreateWithoutViral_opportunitiesInput> | viral_postsCreateWithoutViral_opportunitiesInput[] | viral_postsUncheckedCreateWithoutViral_opportunitiesInput[]
    connectOrCreate?: viral_postsCreateOrConnectWithoutViral_opportunitiesInput | viral_postsCreateOrConnectWithoutViral_opportunitiesInput[]
    createMany?: viral_postsCreateManyViral_opportunitiesInputEnvelope
    connect?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
  }

  export type viral_opportunitiesUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type viral_postsUpdateManyWithoutViral_opportunitiesNestedInput = {
    create?: XOR<viral_postsCreateWithoutViral_opportunitiesInput, viral_postsUncheckedCreateWithoutViral_opportunitiesInput> | viral_postsCreateWithoutViral_opportunitiesInput[] | viral_postsUncheckedCreateWithoutViral_opportunitiesInput[]
    connectOrCreate?: viral_postsCreateOrConnectWithoutViral_opportunitiesInput | viral_postsCreateOrConnectWithoutViral_opportunitiesInput[]
    upsert?: viral_postsUpsertWithWhereUniqueWithoutViral_opportunitiesInput | viral_postsUpsertWithWhereUniqueWithoutViral_opportunitiesInput[]
    createMany?: viral_postsCreateManyViral_opportunitiesInputEnvelope
    set?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    disconnect?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    delete?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    connect?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    update?: viral_postsUpdateWithWhereUniqueWithoutViral_opportunitiesInput | viral_postsUpdateWithWhereUniqueWithoutViral_opportunitiesInput[]
    updateMany?: viral_postsUpdateManyWithWhereWithoutViral_opportunitiesInput | viral_postsUpdateManyWithWhereWithoutViral_opportunitiesInput[]
    deleteMany?: viral_postsScalarWhereInput | viral_postsScalarWhereInput[]
  }

  export type viral_postsUncheckedUpdateManyWithoutViral_opportunitiesNestedInput = {
    create?: XOR<viral_postsCreateWithoutViral_opportunitiesInput, viral_postsUncheckedCreateWithoutViral_opportunitiesInput> | viral_postsCreateWithoutViral_opportunitiesInput[] | viral_postsUncheckedCreateWithoutViral_opportunitiesInput[]
    connectOrCreate?: viral_postsCreateOrConnectWithoutViral_opportunitiesInput | viral_postsCreateOrConnectWithoutViral_opportunitiesInput[]
    upsert?: viral_postsUpsertWithWhereUniqueWithoutViral_opportunitiesInput | viral_postsUpsertWithWhereUniqueWithoutViral_opportunitiesInput[]
    createMany?: viral_postsCreateManyViral_opportunitiesInputEnvelope
    set?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    disconnect?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    delete?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    connect?: viral_postsWhereUniqueInput | viral_postsWhereUniqueInput[]
    update?: viral_postsUpdateWithWhereUniqueWithoutViral_opportunitiesInput | viral_postsUpdateWithWhereUniqueWithoutViral_opportunitiesInput[]
    updateMany?: viral_postsUpdateManyWithWhereWithoutViral_opportunitiesInput | viral_postsUpdateManyWithWhereWithoutViral_opportunitiesInput[]
    deleteMany?: viral_postsScalarWhereInput | viral_postsScalarWhereInput[]
  }

  export type viral_postsCreateNestedOneWithoutViral_post_performanceInput = {
    create?: XOR<viral_postsCreateWithoutViral_post_performanceInput, viral_postsUncheckedCreateWithoutViral_post_performanceInput>
    connectOrCreate?: viral_postsCreateOrConnectWithoutViral_post_performanceInput
    connect?: viral_postsWhereUniqueInput
  }

  export type viral_postsUpdateOneRequiredWithoutViral_post_performanceNestedInput = {
    create?: XOR<viral_postsCreateWithoutViral_post_performanceInput, viral_postsUncheckedCreateWithoutViral_post_performanceInput>
    connectOrCreate?: viral_postsCreateOrConnectWithoutViral_post_performanceInput
    upsert?: viral_postsUpsertWithoutViral_post_performanceInput
    connect?: viral_postsWhereUniqueInput
    update?: XOR<XOR<viral_postsUpdateToOneWithWhereWithoutViral_post_performanceInput, viral_postsUpdateWithoutViral_post_performanceInput>, viral_postsUncheckedUpdateWithoutViral_post_performanceInput>
  }

  export type viral_postsCreatehashtagsInput = {
    set: string[]
  }

  export type viral_post_performanceCreateNestedOneWithoutViral_postsInput = {
    create?: XOR<viral_post_performanceCreateWithoutViral_postsInput, viral_post_performanceUncheckedCreateWithoutViral_postsInput>
    connectOrCreate?: viral_post_performanceCreateOrConnectWithoutViral_postsInput
    connect?: viral_post_performanceWhereUniqueInput
  }

  export type viral_opportunitiesCreateNestedOneWithoutViral_postsInput = {
    create?: XOR<viral_opportunitiesCreateWithoutViral_postsInput, viral_opportunitiesUncheckedCreateWithoutViral_postsInput>
    connectOrCreate?: viral_opportunitiesCreateOrConnectWithoutViral_postsInput
    connect?: viral_opportunitiesWhereUniqueInput
  }

  export type viral_post_performanceUncheckedCreateNestedOneWithoutViral_postsInput = {
    create?: XOR<viral_post_performanceCreateWithoutViral_postsInput, viral_post_performanceUncheckedCreateWithoutViral_postsInput>
    connectOrCreate?: viral_post_performanceCreateOrConnectWithoutViral_postsInput
    connect?: viral_post_performanceWhereUniqueInput
  }

  export type viral_postsUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type viral_post_performanceUpdateOneWithoutViral_postsNestedInput = {
    create?: XOR<viral_post_performanceCreateWithoutViral_postsInput, viral_post_performanceUncheckedCreateWithoutViral_postsInput>
    connectOrCreate?: viral_post_performanceCreateOrConnectWithoutViral_postsInput
    upsert?: viral_post_performanceUpsertWithoutViral_postsInput
    disconnect?: viral_post_performanceWhereInput | boolean
    delete?: viral_post_performanceWhereInput | boolean
    connect?: viral_post_performanceWhereUniqueInput
    update?: XOR<XOR<viral_post_performanceUpdateToOneWithWhereWithoutViral_postsInput, viral_post_performanceUpdateWithoutViral_postsInput>, viral_post_performanceUncheckedUpdateWithoutViral_postsInput>
  }

  export type viral_opportunitiesUpdateOneRequiredWithoutViral_postsNestedInput = {
    create?: XOR<viral_opportunitiesCreateWithoutViral_postsInput, viral_opportunitiesUncheckedCreateWithoutViral_postsInput>
    connectOrCreate?: viral_opportunitiesCreateOrConnectWithoutViral_postsInput
    upsert?: viral_opportunitiesUpsertWithoutViral_postsInput
    connect?: viral_opportunitiesWhereUniqueInput
    update?: XOR<XOR<viral_opportunitiesUpdateToOneWithWhereWithoutViral_postsInput, viral_opportunitiesUpdateWithoutViral_postsInput>, viral_opportunitiesUncheckedUpdateWithoutViral_postsInput>
  }

  export type viral_post_performanceUncheckedUpdateOneWithoutViral_postsNestedInput = {
    create?: XOR<viral_post_performanceCreateWithoutViral_postsInput, viral_post_performanceUncheckedCreateWithoutViral_postsInput>
    connectOrCreate?: viral_post_performanceCreateOrConnectWithoutViral_postsInput
    upsert?: viral_post_performanceUpsertWithoutViral_postsInput
    disconnect?: viral_post_performanceWhereInput | boolean
    delete?: viral_post_performanceWhereInput | boolean
    connect?: viral_post_performanceWhereUniqueInput
    update?: XOR<XOR<viral_post_performanceUpdateToOneWithWhereWithoutViral_postsInput, viral_post_performanceUpdateWithoutViral_postsInput>, viral_post_performanceUncheckedUpdateWithoutViral_postsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCotSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusFilter<$PrismaModel> | $Enums.CotSessionStatus
  }

  export type NestedEnumCotPhaseStepFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepFilter<$PrismaModel> | $Enums.CotPhaseStep
  }

  export type NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCotSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStepFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStepFilter<$PrismaModel>
  }

  export type NestedEnumCotPhaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusFilter<$PrismaModel> | $Enums.CotPhaseStatus
  }

  export type NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumCotDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusFilter<$PrismaModel> | $Enums.CotDraftStatus
  }

  export type NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotDraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumCotDraftStatusFilter<$PrismaModel>
  }

  export type NestedEnumRTStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusFilter<$PrismaModel> | $Enums.RTStatus
  }

  export type NestedEnumRTStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RTStatus | EnumRTStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RTStatus[] | ListEnumRTStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRTStatusWithAggregatesFilter<$PrismaModel> | $Enums.RTStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRTStatusFilter<$PrismaModel>
    _max?: NestedEnumRTStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ScheduledPostCreateWithoutRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post_analytics?: PostAnalyticsCreateNestedManyWithoutScheduled_postsInput
  }

  export type ScheduledPostUncheckedCreateWithoutRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post_analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutScheduled_postsInput
  }

  export type ScheduledPostCreateOrConnectWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    create: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput>
  }

  export type ScheduledPostCreateManyRefPostInputEnvelope = {
    data: ScheduledPostCreateManyRefPostInput | ScheduledPostCreateManyRefPostInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    update: XOR<ScheduledPostUpdateWithoutRefPostInput, ScheduledPostUncheckedUpdateWithoutRefPostInput>
    create: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput>
  }

  export type ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    data: XOR<ScheduledPostUpdateWithoutRefPostInput, ScheduledPostUncheckedUpdateWithoutRefPostInput>
  }

  export type ScheduledPostUpdateManyWithWhereWithoutRefPostInput = {
    where: ScheduledPostScalarWhereInput
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyWithoutRefPostInput>
  }

  export type ScheduledPostScalarWhereInput = {
    AND?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
    OR?: ScheduledPostScalarWhereInput[]
    NOT?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
  }

  export type PostAnalyticsCreateWithoutScheduled_postsInput = {
    id?: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at?: Date | string
    engagementRate: number
    ai_analysis?: string | null
  }

  export type PostAnalyticsUncheckedCreateWithoutScheduled_postsInput = {
    id?: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at?: Date | string
    engagementRate: number
    ai_analysis?: string | null
  }

  export type PostAnalyticsCreateOrConnectWithoutScheduled_postsInput = {
    where: PostAnalyticsWhereUniqueInput
    create: XOR<PostAnalyticsCreateWithoutScheduled_postsInput, PostAnalyticsUncheckedCreateWithoutScheduled_postsInput>
  }

  export type PostAnalyticsCreateManyScheduled_postsInputEnvelope = {
    data: PostAnalyticsCreateManyScheduled_postsInput | PostAnalyticsCreateManyScheduled_postsInput[]
    skipDuplicates?: boolean
  }

  export type BuzzPostCreateWithoutScheduledPostsInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostUncheckedCreateWithoutScheduledPostsInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostCreateOrConnectWithoutScheduledPostsInput = {
    where: BuzzPostWhereUniqueInput
    create: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
  }

  export type PostAnalyticsUpsertWithWhereUniqueWithoutScheduled_postsInput = {
    where: PostAnalyticsWhereUniqueInput
    update: XOR<PostAnalyticsUpdateWithoutScheduled_postsInput, PostAnalyticsUncheckedUpdateWithoutScheduled_postsInput>
    create: XOR<PostAnalyticsCreateWithoutScheduled_postsInput, PostAnalyticsUncheckedCreateWithoutScheduled_postsInput>
  }

  export type PostAnalyticsUpdateWithWhereUniqueWithoutScheduled_postsInput = {
    where: PostAnalyticsWhereUniqueInput
    data: XOR<PostAnalyticsUpdateWithoutScheduled_postsInput, PostAnalyticsUncheckedUpdateWithoutScheduled_postsInput>
  }

  export type PostAnalyticsUpdateManyWithWhereWithoutScheduled_postsInput = {
    where: PostAnalyticsScalarWhereInput
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyWithoutScheduled_postsInput>
  }

  export type PostAnalyticsScalarWhereInput = {
    AND?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
    OR?: PostAnalyticsScalarWhereInput[]
    NOT?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
    id?: StringFilter<"PostAnalytics"> | string
    scheduled_post_id?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    link_clicks?: IntFilter<"PostAnalytics"> | number
    measured_at?: DateTimeFilter<"PostAnalytics"> | Date | string
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    ai_analysis?: StringNullableFilter<"PostAnalytics"> | string | null
  }

  export type BuzzPostUpsertWithoutScheduledPostsInput = {
    update: XOR<BuzzPostUpdateWithoutScheduledPostsInput, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
    create: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    where?: BuzzPostWhereInput
  }

  export type BuzzPostUpdateToOneWithWhereWithoutScheduledPostsInput = {
    where?: BuzzPostWhereInput
    data: XOR<BuzzPostUpdateWithoutScheduledPostsInput, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
  }

  export type BuzzPostUpdateWithoutScheduledPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzPostUncheckedUpdateWithoutScheduledPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ScheduledPostCreateWithoutPost_analyticsInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    refPost?: BuzzPostCreateNestedOneWithoutScheduledPostsInput
  }

  export type ScheduledPostUncheckedCreateWithoutPost_analyticsInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostCreateOrConnectWithoutPost_analyticsInput = {
    where: ScheduledPostWhereUniqueInput
    create: XOR<ScheduledPostCreateWithoutPost_analyticsInput, ScheduledPostUncheckedCreateWithoutPost_analyticsInput>
  }

  export type ScheduledPostUpsertWithoutPost_analyticsInput = {
    update: XOR<ScheduledPostUpdateWithoutPost_analyticsInput, ScheduledPostUncheckedUpdateWithoutPost_analyticsInput>
    create: XOR<ScheduledPostCreateWithoutPost_analyticsInput, ScheduledPostUncheckedCreateWithoutPost_analyticsInput>
    where?: ScheduledPostWhereInput
  }

  export type ScheduledPostUpdateToOneWithWhereWithoutPost_analyticsInput = {
    where?: ScheduledPostWhereInput
    data: XOR<ScheduledPostUpdateWithoutPost_analyticsInput, ScheduledPostUncheckedUpdateWithoutPost_analyticsInput>
  }

  export type ScheduledPostUpdateWithoutPost_analyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refPost?: BuzzPostUpdateOneWithoutScheduledPostsNestedInput
  }

  export type ScheduledPostUncheckedUpdateWithoutPost_analyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountsCreateWithoutUsersInput = {
    id?: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type accountsUncheckedCreateWithoutUsersInput = {
    id?: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type accountsCreateOrConnectWithoutUsersInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutUsersInput, accountsUncheckedCreateWithoutUsersInput>
  }

  export type accountsCreateManyUsersInputEnvelope = {
    data: accountsCreateManyUsersInput | accountsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    created_at?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    created_at?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WatchlistUserCreateWithoutUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUserCreateManyUserInputEnvelope = {
    data: WatchlistUserCreateManyUserInput | WatchlistUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type accountsUpsertWithWhereUniqueWithoutUsersInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutUsersInput, accountsUncheckedUpdateWithoutUsersInput>
    create: XOR<accountsCreateWithoutUsersInput, accountsUncheckedCreateWithoutUsersInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutUsersInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutUsersInput, accountsUncheckedUpdateWithoutUsersInput>
  }

  export type accountsUpdateManyWithWhereWithoutUsersInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutUsersInput>
  }

  export type accountsScalarWhereInput = {
    AND?: accountsScalarWhereInput | accountsScalarWhereInput[]
    OR?: accountsScalarWhereInput[]
    NOT?: accountsScalarWhereInput | accountsScalarWhereInput[]
    id?: StringFilter<"accounts"> | string
    user_id?: StringFilter<"accounts"> | string
    type?: StringFilter<"accounts"> | string
    provider?: StringFilter<"accounts"> | string
    provider_account_id?: StringFilter<"accounts"> | string
    refresh_token?: StringNullableFilter<"accounts"> | string | null
    access_token?: StringNullableFilter<"accounts"> | string | null
    expires_at?: IntNullableFilter<"accounts"> | number | null
    token_type?: StringNullableFilter<"accounts"> | string | null
    scope?: StringNullableFilter<"accounts"> | string | null
    id_token?: StringNullableFilter<"accounts"> | string | null
    session_state?: StringNullableFilter<"accounts"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    created_at?: DateTimeFilter<"Session"> | Date | string
  }

  export type WatchlistUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    update: XOR<WatchlistUserUpdateWithoutUserInput, WatchlistUserUncheckedUpdateWithoutUserInput>
    create: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    data: XOR<WatchlistUserUpdateWithoutUserInput, WatchlistUserUncheckedUpdateWithoutUserInput>
  }

  export type WatchlistUserUpdateManyWithWhereWithoutUserInput = {
    where: WatchlistUserScalarWhereInput
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WatchlistUserScalarWhereInput = {
    AND?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
    OR?: WatchlistUserScalarWhereInput[]
    NOT?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
    id?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    profile_image?: StringNullableFilter<"WatchlistUser"> | string | null
    bio?: StringNullableFilter<"WatchlistUser"> | string | null
    followers_count?: IntFilter<"WatchlistUser"> | number
    category?: StringNullableListFilter<"WatchlistUser">
    notes?: StringNullableFilter<"WatchlistUser"> | string | null
    priority?: IntFilter<"WatchlistUser"> | number
    is_following?: BoolFilter<"WatchlistUser"> | boolean
    added_at?: DateTimeFilter<"WatchlistUser"> | Date | string
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    userId?: StringFilter<"WatchlistUser"> | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: accountsCreateNestedManyWithoutUsersInput
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: accountsUncheckedCreateNestedManyWithoutUsersInput
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUpdateManyWithoutUsersNestedInput
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUncheckedUpdateManyWithoutUsersNestedInput
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NewsArticleCreateWithoutSourceInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    news_analysis_results?: news_analysis_resultsCreateNestedManyWithoutNews_articlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutSourceInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    news_analysis_results?: news_analysis_resultsUncheckedCreateNestedManyWithoutNews_articlesInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput>
  }

  export type NewsArticleCreateManySourceInputEnvelope = {
    data: NewsArticleCreateManySourceInput | NewsArticleCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type NewsArticleUpsertWithWhereUniqueWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    update: XOR<NewsArticleUpdateWithoutSourceInput, NewsArticleUncheckedUpdateWithoutSourceInput>
    create: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput>
  }

  export type NewsArticleUpdateWithWhereUniqueWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    data: XOR<NewsArticleUpdateWithoutSourceInput, NewsArticleUncheckedUpdateWithoutSourceInput>
  }

  export type NewsArticleUpdateManyWithWhereWithoutSourceInput = {
    where: NewsArticleScalarWhereInput
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyWithoutSourceInput>
  }

  export type NewsArticleScalarWhereInput = {
    AND?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
    OR?: NewsArticleScalarWhereInput[]
    NOT?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    summary?: StringFilter<"NewsArticle"> | string
    content?: StringFilter<"NewsArticle"> | string
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
  }

  export type NewsAnalysisCreateWithoutArticleInput = {
    id?: string
    category: string
    summary: string
    japanese_summary: string
    key_points?: NewsAnalysisCreatekey_pointsInput | string[]
    impact: string
    analyzed_by: string
    createdAt?: Date | string
    updated_at: Date | string
  }

  export type NewsAnalysisUncheckedCreateWithoutArticleInput = {
    id?: string
    category: string
    summary: string
    japanese_summary: string
    key_points?: NewsAnalysisCreatekey_pointsInput | string[]
    impact: string
    analyzed_by: string
    createdAt?: Date | string
    updated_at: Date | string
  }

  export type NewsAnalysisCreateOrConnectWithoutArticleInput = {
    where: NewsAnalysisWhereUniqueInput
    create: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
  }

  export type news_analysis_resultsCreateWithoutNews_articlesInput = {
    id?: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    news_analysis_jobs: news_analysis_jobsCreateNestedOneWithoutNews_analysis_resultsInput
  }

  export type news_analysis_resultsUncheckedCreateWithoutNews_articlesInput = {
    id?: string
    job_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type news_analysis_resultsCreateOrConnectWithoutNews_articlesInput = {
    where: news_analysis_resultsWhereUniqueInput
    create: XOR<news_analysis_resultsCreateWithoutNews_articlesInput, news_analysis_resultsUncheckedCreateWithoutNews_articlesInput>
  }

  export type news_analysis_resultsCreateManyNews_articlesInputEnvelope = {
    data: news_analysis_resultsCreateManyNews_articlesInput | news_analysis_resultsCreateManyNews_articlesInput[]
    skipDuplicates?: boolean
  }

  export type NewsSourceCreateWithoutArticlesInput = {
    id?: string
    name: string
    url: string
    type: string
    category: string
    active?: boolean
    createdAt?: Date | string
  }

  export type NewsSourceUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    url: string
    type: string
    category: string
    active?: boolean
    createdAt?: Date | string
  }

  export type NewsSourceCreateOrConnectWithoutArticlesInput = {
    where: NewsSourceWhereUniqueInput
    create: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
  }

  export type NewsThreadItemCreateWithoutArticleInput = {
    id?: string
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
    thread: NewsThreadCreateNestedOneWithoutItemsInput
  }

  export type NewsThreadItemUncheckedCreateWithoutArticleInput = {
    id?: string
    threadId: string
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type NewsThreadItemCreateOrConnectWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    create: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput>
  }

  export type NewsThreadItemCreateManyArticleInputEnvelope = {
    data: NewsThreadItemCreateManyArticleInput | NewsThreadItemCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type NewsAnalysisUpsertWithoutArticleInput = {
    update: XOR<NewsAnalysisUpdateWithoutArticleInput, NewsAnalysisUncheckedUpdateWithoutArticleInput>
    create: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    where?: NewsAnalysisWhereInput
  }

  export type NewsAnalysisUpdateToOneWithWhereWithoutArticleInput = {
    where?: NewsAnalysisWhereInput
    data: XOR<NewsAnalysisUpdateWithoutArticleInput, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsAnalysisUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    japanese_summary?: StringFieldUpdateOperationsInput | string
    key_points?: NewsAnalysisUpdatekey_pointsInput | string[]
    impact?: StringFieldUpdateOperationsInput | string
    analyzed_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    japanese_summary?: StringFieldUpdateOperationsInput | string
    key_points?: NewsAnalysisUpdatekey_pointsInput | string[]
    impact?: StringFieldUpdateOperationsInput | string
    analyzed_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_resultsUpsertWithWhereUniqueWithoutNews_articlesInput = {
    where: news_analysis_resultsWhereUniqueInput
    update: XOR<news_analysis_resultsUpdateWithoutNews_articlesInput, news_analysis_resultsUncheckedUpdateWithoutNews_articlesInput>
    create: XOR<news_analysis_resultsCreateWithoutNews_articlesInput, news_analysis_resultsUncheckedCreateWithoutNews_articlesInput>
  }

  export type news_analysis_resultsUpdateWithWhereUniqueWithoutNews_articlesInput = {
    where: news_analysis_resultsWhereUniqueInput
    data: XOR<news_analysis_resultsUpdateWithoutNews_articlesInput, news_analysis_resultsUncheckedUpdateWithoutNews_articlesInput>
  }

  export type news_analysis_resultsUpdateManyWithWhereWithoutNews_articlesInput = {
    where: news_analysis_resultsScalarWhereInput
    data: XOR<news_analysis_resultsUpdateManyMutationInput, news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesInput>
  }

  export type news_analysis_resultsScalarWhereInput = {
    AND?: news_analysis_resultsScalarWhereInput | news_analysis_resultsScalarWhereInput[]
    OR?: news_analysis_resultsScalarWhereInput[]
    NOT?: news_analysis_resultsScalarWhereInput | news_analysis_resultsScalarWhereInput[]
    id?: StringFilter<"news_analysis_results"> | string
    job_id?: StringFilter<"news_analysis_results"> | string
    article_id?: StringFilter<"news_analysis_results"> | string
    importance_score?: FloatFilter<"news_analysis_results"> | number
    category?: StringFilter<"news_analysis_results"> | string
    summary_ja?: StringFilter<"news_analysis_results"> | string
    key_points?: JsonFilter<"news_analysis_results">
    impact_assessment?: StringFilter<"news_analysis_results"> | string
    expert_perspective?: StringNullableFilter<"news_analysis_results"> | string | null
    metadata?: JsonNullableFilter<"news_analysis_results">
    created_at?: DateTimeFilter<"news_analysis_results"> | Date | string
  }

  export type NewsSourceUpsertWithoutArticlesInput = {
    update: XOR<NewsSourceUpdateWithoutArticlesInput, NewsSourceUncheckedUpdateWithoutArticlesInput>
    create: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    where?: NewsSourceWhereInput
  }

  export type NewsSourceUpdateToOneWithWhereWithoutArticlesInput = {
    where?: NewsSourceWhereInput
    data: XOR<NewsSourceUpdateWithoutArticlesInput, NewsSourceUncheckedUpdateWithoutArticlesInput>
  }

  export type NewsSourceUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    update: XOR<NewsThreadItemUpdateWithoutArticleInput, NewsThreadItemUncheckedUpdateWithoutArticleInput>
    create: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput>
  }

  export type NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    data: XOR<NewsThreadItemUpdateWithoutArticleInput, NewsThreadItemUncheckedUpdateWithoutArticleInput>
  }

  export type NewsThreadItemUpdateManyWithWhereWithoutArticleInput = {
    where: NewsThreadItemScalarWhereInput
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyWithoutArticleInput>
  }

  export type NewsThreadItemScalarWhereInput = {
    AND?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
    OR?: NewsThreadItemScalarWhereInput[]
    NOT?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
    id?: StringFilter<"NewsThreadItem"> | string
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringNullableFilter<"NewsThreadItem"> | string | null
    tweet_id?: StringNullableFilter<"NewsThreadItem"> | string | null
    parent_tweet_id?: StringNullableFilter<"NewsThreadItem"> | string | null
    posted_at?: DateTimeNullableFilter<"NewsThreadItem"> | Date | string | null
    content?: StringFilter<"NewsThreadItem"> | string
    metadata?: JsonNullableFilter<"NewsThreadItem">
    position?: IntFilter<"NewsThreadItem"> | number
  }

  export type NewsThreadItemCreateWithoutThreadInput = {
    id?: string
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
    article?: NewsArticleCreateNestedOneWithoutNewsThreadItemsInput
  }

  export type NewsThreadItemUncheckedCreateWithoutThreadInput = {
    id?: string
    articleId?: string | null
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type NewsThreadItemCreateOrConnectWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    create: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput>
  }

  export type NewsThreadItemCreateManyThreadInputEnvelope = {
    data: NewsThreadItemCreateManyThreadInput | NewsThreadItemCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    update: XOR<NewsThreadItemUpdateWithoutThreadInput, NewsThreadItemUncheckedUpdateWithoutThreadInput>
    create: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput>
  }

  export type NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    data: XOR<NewsThreadItemUpdateWithoutThreadInput, NewsThreadItemUncheckedUpdateWithoutThreadInput>
  }

  export type NewsThreadItemUpdateManyWithWhereWithoutThreadInput = {
    where: NewsThreadItemScalarWhereInput
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyWithoutThreadInput>
  }

  export type NewsArticleCreateWithoutNewsThreadItemsInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    news_analysis_results?: news_analysis_resultsCreateNestedManyWithoutNews_articlesInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
  }

  export type NewsArticleUncheckedCreateWithoutNewsThreadItemsInput = {
    id?: string
    sourceId: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    news_analysis_results?: news_analysis_resultsUncheckedCreateNestedManyWithoutNews_articlesInput
  }

  export type NewsArticleCreateOrConnectWithoutNewsThreadItemsInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
  }

  export type NewsThreadCreateWithoutItemsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadUncheckedCreateWithoutItemsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadCreateOrConnectWithoutItemsInput = {
    where: NewsThreadWhereUniqueInput
    create: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
  }

  export type NewsArticleUpsertWithoutNewsThreadItemsInput = {
    update: XOR<NewsArticleUpdateWithoutNewsThreadItemsInput, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
    create: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutNewsThreadItemsInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutNewsThreadItemsInput, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
  }

  export type NewsArticleUpdateWithoutNewsThreadItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    news_analysis_results?: news_analysis_resultsUpdateManyWithoutNews_articlesNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    news_analysis_results?: news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesNestedInput
  }

  export type NewsThreadUpsertWithoutItemsInput = {
    update: XOR<NewsThreadUpdateWithoutItemsInput, NewsThreadUncheckedUpdateWithoutItemsInput>
    create: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    where?: NewsThreadWhereInput
  }

  export type NewsThreadUpdateToOneWithWhereWithoutItemsInput = {
    where?: NewsThreadWhereInput
    data: XOR<NewsThreadUpdateWithoutItemsInput, NewsThreadUncheckedUpdateWithoutItemsInput>
  }

  export type NewsThreadUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsArticleCreateWithoutAnalysisInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    news_analysis_results?: news_analysis_resultsCreateNestedManyWithoutNews_articlesInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutAnalysisInput = {
    id?: string
    sourceId: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    news_analysis_results?: news_analysis_resultsUncheckedCreateNestedManyWithoutNews_articlesInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutAnalysisInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
  }

  export type NewsArticleUpsertWithoutAnalysisInput = {
    update: XOR<NewsArticleUpdateWithoutAnalysisInput, NewsArticleUncheckedUpdateWithoutAnalysisInput>
    create: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutAnalysisInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutAnalysisInput, NewsArticleUncheckedUpdateWithoutAnalysisInput>
  }

  export type NewsArticleUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    news_analysis_results?: news_analysis_resultsUpdateManyWithoutNews_articlesNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    news_analysis_results?: news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type WatchlistTweetCreateWithoutWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied?: boolean
    has_quoted?: boolean
    posted_at: Date | string
    collectedAt?: Date | string
    url: string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUncheckedCreateWithoutWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied?: boolean
    has_quoted?: boolean
    posted_at: Date | string
    collectedAt?: Date | string
    url: string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetCreateOrConnectWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    create: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetCreateManyWatchlistUserInputEnvelope = {
    data: WatchlistTweetCreateManyWatchlistUserInput | WatchlistTweetCreateManyWatchlistUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWatchlistUsersInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: accountsCreateNestedManyWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchlistUsersInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: accountsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchlistUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
  }

  export type WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    update: XOR<WatchlistTweetUpdateWithoutWatchlistUserInput, WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput>
    create: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    data: XOR<WatchlistTweetUpdateWithoutWatchlistUserInput, WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput = {
    where: WatchlistTweetScalarWhereInput
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserInput>
  }

  export type WatchlistTweetScalarWhereInput = {
    AND?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
    OR?: WatchlistTweetScalarWhereInput[]
    NOT?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
    id?: StringFilter<"WatchlistTweet"> | string
    tweetId?: StringFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    likes_count?: IntFilter<"WatchlistTweet"> | number
    retweets_count?: IntFilter<"WatchlistTweet"> | number
    replies_count?: IntFilter<"WatchlistTweet"> | number
    impressions_count?: IntFilter<"WatchlistTweet"> | number
    has_replied?: BoolFilter<"WatchlistTweet"> | boolean
    has_quoted?: BoolFilter<"WatchlistTweet"> | boolean
    posted_at?: DateTimeFilter<"WatchlistTweet"> | Date | string
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    url?: StringFilter<"WatchlistTweet"> | string
    media_urls?: JsonNullableFilter<"WatchlistTweet">
  }

  export type UserUpsertWithoutWatchlistUsersInput = {
    update: XOR<UserUpdateWithoutWatchlistUsersInput, UserUncheckedUpdateWithoutWatchlistUsersInput>
    create: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchlistUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchlistUsersInput, UserUncheckedUpdateWithoutWatchlistUsersInput>
  }

  export type UserUpdateWithoutWatchlistUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUpdateManyWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchlistUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WatchlistUserCreateWithoutTweetsInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    user: UserCreateNestedOneWithoutWatchlistUsersInput
  }

  export type WatchlistUserUncheckedCreateWithoutTweetsInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
    userId: string
  }

  export type WatchlistUserCreateOrConnectWithoutTweetsInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
  }

  export type WatchlistUserUpsertWithoutTweetsInput = {
    update: XOR<WatchlistUserUpdateWithoutTweetsInput, WatchlistUserUncheckedUpdateWithoutTweetsInput>
    create: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    where?: WatchlistUserWhereInput
  }

  export type WatchlistUserUpdateToOneWithWhereWithoutTweetsInput = {
    where?: WatchlistUserWhereInput
    data: XOR<WatchlistUserUpdateWithoutTweetsInput, WatchlistUserUncheckedUpdateWithoutTweetsInput>
  }

  export type WatchlistUserUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CotDraftCreateWithoutSessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type CotDraftUncheckedCreateWithoutSessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type CotDraftCreateOrConnectWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput>
  }

  export type CotDraftCreateManySessionInputEnvelope = {
    data: CotDraftCreateManySessionInput | CotDraftCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CotPhaseCreateWithoutSessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUncheckedCreateWithoutSessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseCreateOrConnectWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    create: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput>
  }

  export type CotPhaseCreateManySessionInputEnvelope = {
    data: CotPhaseCreateManySessionInput | CotPhaseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CotDraftUpsertWithWhereUniqueWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    update: XOR<CotDraftUpdateWithoutSessionInput, CotDraftUncheckedUpdateWithoutSessionInput>
    create: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput>
  }

  export type CotDraftUpdateWithWhereUniqueWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    data: XOR<CotDraftUpdateWithoutSessionInput, CotDraftUncheckedUpdateWithoutSessionInput>
  }

  export type CotDraftUpdateManyWithWhereWithoutSessionInput = {
    where: CotDraftScalarWhereInput
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyWithoutSessionInput>
  }

  export type CotDraftScalarWhereInput = {
    AND?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
    OR?: CotDraftScalarWhereInput[]
    NOT?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
    id?: StringFilter<"CotDraft"> | string
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    thread_content?: JsonNullableFilter<"CotDraft">
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
  }

  export type CotPhaseUpsertWithWhereUniqueWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    update: XOR<CotPhaseUpdateWithoutSessionInput, CotPhaseUncheckedUpdateWithoutSessionInput>
    create: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput>
  }

  export type CotPhaseUpdateWithWhereUniqueWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    data: XOR<CotPhaseUpdateWithoutSessionInput, CotPhaseUncheckedUpdateWithoutSessionInput>
  }

  export type CotPhaseUpdateManyWithWhereWithoutSessionInput = {
    where: CotPhaseScalarWhereInput
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyWithoutSessionInput>
  }

  export type CotPhaseScalarWhereInput = {
    AND?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
    OR?: CotPhaseScalarWhereInput[]
    NOT?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
    id?: StringFilter<"CotPhase"> | string
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
  }

  export type CotSessionCreateWithoutPhasesInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateWithoutPhasesInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionCreateOrConnectWithoutPhasesInput = {
    where: CotSessionWhereUniqueInput
    create: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
  }

  export type CotSessionUpsertWithoutPhasesInput = {
    update: XOR<CotSessionUpdateWithoutPhasesInput, CotSessionUncheckedUpdateWithoutPhasesInput>
    create: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    where?: CotSessionWhereInput
  }

  export type CotSessionUpdateToOneWithWhereWithoutPhasesInput = {
    where?: CotSessionWhereInput
    data: XOR<CotSessionUpdateWithoutPhasesInput, CotSessionUncheckedUpdateWithoutPhasesInput>
  }

  export type CotSessionUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    drafts?: CotDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotDraftPerformanceCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUncheckedCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceCreateOrConnectWithoutDraftInput = {
    where: CotDraftPerformanceWhereUniqueInput
    create: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
  }

  export type CotSessionCreateWithoutDraftsInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    phases?: CotPhaseCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateWithoutDraftsInput = {
    id?: string
    theme: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    phases?: CotPhaseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionCreateOrConnectWithoutDraftsInput = {
    where: CotSessionWhereUniqueInput
    create: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
  }

  export type CotDraftPerformanceUpsertWithoutDraftInput = {
    update: XOR<CotDraftPerformanceUpdateWithoutDraftInput, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
    create: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    where?: CotDraftPerformanceWhereInput
  }

  export type CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput = {
    where?: CotDraftPerformanceWhereInput
    data: XOR<CotDraftPerformanceUpdateWithoutDraftInput, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotDraftPerformanceUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotSessionUpsertWithoutDraftsInput = {
    update: XOR<CotSessionUpdateWithoutDraftsInput, CotSessionUncheckedUpdateWithoutDraftsInput>
    create: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    where?: CotSessionWhereInput
  }

  export type CotSessionUpdateToOneWithWhereWithoutDraftsInput = {
    where?: CotSessionWhereInput
    data: XOR<CotSessionUpdateWithoutDraftsInput, CotSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type CotSessionUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    phases?: CotPhaseUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    phases?: CotPhaseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotDraftCreateWithoutPerformanceInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutDraftsInput
  }

  export type CotDraftUncheckedCreateWithoutPerformanceInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftCreateOrConnectWithoutPerformanceInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
  }

  export type CotDraftUpsertWithoutPerformanceInput = {
    update: XOR<CotDraftUpdateWithoutPerformanceInput, CotDraftUncheckedUpdateWithoutPerformanceInput>
    create: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    where?: CotDraftWhereInput
  }

  export type CotDraftUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: CotDraftWhereInput
    data: XOR<CotDraftUpdateWithoutPerformanceInput, CotDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type CotDraftUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftV2CreateWithoutSessionInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
    performance?: ViralDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type ViralDraftV2UncheckedCreateWithoutSessionInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
    performance?: ViralDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type ViralDraftV2CreateOrConnectWithoutSessionInput = {
    where: ViralDraftV2WhereUniqueInput
    create: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput>
  }

  export type ViralDraftV2CreateManySessionInputEnvelope = {
    data: ViralDraftV2CreateManySessionInput | ViralDraftV2CreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ViralDraftV2UpsertWithWhereUniqueWithoutSessionInput = {
    where: ViralDraftV2WhereUniqueInput
    update: XOR<ViralDraftV2UpdateWithoutSessionInput, ViralDraftV2UncheckedUpdateWithoutSessionInput>
    create: XOR<ViralDraftV2CreateWithoutSessionInput, ViralDraftV2UncheckedCreateWithoutSessionInput>
  }

  export type ViralDraftV2UpdateWithWhereUniqueWithoutSessionInput = {
    where: ViralDraftV2WhereUniqueInput
    data: XOR<ViralDraftV2UpdateWithoutSessionInput, ViralDraftV2UncheckedUpdateWithoutSessionInput>
  }

  export type ViralDraftV2UpdateManyWithWhereWithoutSessionInput = {
    where: ViralDraftV2ScalarWhereInput
    data: XOR<ViralDraftV2UpdateManyMutationInput, ViralDraftV2UncheckedUpdateManyWithoutSessionInput>
  }

  export type ViralDraftV2ScalarWhereInput = {
    AND?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
    OR?: ViralDraftV2ScalarWhereInput[]
    NOT?: ViralDraftV2ScalarWhereInput | ViralDraftV2ScalarWhereInput[]
    id?: StringFilter<"ViralDraftV2"> | string
    sessionId?: StringFilter<"ViralDraftV2"> | string
    conceptId?: StringFilter<"ViralDraftV2"> | string
    title?: StringFilter<"ViralDraftV2"> | string
    content?: StringFilter<"ViralDraftV2"> | string
    hashtags?: StringNullableListFilter<"ViralDraftV2">
    visualNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    status?: StringFilter<"ViralDraftV2"> | string
    scheduledAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"ViralDraftV2"> | Date | string | null
    tweetId?: StringNullableFilter<"ViralDraftV2"> | string | null
    createdAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    updatedAt?: DateTimeFilter<"ViralDraftV2"> | Date | string
    characterId?: StringNullableFilter<"ViralDraftV2"> | string | null
    characterNote?: StringNullableFilter<"ViralDraftV2"> | string | null
    sourceUrl?: StringNullableFilter<"ViralDraftV2"> | string | null
    news_article_id?: StringNullableFilter<"ViralDraftV2"> | string | null
  }

  export type ViralDraftPerformanceCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceUncheckedCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViralDraftPerformanceCreateOrConnectWithoutDraftInput = {
    where: ViralDraftPerformanceWhereUniqueInput
    create: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
  }

  export type ViralSessionCreateWithoutDraftsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: string | null
    voiceStyleMode?: string | null
  }

  export type ViralSessionUncheckedCreateWithoutDraftsInput = {
    id?: string
    theme: string
    platform: string
    style: string
    status?: string
    createdAt?: Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionCreateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: string | null
    voiceStyleMode?: string | null
  }

  export type ViralSessionCreateOrConnectWithoutDraftsInput = {
    where: ViralSessionWhereUniqueInput
    create: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
  }

  export type ViralDraftPerformanceUpsertWithoutDraftInput = {
    update: XOR<ViralDraftPerformanceUpdateWithoutDraftInput, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
    create: XOR<ViralDraftPerformanceCreateWithoutDraftInput, ViralDraftPerformanceUncheckedCreateWithoutDraftInput>
    where?: ViralDraftPerformanceWhereInput
  }

  export type ViralDraftPerformanceUpdateToOneWithWhereWithoutDraftInput = {
    where?: ViralDraftPerformanceWhereInput
    data: XOR<ViralDraftPerformanceUpdateWithoutDraftInput, ViralDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type ViralDraftPerformanceUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftPerformanceUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralSessionUpsertWithoutDraftsInput = {
    update: XOR<ViralSessionUpdateWithoutDraftsInput, ViralSessionUncheckedUpdateWithoutDraftsInput>
    create: XOR<ViralSessionCreateWithoutDraftsInput, ViralSessionUncheckedCreateWithoutDraftsInput>
    where?: ViralSessionWhereInput
  }

  export type ViralSessionUpdateToOneWithWhereWithoutDraftsInput = {
    where?: ViralSessionWhereInput
    data: XOR<ViralSessionUpdateWithoutDraftsInput, ViralSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type ViralSessionUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViralSessionUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: NullableJsonNullValueInput | InputJsonValue
    concepts?: NullableJsonNullValueInput | InputJsonValue
    selectedIds?: ViralSessionUpdateselectedIdsInput | string[]
    contents?: NullableJsonNullValueInput | InputJsonValue
    characterProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceStyleMode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViralDraftV2CreateWithoutPerformanceInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
    session: ViralSessionCreateNestedOneWithoutDraftsInput
  }

  export type ViralDraftV2UncheckedCreateWithoutPerformanceInput = {
    id?: string
    sessionId: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
  }

  export type ViralDraftV2CreateOrConnectWithoutPerformanceInput = {
    where: ViralDraftV2WhereUniqueInput
    create: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
  }

  export type ViralDraftV2UpsertWithoutPerformanceInput = {
    update: XOR<ViralDraftV2UpdateWithoutPerformanceInput, ViralDraftV2UncheckedUpdateWithoutPerformanceInput>
    create: XOR<ViralDraftV2CreateWithoutPerformanceInput, ViralDraftV2UncheckedCreateWithoutPerformanceInput>
    where?: ViralDraftV2WhereInput
  }

  export type ViralDraftV2UpdateToOneWithWhereWithoutPerformanceInput = {
    where?: ViralDraftV2WhereInput
    data: XOR<ViralDraftV2UpdateWithoutPerformanceInput, ViralDraftV2UncheckedUpdateWithoutPerformanceInput>
  }

  export type ViralDraftV2UpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
    session?: ViralSessionUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type ViralDraftV2UncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type gpt_analysesCreateWithoutContent_draftsInput = {
    id?: string
    analysis_type: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gpt_analysesUncheckedCreateWithoutContent_draftsInput = {
    id?: string
    analysis_type: string
    prompt: string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: number | null
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gpt_analysesCreateOrConnectWithoutContent_draftsInput = {
    where: gpt_analysesWhereUniqueInput
    create: XOR<gpt_analysesCreateWithoutContent_draftsInput, gpt_analysesUncheckedCreateWithoutContent_draftsInput>
  }

  export type gpt_analysesUpsertWithoutContent_draftsInput = {
    update: XOR<gpt_analysesUpdateWithoutContent_draftsInput, gpt_analysesUncheckedUpdateWithoutContent_draftsInput>
    create: XOR<gpt_analysesCreateWithoutContent_draftsInput, gpt_analysesUncheckedCreateWithoutContent_draftsInput>
    where?: gpt_analysesWhereInput
  }

  export type gpt_analysesUpdateToOneWithWhereWithoutContent_draftsInput = {
    where?: gpt_analysesWhereInput
    data: XOR<gpt_analysesUpdateWithoutContent_draftsInput, gpt_analysesUncheckedUpdateWithoutContent_draftsInput>
  }

  export type gpt_analysesUpdateWithoutContent_draftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_type?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gpt_analysesUncheckedUpdateWithoutContent_draftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysis_type?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type content_draftsCreateWithoutGpt_analysesInput = {
    id?: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content?: string | null
    explanation?: string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    platform?: string | null
    format?: string | null
    status?: string | null
    editor_notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type content_draftsUncheckedCreateWithoutGpt_analysesInput = {
    id?: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content?: string | null
    explanation?: string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    platform?: string | null
    format?: string | null
    status?: string | null
    editor_notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type content_draftsCreateOrConnectWithoutGpt_analysesInput = {
    where: content_draftsWhereUniqueInput
    create: XOR<content_draftsCreateWithoutGpt_analysesInput, content_draftsUncheckedCreateWithoutGpt_analysesInput>
  }

  export type content_draftsCreateManyGpt_analysesInputEnvelope = {
    data: content_draftsCreateManyGpt_analysesInput | content_draftsCreateManyGpt_analysesInput[]
    skipDuplicates?: boolean
  }

  export type content_draftsUpsertWithWhereUniqueWithoutGpt_analysesInput = {
    where: content_draftsWhereUniqueInput
    update: XOR<content_draftsUpdateWithoutGpt_analysesInput, content_draftsUncheckedUpdateWithoutGpt_analysesInput>
    create: XOR<content_draftsCreateWithoutGpt_analysesInput, content_draftsUncheckedCreateWithoutGpt_analysesInput>
  }

  export type content_draftsUpdateWithWhereUniqueWithoutGpt_analysesInput = {
    where: content_draftsWhereUniqueInput
    data: XOR<content_draftsUpdateWithoutGpt_analysesInput, content_draftsUncheckedUpdateWithoutGpt_analysesInput>
  }

  export type content_draftsUpdateManyWithWhereWithoutGpt_analysesInput = {
    where: content_draftsScalarWhereInput
    data: XOR<content_draftsUpdateManyMutationInput, content_draftsUncheckedUpdateManyWithoutGpt_analysesInput>
  }

  export type content_draftsScalarWhereInput = {
    AND?: content_draftsScalarWhereInput | content_draftsScalarWhereInput[]
    OR?: content_draftsScalarWhereInput[]
    NOT?: content_draftsScalarWhereInput | content_draftsScalarWhereInput[]
    id?: UuidFilter<"content_drafts"> | string
    analysis_id?: UuidFilter<"content_drafts"> | string
    concept_type?: StringFilter<"content_drafts"> | string
    category?: StringFilter<"content_drafts"> | string
    title?: StringFilter<"content_drafts"> | string
    content?: StringFilter<"content_drafts"> | string
    edited_content?: StringNullableFilter<"content_drafts"> | string | null
    explanation?: StringNullableFilter<"content_drafts"> | string | null
    buzz_factors?: JsonNullableFilter<"content_drafts">
    target_audience?: StringNullableFilter<"content_drafts"> | string | null
    estimated_engagement?: JsonNullableFilter<"content_drafts">
    hashtags?: JsonNullableFilter<"content_drafts">
    visual_guide?: StringNullableFilter<"content_drafts"> | string | null
    platform?: StringNullableFilter<"content_drafts"> | string | null
    format?: StringNullableFilter<"content_drafts"> | string | null
    status?: StringNullableFilter<"content_drafts"> | string | null
    editor_notes?: StringNullableFilter<"content_drafts"> | string | null
    metadata?: JsonNullableFilter<"content_drafts">
    created_at?: DateTimeNullableFilter<"content_drafts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"content_drafts"> | Date | string | null
  }

  export type news_analysis_resultsCreateWithoutNews_analysis_jobsInput = {
    id?: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    news_articles: NewsArticleCreateNestedOneWithoutNews_analysis_resultsInput
  }

  export type news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput = {
    id?: string
    article_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type news_analysis_resultsCreateOrConnectWithoutNews_analysis_jobsInput = {
    where: news_analysis_resultsWhereUniqueInput
    create: XOR<news_analysis_resultsCreateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput>
  }

  export type news_analysis_resultsCreateManyNews_analysis_jobsInputEnvelope = {
    data: news_analysis_resultsCreateManyNews_analysis_jobsInput | news_analysis_resultsCreateManyNews_analysis_jobsInput[]
    skipDuplicates?: boolean
  }

  export type news_analysis_resultsUpsertWithWhereUniqueWithoutNews_analysis_jobsInput = {
    where: news_analysis_resultsWhereUniqueInput
    update: XOR<news_analysis_resultsUpdateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedUpdateWithoutNews_analysis_jobsInput>
    create: XOR<news_analysis_resultsCreateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedCreateWithoutNews_analysis_jobsInput>
  }

  export type news_analysis_resultsUpdateWithWhereUniqueWithoutNews_analysis_jobsInput = {
    where: news_analysis_resultsWhereUniqueInput
    data: XOR<news_analysis_resultsUpdateWithoutNews_analysis_jobsInput, news_analysis_resultsUncheckedUpdateWithoutNews_analysis_jobsInput>
  }

  export type news_analysis_resultsUpdateManyWithWhereWithoutNews_analysis_jobsInput = {
    where: news_analysis_resultsScalarWhereInput
    data: XOR<news_analysis_resultsUpdateManyMutationInput, news_analysis_resultsUncheckedUpdateManyWithoutNews_analysis_jobsInput>
  }

  export type NewsArticleCreateWithoutNews_analysis_resultsInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutNews_analysis_resultsInput = {
    id?: string
    sourceId: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutNews_analysis_resultsInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutNews_analysis_resultsInput, NewsArticleUncheckedCreateWithoutNews_analysis_resultsInput>
  }

  export type news_analysis_jobsCreateWithoutNews_analysis_resultsInput = {
    id?: string
    type: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type news_analysis_jobsUncheckedCreateWithoutNews_analysis_resultsInput = {
    id?: string
    type: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type news_analysis_jobsCreateOrConnectWithoutNews_analysis_resultsInput = {
    where: news_analysis_jobsWhereUniqueInput
    create: XOR<news_analysis_jobsCreateWithoutNews_analysis_resultsInput, news_analysis_jobsUncheckedCreateWithoutNews_analysis_resultsInput>
  }

  export type NewsArticleUpsertWithoutNews_analysis_resultsInput = {
    update: XOR<NewsArticleUpdateWithoutNews_analysis_resultsInput, NewsArticleUncheckedUpdateWithoutNews_analysis_resultsInput>
    create: XOR<NewsArticleCreateWithoutNews_analysis_resultsInput, NewsArticleUncheckedCreateWithoutNews_analysis_resultsInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutNews_analysis_resultsInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutNews_analysis_resultsInput, NewsArticleUncheckedUpdateWithoutNews_analysis_resultsInput>
  }

  export type NewsArticleUpdateWithoutNews_analysis_resultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutNews_analysis_resultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type news_analysis_jobsUpsertWithoutNews_analysis_resultsInput = {
    update: XOR<news_analysis_jobsUpdateWithoutNews_analysis_resultsInput, news_analysis_jobsUncheckedUpdateWithoutNews_analysis_resultsInput>
    create: XOR<news_analysis_jobsCreateWithoutNews_analysis_resultsInput, news_analysis_jobsUncheckedCreateWithoutNews_analysis_resultsInput>
    where?: news_analysis_jobsWhereInput
  }

  export type news_analysis_jobsUpdateToOneWithWhereWithoutNews_analysis_resultsInput = {
    where?: news_analysis_jobsWhereInput
    data: XOR<news_analysis_jobsUpdateWithoutNews_analysis_resultsInput, news_analysis_jobsUncheckedUpdateWithoutNews_analysis_resultsInput>
  }

  export type news_analysis_jobsUpdateWithoutNews_analysis_resultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_jobsUncheckedUpdateWithoutNews_analysis_resultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type viral_postsCreateWithoutViral_opportunitiesInput = {
    id?: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_post_performance?: viral_post_performanceCreateNestedOneWithoutViral_postsInput
  }

  export type viral_postsUncheckedCreateWithoutViral_opportunitiesInput = {
    id?: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_post_performance?: viral_post_performanceUncheckedCreateNestedOneWithoutViral_postsInput
  }

  export type viral_postsCreateOrConnectWithoutViral_opportunitiesInput = {
    where: viral_postsWhereUniqueInput
    create: XOR<viral_postsCreateWithoutViral_opportunitiesInput, viral_postsUncheckedCreateWithoutViral_opportunitiesInput>
  }

  export type viral_postsCreateManyViral_opportunitiesInputEnvelope = {
    data: viral_postsCreateManyViral_opportunitiesInput | viral_postsCreateManyViral_opportunitiesInput[]
    skipDuplicates?: boolean
  }

  export type viral_postsUpsertWithWhereUniqueWithoutViral_opportunitiesInput = {
    where: viral_postsWhereUniqueInput
    update: XOR<viral_postsUpdateWithoutViral_opportunitiesInput, viral_postsUncheckedUpdateWithoutViral_opportunitiesInput>
    create: XOR<viral_postsCreateWithoutViral_opportunitiesInput, viral_postsUncheckedCreateWithoutViral_opportunitiesInput>
  }

  export type viral_postsUpdateWithWhereUniqueWithoutViral_opportunitiesInput = {
    where: viral_postsWhereUniqueInput
    data: XOR<viral_postsUpdateWithoutViral_opportunitiesInput, viral_postsUncheckedUpdateWithoutViral_opportunitiesInput>
  }

  export type viral_postsUpdateManyWithWhereWithoutViral_opportunitiesInput = {
    where: viral_postsScalarWhereInput
    data: XOR<viral_postsUpdateManyMutationInput, viral_postsUncheckedUpdateManyWithoutViral_opportunitiesInput>
  }

  export type viral_postsScalarWhereInput = {
    AND?: viral_postsScalarWhereInput | viral_postsScalarWhereInput[]
    OR?: viral_postsScalarWhereInput[]
    NOT?: viral_postsScalarWhereInput | viral_postsScalarWhereInput[]
    id?: UuidFilter<"viral_posts"> | string
    opportunity_id?: UuidFilter<"viral_posts"> | string
    concept_type?: StringFilter<"viral_posts"> | string
    content?: StringFilter<"viral_posts"> | string
    thread_content?: JsonNullableFilter<"viral_posts">
    visual_guide?: StringNullableFilter<"viral_posts"> | string | null
    hashtags?: StringNullableListFilter<"viral_posts">
    post_type?: StringFilter<"viral_posts"> | string
    platform?: StringFilter<"viral_posts"> | string
    scheduled_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    posted_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    post_url?: StringNullableFilter<"viral_posts"> | string | null
    created_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"viral_posts"> | Date | string | null
  }

  export type viral_postsCreateWithoutViral_post_performanceInput = {
    id?: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    viral_opportunities: viral_opportunitiesCreateNestedOneWithoutViral_postsInput
  }

  export type viral_postsUncheckedCreateWithoutViral_post_performanceInput = {
    id?: string
    opportunity_id: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_postsCreateOrConnectWithoutViral_post_performanceInput = {
    where: viral_postsWhereUniqueInput
    create: XOR<viral_postsCreateWithoutViral_post_performanceInput, viral_postsUncheckedCreateWithoutViral_post_performanceInput>
  }

  export type viral_postsUpsertWithoutViral_post_performanceInput = {
    update: XOR<viral_postsUpdateWithoutViral_post_performanceInput, viral_postsUncheckedUpdateWithoutViral_post_performanceInput>
    create: XOR<viral_postsCreateWithoutViral_post_performanceInput, viral_postsUncheckedCreateWithoutViral_post_performanceInput>
    where?: viral_postsWhereInput
  }

  export type viral_postsUpdateToOneWithWhereWithoutViral_post_performanceInput = {
    where?: viral_postsWhereInput
    data: XOR<viral_postsUpdateWithoutViral_post_performanceInput, viral_postsUncheckedUpdateWithoutViral_post_performanceInput>
  }

  export type viral_postsUpdateWithoutViral_post_performanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_opportunities?: viral_opportunitiesUpdateOneRequiredWithoutViral_postsNestedInput
  }

  export type viral_postsUncheckedUpdateWithoutViral_post_performanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunity_id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_post_performanceCreateWithoutViral_postsInput = {
    id?: string
    impressions_30m?: number | null
    likes_30m?: number | null
    retweets_30m?: number | null
    comments_30m?: number | null
    impressions_1h?: number | null
    likes_1h?: number | null
    retweets_1h?: number | null
    comments_1h?: number | null
    impressions_24h?: number | null
    likes_24h?: number | null
    retweets_24h?: number | null
    comments_24h?: number | null
    followers_24h?: number | null
    engagement_rate?: number | null
    viral_coefficient?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_post_performanceUncheckedCreateWithoutViral_postsInput = {
    id?: string
    impressions_30m?: number | null
    likes_30m?: number | null
    retweets_30m?: number | null
    comments_30m?: number | null
    impressions_1h?: number | null
    likes_1h?: number | null
    retweets_1h?: number | null
    comments_1h?: number | null
    impressions_24h?: number | null
    likes_24h?: number | null
    retweets_24h?: number | null
    comments_24h?: number | null
    followers_24h?: number | null
    engagement_rate?: number | null
    viral_coefficient?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_post_performanceCreateOrConnectWithoutViral_postsInput = {
    where: viral_post_performanceWhereUniqueInput
    create: XOR<viral_post_performanceCreateWithoutViral_postsInput, viral_post_performanceUncheckedCreateWithoutViral_postsInput>
  }

  export type viral_opportunitiesCreateWithoutViral_postsInput = {
    id?: string
    topic: string
    platform: string
    viral_score: number
    time_window: number
    angle: string
    keywords?: viral_opportunitiesCreatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status: string
    analyzed_at: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_opportunitiesUncheckedCreateWithoutViral_postsInput = {
    id?: string
    topic: string
    platform: string
    viral_score: number
    time_window: number
    angle: string
    keywords?: viral_opportunitiesCreatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status: string
    analyzed_at: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_opportunitiesCreateOrConnectWithoutViral_postsInput = {
    where: viral_opportunitiesWhereUniqueInput
    create: XOR<viral_opportunitiesCreateWithoutViral_postsInput, viral_opportunitiesUncheckedCreateWithoutViral_postsInput>
  }

  export type viral_post_performanceUpsertWithoutViral_postsInput = {
    update: XOR<viral_post_performanceUpdateWithoutViral_postsInput, viral_post_performanceUncheckedUpdateWithoutViral_postsInput>
    create: XOR<viral_post_performanceCreateWithoutViral_postsInput, viral_post_performanceUncheckedCreateWithoutViral_postsInput>
    where?: viral_post_performanceWhereInput
  }

  export type viral_post_performanceUpdateToOneWithWhereWithoutViral_postsInput = {
    where?: viral_post_performanceWhereInput
    data: XOR<viral_post_performanceUpdateWithoutViral_postsInput, viral_post_performanceUncheckedUpdateWithoutViral_postsInput>
  }

  export type viral_post_performanceUpdateWithoutViral_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions_30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes_30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_30m?: NullableIntFieldUpdateOperationsInput | number | null
    comments_30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_1h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_24h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_24h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_24h?: NullableIntFieldUpdateOperationsInput | number | null
    followers_24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagement_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    viral_coefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_post_performanceUncheckedUpdateWithoutViral_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions_30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes_30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_30m?: NullableIntFieldUpdateOperationsInput | number | null
    comments_30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_1h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions_24h?: NullableIntFieldUpdateOperationsInput | number | null
    likes_24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets_24h?: NullableIntFieldUpdateOperationsInput | number | null
    comments_24h?: NullableIntFieldUpdateOperationsInput | number | null
    followers_24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagement_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    viral_coefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_opportunitiesUpsertWithoutViral_postsInput = {
    update: XOR<viral_opportunitiesUpdateWithoutViral_postsInput, viral_opportunitiesUncheckedUpdateWithoutViral_postsInput>
    create: XOR<viral_opportunitiesCreateWithoutViral_postsInput, viral_opportunitiesUncheckedCreateWithoutViral_postsInput>
    where?: viral_opportunitiesWhereInput
  }

  export type viral_opportunitiesUpdateToOneWithWhereWithoutViral_postsInput = {
    where?: viral_opportunitiesWhereInput
    data: XOR<viral_opportunitiesUpdateWithoutViral_postsInput, viral_opportunitiesUncheckedUpdateWithoutViral_postsInput>
  }

  export type viral_opportunitiesUpdateWithoutViral_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    viral_score?: FloatFieldUpdateOperationsInput | number
    time_window?: IntFieldUpdateOperationsInput | number
    angle?: StringFieldUpdateOperationsInput | string
    keywords?: viral_opportunitiesUpdatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    analyzed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viral_opportunitiesUncheckedUpdateWithoutViral_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    viral_score?: FloatFieldUpdateOperationsInput | number
    time_window?: IntFieldUpdateOperationsInput | number
    angle?: StringFieldUpdateOperationsInput | string
    keywords?: viral_opportunitiesUpdatekeywordsInput | string[]
    source_data?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    analyzed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduledPostCreateManyRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_analytics?: PostAnalyticsUpdateManyWithoutScheduled_postsNestedInput
  }

  export type ScheduledPostUncheckedUpdateWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_analytics?: PostAnalyticsUncheckedUpdateManyWithoutScheduled_postsNestedInput
  }

  export type ScheduledPostUncheckedUpdateManyWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateManyScheduled_postsInput = {
    id?: string
    impressions: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    link_clicks: number
    measured_at?: Date | string
    engagementRate: number
    ai_analysis?: string | null
  }

  export type PostAnalyticsUpdateWithoutScheduled_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostAnalyticsUncheckedUpdateWithoutScheduled_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostAnalyticsUncheckedUpdateManyWithoutScheduled_postsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    link_clicks?: IntFieldUpdateOperationsInput | number
    measured_at?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementRate?: FloatFieldUpdateOperationsInput | number
    ai_analysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountsCreateManyUsersInput = {
    id?: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    created_at?: Date | string
  }

  export type WatchlistUserCreateManyUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    profile_image?: string | null
    bio?: string | null
    followers_count?: number
    category?: WatchlistUserCreatecategoryInput | string[]
    notes?: string | null
    priority?: number
    is_following?: boolean
    added_at?: Date | string
    lastChecked?: Date | string | null
  }

  export type accountsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    followers_count?: IntFieldUpdateOperationsInput | number
    category?: WatchlistUserUpdatecategoryInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    is_following?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsArticleCreateManySourceInput = {
    id?: string
    title: string
    summary: string
    content: string
    url: string
    publishedAt: Date | string
    category?: string | null
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    news_analysis_results?: news_analysis_resultsUpdateManyWithoutNews_articlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    news_analysis_results?: news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type news_analysis_resultsCreateManyNews_articlesInput = {
    id?: string
    job_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type NewsThreadItemCreateManyArticleInput = {
    id?: string
    threadId: string
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type news_analysis_resultsUpdateWithoutNews_articlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    news_analysis_jobs?: news_analysis_jobsUpdateOneRequiredWithoutNews_analysis_resultsNestedInput
  }

  export type news_analysis_resultsUncheckedUpdateWithoutNews_articlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_resultsUncheckedUpdateManyWithoutNews_articlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    thread?: NewsThreadUpdateOneRequiredWithoutItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type NewsThreadItemCreateManyThreadInput = {
    id?: string
    articleId?: string | null
    tweet_id?: string | null
    parent_tweet_id?: string | null
    posted_at?: Date | string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type NewsThreadItemUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    article?: NewsArticleUpdateOneWithoutNewsThreadItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_tweet_id?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type WatchlistTweetCreateManyWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    likes_count: number
    retweets_count: number
    replies_count: number
    impressions_count: number
    has_replied?: boolean
    has_quoted?: boolean
    posted_at: Date | string
    collectedAt?: Date | string
    url: string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes_count?: IntFieldUpdateOperationsInput | number
    retweets_count?: IntFieldUpdateOperationsInput | number
    replies_count?: IntFieldUpdateOperationsInput | number
    impressions_count?: IntFieldUpdateOperationsInput | number
    has_replied?: BoolFieldUpdateOperationsInput | boolean
    has_quoted?: BoolFieldUpdateOperationsInput | boolean
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    media_urls?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CotDraftCreateManySessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseCreateManySessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViralDraftV2CreateManySessionInput = {
    id?: string
    conceptId: string
    title: string
    content: string
    hashtags?: ViralDraftV2CreatehashtagsInput | string[]
    visualNote?: string | null
    status?: string
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    tweetId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterId?: string | null
    characterNote?: string | null
    sourceUrl?: string | null
    news_article_id?: string | null
  }

  export type ViralDraftV2UpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
    performance?: ViralDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
    performance?: ViralDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type ViralDraftV2UncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    hashtags?: ViralDraftV2UpdatehashtagsInput | string[]
    visualNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    characterNote?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    news_article_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type content_draftsCreateManyGpt_analysesInput = {
    id?: string
    concept_type: string
    category: string
    title: string
    content: string
    edited_content?: string | null
    explanation?: string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    platform?: string | null
    format?: string | null
    status?: string | null
    editor_notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type content_draftsUpdateWithoutGpt_analysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type content_draftsUncheckedUpdateWithoutGpt_analysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type content_draftsUncheckedUpdateManyWithoutGpt_analysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited_content?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    buzz_factors?: NullableJsonNullValueInput | InputJsonValue
    target_audience?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_engagement?: NullableJsonNullValueInput | InputJsonValue
    hashtags?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    editor_notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_analysis_resultsCreateManyNews_analysis_jobsInput = {
    id?: string
    article_id: string
    importance_score: number
    category: string
    summary_ja: string
    key_points: JsonNullValueInput | InputJsonValue
    impact_assessment: string
    expert_perspective?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type news_analysis_resultsUpdateWithoutNews_analysis_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    news_articles?: NewsArticleUpdateOneRequiredWithoutNews_analysis_resultsNestedInput
  }

  export type news_analysis_resultsUncheckedUpdateWithoutNews_analysis_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type news_analysis_resultsUncheckedUpdateManyWithoutNews_analysis_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
    importance_score?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    summary_ja?: StringFieldUpdateOperationsInput | string
    key_points?: JsonNullValueInput | InputJsonValue
    impact_assessment?: StringFieldUpdateOperationsInput | string
    expert_perspective?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type viral_postsCreateManyViral_opportunitiesInput = {
    id?: string
    concept_type: string
    content: string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: string | null
    hashtags?: viral_postsCreatehashtagsInput | string[]
    post_type: string
    platform: string
    scheduled_at?: Date | string | null
    posted_at?: Date | string | null
    post_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type viral_postsUpdateWithoutViral_opportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_post_performance?: viral_post_performanceUpdateOneWithoutViral_postsNestedInput
  }

  export type viral_postsUncheckedUpdateWithoutViral_opportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viral_post_performance?: viral_post_performanceUncheckedUpdateOneWithoutViral_postsNestedInput
  }

  export type viral_postsUncheckedUpdateManyWithoutViral_opportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    concept_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thread_content?: NullableJsonNullValueInput | InputJsonValue
    visual_guide?: NullableStringFieldUpdateOperationsInput | string | null
    hashtags?: viral_postsUpdatehashtagsInput | string[]
    post_type?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}