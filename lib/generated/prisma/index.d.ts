
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BuzzPost
 * 
 */
export type BuzzPost = $Result.DefaultSelection<Prisma.$BuzzPostPayload>
/**
 * Model ScheduledPost
 * 
 */
export type ScheduledPost = $Result.DefaultSelection<Prisma.$ScheduledPostPayload>
/**
 * Model PostAnalytics
 * 
 */
export type PostAnalytics = $Result.DefaultSelection<Prisma.$PostAnalyticsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model NewsSource
 * 
 */
export type NewsSource = $Result.DefaultSelection<Prisma.$NewsSourcePayload>
/**
 * Model NewsArticle
 * 
 */
export type NewsArticle = $Result.DefaultSelection<Prisma.$NewsArticlePayload>
/**
 * Model NewsThread
 * 
 */
export type NewsThread = $Result.DefaultSelection<Prisma.$NewsThreadPayload>
/**
 * Model NewsThreadItem
 * 
 */
export type NewsThreadItem = $Result.DefaultSelection<Prisma.$NewsThreadItemPayload>
/**
 * Model NewsAnalysis
 * 
 */
export type NewsAnalysis = $Result.DefaultSelection<Prisma.$NewsAnalysisPayload>
/**
 * Model JobQueue
 * 
 */
export type JobQueue = $Result.DefaultSelection<Prisma.$JobQueuePayload>
/**
 * Model CollectionPreset
 * 
 */
export type CollectionPreset = $Result.DefaultSelection<Prisma.$CollectionPresetPayload>
/**
 * Model WatchlistUser
 * 
 */
export type WatchlistUser = $Result.DefaultSelection<Prisma.$WatchlistUserPayload>
/**
 * Model WatchlistTweet
 * 
 */
export type WatchlistTweet = $Result.DefaultSelection<Prisma.$WatchlistTweetPayload>
/**
 * Model InteractionHistory
 * 
 */
export type InteractionHistory = $Result.DefaultSelection<Prisma.$InteractionHistoryPayload>
/**
 * Model PerplexityReport
 * 
 */
export type PerplexityReport = $Result.DefaultSelection<Prisma.$PerplexityReportPayload>
/**
 * Model CotSession
 * 
 */
export type CotSession = $Result.DefaultSelection<Prisma.$CotSessionPayload>
/**
 * Model CotPhase
 * 
 */
export type CotPhase = $Result.DefaultSelection<Prisma.$CotPhasePayload>
/**
 * Model CotDraft
 * 
 */
export type CotDraft = $Result.DefaultSelection<Prisma.$CotDraftPayload>
/**
 * Model CotDraftPerformance
 * 
 */
export type CotDraftPerformance = $Result.DefaultSelection<Prisma.$CotDraftPerformancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  FAILED: 'FAILED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const PostType: {
  NEW: 'NEW',
  RETWEET: 'RETWEET',
  QUOTE: 'QUOTE'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const CotSessionStatus: {
  PENDING: 'PENDING',
  THINKING: 'THINKING',
  EXECUTING: 'EXECUTING',
  INTEGRATING: 'INTEGRATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PAUSED: 'PAUSED'
};

export type CotSessionStatus = (typeof CotSessionStatus)[keyof typeof CotSessionStatus]


export const CotPhaseStep: {
  THINK: 'THINK',
  EXECUTE: 'EXECUTE',
  INTEGRATE: 'INTEGRATE'
};

export type CotPhaseStep = (typeof CotPhaseStep)[keyof typeof CotPhaseStep]


export const CotPhaseStatus: {
  PENDING: 'PENDING',
  THINKING: 'THINKING',
  EXECUTING: 'EXECUTING',
  INTEGRATING: 'INTEGRATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type CotPhaseStatus = (typeof CotPhaseStatus)[keyof typeof CotPhaseStatus]


export const CotDraftStatus: {
  DRAFT: 'DRAFT',
  EDITED: 'EDITED',
  SCHEDULED: 'SCHEDULED',
  POSTED: 'POSTED',
  ARCHIVED: 'ARCHIVED'
};

export type CotDraftStatus = (typeof CotDraftStatus)[keyof typeof CotDraftStatus]

}

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type CotSessionStatus = $Enums.CotSessionStatus

export const CotSessionStatus: typeof $Enums.CotSessionStatus

export type CotPhaseStep = $Enums.CotPhaseStep

export const CotPhaseStep: typeof $Enums.CotPhaseStep

export type CotPhaseStatus = $Enums.CotPhaseStatus

export const CotPhaseStatus: typeof $Enums.CotPhaseStatus

export type CotDraftStatus = $Enums.CotDraftStatus

export const CotDraftStatus: typeof $Enums.CotDraftStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BuzzPosts
 * const buzzPosts = await prisma.buzzPost.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BuzzPosts
   * const buzzPosts = await prisma.buzzPost.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.buzzPost`: Exposes CRUD operations for the **BuzzPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzPosts
    * const buzzPosts = await prisma.buzzPost.findMany()
    * ```
    */
  get buzzPost(): Prisma.BuzzPostDelegate<ExtArgs>;

  /**
   * `prisma.scheduledPost`: Exposes CRUD operations for the **ScheduledPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledPosts
    * const scheduledPosts = await prisma.scheduledPost.findMany()
    * ```
    */
  get scheduledPost(): Prisma.ScheduledPostDelegate<ExtArgs>;

  /**
   * `prisma.postAnalytics`: Exposes CRUD operations for the **PostAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAnalytics
    * const postAnalytics = await prisma.postAnalytics.findMany()
    * ```
    */
  get postAnalytics(): Prisma.PostAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.newsSource`: Exposes CRUD operations for the **NewsSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsSources
    * const newsSources = await prisma.newsSource.findMany()
    * ```
    */
  get newsSource(): Prisma.NewsSourceDelegate<ExtArgs>;

  /**
   * `prisma.newsArticle`: Exposes CRUD operations for the **NewsArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsArticles
    * const newsArticles = await prisma.newsArticle.findMany()
    * ```
    */
  get newsArticle(): Prisma.NewsArticleDelegate<ExtArgs>;

  /**
   * `prisma.newsThread`: Exposes CRUD operations for the **NewsThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsThreads
    * const newsThreads = await prisma.newsThread.findMany()
    * ```
    */
  get newsThread(): Prisma.NewsThreadDelegate<ExtArgs>;

  /**
   * `prisma.newsThreadItem`: Exposes CRUD operations for the **NewsThreadItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsThreadItems
    * const newsThreadItems = await prisma.newsThreadItem.findMany()
    * ```
    */
  get newsThreadItem(): Prisma.NewsThreadItemDelegate<ExtArgs>;

  /**
   * `prisma.newsAnalysis`: Exposes CRUD operations for the **NewsAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsAnalyses
    * const newsAnalyses = await prisma.newsAnalysis.findMany()
    * ```
    */
  get newsAnalysis(): Prisma.NewsAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.jobQueue`: Exposes CRUD operations for the **JobQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobQueues
    * const jobQueues = await prisma.jobQueue.findMany()
    * ```
    */
  get jobQueue(): Prisma.JobQueueDelegate<ExtArgs>;

  /**
   * `prisma.collectionPreset`: Exposes CRUD operations for the **CollectionPreset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionPresets
    * const collectionPresets = await prisma.collectionPreset.findMany()
    * ```
    */
  get collectionPreset(): Prisma.CollectionPresetDelegate<ExtArgs>;

  /**
   * `prisma.watchlistUser`: Exposes CRUD operations for the **WatchlistUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistUsers
    * const watchlistUsers = await prisma.watchlistUser.findMany()
    * ```
    */
  get watchlistUser(): Prisma.WatchlistUserDelegate<ExtArgs>;

  /**
   * `prisma.watchlistTweet`: Exposes CRUD operations for the **WatchlistTweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistTweets
    * const watchlistTweets = await prisma.watchlistTweet.findMany()
    * ```
    */
  get watchlistTweet(): Prisma.WatchlistTweetDelegate<ExtArgs>;

  /**
   * `prisma.interactionHistory`: Exposes CRUD operations for the **InteractionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InteractionHistories
    * const interactionHistories = await prisma.interactionHistory.findMany()
    * ```
    */
  get interactionHistory(): Prisma.InteractionHistoryDelegate<ExtArgs>;

  /**
   * `prisma.perplexityReport`: Exposes CRUD operations for the **PerplexityReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerplexityReports
    * const perplexityReports = await prisma.perplexityReport.findMany()
    * ```
    */
  get perplexityReport(): Prisma.PerplexityReportDelegate<ExtArgs>;

  /**
   * `prisma.cotSession`: Exposes CRUD operations for the **CotSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotSessions
    * const cotSessions = await prisma.cotSession.findMany()
    * ```
    */
  get cotSession(): Prisma.CotSessionDelegate<ExtArgs>;

  /**
   * `prisma.cotPhase`: Exposes CRUD operations for the **CotPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotPhases
    * const cotPhases = await prisma.cotPhase.findMany()
    * ```
    */
  get cotPhase(): Prisma.CotPhaseDelegate<ExtArgs>;

  /**
   * `prisma.cotDraft`: Exposes CRUD operations for the **CotDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotDrafts
    * const cotDrafts = await prisma.cotDraft.findMany()
    * ```
    */
  get cotDraft(): Prisma.CotDraftDelegate<ExtArgs>;

  /**
   * `prisma.cotDraftPerformance`: Exposes CRUD operations for the **CotDraftPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CotDraftPerformances
    * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany()
    * ```
    */
  get cotDraftPerformance(): Prisma.CotDraftPerformanceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BuzzPost: 'BuzzPost',
    ScheduledPost: 'ScheduledPost',
    PostAnalytics: 'PostAnalytics',
    User: 'User',
    Session: 'Session',
    NewsSource: 'NewsSource',
    NewsArticle: 'NewsArticle',
    NewsThread: 'NewsThread',
    NewsThreadItem: 'NewsThreadItem',
    NewsAnalysis: 'NewsAnalysis',
    JobQueue: 'JobQueue',
    CollectionPreset: 'CollectionPreset',
    WatchlistUser: 'WatchlistUser',
    WatchlistTweet: 'WatchlistTweet',
    InteractionHistory: 'InteractionHistory',
    PerplexityReport: 'PerplexityReport',
    CotSession: 'CotSession',
    CotPhase: 'CotPhase',
    CotDraft: 'CotDraft',
    CotDraftPerformance: 'CotDraftPerformance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "buzzPost" | "scheduledPost" | "postAnalytics" | "user" | "session" | "newsSource" | "newsArticle" | "newsThread" | "newsThreadItem" | "newsAnalysis" | "jobQueue" | "collectionPreset" | "watchlistUser" | "watchlistTweet" | "interactionHistory" | "perplexityReport" | "cotSession" | "cotPhase" | "cotDraft" | "cotDraftPerformance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BuzzPost: {
        payload: Prisma.$BuzzPostPayload<ExtArgs>
        fields: Prisma.BuzzPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          findFirst: {
            args: Prisma.BuzzPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          findMany: {
            args: Prisma.BuzzPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          create: {
            args: Prisma.BuzzPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          createMany: {
            args: Prisma.BuzzPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuzzPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>[]
          }
          delete: {
            args: Prisma.BuzzPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          update: {
            args: Prisma.BuzzPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          deleteMany: {
            args: Prisma.BuzzPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuzzPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzPostPayload>
          }
          aggregate: {
            args: Prisma.BuzzPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzPost>
          }
          groupBy: {
            args: Prisma.BuzzPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzPostCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzPostCountAggregateOutputType> | number
          }
        }
      }
      ScheduledPost: {
        payload: Prisma.$ScheduledPostPayload<ExtArgs>
        fields: Prisma.ScheduledPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findFirst: {
            args: Prisma.ScheduledPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findMany: {
            args: Prisma.ScheduledPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          create: {
            args: Prisma.ScheduledPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          createMany: {
            args: Prisma.ScheduledPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          delete: {
            args: Prisma.ScheduledPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          update: {
            args: Prisma.ScheduledPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          aggregate: {
            args: Prisma.ScheduledPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledPost>
          }
          groupBy: {
            args: Prisma.ScheduledPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledPostCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostCountAggregateOutputType> | number
          }
        }
      }
      PostAnalytics: {
        payload: Prisma.$PostAnalyticsPayload<ExtArgs>
        fields: Prisma.PostAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PostAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PostAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PostAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PostAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.PostAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          update: {
            args: Prisma.PostAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PostAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PostAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAnalytics>
          }
          groupBy: {
            args: Prisma.PostAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      NewsSource: {
        payload: Prisma.$NewsSourcePayload<ExtArgs>
        fields: Prisma.NewsSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findFirst: {
            args: Prisma.NewsSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findMany: {
            args: Prisma.NewsSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          create: {
            args: Prisma.NewsSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          createMany: {
            args: Prisma.NewsSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          delete: {
            args: Prisma.NewsSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          update: {
            args: Prisma.NewsSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          deleteMany: {
            args: Prisma.NewsSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          aggregate: {
            args: Prisma.NewsSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsSource>
          }
          groupBy: {
            args: Prisma.NewsSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsSourceCountArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceCountAggregateOutputType> | number
          }
        }
      }
      NewsArticle: {
        payload: Prisma.$NewsArticlePayload<ExtArgs>
        fields: Prisma.NewsArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findFirst: {
            args: Prisma.NewsArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findMany: {
            args: Prisma.NewsArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          create: {
            args: Prisma.NewsArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          createMany: {
            args: Prisma.NewsArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          delete: {
            args: Prisma.NewsArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          update: {
            args: Prisma.NewsArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          deleteMany: {
            args: Prisma.NewsArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          aggregate: {
            args: Prisma.NewsArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsArticle>
          }
          groupBy: {
            args: Prisma.NewsArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsArticleCountArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleCountAggregateOutputType> | number
          }
        }
      }
      NewsThread: {
        payload: Prisma.$NewsThreadPayload<ExtArgs>
        fields: Prisma.NewsThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          findFirst: {
            args: Prisma.NewsThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          findMany: {
            args: Prisma.NewsThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          create: {
            args: Prisma.NewsThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          createMany: {
            args: Prisma.NewsThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>[]
          }
          delete: {
            args: Prisma.NewsThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          update: {
            args: Prisma.NewsThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          deleteMany: {
            args: Prisma.NewsThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadPayload>
          }
          aggregate: {
            args: Prisma.NewsThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsThread>
          }
          groupBy: {
            args: Prisma.NewsThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsThreadCountArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadCountAggregateOutputType> | number
          }
        }
      }
      NewsThreadItem: {
        payload: Prisma.$NewsThreadItemPayload<ExtArgs>
        fields: Prisma.NewsThreadItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsThreadItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsThreadItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          findFirst: {
            args: Prisma.NewsThreadItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsThreadItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          findMany: {
            args: Prisma.NewsThreadItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          create: {
            args: Prisma.NewsThreadItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          createMany: {
            args: Prisma.NewsThreadItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsThreadItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>[]
          }
          delete: {
            args: Prisma.NewsThreadItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          update: {
            args: Prisma.NewsThreadItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          deleteMany: {
            args: Prisma.NewsThreadItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsThreadItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsThreadItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsThreadItemPayload>
          }
          aggregate: {
            args: Prisma.NewsThreadItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsThreadItem>
          }
          groupBy: {
            args: Prisma.NewsThreadItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsThreadItemCountArgs<ExtArgs>
            result: $Utils.Optional<NewsThreadItemCountAggregateOutputType> | number
          }
        }
      }
      NewsAnalysis: {
        payload: Prisma.$NewsAnalysisPayload<ExtArgs>
        fields: Prisma.NewsAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          findFirst: {
            args: Prisma.NewsAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          findMany: {
            args: Prisma.NewsAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          create: {
            args: Prisma.NewsAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          createMany: {
            args: Prisma.NewsAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>[]
          }
          delete: {
            args: Prisma.NewsAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          update: {
            args: Prisma.NewsAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.NewsAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsAnalysisPayload>
          }
          aggregate: {
            args: Prisma.NewsAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsAnalysis>
          }
          groupBy: {
            args: Prisma.NewsAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<NewsAnalysisCountAggregateOutputType> | number
          }
        }
      }
      JobQueue: {
        payload: Prisma.$JobQueuePayload<ExtArgs>
        fields: Prisma.JobQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findFirst: {
            args: Prisma.JobQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findMany: {
            args: Prisma.JobQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          create: {
            args: Prisma.JobQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          createMany: {
            args: Prisma.JobQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          delete: {
            args: Prisma.JobQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          update: {
            args: Prisma.JobQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          deleteMany: {
            args: Prisma.JobQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          aggregate: {
            args: Prisma.JobQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobQueue>
          }
          groupBy: {
            args: Prisma.JobQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobQueueCountArgs<ExtArgs>
            result: $Utils.Optional<JobQueueCountAggregateOutputType> | number
          }
        }
      }
      CollectionPreset: {
        payload: Prisma.$CollectionPresetPayload<ExtArgs>
        fields: Prisma.CollectionPresetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionPresetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionPresetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          findFirst: {
            args: Prisma.CollectionPresetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionPresetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          findMany: {
            args: Prisma.CollectionPresetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          create: {
            args: Prisma.CollectionPresetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          createMany: {
            args: Prisma.CollectionPresetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionPresetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>[]
          }
          delete: {
            args: Prisma.CollectionPresetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          update: {
            args: Prisma.CollectionPresetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          deleteMany: {
            args: Prisma.CollectionPresetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionPresetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CollectionPresetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPresetPayload>
          }
          aggregate: {
            args: Prisma.CollectionPresetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionPreset>
          }
          groupBy: {
            args: Prisma.CollectionPresetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionPresetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionPresetCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionPresetCountAggregateOutputType> | number
          }
        }
      }
      WatchlistUser: {
        payload: Prisma.$WatchlistUserPayload<ExtArgs>
        fields: Prisma.WatchlistUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          findFirst: {
            args: Prisma.WatchlistUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          findMany: {
            args: Prisma.WatchlistUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          create: {
            args: Prisma.WatchlistUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          createMany: {
            args: Prisma.WatchlistUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>[]
          }
          delete: {
            args: Prisma.WatchlistUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          update: {
            args: Prisma.WatchlistUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchlistUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistUserPayload>
          }
          aggregate: {
            args: Prisma.WatchlistUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistUser>
          }
          groupBy: {
            args: Prisma.WatchlistUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistUserCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistUserCountAggregateOutputType> | number
          }
        }
      }
      WatchlistTweet: {
        payload: Prisma.$WatchlistTweetPayload<ExtArgs>
        fields: Prisma.WatchlistTweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistTweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistTweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          findFirst: {
            args: Prisma.WatchlistTweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistTweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          findMany: {
            args: Prisma.WatchlistTweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          create: {
            args: Prisma.WatchlistTweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          createMany: {
            args: Prisma.WatchlistTweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistTweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>[]
          }
          delete: {
            args: Prisma.WatchlistTweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          update: {
            args: Prisma.WatchlistTweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistTweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistTweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchlistTweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistTweetPayload>
          }
          aggregate: {
            args: Prisma.WatchlistTweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistTweet>
          }
          groupBy: {
            args: Prisma.WatchlistTweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistTweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistTweetCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistTweetCountAggregateOutputType> | number
          }
        }
      }
      InteractionHistory: {
        payload: Prisma.$InteractionHistoryPayload<ExtArgs>
        fields: Prisma.InteractionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          findFirst: {
            args: Prisma.InteractionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          findMany: {
            args: Prisma.InteractionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          create: {
            args: Prisma.InteractionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          createMany: {
            args: Prisma.InteractionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>[]
          }
          delete: {
            args: Prisma.InteractionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          update: {
            args: Prisma.InteractionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.InteractionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InteractionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionHistoryPayload>
          }
          aggregate: {
            args: Prisma.InteractionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteractionHistory>
          }
          groupBy: {
            args: Prisma.InteractionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionHistoryCountAggregateOutputType> | number
          }
        }
      }
      PerplexityReport: {
        payload: Prisma.$PerplexityReportPayload<ExtArgs>
        fields: Prisma.PerplexityReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerplexityReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerplexityReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          findFirst: {
            args: Prisma.PerplexityReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerplexityReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          findMany: {
            args: Prisma.PerplexityReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          create: {
            args: Prisma.PerplexityReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          createMany: {
            args: Prisma.PerplexityReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerplexityReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>[]
          }
          delete: {
            args: Prisma.PerplexityReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          update: {
            args: Prisma.PerplexityReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          deleteMany: {
            args: Prisma.PerplexityReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerplexityReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerplexityReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerplexityReportPayload>
          }
          aggregate: {
            args: Prisma.PerplexityReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerplexityReport>
          }
          groupBy: {
            args: Prisma.PerplexityReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerplexityReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerplexityReportCountArgs<ExtArgs>
            result: $Utils.Optional<PerplexityReportCountAggregateOutputType> | number
          }
        }
      }
      CotSession: {
        payload: Prisma.$CotSessionPayload<ExtArgs>
        fields: Prisma.CotSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          findFirst: {
            args: Prisma.CotSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          findMany: {
            args: Prisma.CotSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          create: {
            args: Prisma.CotSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          createMany: {
            args: Prisma.CotSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>[]
          }
          delete: {
            args: Prisma.CotSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          update: {
            args: Prisma.CotSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          deleteMany: {
            args: Prisma.CotSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotSessionPayload>
          }
          aggregate: {
            args: Prisma.CotSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotSession>
          }
          groupBy: {
            args: Prisma.CotSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CotSessionCountAggregateOutputType> | number
          }
        }
      }
      CotPhase: {
        payload: Prisma.$CotPhasePayload<ExtArgs>
        fields: Prisma.CotPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          findFirst: {
            args: Prisma.CotPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          findMany: {
            args: Prisma.CotPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          create: {
            args: Prisma.CotPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          createMany: {
            args: Prisma.CotPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotPhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>[]
          }
          delete: {
            args: Prisma.CotPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          update: {
            args: Prisma.CotPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          deleteMany: {
            args: Prisma.CotPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotPhasePayload>
          }
          aggregate: {
            args: Prisma.CotPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotPhase>
          }
          groupBy: {
            args: Prisma.CotPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<CotPhaseCountAggregateOutputType> | number
          }
        }
      }
      CotDraft: {
        payload: Prisma.$CotDraftPayload<ExtArgs>
        fields: Prisma.CotDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotDraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotDraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          findFirst: {
            args: Prisma.CotDraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotDraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          findMany: {
            args: Prisma.CotDraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          create: {
            args: Prisma.CotDraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          createMany: {
            args: Prisma.CotDraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotDraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>[]
          }
          delete: {
            args: Prisma.CotDraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          update: {
            args: Prisma.CotDraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          deleteMany: {
            args: Prisma.CotDraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotDraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotDraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPayload>
          }
          aggregate: {
            args: Prisma.CotDraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotDraft>
          }
          groupBy: {
            args: Prisma.CotDraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotDraftCountArgs<ExtArgs>
            result: $Utils.Optional<CotDraftCountAggregateOutputType> | number
          }
        }
      }
      CotDraftPerformance: {
        payload: Prisma.$CotDraftPerformancePayload<ExtArgs>
        fields: Prisma.CotDraftPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CotDraftPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          findFirst: {
            args: Prisma.CotDraftPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          findMany: {
            args: Prisma.CotDraftPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          create: {
            args: Prisma.CotDraftPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          createMany: {
            args: Prisma.CotDraftPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>[]
          }
          delete: {
            args: Prisma.CotDraftPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          update: {
            args: Prisma.CotDraftPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          deleteMany: {
            args: Prisma.CotDraftPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CotDraftPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CotDraftPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CotDraftPerformancePayload>
          }
          aggregate: {
            args: Prisma.CotDraftPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCotDraftPerformance>
          }
          groupBy: {
            args: Prisma.CotDraftPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CotDraftPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CotDraftPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<CotDraftPerformanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BuzzPostCountOutputType
   */

  export type BuzzPostCountOutputType = {
    scheduledPosts: number
  }

  export type BuzzPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPosts?: boolean | BuzzPostCountOutputTypeCountScheduledPostsArgs
  }

  // Custom InputTypes
  /**
   * BuzzPostCountOutputType without action
   */
  export type BuzzPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPostCountOutputType
     */
    select?: BuzzPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuzzPostCountOutputType without action
   */
  export type BuzzPostCountOutputTypeCountScheduledPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    watchlistUsers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    watchlistUsers?: boolean | UserCountOutputTypeCountWatchlistUsersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchlistUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistUserWhereInput
  }


  /**
   * Count Type NewsSourceCountOutputType
   */

  export type NewsSourceCountOutputType = {
    articles: number
  }

  export type NewsSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | NewsSourceCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * NewsSourceCountOutputType without action
   */
  export type NewsSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSourceCountOutputType
     */
    select?: NewsSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsSourceCountOutputType without action
   */
  export type NewsSourceCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
  }


  /**
   * Count Type NewsArticleCountOutputType
   */

  export type NewsArticleCountOutputType = {
    newsThreadItems: number
  }

  export type NewsArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsThreadItems?: boolean | NewsArticleCountOutputTypeCountNewsThreadItemsArgs
  }

  // Custom InputTypes
  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticleCountOutputType
     */
    select?: NewsArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsArticleCountOutputType without action
   */
  export type NewsArticleCountOutputTypeCountNewsThreadItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
  }


  /**
   * Count Type NewsThreadCountOutputType
   */

  export type NewsThreadCountOutputType = {
    items: number
  }

  export type NewsThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NewsThreadCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * NewsThreadCountOutputType without action
   */
  export type NewsThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadCountOutputType
     */
    select?: NewsThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsThreadCountOutputType without action
   */
  export type NewsThreadCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
  }


  /**
   * Count Type WatchlistUserCountOutputType
   */

  export type WatchlistUserCountOutputType = {
    tweets: number
    interactions: number
  }

  export type WatchlistUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | WatchlistUserCountOutputTypeCountTweetsArgs
    interactions?: boolean | WatchlistUserCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUserCountOutputType
     */
    select?: WatchlistUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistTweetWhereInput
  }

  /**
   * WatchlistUserCountOutputType without action
   */
  export type WatchlistUserCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionHistoryWhereInput
  }


  /**
   * Count Type CotSessionCountOutputType
   */

  export type CotSessionCountOutputType = {
    phases: number
    drafts: number
  }

  export type CotSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | CotSessionCountOutputTypeCountPhasesArgs
    drafts?: boolean | CotSessionCountOutputTypeCountDraftsArgs
  }

  // Custom InputTypes
  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSessionCountOutputType
     */
    select?: CotSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotPhaseWhereInput
  }

  /**
   * CotSessionCountOutputType without action
   */
  export type CotSessionCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BuzzPost
   */

  export type AggregateBuzzPost = {
    _count: BuzzPostCountAggregateOutputType | null
    _avg: BuzzPostAvgAggregateOutputType | null
    _sum: BuzzPostSumAggregateOutputType | null
    _min: BuzzPostMinAggregateOutputType | null
    _max: BuzzPostMaxAggregateOutputType | null
  }

  export type BuzzPostAvgAggregateOutputType = {
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    authorFollowers: number | null
    authorFollowing: number | null
  }

  export type BuzzPostSumAggregateOutputType = {
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    authorFollowers: number | null
    authorFollowing: number | null
  }

  export type BuzzPostMinAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    authorUsername: string | null
    authorId: string | null
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    postedAt: Date | null
    collectedAt: Date | null
    url: string | null
    theme: string | null
    language: string | null
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
  }

  export type BuzzPostMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    authorUsername: string | null
    authorId: string | null
    likesCount: number | null
    retweetsCount: number | null
    repliesCount: number | null
    impressionsCount: number | null
    postedAt: Date | null
    collectedAt: Date | null
    url: string | null
    theme: string | null
    language: string | null
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
  }

  export type BuzzPostCountAggregateOutputType = {
    id: number
    postId: number
    content: number
    authorUsername: number
    authorId: number
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: number
    collectedAt: number
    url: number
    theme: number
    language: number
    mediaUrls: number
    hashtags: number
    chromaId: number
    authorFollowers: number
    authorFollowing: number
    authorVerified: number
    _all: number
  }


  export type BuzzPostAvgAggregateInputType = {
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    authorFollowers?: true
    authorFollowing?: true
  }

  export type BuzzPostSumAggregateInputType = {
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    authorFollowers?: true
    authorFollowing?: true
  }

  export type BuzzPostMinAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
  }

  export type BuzzPostMaxAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
  }

  export type BuzzPostCountAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    authorUsername?: true
    authorId?: true
    likesCount?: true
    retweetsCount?: true
    repliesCount?: true
    impressionsCount?: true
    postedAt?: true
    collectedAt?: true
    url?: true
    theme?: true
    language?: true
    mediaUrls?: true
    hashtags?: true
    chromaId?: true
    authorFollowers?: true
    authorFollowing?: true
    authorVerified?: true
    _all?: true
  }

  export type BuzzPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzPost to aggregate.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzPosts
    **/
    _count?: true | BuzzPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzPostMaxAggregateInputType
  }

  export type GetBuzzPostAggregateType<T extends BuzzPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzPost[P]>
      : GetScalarType<T[P], AggregateBuzzPost[P]>
  }




  export type BuzzPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzPostWhereInput
    orderBy?: BuzzPostOrderByWithAggregationInput | BuzzPostOrderByWithAggregationInput[]
    by: BuzzPostScalarFieldEnum[] | BuzzPostScalarFieldEnum
    having?: BuzzPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzPostCountAggregateInputType | true
    _avg?: BuzzPostAvgAggregateInputType
    _sum?: BuzzPostSumAggregateInputType
    _min?: BuzzPostMinAggregateInputType
    _max?: BuzzPostMaxAggregateInputType
  }

  export type BuzzPostGroupByOutputType = {
    id: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date
    collectedAt: Date
    url: string
    theme: string
    language: string
    mediaUrls: JsonValue
    hashtags: JsonValue
    chromaId: string | null
    authorFollowers: number | null
    authorFollowing: number | null
    authorVerified: boolean | null
    _count: BuzzPostCountAggregateOutputType | null
    _avg: BuzzPostAvgAggregateOutputType | null
    _sum: BuzzPostSumAggregateOutputType | null
    _min: BuzzPostMinAggregateOutputType | null
    _max: BuzzPostMaxAggregateOutputType | null
  }

  type GetBuzzPostGroupByPayload<T extends BuzzPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzPostGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzPostGroupByOutputType[P]>
        }
      >
    >


  export type BuzzPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
    scheduledPosts?: boolean | BuzzPost$scheduledPostsArgs<ExtArgs>
    _count?: boolean | BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }, ExtArgs["result"]["buzzPost"]>

  export type BuzzPostSelectScalar = {
    id?: boolean
    postId?: boolean
    content?: boolean
    authorUsername?: boolean
    authorId?: boolean
    likesCount?: boolean
    retweetsCount?: boolean
    repliesCount?: boolean
    impressionsCount?: boolean
    postedAt?: boolean
    collectedAt?: boolean
    url?: boolean
    theme?: boolean
    language?: boolean
    mediaUrls?: boolean
    hashtags?: boolean
    chromaId?: boolean
    authorFollowers?: boolean
    authorFollowing?: boolean
    authorVerified?: boolean
  }

  export type BuzzPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPosts?: boolean | BuzzPost$scheduledPostsArgs<ExtArgs>
    _count?: boolean | BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuzzPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BuzzPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzPost"
    objects: {
      scheduledPosts: Prisma.$ScheduledPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      content: string
      authorUsername: string
      authorId: string
      likesCount: number
      retweetsCount: number
      repliesCount: number
      impressionsCount: number
      postedAt: Date
      collectedAt: Date
      url: string
      theme: string
      language: string
      mediaUrls: Prisma.JsonValue
      hashtags: Prisma.JsonValue
      chromaId: string | null
      authorFollowers: number | null
      authorFollowing: number | null
      authorVerified: boolean | null
    }, ExtArgs["result"]["buzzPost"]>
    composites: {}
  }

  type BuzzPostGetPayload<S extends boolean | null | undefined | BuzzPostDefaultArgs> = $Result.GetResult<Prisma.$BuzzPostPayload, S>

  type BuzzPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuzzPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuzzPostCountAggregateInputType | true
    }

  export interface BuzzPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzPost'], meta: { name: 'BuzzPost' } }
    /**
     * Find zero or one BuzzPost that matches the filter.
     * @param {BuzzPostFindUniqueArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzPostFindUniqueArgs>(args: SelectSubset<T, BuzzPostFindUniqueArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuzzPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuzzPostFindUniqueOrThrowArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuzzPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindFirstArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzPostFindFirstArgs>(args?: SelectSubset<T, BuzzPostFindFirstArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuzzPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindFirstOrThrowArgs} args - Arguments to find a BuzzPost
     * @example
     * // Get one BuzzPost
     * const buzzPost = await prisma.buzzPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuzzPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzPosts
     * const buzzPosts = await prisma.buzzPost.findMany()
     * 
     * // Get first 10 BuzzPosts
     * const buzzPosts = await prisma.buzzPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzPostFindManyArgs>(args?: SelectSubset<T, BuzzPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuzzPost.
     * @param {BuzzPostCreateArgs} args - Arguments to create a BuzzPost.
     * @example
     * // Create one BuzzPost
     * const BuzzPost = await prisma.buzzPost.create({
     *   data: {
     *     // ... data to create a BuzzPost
     *   }
     * })
     * 
     */
    create<T extends BuzzPostCreateArgs>(args: SelectSubset<T, BuzzPostCreateArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuzzPosts.
     * @param {BuzzPostCreateManyArgs} args - Arguments to create many BuzzPosts.
     * @example
     * // Create many BuzzPosts
     * const buzzPost = await prisma.buzzPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzPostCreateManyArgs>(args?: SelectSubset<T, BuzzPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuzzPosts and returns the data saved in the database.
     * @param {BuzzPostCreateManyAndReturnArgs} args - Arguments to create many BuzzPosts.
     * @example
     * // Create many BuzzPosts
     * const buzzPost = await prisma.buzzPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuzzPosts and only return the `id`
     * const buzzPostWithIdOnly = await prisma.buzzPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuzzPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BuzzPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuzzPost.
     * @param {BuzzPostDeleteArgs} args - Arguments to delete one BuzzPost.
     * @example
     * // Delete one BuzzPost
     * const BuzzPost = await prisma.buzzPost.delete({
     *   where: {
     *     // ... filter to delete one BuzzPost
     *   }
     * })
     * 
     */
    delete<T extends BuzzPostDeleteArgs>(args: SelectSubset<T, BuzzPostDeleteArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuzzPost.
     * @param {BuzzPostUpdateArgs} args - Arguments to update one BuzzPost.
     * @example
     * // Update one BuzzPost
     * const buzzPost = await prisma.buzzPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzPostUpdateArgs>(args: SelectSubset<T, BuzzPostUpdateArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuzzPosts.
     * @param {BuzzPostDeleteManyArgs} args - Arguments to filter BuzzPosts to delete.
     * @example
     * // Delete a few BuzzPosts
     * const { count } = await prisma.buzzPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzPostDeleteManyArgs>(args?: SelectSubset<T, BuzzPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzPosts
     * const buzzPost = await prisma.buzzPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzPostUpdateManyArgs>(args: SelectSubset<T, BuzzPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuzzPost.
     * @param {BuzzPostUpsertArgs} args - Arguments to update or create a BuzzPost.
     * @example
     * // Update or create a BuzzPost
     * const buzzPost = await prisma.buzzPost.upsert({
     *   create: {
     *     // ... data to create a BuzzPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzPost we want to update
     *   }
     * })
     */
    upsert<T extends BuzzPostUpsertArgs>(args: SelectSubset<T, BuzzPostUpsertArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuzzPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostCountArgs} args - Arguments to filter BuzzPosts to count.
     * @example
     * // Count the number of BuzzPosts
     * const count = await prisma.buzzPost.count({
     *   where: {
     *     // ... the filter for the BuzzPosts we want to count
     *   }
     * })
    **/
    count<T extends BuzzPostCountArgs>(
      args?: Subset<T, BuzzPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzPostAggregateArgs>(args: Subset<T, BuzzPostAggregateArgs>): Prisma.PrismaPromise<GetBuzzPostAggregateType<T>>

    /**
     * Group by BuzzPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzPostGroupByArgs['orderBy'] }
        : { orderBy?: BuzzPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzPost model
   */
  readonly fields: BuzzPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scheduledPosts<T extends BuzzPost$scheduledPostsArgs<ExtArgs> = {}>(args?: Subset<T, BuzzPost$scheduledPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzPost model
   */ 
  interface BuzzPostFieldRefs {
    readonly id: FieldRef<"BuzzPost", 'String'>
    readonly postId: FieldRef<"BuzzPost", 'String'>
    readonly content: FieldRef<"BuzzPost", 'String'>
    readonly authorUsername: FieldRef<"BuzzPost", 'String'>
    readonly authorId: FieldRef<"BuzzPost", 'String'>
    readonly likesCount: FieldRef<"BuzzPost", 'Int'>
    readonly retweetsCount: FieldRef<"BuzzPost", 'Int'>
    readonly repliesCount: FieldRef<"BuzzPost", 'Int'>
    readonly impressionsCount: FieldRef<"BuzzPost", 'Int'>
    readonly postedAt: FieldRef<"BuzzPost", 'DateTime'>
    readonly collectedAt: FieldRef<"BuzzPost", 'DateTime'>
    readonly url: FieldRef<"BuzzPost", 'String'>
    readonly theme: FieldRef<"BuzzPost", 'String'>
    readonly language: FieldRef<"BuzzPost", 'String'>
    readonly mediaUrls: FieldRef<"BuzzPost", 'Json'>
    readonly hashtags: FieldRef<"BuzzPost", 'Json'>
    readonly chromaId: FieldRef<"BuzzPost", 'String'>
    readonly authorFollowers: FieldRef<"BuzzPost", 'Int'>
    readonly authorFollowing: FieldRef<"BuzzPost", 'Int'>
    readonly authorVerified: FieldRef<"BuzzPost", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BuzzPost findUnique
   */
  export type BuzzPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost findUniqueOrThrow
   */
  export type BuzzPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost findFirst
   */
  export type BuzzPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzPosts.
     */
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost findFirstOrThrow
   */
  export type BuzzPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPost to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzPosts.
     */
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost findMany
   */
  export type BuzzPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter, which BuzzPosts to fetch.
     */
    where?: BuzzPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzPosts to fetch.
     */
    orderBy?: BuzzPostOrderByWithRelationInput | BuzzPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzPosts.
     */
    cursor?: BuzzPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzPosts.
     */
    skip?: number
    distinct?: BuzzPostScalarFieldEnum | BuzzPostScalarFieldEnum[]
  }

  /**
   * BuzzPost create
   */
  export type BuzzPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BuzzPost.
     */
    data: XOR<BuzzPostCreateInput, BuzzPostUncheckedCreateInput>
  }

  /**
   * BuzzPost createMany
   */
  export type BuzzPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzPosts.
     */
    data: BuzzPostCreateManyInput | BuzzPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzPost createManyAndReturn
   */
  export type BuzzPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuzzPosts.
     */
    data: BuzzPostCreateManyInput | BuzzPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzPost update
   */
  export type BuzzPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BuzzPost.
     */
    data: XOR<BuzzPostUpdateInput, BuzzPostUncheckedUpdateInput>
    /**
     * Choose, which BuzzPost to update.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost updateMany
   */
  export type BuzzPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzPosts.
     */
    data: XOR<BuzzPostUpdateManyMutationInput, BuzzPostUncheckedUpdateManyInput>
    /**
     * Filter which BuzzPosts to update
     */
    where?: BuzzPostWhereInput
  }

  /**
   * BuzzPost upsert
   */
  export type BuzzPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BuzzPost to update in case it exists.
     */
    where: BuzzPostWhereUniqueInput
    /**
     * In case the BuzzPost found by the `where` argument doesn't exist, create a new BuzzPost with this data.
     */
    create: XOR<BuzzPostCreateInput, BuzzPostUncheckedCreateInput>
    /**
     * In case the BuzzPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzPostUpdateInput, BuzzPostUncheckedUpdateInput>
  }

  /**
   * BuzzPost delete
   */
  export type BuzzPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    /**
     * Filter which BuzzPost to delete.
     */
    where: BuzzPostWhereUniqueInput
  }

  /**
   * BuzzPost deleteMany
   */
  export type BuzzPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzPosts to delete
     */
    where?: BuzzPostWhereInput
  }

  /**
   * BuzzPost.scheduledPosts
   */
  export type BuzzPost$scheduledPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    cursor?: ScheduledPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * BuzzPost without action
   */
  export type BuzzPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledPost
   */

  export type AggregateScheduledPost = {
    _count: ScheduledPostCountAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  export type ScheduledPostMinAggregateOutputType = {
    id: string | null
    content: string | null
    scheduledTime: Date | null
    status: $Enums.PostStatus | null
    postType: $Enums.PostType | null
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean | null
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    scheduledTime: Date | null
    status: $Enums.PostStatus | null
    postType: $Enums.PostType | null
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean | null
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPostCountAggregateOutputType = {
    id: number
    content: number
    scheduledTime: number
    status: number
    postType: number
    refPostId: number
    templateType: number
    aiGenerated: number
    aiPrompt: number
    editedContent: number
    postedAt: number
    postResult: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledPostMinAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPostMaxAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPostCountAggregateInputType = {
    id?: true
    content?: true
    scheduledTime?: true
    status?: true
    postType?: true
    refPostId?: true
    templateType?: true
    aiGenerated?: true
    aiPrompt?: true
    editedContent?: true
    postedAt?: true
    postResult?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPost to aggregate.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledPosts
    **/
    _count?: true | ScheduledPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type GetScheduledPostAggregateType<T extends ScheduledPostAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledPost[P]>
      : GetScalarType<T[P], AggregateScheduledPost[P]>
  }




  export type ScheduledPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithAggregationInput | ScheduledPostOrderByWithAggregationInput[]
    by: ScheduledPostScalarFieldEnum[] | ScheduledPostScalarFieldEnum
    having?: ScheduledPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledPostCountAggregateInputType | true
    _min?: ScheduledPostMinAggregateInputType
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type ScheduledPostGroupByOutputType = {
    id: string
    content: string
    scheduledTime: Date
    status: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId: string | null
    templateType: string | null
    aiGenerated: boolean
    aiPrompt: string | null
    editedContent: string | null
    postedAt: Date | null
    postResult: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledPostCountAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  type GetScheduledPostGroupByPayload<T extends ScheduledPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPost"]>

  export type ScheduledPostSelectScalar = {
    id?: boolean
    content?: boolean
    scheduledTime?: boolean
    status?: boolean
    postType?: boolean
    refPostId?: boolean
    templateType?: boolean
    aiGenerated?: boolean
    aiPrompt?: boolean
    editedContent?: boolean
    postedAt?: boolean
    postResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }
  export type ScheduledPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refPost?: boolean | ScheduledPost$refPostArgs<ExtArgs>
  }

  export type $ScheduledPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledPost"
    objects: {
      refPost: Prisma.$BuzzPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      scheduledTime: Date
      status: $Enums.PostStatus
      postType: $Enums.PostType
      refPostId: string | null
      templateType: string | null
      aiGenerated: boolean
      aiPrompt: string | null
      editedContent: string | null
      postedAt: Date | null
      postResult: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledPost"]>
    composites: {}
  }

  type ScheduledPostGetPayload<S extends boolean | null | undefined | ScheduledPostDefaultArgs> = $Result.GetResult<Prisma.$ScheduledPostPayload, S>

  type ScheduledPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledPostCountAggregateInputType | true
    }

  export interface ScheduledPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledPost'], meta: { name: 'ScheduledPost' } }
    /**
     * Find zero or one ScheduledPost that matches the filter.
     * @param {ScheduledPostFindUniqueArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledPostFindUniqueArgs>(args: SelectSubset<T, ScheduledPostFindUniqueArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledPostFindUniqueOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledPostFindFirstArgs>(args?: SelectSubset<T, ScheduledPostFindFirstArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany()
     * 
     * // Get first 10 ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledPostFindManyArgs>(args?: SelectSubset<T, ScheduledPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledPost.
     * @param {ScheduledPostCreateArgs} args - Arguments to create a ScheduledPost.
     * @example
     * // Create one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.create({
     *   data: {
     *     // ... data to create a ScheduledPost
     *   }
     * })
     * 
     */
    create<T extends ScheduledPostCreateArgs>(args: SelectSubset<T, ScheduledPostCreateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledPosts.
     * @param {ScheduledPostCreateManyArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledPostCreateManyArgs>(args?: SelectSubset<T, ScheduledPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledPosts and returns the data saved in the database.
     * @param {ScheduledPostCreateManyAndReturnArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledPosts and only return the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledPost.
     * @param {ScheduledPostDeleteArgs} args - Arguments to delete one ScheduledPost.
     * @example
     * // Delete one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.delete({
     *   where: {
     *     // ... filter to delete one ScheduledPost
     *   }
     * })
     * 
     */
    delete<T extends ScheduledPostDeleteArgs>(args: SelectSubset<T, ScheduledPostDeleteArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledPost.
     * @param {ScheduledPostUpdateArgs} args - Arguments to update one ScheduledPost.
     * @example
     * // Update one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledPostUpdateArgs>(args: SelectSubset<T, ScheduledPostUpdateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledPosts.
     * @param {ScheduledPostDeleteManyArgs} args - Arguments to filter ScheduledPosts to delete.
     * @example
     * // Delete a few ScheduledPosts
     * const { count } = await prisma.scheduledPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledPostDeleteManyArgs>(args?: SelectSubset<T, ScheduledPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledPostUpdateManyArgs>(args: SelectSubset<T, ScheduledPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledPost.
     * @param {ScheduledPostUpsertArgs} args - Arguments to update or create a ScheduledPost.
     * @example
     * // Update or create a ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.upsert({
     *   create: {
     *     // ... data to create a ScheduledPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledPost we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledPostUpsertArgs>(args: SelectSubset<T, ScheduledPostUpsertArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostCountArgs} args - Arguments to filter ScheduledPosts to count.
     * @example
     * // Count the number of ScheduledPosts
     * const count = await prisma.scheduledPost.count({
     *   where: {
     *     // ... the filter for the ScheduledPosts we want to count
     *   }
     * })
    **/
    count<T extends ScheduledPostCountArgs>(
      args?: Subset<T, ScheduledPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledPostAggregateArgs>(args: Subset<T, ScheduledPostAggregateArgs>): Prisma.PrismaPromise<GetScheduledPostAggregateType<T>>

    /**
     * Group by ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledPostGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledPost model
   */
  readonly fields: ScheduledPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refPost<T extends ScheduledPost$refPostArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledPost$refPostArgs<ExtArgs>>): Prisma__BuzzPostClient<$Result.GetResult<Prisma.$BuzzPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledPost model
   */ 
  interface ScheduledPostFieldRefs {
    readonly id: FieldRef<"ScheduledPost", 'String'>
    readonly content: FieldRef<"ScheduledPost", 'String'>
    readonly scheduledTime: FieldRef<"ScheduledPost", 'DateTime'>
    readonly status: FieldRef<"ScheduledPost", 'PostStatus'>
    readonly postType: FieldRef<"ScheduledPost", 'PostType'>
    readonly refPostId: FieldRef<"ScheduledPost", 'String'>
    readonly templateType: FieldRef<"ScheduledPost", 'String'>
    readonly aiGenerated: FieldRef<"ScheduledPost", 'Boolean'>
    readonly aiPrompt: FieldRef<"ScheduledPost", 'String'>
    readonly editedContent: FieldRef<"ScheduledPost", 'String'>
    readonly postedAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly postResult: FieldRef<"ScheduledPost", 'Json'>
    readonly createdAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledPost findUnique
   */
  export type ScheduledPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findUniqueOrThrow
   */
  export type ScheduledPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findFirst
   */
  export type ScheduledPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findFirstOrThrow
   */
  export type ScheduledPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findMany
   */
  export type ScheduledPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPosts to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost create
   */
  export type ScheduledPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledPost.
     */
    data: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
  }

  /**
   * ScheduledPost createMany
   */
  export type ScheduledPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledPost createManyAndReturn
   */
  export type ScheduledPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledPost update
   */
  export type ScheduledPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledPost.
     */
    data: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
    /**
     * Choose, which ScheduledPost to update.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost updateMany
   */
  export type ScheduledPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledPosts.
     */
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPosts to update
     */
    where?: ScheduledPostWhereInput
  }

  /**
   * ScheduledPost upsert
   */
  export type ScheduledPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledPost to update in case it exists.
     */
    where: ScheduledPostWhereUniqueInput
    /**
     * In case the ScheduledPost found by the `where` argument doesn't exist, create a new ScheduledPost with this data.
     */
    create: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
    /**
     * In case the ScheduledPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
  }

  /**
   * ScheduledPost delete
   */
  export type ScheduledPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
    /**
     * Filter which ScheduledPost to delete.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost deleteMany
   */
  export type ScheduledPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPosts to delete
     */
    where?: ScheduledPostWhereInput
  }

  /**
   * ScheduledPost.refPost
   */
  export type ScheduledPost$refPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzPost
     */
    select?: BuzzPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzPostInclude<ExtArgs> | null
    where?: BuzzPostWhereInput
  }

  /**
   * ScheduledPost without action
   */
  export type ScheduledPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPostInclude<ExtArgs> | null
  }


  /**
   * Model PostAnalytics
   */

  export type AggregatePostAnalytics = {
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  export type PostAnalyticsAvgAggregateOutputType = {
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
  }

  export type PostAnalyticsSumAggregateOutputType = {
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
  }

  export type PostAnalyticsMinAggregateOutputType = {
    id: string | null
    postId: string | null
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
    collectedAt: Date | null
  }

  export type PostAnalyticsMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    impressions: number | null
    engagements: number | null
    likes: number | null
    retweets: number | null
    replies: number | null
    profileClicks: number | null
    urlClicks: number | null
    detailExpands: number | null
    engagementRate: number | null
    collectedAt: Date | null
  }

  export type PostAnalyticsCountAggregateOutputType = {
    id: number
    postId: number
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt: number
    _all: number
  }


  export type PostAnalyticsAvgAggregateInputType = {
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
  }

  export type PostAnalyticsSumAggregateInputType = {
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
  }

  export type PostAnalyticsMinAggregateInputType = {
    id?: true
    postId?: true
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
    collectedAt?: true
  }

  export type PostAnalyticsMaxAggregateInputType = {
    id?: true
    postId?: true
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
    collectedAt?: true
  }

  export type PostAnalyticsCountAggregateInputType = {
    id?: true
    postId?: true
    impressions?: true
    engagements?: true
    likes?: true
    retweets?: true
    replies?: true
    profileClicks?: true
    urlClicks?: true
    detailExpands?: true
    engagementRate?: true
    collectedAt?: true
    _all?: true
  }

  export type PostAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to aggregate.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAnalytics
    **/
    _count?: true | PostAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type GetPostAnalyticsAggregateType<T extends PostAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAnalytics[P]>
      : GetScalarType<T[P], AggregatePostAnalytics[P]>
  }




  export type PostAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAnalyticsWhereInput
    orderBy?: PostAnalyticsOrderByWithAggregationInput | PostAnalyticsOrderByWithAggregationInput[]
    by: PostAnalyticsScalarFieldEnum[] | PostAnalyticsScalarFieldEnum
    having?: PostAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAnalyticsCountAggregateInputType | true
    _avg?: PostAnalyticsAvgAggregateInputType
    _sum?: PostAnalyticsSumAggregateInputType
    _min?: PostAnalyticsMinAggregateInputType
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type PostAnalyticsGroupByOutputType = {
    id: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt: Date
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  type GetPostAnalyticsGroupByPayload<T extends PostAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PostAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    impressions?: boolean
    engagements?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    urlClicks?: boolean
    detailExpands?: boolean
    engagementRate?: boolean
    collectedAt?: boolean
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    impressions?: boolean
    engagements?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    urlClicks?: boolean
    detailExpands?: boolean
    engagementRate?: boolean
    collectedAt?: boolean
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectScalar = {
    id?: boolean
    postId?: boolean
    impressions?: boolean
    engagements?: boolean
    likes?: boolean
    retweets?: boolean
    replies?: boolean
    profileClicks?: boolean
    urlClicks?: boolean
    detailExpands?: boolean
    engagementRate?: boolean
    collectedAt?: boolean
  }


  export type $PostAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      impressions: number
      engagements: number
      likes: number
      retweets: number
      replies: number
      profileClicks: number
      urlClicks: number
      detailExpands: number
      engagementRate: number
      collectedAt: Date
    }, ExtArgs["result"]["postAnalytics"]>
    composites: {}
  }

  type PostAnalyticsGetPayload<S extends boolean | null | undefined | PostAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PostAnalyticsPayload, S>

  type PostAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostAnalyticsCountAggregateInputType | true
    }

  export interface PostAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAnalytics'], meta: { name: 'PostAnalytics' } }
    /**
     * Find zero or one PostAnalytics that matches the filter.
     * @param {PostAnalyticsFindUniqueArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostAnalyticsFindUniqueArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostAnalyticsFindFirstArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany()
     * 
     * // Get first 10 PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostAnalyticsFindManyArgs>(args?: SelectSubset<T, PostAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostAnalytics.
     * @param {PostAnalyticsCreateArgs} args - Arguments to create a PostAnalytics.
     * @example
     * // Create one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.create({
     *   data: {
     *     // ... data to create a PostAnalytics
     *   }
     * })
     * 
     */
    create<T extends PostAnalyticsCreateArgs>(args: SelectSubset<T, PostAnalyticsCreateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostAnalytics.
     * @param {PostAnalyticsCreateManyArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostAnalyticsCreateManyArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostAnalytics and returns the data saved in the database.
     * @param {PostAnalyticsCreateManyAndReturnArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostAnalytics and only return the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostAnalytics.
     * @param {PostAnalyticsDeleteArgs} args - Arguments to delete one PostAnalytics.
     * @example
     * // Delete one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PostAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PostAnalyticsDeleteArgs>(args: SelectSubset<T, PostAnalyticsDeleteArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostAnalytics.
     * @param {PostAnalyticsUpdateArgs} args - Arguments to update one PostAnalytics.
     * @example
     * // Update one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostAnalyticsUpdateArgs>(args: SelectSubset<T, PostAnalyticsUpdateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostAnalytics.
     * @param {PostAnalyticsDeleteManyArgs} args - Arguments to filter PostAnalytics to delete.
     * @example
     * // Delete a few PostAnalytics
     * const { count } = await prisma.postAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PostAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostAnalyticsUpdateManyArgs>(args: SelectSubset<T, PostAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostAnalytics.
     * @param {PostAnalyticsUpsertArgs} args - Arguments to update or create a PostAnalytics.
     * @example
     * // Update or create a PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.upsert({
     *   create: {
     *     // ... data to create a PostAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PostAnalyticsUpsertArgs>(args: SelectSubset<T, PostAnalyticsUpsertArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsCountArgs} args - Arguments to filter PostAnalytics to count.
     * @example
     * // Count the number of PostAnalytics
     * const count = await prisma.postAnalytics.count({
     *   where: {
     *     // ... the filter for the PostAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PostAnalyticsCountArgs>(
      args?: Subset<T, PostAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAnalyticsAggregateArgs>(args: Subset<T, PostAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPostAnalyticsAggregateType<T>>

    /**
     * Group by PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PostAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAnalytics model
   */
  readonly fields: PostAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAnalytics model
   */ 
  interface PostAnalyticsFieldRefs {
    readonly id: FieldRef<"PostAnalytics", 'String'>
    readonly postId: FieldRef<"PostAnalytics", 'String'>
    readonly impressions: FieldRef<"PostAnalytics", 'Int'>
    readonly engagements: FieldRef<"PostAnalytics", 'Int'>
    readonly likes: FieldRef<"PostAnalytics", 'Int'>
    readonly retweets: FieldRef<"PostAnalytics", 'Int'>
    readonly replies: FieldRef<"PostAnalytics", 'Int'>
    readonly profileClicks: FieldRef<"PostAnalytics", 'Int'>
    readonly urlClicks: FieldRef<"PostAnalytics", 'Int'>
    readonly detailExpands: FieldRef<"PostAnalytics", 'Int'>
    readonly engagementRate: FieldRef<"PostAnalytics", 'Float'>
    readonly collectedAt: FieldRef<"PostAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostAnalytics findUnique
   */
  export type PostAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findUniqueOrThrow
   */
  export type PostAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findFirst
   */
  export type PostAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findFirstOrThrow
   */
  export type PostAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findMany
   */
  export type PostAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics create
   */
  export type PostAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a PostAnalytics.
     */
    data: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
  }

  /**
   * PostAnalytics createMany
   */
  export type PostAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAnalytics createManyAndReturn
   */
  export type PostAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAnalytics update
   */
  export type PostAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PostAnalytics to update.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics updateMany
   */
  export type PostAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PostAnalytics to update
     */
    where?: PostAnalyticsWhereInput
  }

  /**
   * PostAnalytics upsert
   */
  export type PostAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the PostAnalytics to update in case it exists.
     */
    where: PostAnalyticsWhereUniqueInput
    /**
     * In case the PostAnalytics found by the `where` argument doesn't exist, create a new PostAnalytics with this data.
     */
    create: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
    /**
     * In case the PostAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
  }

  /**
   * PostAnalytics delete
   */
  export type PostAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which PostAnalytics to delete.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics deleteMany
   */
  export type PostAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to delete
     */
    where?: PostAnalyticsWhereInput
  }

  /**
   * PostAnalytics without action
   */
  export type PostAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    name: string | null
    email: string | null
    image: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    twitterId: string | null
    username: string | null
    name: string | null
    email: string | null
    image: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    twitterId: number
    username: number
    name: number
    email: number
    image: number
    accessToken: number
    refreshToken: number
    tokenSecret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    twitterId?: true
    username?: true
    name?: true
    email?: true
    image?: true
    accessToken?: true
    refreshToken?: true
    tokenSecret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    twitterId: string
    username: string
    name: string | null
    email: string | null
    image: string | null
    accessToken: string
    refreshToken: string | null
    tokenSecret: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    watchlistUsers?: boolean | User$watchlistUsersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    twitterId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    watchlistUsers?: boolean | User$watchlistUsersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      watchlistUsers: Prisma.$WatchlistUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      twitterId: string
      username: string
      name: string | null
      email: string | null
      image: string | null
      accessToken: string
      refreshToken: string | null
      tokenSecret: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    watchlistUsers<T extends User$watchlistUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$watchlistUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly twitterId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly tokenSecret: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.watchlistUsers
   */
  export type User$watchlistUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    where?: WatchlistUserWhereInput
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    cursor?: WatchlistUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model NewsSource
   */

  export type AggregateNewsSource = {
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  export type NewsSourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    rssUrl: string | null
    category: string | null
    language: string | null
    isActive: boolean | null
    lastFetched: Date | null
    createdAt: Date | null
  }

  export type NewsSourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    rssUrl: string | null
    category: string | null
    language: string | null
    isActive: boolean | null
    lastFetched: Date | null
    createdAt: Date | null
  }

  export type NewsSourceCountAggregateOutputType = {
    id: number
    name: number
    url: number
    rssUrl: number
    category: number
    language: number
    isActive: number
    lastFetched: number
    createdAt: number
    _all: number
  }


  export type NewsSourceMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    rssUrl?: true
    category?: true
    language?: true
    isActive?: true
    lastFetched?: true
    createdAt?: true
  }

  export type NewsSourceMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    rssUrl?: true
    category?: true
    language?: true
    isActive?: true
    lastFetched?: true
    createdAt?: true
  }

  export type NewsSourceCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    rssUrl?: true
    category?: true
    language?: true
    isActive?: true
    lastFetched?: true
    createdAt?: true
    _all?: true
  }

  export type NewsSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSource to aggregate.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsSources
    **/
    _count?: true | NewsSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsSourceMaxAggregateInputType
  }

  export type GetNewsSourceAggregateType<T extends NewsSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsSource[P]>
      : GetScalarType<T[P], AggregateNewsSource[P]>
  }




  export type NewsSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsSourceWhereInput
    orderBy?: NewsSourceOrderByWithAggregationInput | NewsSourceOrderByWithAggregationInput[]
    by: NewsSourceScalarFieldEnum[] | NewsSourceScalarFieldEnum
    having?: NewsSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsSourceCountAggregateInputType | true
    _min?: NewsSourceMinAggregateInputType
    _max?: NewsSourceMaxAggregateInputType
  }

  export type NewsSourceGroupByOutputType = {
    id: string
    name: string
    url: string
    rssUrl: string
    category: string
    language: string
    isActive: boolean
    lastFetched: Date | null
    createdAt: Date
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  type GetNewsSourceGroupByPayload<T extends NewsSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
            : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
        }
      >
    >


  export type NewsSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    rssUrl?: boolean
    category?: boolean
    language?: boolean
    isActive?: boolean
    lastFetched?: boolean
    createdAt?: boolean
    articles?: boolean | NewsSource$articlesArgs<ExtArgs>
    _count?: boolean | NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    rssUrl?: boolean
    category?: boolean
    language?: boolean
    isActive?: boolean
    lastFetched?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    rssUrl?: boolean
    category?: boolean
    language?: boolean
    isActive?: boolean
    lastFetched?: boolean
    createdAt?: boolean
  }

  export type NewsSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | NewsSource$articlesArgs<ExtArgs>
    _count?: boolean | NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsSource"
    objects: {
      articles: Prisma.$NewsArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      rssUrl: string
      category: string
      language: string
      isActive: boolean
      lastFetched: Date | null
      createdAt: Date
    }, ExtArgs["result"]["newsSource"]>
    composites: {}
  }

  type NewsSourceGetPayload<S extends boolean | null | undefined | NewsSourceDefaultArgs> = $Result.GetResult<Prisma.$NewsSourcePayload, S>

  type NewsSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsSourceCountAggregateInputType | true
    }

  export interface NewsSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsSource'], meta: { name: 'NewsSource' } }
    /**
     * Find zero or one NewsSource that matches the filter.
     * @param {NewsSourceFindUniqueArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsSourceFindUniqueArgs>(args: SelectSubset<T, NewsSourceFindUniqueArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsSource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsSourceFindUniqueOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsSourceFindFirstArgs>(args?: SelectSubset<T, NewsSourceFindFirstArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsSources
     * const newsSources = await prisma.newsSource.findMany()
     * 
     * // Get first 10 NewsSources
     * const newsSources = await prisma.newsSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsSourceFindManyArgs>(args?: SelectSubset<T, NewsSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsSource.
     * @param {NewsSourceCreateArgs} args - Arguments to create a NewsSource.
     * @example
     * // Create one NewsSource
     * const NewsSource = await prisma.newsSource.create({
     *   data: {
     *     // ... data to create a NewsSource
     *   }
     * })
     * 
     */
    create<T extends NewsSourceCreateArgs>(args: SelectSubset<T, NewsSourceCreateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsSources.
     * @param {NewsSourceCreateManyArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsSourceCreateManyArgs>(args?: SelectSubset<T, NewsSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsSources and returns the data saved in the database.
     * @param {NewsSourceCreateManyAndReturnArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsSources and only return the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsSource.
     * @param {NewsSourceDeleteArgs} args - Arguments to delete one NewsSource.
     * @example
     * // Delete one NewsSource
     * const NewsSource = await prisma.newsSource.delete({
     *   where: {
     *     // ... filter to delete one NewsSource
     *   }
     * })
     * 
     */
    delete<T extends NewsSourceDeleteArgs>(args: SelectSubset<T, NewsSourceDeleteArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsSource.
     * @param {NewsSourceUpdateArgs} args - Arguments to update one NewsSource.
     * @example
     * // Update one NewsSource
     * const newsSource = await prisma.newsSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsSourceUpdateArgs>(args: SelectSubset<T, NewsSourceUpdateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsSources.
     * @param {NewsSourceDeleteManyArgs} args - Arguments to filter NewsSources to delete.
     * @example
     * // Delete a few NewsSources
     * const { count } = await prisma.newsSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsSourceDeleteManyArgs>(args?: SelectSubset<T, NewsSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsSources
     * const newsSource = await prisma.newsSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsSourceUpdateManyArgs>(args: SelectSubset<T, NewsSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsSource.
     * @param {NewsSourceUpsertArgs} args - Arguments to update or create a NewsSource.
     * @example
     * // Update or create a NewsSource
     * const newsSource = await prisma.newsSource.upsert({
     *   create: {
     *     // ... data to create a NewsSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsSource we want to update
     *   }
     * })
     */
    upsert<T extends NewsSourceUpsertArgs>(args: SelectSubset<T, NewsSourceUpsertArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceCountArgs} args - Arguments to filter NewsSources to count.
     * @example
     * // Count the number of NewsSources
     * const count = await prisma.newsSource.count({
     *   where: {
     *     // ... the filter for the NewsSources we want to count
     *   }
     * })
    **/
    count<T extends NewsSourceCountArgs>(
      args?: Subset<T, NewsSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsSourceAggregateArgs>(args: Subset<T, NewsSourceAggregateArgs>): Prisma.PrismaPromise<GetNewsSourceAggregateType<T>>

    /**
     * Group by NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsSourceGroupByArgs['orderBy'] }
        : { orderBy?: NewsSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsSource model
   */
  readonly fields: NewsSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends NewsSource$articlesArgs<ExtArgs> = {}>(args?: Subset<T, NewsSource$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsSource model
   */ 
  interface NewsSourceFieldRefs {
    readonly id: FieldRef<"NewsSource", 'String'>
    readonly name: FieldRef<"NewsSource", 'String'>
    readonly url: FieldRef<"NewsSource", 'String'>
    readonly rssUrl: FieldRef<"NewsSource", 'String'>
    readonly category: FieldRef<"NewsSource", 'String'>
    readonly language: FieldRef<"NewsSource", 'String'>
    readonly isActive: FieldRef<"NewsSource", 'Boolean'>
    readonly lastFetched: FieldRef<"NewsSource", 'DateTime'>
    readonly createdAt: FieldRef<"NewsSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsSource findUnique
   */
  export type NewsSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findUniqueOrThrow
   */
  export type NewsSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findFirst
   */
  export type NewsSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findFirstOrThrow
   */
  export type NewsSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findMany
   */
  export type NewsSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter, which NewsSources to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource create
   */
  export type NewsSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsSource.
     */
    data: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
  }

  /**
   * NewsSource createMany
   */
  export type NewsSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsSource createManyAndReturn
   */
  export type NewsSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsSource update
   */
  export type NewsSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsSource.
     */
    data: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
    /**
     * Choose, which NewsSource to update.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource updateMany
   */
  export type NewsSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsSources.
     */
    data: XOR<NewsSourceUpdateManyMutationInput, NewsSourceUncheckedUpdateManyInput>
    /**
     * Filter which NewsSources to update
     */
    where?: NewsSourceWhereInput
  }

  /**
   * NewsSource upsert
   */
  export type NewsSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsSource to update in case it exists.
     */
    where: NewsSourceWhereUniqueInput
    /**
     * In case the NewsSource found by the `where` argument doesn't exist, create a new NewsSource with this data.
     */
    create: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
    /**
     * In case the NewsSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
  }

  /**
   * NewsSource delete
   */
  export type NewsSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
    /**
     * Filter which NewsSource to delete.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource deleteMany
   */
  export type NewsSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSources to delete
     */
    where?: NewsSourceWhereInput
  }

  /**
   * NewsSource.articles
   */
  export type NewsSource$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    cursor?: NewsArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsSource without action
   */
  export type NewsSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsSourceInclude<ExtArgs> | null
  }


  /**
   * Model NewsArticle
   */

  export type AggregateNewsArticle = {
    _count: NewsArticleCountAggregateOutputType | null
    _avg: NewsArticleAvgAggregateOutputType | null
    _sum: NewsArticleSumAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  export type NewsArticleAvgAggregateOutputType = {
    importance: number | null
  }

  export type NewsArticleSumAggregateOutputType = {
    importance: number | null
  }

  export type NewsArticleMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    title: string | null
    description: string | null
    url: string | null
    publishedAt: Date | null
    category: string | null
    importance: number | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type NewsArticleMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    title: string | null
    description: string | null
    url: string | null
    publishedAt: Date | null
    category: string | null
    importance: number | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type NewsArticleCountAggregateOutputType = {
    id: number
    sourceId: number
    title: number
    description: number
    url: number
    publishedAt: number
    category: number
    tags: number
    importance: number
    processed: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type NewsArticleAvgAggregateInputType = {
    importance?: true
  }

  export type NewsArticleSumAggregateInputType = {
    importance?: true
  }

  export type NewsArticleMinAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    description?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
  }

  export type NewsArticleMaxAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    description?: true
    url?: true
    publishedAt?: true
    category?: true
    importance?: true
    processed?: true
    createdAt?: true
  }

  export type NewsArticleCountAggregateInputType = {
    id?: true
    sourceId?: true
    title?: true
    description?: true
    url?: true
    publishedAt?: true
    category?: true
    tags?: true
    importance?: true
    processed?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type NewsArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticle to aggregate.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsArticles
    **/
    _count?: true | NewsArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsArticleMaxAggregateInputType
  }

  export type GetNewsArticleAggregateType<T extends NewsArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsArticle[P]>
      : GetScalarType<T[P], AggregateNewsArticle[P]>
  }




  export type NewsArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithAggregationInput | NewsArticleOrderByWithAggregationInput[]
    by: NewsArticleScalarFieldEnum[] | NewsArticleScalarFieldEnum
    having?: NewsArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsArticleCountAggregateInputType | true
    _avg?: NewsArticleAvgAggregateInputType
    _sum?: NewsArticleSumAggregateInputType
    _min?: NewsArticleMinAggregateInputType
    _max?: NewsArticleMaxAggregateInputType
  }

  export type NewsArticleGroupByOutputType = {
    id: string
    sourceId: string
    title: string
    description: string | null
    url: string
    publishedAt: Date
    category: string | null
    tags: string[]
    importance: number | null
    processed: boolean
    createdAt: Date
    metadata: JsonValue | null
    _count: NewsArticleCountAggregateOutputType | null
    _avg: NewsArticleAvgAggregateOutputType | null
    _sum: NewsArticleSumAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  type GetNewsArticleGroupByPayload<T extends NewsArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
            : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
        }
      >
    >


  export type NewsArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    tags?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    analysis?: boolean | NewsArticle$analysisArgs<ExtArgs>
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
    newsThreadItems?: boolean | NewsArticle$newsThreadItemsArgs<ExtArgs>
    _count?: boolean | NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    tags?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectScalar = {
    id?: boolean
    sourceId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    publishedAt?: boolean
    category?: boolean
    tags?: boolean
    importance?: boolean
    processed?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type NewsArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysis?: boolean | NewsArticle$analysisArgs<ExtArgs>
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
    newsThreadItems?: boolean | NewsArticle$newsThreadItemsArgs<ExtArgs>
    _count?: boolean | NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | NewsSourceDefaultArgs<ExtArgs>
  }

  export type $NewsArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsArticle"
    objects: {
      analysis: Prisma.$NewsAnalysisPayload<ExtArgs> | null
      source: Prisma.$NewsSourcePayload<ExtArgs>
      newsThreadItems: Prisma.$NewsThreadItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      title: string
      description: string | null
      url: string
      publishedAt: Date
      category: string | null
      tags: string[]
      importance: number | null
      processed: boolean
      createdAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["newsArticle"]>
    composites: {}
  }

  type NewsArticleGetPayload<S extends boolean | null | undefined | NewsArticleDefaultArgs> = $Result.GetResult<Prisma.$NewsArticlePayload, S>

  type NewsArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsArticleCountAggregateInputType | true
    }

  export interface NewsArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsArticle'], meta: { name: 'NewsArticle' } }
    /**
     * Find zero or one NewsArticle that matches the filter.
     * @param {NewsArticleFindUniqueArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsArticleFindUniqueArgs>(args: SelectSubset<T, NewsArticleFindUniqueArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsArticleFindUniqueOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsArticleFindFirstArgs>(args?: SelectSubset<T, NewsArticleFindFirstArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany()
     * 
     * // Get first 10 NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsArticleFindManyArgs>(args?: SelectSubset<T, NewsArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsArticle.
     * @param {NewsArticleCreateArgs} args - Arguments to create a NewsArticle.
     * @example
     * // Create one NewsArticle
     * const NewsArticle = await prisma.newsArticle.create({
     *   data: {
     *     // ... data to create a NewsArticle
     *   }
     * })
     * 
     */
    create<T extends NewsArticleCreateArgs>(args: SelectSubset<T, NewsArticleCreateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsArticles.
     * @param {NewsArticleCreateManyArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsArticleCreateManyArgs>(args?: SelectSubset<T, NewsArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsArticles and returns the data saved in the database.
     * @param {NewsArticleCreateManyAndReturnArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsArticles and only return the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsArticle.
     * @param {NewsArticleDeleteArgs} args - Arguments to delete one NewsArticle.
     * @example
     * // Delete one NewsArticle
     * const NewsArticle = await prisma.newsArticle.delete({
     *   where: {
     *     // ... filter to delete one NewsArticle
     *   }
     * })
     * 
     */
    delete<T extends NewsArticleDeleteArgs>(args: SelectSubset<T, NewsArticleDeleteArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsArticle.
     * @param {NewsArticleUpdateArgs} args - Arguments to update one NewsArticle.
     * @example
     * // Update one NewsArticle
     * const newsArticle = await prisma.newsArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsArticleUpdateArgs>(args: SelectSubset<T, NewsArticleUpdateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsArticles.
     * @param {NewsArticleDeleteManyArgs} args - Arguments to filter NewsArticles to delete.
     * @example
     * // Delete a few NewsArticles
     * const { count } = await prisma.newsArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsArticleDeleteManyArgs>(args?: SelectSubset<T, NewsArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsArticles
     * const newsArticle = await prisma.newsArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsArticleUpdateManyArgs>(args: SelectSubset<T, NewsArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsArticle.
     * @param {NewsArticleUpsertArgs} args - Arguments to update or create a NewsArticle.
     * @example
     * // Update or create a NewsArticle
     * const newsArticle = await prisma.newsArticle.upsert({
     *   create: {
     *     // ... data to create a NewsArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsArticle we want to update
     *   }
     * })
     */
    upsert<T extends NewsArticleUpsertArgs>(args: SelectSubset<T, NewsArticleUpsertArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleCountArgs} args - Arguments to filter NewsArticles to count.
     * @example
     * // Count the number of NewsArticles
     * const count = await prisma.newsArticle.count({
     *   where: {
     *     // ... the filter for the NewsArticles we want to count
     *   }
     * })
    **/
    count<T extends NewsArticleCountArgs>(
      args?: Subset<T, NewsArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsArticleAggregateArgs>(args: Subset<T, NewsArticleAggregateArgs>): Prisma.PrismaPromise<GetNewsArticleAggregateType<T>>

    /**
     * Group by NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsArticleGroupByArgs['orderBy'] }
        : { orderBy?: NewsArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsArticle model
   */
  readonly fields: NewsArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analysis<T extends NewsArticle$analysisArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$analysisArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    source<T extends NewsSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsSourceDefaultArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    newsThreadItems<T extends NewsArticle$newsThreadItemsArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticle$newsThreadItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsArticle model
   */ 
  interface NewsArticleFieldRefs {
    readonly id: FieldRef<"NewsArticle", 'String'>
    readonly sourceId: FieldRef<"NewsArticle", 'String'>
    readonly title: FieldRef<"NewsArticle", 'String'>
    readonly description: FieldRef<"NewsArticle", 'String'>
    readonly url: FieldRef<"NewsArticle", 'String'>
    readonly publishedAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly category: FieldRef<"NewsArticle", 'String'>
    readonly tags: FieldRef<"NewsArticle", 'String[]'>
    readonly importance: FieldRef<"NewsArticle", 'Float'>
    readonly processed: FieldRef<"NewsArticle", 'Boolean'>
    readonly createdAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly metadata: FieldRef<"NewsArticle", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NewsArticle findUnique
   */
  export type NewsArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findUniqueOrThrow
   */
  export type NewsArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findFirst
   */
  export type NewsArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findFirstOrThrow
   */
  export type NewsArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findMany
   */
  export type NewsArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter, which NewsArticles to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle create
   */
  export type NewsArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsArticle.
     */
    data: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
  }

  /**
   * NewsArticle createMany
   */
  export type NewsArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsArticle createManyAndReturn
   */
  export type NewsArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsArticle update
   */
  export type NewsArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsArticle.
     */
    data: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
    /**
     * Choose, which NewsArticle to update.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle updateMany
   */
  export type NewsArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsArticles.
     */
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyInput>
    /**
     * Filter which NewsArticles to update
     */
    where?: NewsArticleWhereInput
  }

  /**
   * NewsArticle upsert
   */
  export type NewsArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsArticle to update in case it exists.
     */
    where: NewsArticleWhereUniqueInput
    /**
     * In case the NewsArticle found by the `where` argument doesn't exist, create a new NewsArticle with this data.
     */
    create: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
    /**
     * In case the NewsArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
  }

  /**
   * NewsArticle delete
   */
  export type NewsArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
    /**
     * Filter which NewsArticle to delete.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle deleteMany
   */
  export type NewsArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticles to delete
     */
    where?: NewsArticleWhereInput
  }

  /**
   * NewsArticle.analysis
   */
  export type NewsArticle$analysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsArticle.newsThreadItems
   */
  export type NewsArticle$newsThreadItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    cursor?: NewsThreadItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsArticle without action
   */
  export type NewsArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsArticleInclude<ExtArgs> | null
  }


  /**
   * Model NewsThread
   */

  export type AggregateNewsThread = {
    _count: NewsThreadCountAggregateOutputType | null
    _min: NewsThreadMinAggregateOutputType | null
    _max: NewsThreadMaxAggregateOutputType | null
  }

  export type NewsThreadMinAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    title: string | null
    postedAt: Date | null
  }

  export type NewsThreadMaxAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    title: string | null
    postedAt: Date | null
  }

  export type NewsThreadCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    metadata: number
    scheduledAt: number
    title: number
    postedAt: number
    _all: number
  }


  export type NewsThreadMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
  }

  export type NewsThreadMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
  }

  export type NewsThreadCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    metadata?: true
    scheduledAt?: true
    title?: true
    postedAt?: true
    _all?: true
  }

  export type NewsThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThread to aggregate.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsThreads
    **/
    _count?: true | NewsThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsThreadMaxAggregateInputType
  }

  export type GetNewsThreadAggregateType<T extends NewsThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsThread[P]>
      : GetScalarType<T[P], AggregateNewsThread[P]>
  }




  export type NewsThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadWhereInput
    orderBy?: NewsThreadOrderByWithAggregationInput | NewsThreadOrderByWithAggregationInput[]
    by: NewsThreadScalarFieldEnum[] | NewsThreadScalarFieldEnum
    having?: NewsThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsThreadCountAggregateInputType | true
    _min?: NewsThreadMinAggregateInputType
    _max?: NewsThreadMaxAggregateInputType
  }

  export type NewsThreadGroupByOutputType = {
    id: string
    status: string
    createdAt: Date
    metadata: JsonValue | null
    scheduledAt: Date | null
    title: string
    postedAt: Date | null
    _count: NewsThreadCountAggregateOutputType | null
    _min: NewsThreadMinAggregateOutputType | null
    _max: NewsThreadMaxAggregateOutputType | null
  }

  type GetNewsThreadGroupByPayload<T extends NewsThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsThreadGroupByOutputType[P]>
            : GetScalarType<T[P], NewsThreadGroupByOutputType[P]>
        }
      >
    >


  export type NewsThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
    items?: boolean | NewsThread$itemsArgs<ExtArgs>
    _count?: boolean | NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }, ExtArgs["result"]["newsThread"]>

  export type NewsThreadSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    title?: boolean
    postedAt?: boolean
  }

  export type NewsThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NewsThread$itemsArgs<ExtArgs>
    _count?: boolean | NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsThread"
    objects: {
      items: Prisma.$NewsThreadItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      createdAt: Date
      metadata: Prisma.JsonValue | null
      scheduledAt: Date | null
      title: string
      postedAt: Date | null
    }, ExtArgs["result"]["newsThread"]>
    composites: {}
  }

  type NewsThreadGetPayload<S extends boolean | null | undefined | NewsThreadDefaultArgs> = $Result.GetResult<Prisma.$NewsThreadPayload, S>

  type NewsThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsThreadCountAggregateInputType | true
    }

  export interface NewsThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsThread'], meta: { name: 'NewsThread' } }
    /**
     * Find zero or one NewsThread that matches the filter.
     * @param {NewsThreadFindUniqueArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsThreadFindUniqueArgs>(args: SelectSubset<T, NewsThreadFindUniqueArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsThread that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsThreadFindUniqueOrThrowArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindFirstArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsThreadFindFirstArgs>(args?: SelectSubset<T, NewsThreadFindFirstArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindFirstOrThrowArgs} args - Arguments to find a NewsThread
     * @example
     * // Get one NewsThread
     * const newsThread = await prisma.newsThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsThreads
     * const newsThreads = await prisma.newsThread.findMany()
     * 
     * // Get first 10 NewsThreads
     * const newsThreads = await prisma.newsThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsThreadFindManyArgs>(args?: SelectSubset<T, NewsThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsThread.
     * @param {NewsThreadCreateArgs} args - Arguments to create a NewsThread.
     * @example
     * // Create one NewsThread
     * const NewsThread = await prisma.newsThread.create({
     *   data: {
     *     // ... data to create a NewsThread
     *   }
     * })
     * 
     */
    create<T extends NewsThreadCreateArgs>(args: SelectSubset<T, NewsThreadCreateArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsThreads.
     * @param {NewsThreadCreateManyArgs} args - Arguments to create many NewsThreads.
     * @example
     * // Create many NewsThreads
     * const newsThread = await prisma.newsThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsThreadCreateManyArgs>(args?: SelectSubset<T, NewsThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsThreads and returns the data saved in the database.
     * @param {NewsThreadCreateManyAndReturnArgs} args - Arguments to create many NewsThreads.
     * @example
     * // Create many NewsThreads
     * const newsThread = await prisma.newsThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsThreads and only return the `id`
     * const newsThreadWithIdOnly = await prisma.newsThread.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsThread.
     * @param {NewsThreadDeleteArgs} args - Arguments to delete one NewsThread.
     * @example
     * // Delete one NewsThread
     * const NewsThread = await prisma.newsThread.delete({
     *   where: {
     *     // ... filter to delete one NewsThread
     *   }
     * })
     * 
     */
    delete<T extends NewsThreadDeleteArgs>(args: SelectSubset<T, NewsThreadDeleteArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsThread.
     * @param {NewsThreadUpdateArgs} args - Arguments to update one NewsThread.
     * @example
     * // Update one NewsThread
     * const newsThread = await prisma.newsThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsThreadUpdateArgs>(args: SelectSubset<T, NewsThreadUpdateArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsThreads.
     * @param {NewsThreadDeleteManyArgs} args - Arguments to filter NewsThreads to delete.
     * @example
     * // Delete a few NewsThreads
     * const { count } = await prisma.newsThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsThreadDeleteManyArgs>(args?: SelectSubset<T, NewsThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsThreads
     * const newsThread = await prisma.newsThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsThreadUpdateManyArgs>(args: SelectSubset<T, NewsThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsThread.
     * @param {NewsThreadUpsertArgs} args - Arguments to update or create a NewsThread.
     * @example
     * // Update or create a NewsThread
     * const newsThread = await prisma.newsThread.upsert({
     *   create: {
     *     // ... data to create a NewsThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsThread we want to update
     *   }
     * })
     */
    upsert<T extends NewsThreadUpsertArgs>(args: SelectSubset<T, NewsThreadUpsertArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadCountArgs} args - Arguments to filter NewsThreads to count.
     * @example
     * // Count the number of NewsThreads
     * const count = await prisma.newsThread.count({
     *   where: {
     *     // ... the filter for the NewsThreads we want to count
     *   }
     * })
    **/
    count<T extends NewsThreadCountArgs>(
      args?: Subset<T, NewsThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsThreadAggregateArgs>(args: Subset<T, NewsThreadAggregateArgs>): Prisma.PrismaPromise<GetNewsThreadAggregateType<T>>

    /**
     * Group by NewsThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsThreadGroupByArgs['orderBy'] }
        : { orderBy?: NewsThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsThread model
   */
  readonly fields: NewsThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends NewsThread$itemsArgs<ExtArgs> = {}>(args?: Subset<T, NewsThread$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsThread model
   */ 
  interface NewsThreadFieldRefs {
    readonly id: FieldRef<"NewsThread", 'String'>
    readonly status: FieldRef<"NewsThread", 'String'>
    readonly createdAt: FieldRef<"NewsThread", 'DateTime'>
    readonly metadata: FieldRef<"NewsThread", 'Json'>
    readonly scheduledAt: FieldRef<"NewsThread", 'DateTime'>
    readonly title: FieldRef<"NewsThread", 'String'>
    readonly postedAt: FieldRef<"NewsThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsThread findUnique
   */
  export type NewsThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread findUniqueOrThrow
   */
  export type NewsThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread findFirst
   */
  export type NewsThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreads.
     */
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread findFirstOrThrow
   */
  export type NewsThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThread to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreads.
     */
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread findMany
   */
  export type NewsThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreads to fetch.
     */
    where?: NewsThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreads to fetch.
     */
    orderBy?: NewsThreadOrderByWithRelationInput | NewsThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsThreads.
     */
    cursor?: NewsThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreads.
     */
    skip?: number
    distinct?: NewsThreadScalarFieldEnum | NewsThreadScalarFieldEnum[]
  }

  /**
   * NewsThread create
   */
  export type NewsThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsThread.
     */
    data: XOR<NewsThreadCreateInput, NewsThreadUncheckedCreateInput>
  }

  /**
   * NewsThread createMany
   */
  export type NewsThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsThreads.
     */
    data: NewsThreadCreateManyInput | NewsThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThread createManyAndReturn
   */
  export type NewsThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsThreads.
     */
    data: NewsThreadCreateManyInput | NewsThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThread update
   */
  export type NewsThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsThread.
     */
    data: XOR<NewsThreadUpdateInput, NewsThreadUncheckedUpdateInput>
    /**
     * Choose, which NewsThread to update.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread updateMany
   */
  export type NewsThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsThreads.
     */
    data: XOR<NewsThreadUpdateManyMutationInput, NewsThreadUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreads to update
     */
    where?: NewsThreadWhereInput
  }

  /**
   * NewsThread upsert
   */
  export type NewsThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsThread to update in case it exists.
     */
    where: NewsThreadWhereUniqueInput
    /**
     * In case the NewsThread found by the `where` argument doesn't exist, create a new NewsThread with this data.
     */
    create: XOR<NewsThreadCreateInput, NewsThreadUncheckedCreateInput>
    /**
     * In case the NewsThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsThreadUpdateInput, NewsThreadUncheckedUpdateInput>
  }

  /**
   * NewsThread delete
   */
  export type NewsThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
    /**
     * Filter which NewsThread to delete.
     */
    where: NewsThreadWhereUniqueInput
  }

  /**
   * NewsThread deleteMany
   */
  export type NewsThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreads to delete
     */
    where?: NewsThreadWhereInput
  }

  /**
   * NewsThread.items
   */
  export type NewsThread$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    cursor?: NewsThreadItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThread without action
   */
  export type NewsThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThread
     */
    select?: NewsThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadInclude<ExtArgs> | null
  }


  /**
   * Model NewsThreadItem
   */

  export type AggregateNewsThreadItem = {
    _count: NewsThreadItemCountAggregateOutputType | null
    _avg: NewsThreadItemAvgAggregateOutputType | null
    _sum: NewsThreadItemSumAggregateOutputType | null
    _min: NewsThreadItemMinAggregateOutputType | null
    _max: NewsThreadItemMaxAggregateOutputType | null
  }

  export type NewsThreadItemAvgAggregateOutputType = {
    order: number | null
  }

  export type NewsThreadItemSumAggregateOutputType = {
    order: number | null
  }

  export type NewsThreadItemMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    articleId: string | null
    order: number | null
    content: string | null
    createdAt: Date | null
  }

  export type NewsThreadItemMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    articleId: string | null
    order: number | null
    content: string | null
    createdAt: Date | null
  }

  export type NewsThreadItemCountAggregateOutputType = {
    id: number
    threadId: number
    articleId: number
    order: number
    content: number
    createdAt: number
    _all: number
  }


  export type NewsThreadItemAvgAggregateInputType = {
    order?: true
  }

  export type NewsThreadItemSumAggregateInputType = {
    order?: true
  }

  export type NewsThreadItemMinAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    order?: true
    content?: true
    createdAt?: true
  }

  export type NewsThreadItemMaxAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    order?: true
    content?: true
    createdAt?: true
  }

  export type NewsThreadItemCountAggregateInputType = {
    id?: true
    threadId?: true
    articleId?: true
    order?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type NewsThreadItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreadItem to aggregate.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsThreadItems
    **/
    _count?: true | NewsThreadItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsThreadItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsThreadItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsThreadItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsThreadItemMaxAggregateInputType
  }

  export type GetNewsThreadItemAggregateType<T extends NewsThreadItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsThreadItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsThreadItem[P]>
      : GetScalarType<T[P], AggregateNewsThreadItem[P]>
  }




  export type NewsThreadItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsThreadItemWhereInput
    orderBy?: NewsThreadItemOrderByWithAggregationInput | NewsThreadItemOrderByWithAggregationInput[]
    by: NewsThreadItemScalarFieldEnum[] | NewsThreadItemScalarFieldEnum
    having?: NewsThreadItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsThreadItemCountAggregateInputType | true
    _avg?: NewsThreadItemAvgAggregateInputType
    _sum?: NewsThreadItemSumAggregateInputType
    _min?: NewsThreadItemMinAggregateInputType
    _max?: NewsThreadItemMaxAggregateInputType
  }

  export type NewsThreadItemGroupByOutputType = {
    id: string
    threadId: string
    articleId: string
    order: number
    content: string | null
    createdAt: Date
    _count: NewsThreadItemCountAggregateOutputType | null
    _avg: NewsThreadItemAvgAggregateOutputType | null
    _sum: NewsThreadItemSumAggregateOutputType | null
    _min: NewsThreadItemMinAggregateOutputType | null
    _max: NewsThreadItemMaxAggregateOutputType | null
  }

  type GetNewsThreadItemGroupByPayload<T extends NewsThreadItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsThreadItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsThreadItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsThreadItemGroupByOutputType[P]>
            : GetScalarType<T[P], NewsThreadItemGroupByOutputType[P]>
        }
      >
    >


  export type NewsThreadItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsThreadItem"]>

  export type NewsThreadItemSelectScalar = {
    id?: boolean
    threadId?: boolean
    articleId?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type NewsThreadItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }
  export type NewsThreadItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | NewsThreadDefaultArgs<ExtArgs>
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }

  export type $NewsThreadItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsThreadItem"
    objects: {
      thread: Prisma.$NewsThreadPayload<ExtArgs>
      article: Prisma.$NewsArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      articleId: string
      order: number
      content: string | null
      createdAt: Date
    }, ExtArgs["result"]["newsThreadItem"]>
    composites: {}
  }

  type NewsThreadItemGetPayload<S extends boolean | null | undefined | NewsThreadItemDefaultArgs> = $Result.GetResult<Prisma.$NewsThreadItemPayload, S>

  type NewsThreadItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsThreadItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsThreadItemCountAggregateInputType | true
    }

  export interface NewsThreadItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsThreadItem'], meta: { name: 'NewsThreadItem' } }
    /**
     * Find zero or one NewsThreadItem that matches the filter.
     * @param {NewsThreadItemFindUniqueArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsThreadItemFindUniqueArgs>(args: SelectSubset<T, NewsThreadItemFindUniqueArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsThreadItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsThreadItemFindUniqueOrThrowArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsThreadItemFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsThreadItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsThreadItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindFirstArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsThreadItemFindFirstArgs>(args?: SelectSubset<T, NewsThreadItemFindFirstArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsThreadItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindFirstOrThrowArgs} args - Arguments to find a NewsThreadItem
     * @example
     * // Get one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsThreadItemFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsThreadItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsThreadItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsThreadItems
     * const newsThreadItems = await prisma.newsThreadItem.findMany()
     * 
     * // Get first 10 NewsThreadItems
     * const newsThreadItems = await prisma.newsThreadItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsThreadItemFindManyArgs>(args?: SelectSubset<T, NewsThreadItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsThreadItem.
     * @param {NewsThreadItemCreateArgs} args - Arguments to create a NewsThreadItem.
     * @example
     * // Create one NewsThreadItem
     * const NewsThreadItem = await prisma.newsThreadItem.create({
     *   data: {
     *     // ... data to create a NewsThreadItem
     *   }
     * })
     * 
     */
    create<T extends NewsThreadItemCreateArgs>(args: SelectSubset<T, NewsThreadItemCreateArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsThreadItems.
     * @param {NewsThreadItemCreateManyArgs} args - Arguments to create many NewsThreadItems.
     * @example
     * // Create many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsThreadItemCreateManyArgs>(args?: SelectSubset<T, NewsThreadItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsThreadItems and returns the data saved in the database.
     * @param {NewsThreadItemCreateManyAndReturnArgs} args - Arguments to create many NewsThreadItems.
     * @example
     * // Create many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsThreadItems and only return the `id`
     * const newsThreadItemWithIdOnly = await prisma.newsThreadItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsThreadItemCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsThreadItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsThreadItem.
     * @param {NewsThreadItemDeleteArgs} args - Arguments to delete one NewsThreadItem.
     * @example
     * // Delete one NewsThreadItem
     * const NewsThreadItem = await prisma.newsThreadItem.delete({
     *   where: {
     *     // ... filter to delete one NewsThreadItem
     *   }
     * })
     * 
     */
    delete<T extends NewsThreadItemDeleteArgs>(args: SelectSubset<T, NewsThreadItemDeleteArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsThreadItem.
     * @param {NewsThreadItemUpdateArgs} args - Arguments to update one NewsThreadItem.
     * @example
     * // Update one NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsThreadItemUpdateArgs>(args: SelectSubset<T, NewsThreadItemUpdateArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsThreadItems.
     * @param {NewsThreadItemDeleteManyArgs} args - Arguments to filter NewsThreadItems to delete.
     * @example
     * // Delete a few NewsThreadItems
     * const { count } = await prisma.newsThreadItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsThreadItemDeleteManyArgs>(args?: SelectSubset<T, NewsThreadItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsThreadItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsThreadItems
     * const newsThreadItem = await prisma.newsThreadItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsThreadItemUpdateManyArgs>(args: SelectSubset<T, NewsThreadItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsThreadItem.
     * @param {NewsThreadItemUpsertArgs} args - Arguments to update or create a NewsThreadItem.
     * @example
     * // Update or create a NewsThreadItem
     * const newsThreadItem = await prisma.newsThreadItem.upsert({
     *   create: {
     *     // ... data to create a NewsThreadItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsThreadItem we want to update
     *   }
     * })
     */
    upsert<T extends NewsThreadItemUpsertArgs>(args: SelectSubset<T, NewsThreadItemUpsertArgs<ExtArgs>>): Prisma__NewsThreadItemClient<$Result.GetResult<Prisma.$NewsThreadItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsThreadItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemCountArgs} args - Arguments to filter NewsThreadItems to count.
     * @example
     * // Count the number of NewsThreadItems
     * const count = await prisma.newsThreadItem.count({
     *   where: {
     *     // ... the filter for the NewsThreadItems we want to count
     *   }
     * })
    **/
    count<T extends NewsThreadItemCountArgs>(
      args?: Subset<T, NewsThreadItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsThreadItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsThreadItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsThreadItemAggregateArgs>(args: Subset<T, NewsThreadItemAggregateArgs>): Prisma.PrismaPromise<GetNewsThreadItemAggregateType<T>>

    /**
     * Group by NewsThreadItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsThreadItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsThreadItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsThreadItemGroupByArgs['orderBy'] }
        : { orderBy?: NewsThreadItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsThreadItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsThreadItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsThreadItem model
   */
  readonly fields: NewsThreadItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsThreadItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsThreadItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends NewsThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsThreadDefaultArgs<ExtArgs>>): Prisma__NewsThreadClient<$Result.GetResult<Prisma.$NewsThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    article<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsThreadItem model
   */ 
  interface NewsThreadItemFieldRefs {
    readonly id: FieldRef<"NewsThreadItem", 'String'>
    readonly threadId: FieldRef<"NewsThreadItem", 'String'>
    readonly articleId: FieldRef<"NewsThreadItem", 'String'>
    readonly order: FieldRef<"NewsThreadItem", 'Int'>
    readonly content: FieldRef<"NewsThreadItem", 'String'>
    readonly createdAt: FieldRef<"NewsThreadItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsThreadItem findUnique
   */
  export type NewsThreadItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem findUniqueOrThrow
   */
  export type NewsThreadItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem findFirst
   */
  export type NewsThreadItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreadItems.
     */
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem findFirstOrThrow
   */
  export type NewsThreadItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItem to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsThreadItems.
     */
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem findMany
   */
  export type NewsThreadItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter, which NewsThreadItems to fetch.
     */
    where?: NewsThreadItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsThreadItems to fetch.
     */
    orderBy?: NewsThreadItemOrderByWithRelationInput | NewsThreadItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsThreadItems.
     */
    cursor?: NewsThreadItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsThreadItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsThreadItems.
     */
    skip?: number
    distinct?: NewsThreadItemScalarFieldEnum | NewsThreadItemScalarFieldEnum[]
  }

  /**
   * NewsThreadItem create
   */
  export type NewsThreadItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsThreadItem.
     */
    data: XOR<NewsThreadItemCreateInput, NewsThreadItemUncheckedCreateInput>
  }

  /**
   * NewsThreadItem createMany
   */
  export type NewsThreadItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsThreadItems.
     */
    data: NewsThreadItemCreateManyInput | NewsThreadItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsThreadItem createManyAndReturn
   */
  export type NewsThreadItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsThreadItems.
     */
    data: NewsThreadItemCreateManyInput | NewsThreadItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsThreadItem update
   */
  export type NewsThreadItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsThreadItem.
     */
    data: XOR<NewsThreadItemUpdateInput, NewsThreadItemUncheckedUpdateInput>
    /**
     * Choose, which NewsThreadItem to update.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem updateMany
   */
  export type NewsThreadItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsThreadItems.
     */
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyInput>
    /**
     * Filter which NewsThreadItems to update
     */
    where?: NewsThreadItemWhereInput
  }

  /**
   * NewsThreadItem upsert
   */
  export type NewsThreadItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsThreadItem to update in case it exists.
     */
    where: NewsThreadItemWhereUniqueInput
    /**
     * In case the NewsThreadItem found by the `where` argument doesn't exist, create a new NewsThreadItem with this data.
     */
    create: XOR<NewsThreadItemCreateInput, NewsThreadItemUncheckedCreateInput>
    /**
     * In case the NewsThreadItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsThreadItemUpdateInput, NewsThreadItemUncheckedUpdateInput>
  }

  /**
   * NewsThreadItem delete
   */
  export type NewsThreadItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
    /**
     * Filter which NewsThreadItem to delete.
     */
    where: NewsThreadItemWhereUniqueInput
  }

  /**
   * NewsThreadItem deleteMany
   */
  export type NewsThreadItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsThreadItems to delete
     */
    where?: NewsThreadItemWhereInput
  }

  /**
   * NewsThreadItem without action
   */
  export type NewsThreadItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsThreadItem
     */
    select?: NewsThreadItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsThreadItemInclude<ExtArgs> | null
  }


  /**
   * Model NewsAnalysis
   */

  export type AggregateNewsAnalysis = {
    _count: NewsAnalysisCountAggregateOutputType | null
    _min: NewsAnalysisMinAggregateOutputType | null
    _max: NewsAnalysisMaxAggregateOutputType | null
  }

  export type NewsAnalysisMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    summary: string | null
    sentiment: string | null
    createdAt: Date | null
  }

  export type NewsAnalysisMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    summary: string | null
    sentiment: string | null
    createdAt: Date | null
  }

  export type NewsAnalysisCountAggregateOutputType = {
    id: number
    articleId: number
    summary: number
    sentiment: number
    keywords: number
    topics: number
    createdAt: number
    _all: number
  }


  export type NewsAnalysisMinAggregateInputType = {
    id?: true
    articleId?: true
    summary?: true
    sentiment?: true
    createdAt?: true
  }

  export type NewsAnalysisMaxAggregateInputType = {
    id?: true
    articleId?: true
    summary?: true
    sentiment?: true
    createdAt?: true
  }

  export type NewsAnalysisCountAggregateInputType = {
    id?: true
    articleId?: true
    summary?: true
    sentiment?: true
    keywords?: true
    topics?: true
    createdAt?: true
    _all?: true
  }

  export type NewsAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsAnalysis to aggregate.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsAnalyses
    **/
    _count?: true | NewsAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsAnalysisMaxAggregateInputType
  }

  export type GetNewsAnalysisAggregateType<T extends NewsAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsAnalysis[P]>
      : GetScalarType<T[P], AggregateNewsAnalysis[P]>
  }




  export type NewsAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsAnalysisWhereInput
    orderBy?: NewsAnalysisOrderByWithAggregationInput | NewsAnalysisOrderByWithAggregationInput[]
    by: NewsAnalysisScalarFieldEnum[] | NewsAnalysisScalarFieldEnum
    having?: NewsAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsAnalysisCountAggregateInputType | true
    _min?: NewsAnalysisMinAggregateInputType
    _max?: NewsAnalysisMaxAggregateInputType
  }

  export type NewsAnalysisGroupByOutputType = {
    id: string
    articleId: string
    summary: string
    sentiment: string
    keywords: string[]
    topics: string[]
    createdAt: Date
    _count: NewsAnalysisCountAggregateOutputType | null
    _min: NewsAnalysisMinAggregateOutputType | null
    _max: NewsAnalysisMaxAggregateOutputType | null
  }

  type GetNewsAnalysisGroupByPayload<T extends NewsAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], NewsAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type NewsAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    summary?: boolean
    sentiment?: boolean
    keywords?: boolean
    topics?: boolean
    createdAt?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    summary?: boolean
    sentiment?: boolean
    keywords?: boolean
    topics?: boolean
    createdAt?: boolean
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsAnalysis"]>

  export type NewsAnalysisSelectScalar = {
    id?: boolean
    articleId?: boolean
    summary?: boolean
    sentiment?: boolean
    keywords?: boolean
    topics?: boolean
    createdAt?: boolean
  }

  export type NewsAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }
  export type NewsAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | NewsArticleDefaultArgs<ExtArgs>
  }

  export type $NewsAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsAnalysis"
    objects: {
      article: Prisma.$NewsArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      summary: string
      sentiment: string
      keywords: string[]
      topics: string[]
      createdAt: Date
    }, ExtArgs["result"]["newsAnalysis"]>
    composites: {}
  }

  type NewsAnalysisGetPayload<S extends boolean | null | undefined | NewsAnalysisDefaultArgs> = $Result.GetResult<Prisma.$NewsAnalysisPayload, S>

  type NewsAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsAnalysisCountAggregateInputType | true
    }

  export interface NewsAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsAnalysis'], meta: { name: 'NewsAnalysis' } }
    /**
     * Find zero or one NewsAnalysis that matches the filter.
     * @param {NewsAnalysisFindUniqueArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsAnalysisFindUniqueArgs>(args: SelectSubset<T, NewsAnalysisFindUniqueArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsAnalysisFindUniqueOrThrowArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindFirstArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsAnalysisFindFirstArgs>(args?: SelectSubset<T, NewsAnalysisFindFirstArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindFirstOrThrowArgs} args - Arguments to find a NewsAnalysis
     * @example
     * // Get one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsAnalyses
     * const newsAnalyses = await prisma.newsAnalysis.findMany()
     * 
     * // Get first 10 NewsAnalyses
     * const newsAnalyses = await prisma.newsAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsAnalysisFindManyArgs>(args?: SelectSubset<T, NewsAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsAnalysis.
     * @param {NewsAnalysisCreateArgs} args - Arguments to create a NewsAnalysis.
     * @example
     * // Create one NewsAnalysis
     * const NewsAnalysis = await prisma.newsAnalysis.create({
     *   data: {
     *     // ... data to create a NewsAnalysis
     *   }
     * })
     * 
     */
    create<T extends NewsAnalysisCreateArgs>(args: SelectSubset<T, NewsAnalysisCreateArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsAnalyses.
     * @param {NewsAnalysisCreateManyArgs} args - Arguments to create many NewsAnalyses.
     * @example
     * // Create many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsAnalysisCreateManyArgs>(args?: SelectSubset<T, NewsAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsAnalyses and returns the data saved in the database.
     * @param {NewsAnalysisCreateManyAndReturnArgs} args - Arguments to create many NewsAnalyses.
     * @example
     * // Create many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsAnalyses and only return the `id`
     * const newsAnalysisWithIdOnly = await prisma.newsAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsAnalysis.
     * @param {NewsAnalysisDeleteArgs} args - Arguments to delete one NewsAnalysis.
     * @example
     * // Delete one NewsAnalysis
     * const NewsAnalysis = await prisma.newsAnalysis.delete({
     *   where: {
     *     // ... filter to delete one NewsAnalysis
     *   }
     * })
     * 
     */
    delete<T extends NewsAnalysisDeleteArgs>(args: SelectSubset<T, NewsAnalysisDeleteArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsAnalysis.
     * @param {NewsAnalysisUpdateArgs} args - Arguments to update one NewsAnalysis.
     * @example
     * // Update one NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsAnalysisUpdateArgs>(args: SelectSubset<T, NewsAnalysisUpdateArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsAnalyses.
     * @param {NewsAnalysisDeleteManyArgs} args - Arguments to filter NewsAnalyses to delete.
     * @example
     * // Delete a few NewsAnalyses
     * const { count } = await prisma.newsAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsAnalysisDeleteManyArgs>(args?: SelectSubset<T, NewsAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsAnalyses
     * const newsAnalysis = await prisma.newsAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsAnalysisUpdateManyArgs>(args: SelectSubset<T, NewsAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsAnalysis.
     * @param {NewsAnalysisUpsertArgs} args - Arguments to update or create a NewsAnalysis.
     * @example
     * // Update or create a NewsAnalysis
     * const newsAnalysis = await prisma.newsAnalysis.upsert({
     *   create: {
     *     // ... data to create a NewsAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends NewsAnalysisUpsertArgs>(args: SelectSubset<T, NewsAnalysisUpsertArgs<ExtArgs>>): Prisma__NewsAnalysisClient<$Result.GetResult<Prisma.$NewsAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisCountArgs} args - Arguments to filter NewsAnalyses to count.
     * @example
     * // Count the number of NewsAnalyses
     * const count = await prisma.newsAnalysis.count({
     *   where: {
     *     // ... the filter for the NewsAnalyses we want to count
     *   }
     * })
    **/
    count<T extends NewsAnalysisCountArgs>(
      args?: Subset<T, NewsAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAnalysisAggregateArgs>(args: Subset<T, NewsAnalysisAggregateArgs>): Prisma.PrismaPromise<GetNewsAnalysisAggregateType<T>>

    /**
     * Group by NewsAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: NewsAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsAnalysis model
   */
  readonly fields: NewsAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends NewsArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsArticleDefaultArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsAnalysis model
   */ 
  interface NewsAnalysisFieldRefs {
    readonly id: FieldRef<"NewsAnalysis", 'String'>
    readonly articleId: FieldRef<"NewsAnalysis", 'String'>
    readonly summary: FieldRef<"NewsAnalysis", 'String'>
    readonly sentiment: FieldRef<"NewsAnalysis", 'String'>
    readonly keywords: FieldRef<"NewsAnalysis", 'String[]'>
    readonly topics: FieldRef<"NewsAnalysis", 'String[]'>
    readonly createdAt: FieldRef<"NewsAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsAnalysis findUnique
   */
  export type NewsAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis findUniqueOrThrow
   */
  export type NewsAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis findFirst
   */
  export type NewsAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsAnalyses.
     */
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis findFirstOrThrow
   */
  export type NewsAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalysis to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsAnalyses.
     */
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis findMany
   */
  export type NewsAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which NewsAnalyses to fetch.
     */
    where?: NewsAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsAnalyses to fetch.
     */
    orderBy?: NewsAnalysisOrderByWithRelationInput | NewsAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsAnalyses.
     */
    cursor?: NewsAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsAnalyses.
     */
    skip?: number
    distinct?: NewsAnalysisScalarFieldEnum | NewsAnalysisScalarFieldEnum[]
  }

  /**
   * NewsAnalysis create
   */
  export type NewsAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsAnalysis.
     */
    data: XOR<NewsAnalysisCreateInput, NewsAnalysisUncheckedCreateInput>
  }

  /**
   * NewsAnalysis createMany
   */
  export type NewsAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsAnalyses.
     */
    data: NewsAnalysisCreateManyInput | NewsAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsAnalysis createManyAndReturn
   */
  export type NewsAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsAnalyses.
     */
    data: NewsAnalysisCreateManyInput | NewsAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsAnalysis update
   */
  export type NewsAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsAnalysis.
     */
    data: XOR<NewsAnalysisUpdateInput, NewsAnalysisUncheckedUpdateInput>
    /**
     * Choose, which NewsAnalysis to update.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis updateMany
   */
  export type NewsAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsAnalyses.
     */
    data: XOR<NewsAnalysisUpdateManyMutationInput, NewsAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which NewsAnalyses to update
     */
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsAnalysis upsert
   */
  export type NewsAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsAnalysis to update in case it exists.
     */
    where: NewsAnalysisWhereUniqueInput
    /**
     * In case the NewsAnalysis found by the `where` argument doesn't exist, create a new NewsAnalysis with this data.
     */
    create: XOR<NewsAnalysisCreateInput, NewsAnalysisUncheckedCreateInput>
    /**
     * In case the NewsAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsAnalysisUpdateInput, NewsAnalysisUncheckedUpdateInput>
  }

  /**
   * NewsAnalysis delete
   */
  export type NewsAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
    /**
     * Filter which NewsAnalysis to delete.
     */
    where: NewsAnalysisWhereUniqueInput
  }

  /**
   * NewsAnalysis deleteMany
   */
  export type NewsAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsAnalyses to delete
     */
    where?: NewsAnalysisWhereInput
  }

  /**
   * NewsAnalysis without action
   */
  export type NewsAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsAnalysis
     */
    select?: NewsAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model JobQueue
   */

  export type AggregateJobQueue = {
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  export type JobQueueAvgAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type JobQueueSumAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type JobQueueMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    runAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobQueueMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    runAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobQueueCountAggregateOutputType = {
    id: number
    type: number
    payload: number
    status: number
    priority: number
    attempts: number
    maxAttempts: number
    runAt: number
    completedAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobQueueAvgAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type JobQueueSumAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type JobQueueMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    runAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobQueueMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    runAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobQueueCountAggregateInputType = {
    id?: true
    type?: true
    payload?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    runAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueue to aggregate.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobQueues
    **/
    _count?: true | JobQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobQueueMaxAggregateInputType
  }

  export type GetJobQueueAggregateType<T extends JobQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateJobQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobQueue[P]>
      : GetScalarType<T[P], AggregateJobQueue[P]>
  }




  export type JobQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobQueueWhereInput
    orderBy?: JobQueueOrderByWithAggregationInput | JobQueueOrderByWithAggregationInput[]
    by: JobQueueScalarFieldEnum[] | JobQueueScalarFieldEnum
    having?: JobQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobQueueCountAggregateInputType | true
    _avg?: JobQueueAvgAggregateInputType
    _sum?: JobQueueSumAggregateInputType
    _min?: JobQueueMinAggregateInputType
    _max?: JobQueueMaxAggregateInputType
  }

  export type JobQueueGroupByOutputType = {
    id: string
    type: string
    payload: JsonValue
    status: string
    priority: number
    attempts: number
    maxAttempts: number
    runAt: Date
    completedAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  type GetJobQueueGroupByPayload<T extends JobQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
            : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
        }
      >
    >


  export type JobQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    runAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    runAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectScalar = {
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    runAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $JobQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      payload: Prisma.JsonValue
      status: string
      priority: number
      attempts: number
      maxAttempts: number
      runAt: Date
      completedAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobQueue"]>
    composites: {}
  }

  type JobQueueGetPayload<S extends boolean | null | undefined | JobQueueDefaultArgs> = $Result.GetResult<Prisma.$JobQueuePayload, S>

  type JobQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobQueueCountAggregateInputType | true
    }

  export interface JobQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobQueue'], meta: { name: 'JobQueue' } }
    /**
     * Find zero or one JobQueue that matches the filter.
     * @param {JobQueueFindUniqueArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobQueueFindUniqueArgs>(args: SelectSubset<T, JobQueueFindUniqueArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobQueueFindUniqueOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, JobQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobQueueFindFirstArgs>(args?: SelectSubset<T, JobQueueFindFirstArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, JobQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobQueues
     * const jobQueues = await prisma.jobQueue.findMany()
     * 
     * // Get first 10 JobQueues
     * const jobQueues = await prisma.jobQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobQueueFindManyArgs>(args?: SelectSubset<T, JobQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobQueue.
     * @param {JobQueueCreateArgs} args - Arguments to create a JobQueue.
     * @example
     * // Create one JobQueue
     * const JobQueue = await prisma.jobQueue.create({
     *   data: {
     *     // ... data to create a JobQueue
     *   }
     * })
     * 
     */
    create<T extends JobQueueCreateArgs>(args: SelectSubset<T, JobQueueCreateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobQueues.
     * @param {JobQueueCreateManyArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobQueueCreateManyArgs>(args?: SelectSubset<T, JobQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobQueues and returns the data saved in the database.
     * @param {JobQueueCreateManyAndReturnArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobQueues and only return the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, JobQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobQueue.
     * @param {JobQueueDeleteArgs} args - Arguments to delete one JobQueue.
     * @example
     * // Delete one JobQueue
     * const JobQueue = await prisma.jobQueue.delete({
     *   where: {
     *     // ... filter to delete one JobQueue
     *   }
     * })
     * 
     */
    delete<T extends JobQueueDeleteArgs>(args: SelectSubset<T, JobQueueDeleteArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobQueue.
     * @param {JobQueueUpdateArgs} args - Arguments to update one JobQueue.
     * @example
     * // Update one JobQueue
     * const jobQueue = await prisma.jobQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobQueueUpdateArgs>(args: SelectSubset<T, JobQueueUpdateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobQueues.
     * @param {JobQueueDeleteManyArgs} args - Arguments to filter JobQueues to delete.
     * @example
     * // Delete a few JobQueues
     * const { count } = await prisma.jobQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobQueueDeleteManyArgs>(args?: SelectSubset<T, JobQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobQueues
     * const jobQueue = await prisma.jobQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobQueueUpdateManyArgs>(args: SelectSubset<T, JobQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobQueue.
     * @param {JobQueueUpsertArgs} args - Arguments to update or create a JobQueue.
     * @example
     * // Update or create a JobQueue
     * const jobQueue = await prisma.jobQueue.upsert({
     *   create: {
     *     // ... data to create a JobQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobQueue we want to update
     *   }
     * })
     */
    upsert<T extends JobQueueUpsertArgs>(args: SelectSubset<T, JobQueueUpsertArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueCountArgs} args - Arguments to filter JobQueues to count.
     * @example
     * // Count the number of JobQueues
     * const count = await prisma.jobQueue.count({
     *   where: {
     *     // ... the filter for the JobQueues we want to count
     *   }
     * })
    **/
    count<T extends JobQueueCountArgs>(
      args?: Subset<T, JobQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobQueueAggregateArgs>(args: Subset<T, JobQueueAggregateArgs>): Prisma.PrismaPromise<GetJobQueueAggregateType<T>>

    /**
     * Group by JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobQueueGroupByArgs['orderBy'] }
        : { orderBy?: JobQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobQueue model
   */
  readonly fields: JobQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobQueue model
   */ 
  interface JobQueueFieldRefs {
    readonly id: FieldRef<"JobQueue", 'String'>
    readonly type: FieldRef<"JobQueue", 'String'>
    readonly payload: FieldRef<"JobQueue", 'Json'>
    readonly status: FieldRef<"JobQueue", 'String'>
    readonly priority: FieldRef<"JobQueue", 'Int'>
    readonly attempts: FieldRef<"JobQueue", 'Int'>
    readonly maxAttempts: FieldRef<"JobQueue", 'Int'>
    readonly runAt: FieldRef<"JobQueue", 'DateTime'>
    readonly completedAt: FieldRef<"JobQueue", 'DateTime'>
    readonly error: FieldRef<"JobQueue", 'String'>
    readonly createdAt: FieldRef<"JobQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"JobQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobQueue findUnique
   */
  export type JobQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findUniqueOrThrow
   */
  export type JobQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findFirst
   */
  export type JobQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findFirstOrThrow
   */
  export type JobQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findMany
   */
  export type JobQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter, which JobQueues to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue create
   */
  export type JobQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * The data needed to create a JobQueue.
     */
    data: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
  }

  /**
   * JobQueue createMany
   */
  export type JobQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue createManyAndReturn
   */
  export type JobQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue update
   */
  export type JobQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * The data needed to update a JobQueue.
     */
    data: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
    /**
     * Choose, which JobQueue to update.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue updateMany
   */
  export type JobQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobQueues.
     */
    data: XOR<JobQueueUpdateManyMutationInput, JobQueueUncheckedUpdateManyInput>
    /**
     * Filter which JobQueues to update
     */
    where?: JobQueueWhereInput
  }

  /**
   * JobQueue upsert
   */
  export type JobQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * The filter to search for the JobQueue to update in case it exists.
     */
    where: JobQueueWhereUniqueInput
    /**
     * In case the JobQueue found by the `where` argument doesn't exist, create a new JobQueue with this data.
     */
    create: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
    /**
     * In case the JobQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
  }

  /**
   * JobQueue delete
   */
  export type JobQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Filter which JobQueue to delete.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue deleteMany
   */
  export type JobQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueues to delete
     */
    where?: JobQueueWhereInput
  }

  /**
   * JobQueue without action
   */
  export type JobQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
  }


  /**
   * Model CollectionPreset
   */

  export type AggregateCollectionPreset = {
    _count: CollectionPresetCountAggregateOutputType | null
    _min: CollectionPresetMinAggregateOutputType | null
    _max: CollectionPresetMaxAggregateOutputType | null
  }

  export type CollectionPresetMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionPresetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionPresetCountAggregateOutputType = {
    id: number
    name: number
    description: number
    settings: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionPresetMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionPresetMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionPresetCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    settings?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionPresetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionPreset to aggregate.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionPresets
    **/
    _count?: true | CollectionPresetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionPresetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionPresetMaxAggregateInputType
  }

  export type GetCollectionPresetAggregateType<T extends CollectionPresetAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionPreset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionPreset[P]>
      : GetScalarType<T[P], AggregateCollectionPreset[P]>
  }




  export type CollectionPresetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionPresetWhereInput
    orderBy?: CollectionPresetOrderByWithAggregationInput | CollectionPresetOrderByWithAggregationInput[]
    by: CollectionPresetScalarFieldEnum[] | CollectionPresetScalarFieldEnum
    having?: CollectionPresetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionPresetCountAggregateInputType | true
    _min?: CollectionPresetMinAggregateInputType
    _max?: CollectionPresetMaxAggregateInputType
  }

  export type CollectionPresetGroupByOutputType = {
    id: string
    name: string
    description: string | null
    settings: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollectionPresetCountAggregateOutputType | null
    _min: CollectionPresetMinAggregateOutputType | null
    _max: CollectionPresetMaxAggregateOutputType | null
  }

  type GetCollectionPresetGroupByPayload<T extends CollectionPresetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionPresetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionPresetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionPresetGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionPresetGroupByOutputType[P]>
        }
      >
    >


  export type CollectionPresetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["collectionPreset"]>

  export type CollectionPresetSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CollectionPresetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionPreset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      settings: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionPreset"]>
    composites: {}
  }

  type CollectionPresetGetPayload<S extends boolean | null | undefined | CollectionPresetDefaultArgs> = $Result.GetResult<Prisma.$CollectionPresetPayload, S>

  type CollectionPresetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CollectionPresetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollectionPresetCountAggregateInputType | true
    }

  export interface CollectionPresetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionPreset'], meta: { name: 'CollectionPreset' } }
    /**
     * Find zero or one CollectionPreset that matches the filter.
     * @param {CollectionPresetFindUniqueArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionPresetFindUniqueArgs>(args: SelectSubset<T, CollectionPresetFindUniqueArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CollectionPreset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CollectionPresetFindUniqueOrThrowArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionPresetFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionPresetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CollectionPreset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindFirstArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionPresetFindFirstArgs>(args?: SelectSubset<T, CollectionPresetFindFirstArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CollectionPreset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindFirstOrThrowArgs} args - Arguments to find a CollectionPreset
     * @example
     * // Get one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionPresetFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionPresetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CollectionPresets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionPresets
     * const collectionPresets = await prisma.collectionPreset.findMany()
     * 
     * // Get first 10 CollectionPresets
     * const collectionPresets = await prisma.collectionPreset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionPresetFindManyArgs>(args?: SelectSubset<T, CollectionPresetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CollectionPreset.
     * @param {CollectionPresetCreateArgs} args - Arguments to create a CollectionPreset.
     * @example
     * // Create one CollectionPreset
     * const CollectionPreset = await prisma.collectionPreset.create({
     *   data: {
     *     // ... data to create a CollectionPreset
     *   }
     * })
     * 
     */
    create<T extends CollectionPresetCreateArgs>(args: SelectSubset<T, CollectionPresetCreateArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CollectionPresets.
     * @param {CollectionPresetCreateManyArgs} args - Arguments to create many CollectionPresets.
     * @example
     * // Create many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionPresetCreateManyArgs>(args?: SelectSubset<T, CollectionPresetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionPresets and returns the data saved in the database.
     * @param {CollectionPresetCreateManyAndReturnArgs} args - Arguments to create many CollectionPresets.
     * @example
     * // Create many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionPresets and only return the `id`
     * const collectionPresetWithIdOnly = await prisma.collectionPreset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionPresetCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionPresetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CollectionPreset.
     * @param {CollectionPresetDeleteArgs} args - Arguments to delete one CollectionPreset.
     * @example
     * // Delete one CollectionPreset
     * const CollectionPreset = await prisma.collectionPreset.delete({
     *   where: {
     *     // ... filter to delete one CollectionPreset
     *   }
     * })
     * 
     */
    delete<T extends CollectionPresetDeleteArgs>(args: SelectSubset<T, CollectionPresetDeleteArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CollectionPreset.
     * @param {CollectionPresetUpdateArgs} args - Arguments to update one CollectionPreset.
     * @example
     * // Update one CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionPresetUpdateArgs>(args: SelectSubset<T, CollectionPresetUpdateArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CollectionPresets.
     * @param {CollectionPresetDeleteManyArgs} args - Arguments to filter CollectionPresets to delete.
     * @example
     * // Delete a few CollectionPresets
     * const { count } = await prisma.collectionPreset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionPresetDeleteManyArgs>(args?: SelectSubset<T, CollectionPresetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionPresets
     * const collectionPreset = await prisma.collectionPreset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionPresetUpdateManyArgs>(args: SelectSubset<T, CollectionPresetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CollectionPreset.
     * @param {CollectionPresetUpsertArgs} args - Arguments to update or create a CollectionPreset.
     * @example
     * // Update or create a CollectionPreset
     * const collectionPreset = await prisma.collectionPreset.upsert({
     *   create: {
     *     // ... data to create a CollectionPreset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionPreset we want to update
     *   }
     * })
     */
    upsert<T extends CollectionPresetUpsertArgs>(args: SelectSubset<T, CollectionPresetUpsertArgs<ExtArgs>>): Prisma__CollectionPresetClient<$Result.GetResult<Prisma.$CollectionPresetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CollectionPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetCountArgs} args - Arguments to filter CollectionPresets to count.
     * @example
     * // Count the number of CollectionPresets
     * const count = await prisma.collectionPreset.count({
     *   where: {
     *     // ... the filter for the CollectionPresets we want to count
     *   }
     * })
    **/
    count<T extends CollectionPresetCountArgs>(
      args?: Subset<T, CollectionPresetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionPresetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionPresetAggregateArgs>(args: Subset<T, CollectionPresetAggregateArgs>): Prisma.PrismaPromise<GetCollectionPresetAggregateType<T>>

    /**
     * Group by CollectionPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionPresetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionPresetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionPresetGroupByArgs['orderBy'] }
        : { orderBy?: CollectionPresetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionPresetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionPresetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionPreset model
   */
  readonly fields: CollectionPresetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionPreset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionPresetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionPreset model
   */ 
  interface CollectionPresetFieldRefs {
    readonly id: FieldRef<"CollectionPreset", 'String'>
    readonly name: FieldRef<"CollectionPreset", 'String'>
    readonly description: FieldRef<"CollectionPreset", 'String'>
    readonly settings: FieldRef<"CollectionPreset", 'Json'>
    readonly isActive: FieldRef<"CollectionPreset", 'Boolean'>
    readonly createdAt: FieldRef<"CollectionPreset", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionPreset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionPreset findUnique
   */
  export type CollectionPresetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset findUniqueOrThrow
   */
  export type CollectionPresetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset findFirst
   */
  export type CollectionPresetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionPresets.
     */
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset findFirstOrThrow
   */
  export type CollectionPresetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPreset to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionPresets.
     */
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset findMany
   */
  export type CollectionPresetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter, which CollectionPresets to fetch.
     */
    where?: CollectionPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionPresets to fetch.
     */
    orderBy?: CollectionPresetOrderByWithRelationInput | CollectionPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionPresets.
     */
    cursor?: CollectionPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionPresets.
     */
    skip?: number
    distinct?: CollectionPresetScalarFieldEnum | CollectionPresetScalarFieldEnum[]
  }

  /**
   * CollectionPreset create
   */
  export type CollectionPresetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * The data needed to create a CollectionPreset.
     */
    data: XOR<CollectionPresetCreateInput, CollectionPresetUncheckedCreateInput>
  }

  /**
   * CollectionPreset createMany
   */
  export type CollectionPresetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionPresets.
     */
    data: CollectionPresetCreateManyInput | CollectionPresetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionPreset createManyAndReturn
   */
  export type CollectionPresetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CollectionPresets.
     */
    data: CollectionPresetCreateManyInput | CollectionPresetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionPreset update
   */
  export type CollectionPresetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * The data needed to update a CollectionPreset.
     */
    data: XOR<CollectionPresetUpdateInput, CollectionPresetUncheckedUpdateInput>
    /**
     * Choose, which CollectionPreset to update.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset updateMany
   */
  export type CollectionPresetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionPresets.
     */
    data: XOR<CollectionPresetUpdateManyMutationInput, CollectionPresetUncheckedUpdateManyInput>
    /**
     * Filter which CollectionPresets to update
     */
    where?: CollectionPresetWhereInput
  }

  /**
   * CollectionPreset upsert
   */
  export type CollectionPresetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * The filter to search for the CollectionPreset to update in case it exists.
     */
    where: CollectionPresetWhereUniqueInput
    /**
     * In case the CollectionPreset found by the `where` argument doesn't exist, create a new CollectionPreset with this data.
     */
    create: XOR<CollectionPresetCreateInput, CollectionPresetUncheckedCreateInput>
    /**
     * In case the CollectionPreset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionPresetUpdateInput, CollectionPresetUncheckedUpdateInput>
  }

  /**
   * CollectionPreset delete
   */
  export type CollectionPresetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
    /**
     * Filter which CollectionPreset to delete.
     */
    where: CollectionPresetWhereUniqueInput
  }

  /**
   * CollectionPreset deleteMany
   */
  export type CollectionPresetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionPresets to delete
     */
    where?: CollectionPresetWhereInput
  }

  /**
   * CollectionPreset without action
   */
  export type CollectionPresetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionPreset
     */
    select?: CollectionPresetSelect<ExtArgs> | null
  }


  /**
   * Model WatchlistUser
   */

  export type AggregateWatchlistUser = {
    _count: WatchlistUserCountAggregateOutputType | null
    _avg: WatchlistUserAvgAggregateOutputType | null
    _sum: WatchlistUserSumAggregateOutputType | null
    _min: WatchlistUserMinAggregateOutputType | null
    _max: WatchlistUserMaxAggregateOutputType | null
  }

  export type WatchlistUserAvgAggregateOutputType = {
    followers: number | null
    following: number | null
  }

  export type WatchlistUserSumAggregateOutputType = {
    followers: number | null
    following: number | null
  }

  export type WatchlistUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    twitterId: string | null
    username: string | null
    displayName: string | null
    followers: number | null
    following: number | null
    isActive: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
  }

  export type WatchlistUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    twitterId: string | null
    username: string | null
    displayName: string | null
    followers: number | null
    following: number | null
    isActive: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
  }

  export type WatchlistUserCountAggregateOutputType = {
    id: number
    userId: number
    twitterId: number
    username: number
    displayName: number
    followers: number
    following: number
    isActive: number
    lastChecked: number
    createdAt: number
    _all: number
  }


  export type WatchlistUserAvgAggregateInputType = {
    followers?: true
    following?: true
  }

  export type WatchlistUserSumAggregateInputType = {
    followers?: true
    following?: true
  }

  export type WatchlistUserMinAggregateInputType = {
    id?: true
    userId?: true
    twitterId?: true
    username?: true
    displayName?: true
    followers?: true
    following?: true
    isActive?: true
    lastChecked?: true
    createdAt?: true
  }

  export type WatchlistUserMaxAggregateInputType = {
    id?: true
    userId?: true
    twitterId?: true
    username?: true
    displayName?: true
    followers?: true
    following?: true
    isActive?: true
    lastChecked?: true
    createdAt?: true
  }

  export type WatchlistUserCountAggregateInputType = {
    id?: true
    userId?: true
    twitterId?: true
    username?: true
    displayName?: true
    followers?: true
    following?: true
    isActive?: true
    lastChecked?: true
    createdAt?: true
    _all?: true
  }

  export type WatchlistUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistUser to aggregate.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistUsers
    **/
    _count?: true | WatchlistUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistUserMaxAggregateInputType
  }

  export type GetWatchlistUserAggregateType<T extends WatchlistUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistUser[P]>
      : GetScalarType<T[P], AggregateWatchlistUser[P]>
  }




  export type WatchlistUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistUserWhereInput
    orderBy?: WatchlistUserOrderByWithAggregationInput | WatchlistUserOrderByWithAggregationInput[]
    by: WatchlistUserScalarFieldEnum[] | WatchlistUserScalarFieldEnum
    having?: WatchlistUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistUserCountAggregateInputType | true
    _avg?: WatchlistUserAvgAggregateInputType
    _sum?: WatchlistUserSumAggregateInputType
    _min?: WatchlistUserMinAggregateInputType
    _max?: WatchlistUserMaxAggregateInputType
  }

  export type WatchlistUserGroupByOutputType = {
    id: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers: number | null
    following: number | null
    isActive: boolean
    lastChecked: Date | null
    createdAt: Date
    _count: WatchlistUserCountAggregateOutputType | null
    _avg: WatchlistUserAvgAggregateOutputType | null
    _sum: WatchlistUserSumAggregateOutputType | null
    _min: WatchlistUserMinAggregateOutputType | null
    _max: WatchlistUserMaxAggregateOutputType | null
  }

  type GetWatchlistUserGroupByPayload<T extends WatchlistUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistUserGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistUserGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    followers?: boolean
    following?: boolean
    isActive?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tweets?: boolean | WatchlistUser$tweetsArgs<ExtArgs>
    interactions?: boolean | WatchlistUser$interactionsArgs<ExtArgs>
    _count?: boolean | WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    followers?: boolean
    following?: boolean
    isActive?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistUser"]>

  export type WatchlistUserSelectScalar = {
    id?: boolean
    userId?: boolean
    twitterId?: boolean
    username?: boolean
    displayName?: boolean
    followers?: boolean
    following?: boolean
    isActive?: boolean
    lastChecked?: boolean
    createdAt?: boolean
  }

  export type WatchlistUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tweets?: boolean | WatchlistUser$tweetsArgs<ExtArgs>
    interactions?: boolean | WatchlistUser$interactionsArgs<ExtArgs>
    _count?: boolean | WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WatchlistUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WatchlistUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tweets: Prisma.$WatchlistTweetPayload<ExtArgs>[]
      interactions: Prisma.$InteractionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      twitterId: string
      username: string
      displayName: string
      followers: number | null
      following: number | null
      isActive: boolean
      lastChecked: Date | null
      createdAt: Date
    }, ExtArgs["result"]["watchlistUser"]>
    composites: {}
  }

  type WatchlistUserGetPayload<S extends boolean | null | undefined | WatchlistUserDefaultArgs> = $Result.GetResult<Prisma.$WatchlistUserPayload, S>

  type WatchlistUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchlistUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchlistUserCountAggregateInputType | true
    }

  export interface WatchlistUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistUser'], meta: { name: 'WatchlistUser' } }
    /**
     * Find zero or one WatchlistUser that matches the filter.
     * @param {WatchlistUserFindUniqueArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistUserFindUniqueArgs>(args: SelectSubset<T, WatchlistUserFindUniqueArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WatchlistUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchlistUserFindUniqueOrThrowArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WatchlistUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindFirstArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistUserFindFirstArgs>(args?: SelectSubset<T, WatchlistUserFindFirstArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WatchlistUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindFirstOrThrowArgs} args - Arguments to find a WatchlistUser
     * @example
     * // Get one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WatchlistUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistUsers
     * const watchlistUsers = await prisma.watchlistUser.findMany()
     * 
     * // Get first 10 WatchlistUsers
     * const watchlistUsers = await prisma.watchlistUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistUserFindManyArgs>(args?: SelectSubset<T, WatchlistUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WatchlistUser.
     * @param {WatchlistUserCreateArgs} args - Arguments to create a WatchlistUser.
     * @example
     * // Create one WatchlistUser
     * const WatchlistUser = await prisma.watchlistUser.create({
     *   data: {
     *     // ... data to create a WatchlistUser
     *   }
     * })
     * 
     */
    create<T extends WatchlistUserCreateArgs>(args: SelectSubset<T, WatchlistUserCreateArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WatchlistUsers.
     * @param {WatchlistUserCreateManyArgs} args - Arguments to create many WatchlistUsers.
     * @example
     * // Create many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistUserCreateManyArgs>(args?: SelectSubset<T, WatchlistUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistUsers and returns the data saved in the database.
     * @param {WatchlistUserCreateManyAndReturnArgs} args - Arguments to create many WatchlistUsers.
     * @example
     * // Create many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistUsers and only return the `id`
     * const watchlistUserWithIdOnly = await prisma.watchlistUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WatchlistUser.
     * @param {WatchlistUserDeleteArgs} args - Arguments to delete one WatchlistUser.
     * @example
     * // Delete one WatchlistUser
     * const WatchlistUser = await prisma.watchlistUser.delete({
     *   where: {
     *     // ... filter to delete one WatchlistUser
     *   }
     * })
     * 
     */
    delete<T extends WatchlistUserDeleteArgs>(args: SelectSubset<T, WatchlistUserDeleteArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WatchlistUser.
     * @param {WatchlistUserUpdateArgs} args - Arguments to update one WatchlistUser.
     * @example
     * // Update one WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistUserUpdateArgs>(args: SelectSubset<T, WatchlistUserUpdateArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WatchlistUsers.
     * @param {WatchlistUserDeleteManyArgs} args - Arguments to filter WatchlistUsers to delete.
     * @example
     * // Delete a few WatchlistUsers
     * const { count } = await prisma.watchlistUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistUserDeleteManyArgs>(args?: SelectSubset<T, WatchlistUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistUsers
     * const watchlistUser = await prisma.watchlistUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistUserUpdateManyArgs>(args: SelectSubset<T, WatchlistUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchlistUser.
     * @param {WatchlistUserUpsertArgs} args - Arguments to update or create a WatchlistUser.
     * @example
     * // Update or create a WatchlistUser
     * const watchlistUser = await prisma.watchlistUser.upsert({
     *   create: {
     *     // ... data to create a WatchlistUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistUser we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistUserUpsertArgs>(args: SelectSubset<T, WatchlistUserUpsertArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WatchlistUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserCountArgs} args - Arguments to filter WatchlistUsers to count.
     * @example
     * // Count the number of WatchlistUsers
     * const count = await prisma.watchlistUser.count({
     *   where: {
     *     // ... the filter for the WatchlistUsers we want to count
     *   }
     * })
    **/
    count<T extends WatchlistUserCountArgs>(
      args?: Subset<T, WatchlistUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistUserAggregateArgs>(args: Subset<T, WatchlistUserAggregateArgs>): Prisma.PrismaPromise<GetWatchlistUserAggregateType<T>>

    /**
     * Group by WatchlistUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistUserGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistUser model
   */
  readonly fields: WatchlistUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tweets<T extends WatchlistUser$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUser$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findMany"> | Null>
    interactions<T extends WatchlistUser$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUser$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistUser model
   */ 
  interface WatchlistUserFieldRefs {
    readonly id: FieldRef<"WatchlistUser", 'String'>
    readonly userId: FieldRef<"WatchlistUser", 'String'>
    readonly twitterId: FieldRef<"WatchlistUser", 'String'>
    readonly username: FieldRef<"WatchlistUser", 'String'>
    readonly displayName: FieldRef<"WatchlistUser", 'String'>
    readonly followers: FieldRef<"WatchlistUser", 'Int'>
    readonly following: FieldRef<"WatchlistUser", 'Int'>
    readonly isActive: FieldRef<"WatchlistUser", 'Boolean'>
    readonly lastChecked: FieldRef<"WatchlistUser", 'DateTime'>
    readonly createdAt: FieldRef<"WatchlistUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistUser findUnique
   */
  export type WatchlistUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser findUniqueOrThrow
   */
  export type WatchlistUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser findFirst
   */
  export type WatchlistUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistUsers.
     */
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser findFirstOrThrow
   */
  export type WatchlistUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUser to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistUsers.
     */
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser findMany
   */
  export type WatchlistUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistUsers to fetch.
     */
    where?: WatchlistUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistUsers to fetch.
     */
    orderBy?: WatchlistUserOrderByWithRelationInput | WatchlistUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistUsers.
     */
    cursor?: WatchlistUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistUsers.
     */
    skip?: number
    distinct?: WatchlistUserScalarFieldEnum | WatchlistUserScalarFieldEnum[]
  }

  /**
   * WatchlistUser create
   */
  export type WatchlistUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistUser.
     */
    data: XOR<WatchlistUserCreateInput, WatchlistUserUncheckedCreateInput>
  }

  /**
   * WatchlistUser createMany
   */
  export type WatchlistUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistUsers.
     */
    data: WatchlistUserCreateManyInput | WatchlistUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistUser createManyAndReturn
   */
  export type WatchlistUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WatchlistUsers.
     */
    data: WatchlistUserCreateManyInput | WatchlistUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistUser update
   */
  export type WatchlistUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistUser.
     */
    data: XOR<WatchlistUserUpdateInput, WatchlistUserUncheckedUpdateInput>
    /**
     * Choose, which WatchlistUser to update.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser updateMany
   */
  export type WatchlistUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistUsers.
     */
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistUsers to update
     */
    where?: WatchlistUserWhereInput
  }

  /**
   * WatchlistUser upsert
   */
  export type WatchlistUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistUser to update in case it exists.
     */
    where: WatchlistUserWhereUniqueInput
    /**
     * In case the WatchlistUser found by the `where` argument doesn't exist, create a new WatchlistUser with this data.
     */
    create: XOR<WatchlistUserCreateInput, WatchlistUserUncheckedCreateInput>
    /**
     * In case the WatchlistUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistUserUpdateInput, WatchlistUserUncheckedUpdateInput>
  }

  /**
   * WatchlistUser delete
   */
  export type WatchlistUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
    /**
     * Filter which WatchlistUser to delete.
     */
    where: WatchlistUserWhereUniqueInput
  }

  /**
   * WatchlistUser deleteMany
   */
  export type WatchlistUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistUsers to delete
     */
    where?: WatchlistUserWhereInput
  }

  /**
   * WatchlistUser.tweets
   */
  export type WatchlistUser$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    where?: WatchlistTweetWhereInput
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    cursor?: WatchlistTweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistUser.interactions
   */
  export type WatchlistUser$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    where?: InteractionHistoryWhereInput
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    cursor?: InteractionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * WatchlistUser without action
   */
  export type WatchlistUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistUser
     */
    select?: WatchlistUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistUserInclude<ExtArgs> | null
  }


  /**
   * Model WatchlistTweet
   */

  export type AggregateWatchlistTweet = {
    _count: WatchlistTweetCountAggregateOutputType | null
    _avg: WatchlistTweetAvgAggregateOutputType | null
    _sum: WatchlistTweetSumAggregateOutputType | null
    _min: WatchlistTweetMinAggregateOutputType | null
    _max: WatchlistTweetMaxAggregateOutputType | null
  }

  export type WatchlistTweetAvgAggregateOutputType = {
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
  }

  export type WatchlistTweetSumAggregateOutputType = {
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
  }

  export type WatchlistTweetMinAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    tweetId: string | null
    content: string | null
    createdAt: Date | null
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
    collectedAt: Date | null
  }

  export type WatchlistTweetMaxAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    tweetId: string | null
    content: string | null
    createdAt: Date | null
    retweetCount: number | null
    likeCount: number | null
    replyCount: number | null
    collectedAt: Date | null
  }

  export type WatchlistTweetCountAggregateOutputType = {
    id: number
    watchlistUserId: number
    tweetId: number
    content: number
    createdAt: number
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt: number
    _all: number
  }


  export type WatchlistTweetAvgAggregateInputType = {
    retweetCount?: true
    likeCount?: true
    replyCount?: true
  }

  export type WatchlistTweetSumAggregateInputType = {
    retweetCount?: true
    likeCount?: true
    replyCount?: true
  }

  export type WatchlistTweetMinAggregateInputType = {
    id?: true
    watchlistUserId?: true
    tweetId?: true
    content?: true
    createdAt?: true
    retweetCount?: true
    likeCount?: true
    replyCount?: true
    collectedAt?: true
  }

  export type WatchlistTweetMaxAggregateInputType = {
    id?: true
    watchlistUserId?: true
    tweetId?: true
    content?: true
    createdAt?: true
    retweetCount?: true
    likeCount?: true
    replyCount?: true
    collectedAt?: true
  }

  export type WatchlistTweetCountAggregateInputType = {
    id?: true
    watchlistUserId?: true
    tweetId?: true
    content?: true
    createdAt?: true
    retweetCount?: true
    likeCount?: true
    replyCount?: true
    collectedAt?: true
    _all?: true
  }

  export type WatchlistTweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistTweet to aggregate.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistTweets
    **/
    _count?: true | WatchlistTweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistTweetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistTweetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistTweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistTweetMaxAggregateInputType
  }

  export type GetWatchlistTweetAggregateType<T extends WatchlistTweetAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistTweet[P]>
      : GetScalarType<T[P], AggregateWatchlistTweet[P]>
  }




  export type WatchlistTweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistTweetWhereInput
    orderBy?: WatchlistTweetOrderByWithAggregationInput | WatchlistTweetOrderByWithAggregationInput[]
    by: WatchlistTweetScalarFieldEnum[] | WatchlistTweetScalarFieldEnum
    having?: WatchlistTweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistTweetCountAggregateInputType | true
    _avg?: WatchlistTweetAvgAggregateInputType
    _sum?: WatchlistTweetSumAggregateInputType
    _min?: WatchlistTweetMinAggregateInputType
    _max?: WatchlistTweetMaxAggregateInputType
  }

  export type WatchlistTweetGroupByOutputType = {
    id: string
    watchlistUserId: string
    tweetId: string
    content: string
    createdAt: Date
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt: Date
    _count: WatchlistTweetCountAggregateOutputType | null
    _avg: WatchlistTweetAvgAggregateOutputType | null
    _sum: WatchlistTweetSumAggregateOutputType | null
    _min: WatchlistTweetMinAggregateOutputType | null
    _max: WatchlistTweetMaxAggregateOutputType | null
  }

  type GetWatchlistTweetGroupByPayload<T extends WatchlistTweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistTweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistTweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistTweetGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistTweetGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistTweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    tweetId?: boolean
    content?: boolean
    createdAt?: boolean
    retweetCount?: boolean
    likeCount?: boolean
    replyCount?: boolean
    collectedAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    tweetId?: boolean
    content?: boolean
    createdAt?: boolean
    retweetCount?: boolean
    likeCount?: boolean
    replyCount?: boolean
    collectedAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistTweet"]>

  export type WatchlistTweetSelectScalar = {
    id?: boolean
    watchlistUserId?: boolean
    tweetId?: boolean
    content?: boolean
    createdAt?: boolean
    retweetCount?: boolean
    likeCount?: boolean
    replyCount?: boolean
    collectedAt?: boolean
  }

  export type WatchlistTweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }
  export type WatchlistTweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }

  export type $WatchlistTweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistTweet"
    objects: {
      watchlistUser: Prisma.$WatchlistUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      watchlistUserId: string
      tweetId: string
      content: string
      createdAt: Date
      retweetCount: number
      likeCount: number
      replyCount: number
      collectedAt: Date
    }, ExtArgs["result"]["watchlistTweet"]>
    composites: {}
  }

  type WatchlistTweetGetPayload<S extends boolean | null | undefined | WatchlistTweetDefaultArgs> = $Result.GetResult<Prisma.$WatchlistTweetPayload, S>

  type WatchlistTweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchlistTweetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchlistTweetCountAggregateInputType | true
    }

  export interface WatchlistTweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistTweet'], meta: { name: 'WatchlistTweet' } }
    /**
     * Find zero or one WatchlistTweet that matches the filter.
     * @param {WatchlistTweetFindUniqueArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistTweetFindUniqueArgs>(args: SelectSubset<T, WatchlistTweetFindUniqueArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WatchlistTweet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchlistTweetFindUniqueOrThrowArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistTweetFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistTweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WatchlistTweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindFirstArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistTweetFindFirstArgs>(args?: SelectSubset<T, WatchlistTweetFindFirstArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WatchlistTweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindFirstOrThrowArgs} args - Arguments to find a WatchlistTweet
     * @example
     * // Get one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistTweetFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistTweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WatchlistTweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistTweets
     * const watchlistTweets = await prisma.watchlistTweet.findMany()
     * 
     * // Get first 10 WatchlistTweets
     * const watchlistTweets = await prisma.watchlistTweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistTweetFindManyArgs>(args?: SelectSubset<T, WatchlistTweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WatchlistTweet.
     * @param {WatchlistTweetCreateArgs} args - Arguments to create a WatchlistTweet.
     * @example
     * // Create one WatchlistTweet
     * const WatchlistTweet = await prisma.watchlistTweet.create({
     *   data: {
     *     // ... data to create a WatchlistTweet
     *   }
     * })
     * 
     */
    create<T extends WatchlistTweetCreateArgs>(args: SelectSubset<T, WatchlistTweetCreateArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WatchlistTweets.
     * @param {WatchlistTweetCreateManyArgs} args - Arguments to create many WatchlistTweets.
     * @example
     * // Create many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistTweetCreateManyArgs>(args?: SelectSubset<T, WatchlistTweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistTweets and returns the data saved in the database.
     * @param {WatchlistTweetCreateManyAndReturnArgs} args - Arguments to create many WatchlistTweets.
     * @example
     * // Create many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistTweets and only return the `id`
     * const watchlistTweetWithIdOnly = await prisma.watchlistTweet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistTweetCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistTweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WatchlistTweet.
     * @param {WatchlistTweetDeleteArgs} args - Arguments to delete one WatchlistTweet.
     * @example
     * // Delete one WatchlistTweet
     * const WatchlistTweet = await prisma.watchlistTweet.delete({
     *   where: {
     *     // ... filter to delete one WatchlistTweet
     *   }
     * })
     * 
     */
    delete<T extends WatchlistTweetDeleteArgs>(args: SelectSubset<T, WatchlistTweetDeleteArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WatchlistTweet.
     * @param {WatchlistTweetUpdateArgs} args - Arguments to update one WatchlistTweet.
     * @example
     * // Update one WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistTweetUpdateArgs>(args: SelectSubset<T, WatchlistTweetUpdateArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WatchlistTweets.
     * @param {WatchlistTweetDeleteManyArgs} args - Arguments to filter WatchlistTweets to delete.
     * @example
     * // Delete a few WatchlistTweets
     * const { count } = await prisma.watchlistTweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistTweetDeleteManyArgs>(args?: SelectSubset<T, WatchlistTweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistTweets
     * const watchlistTweet = await prisma.watchlistTweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistTweetUpdateManyArgs>(args: SelectSubset<T, WatchlistTweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchlistTweet.
     * @param {WatchlistTweetUpsertArgs} args - Arguments to update or create a WatchlistTweet.
     * @example
     * // Update or create a WatchlistTweet
     * const watchlistTweet = await prisma.watchlistTweet.upsert({
     *   create: {
     *     // ... data to create a WatchlistTweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistTweet we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistTweetUpsertArgs>(args: SelectSubset<T, WatchlistTweetUpsertArgs<ExtArgs>>): Prisma__WatchlistTweetClient<$Result.GetResult<Prisma.$WatchlistTweetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WatchlistTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetCountArgs} args - Arguments to filter WatchlistTweets to count.
     * @example
     * // Count the number of WatchlistTweets
     * const count = await prisma.watchlistTweet.count({
     *   where: {
     *     // ... the filter for the WatchlistTweets we want to count
     *   }
     * })
    **/
    count<T extends WatchlistTweetCountArgs>(
      args?: Subset<T, WatchlistTweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistTweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistTweetAggregateArgs>(args: Subset<T, WatchlistTweetAggregateArgs>): Prisma.PrismaPromise<GetWatchlistTweetAggregateType<T>>

    /**
     * Group by WatchlistTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistTweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistTweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistTweetGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistTweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistTweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistTweet model
   */
  readonly fields: WatchlistTweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistTweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistTweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlistUser<T extends WatchlistUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUserDefaultArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistTweet model
   */ 
  interface WatchlistTweetFieldRefs {
    readonly id: FieldRef<"WatchlistTweet", 'String'>
    readonly watchlistUserId: FieldRef<"WatchlistTweet", 'String'>
    readonly tweetId: FieldRef<"WatchlistTweet", 'String'>
    readonly content: FieldRef<"WatchlistTweet", 'String'>
    readonly createdAt: FieldRef<"WatchlistTweet", 'DateTime'>
    readonly retweetCount: FieldRef<"WatchlistTweet", 'Int'>
    readonly likeCount: FieldRef<"WatchlistTweet", 'Int'>
    readonly replyCount: FieldRef<"WatchlistTweet", 'Int'>
    readonly collectedAt: FieldRef<"WatchlistTweet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistTweet findUnique
   */
  export type WatchlistTweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet findUniqueOrThrow
   */
  export type WatchlistTweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet findFirst
   */
  export type WatchlistTweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistTweets.
     */
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet findFirstOrThrow
   */
  export type WatchlistTweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweet to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistTweets.
     */
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet findMany
   */
  export type WatchlistTweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistTweets to fetch.
     */
    where?: WatchlistTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistTweets to fetch.
     */
    orderBy?: WatchlistTweetOrderByWithRelationInput | WatchlistTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistTweets.
     */
    cursor?: WatchlistTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistTweets.
     */
    skip?: number
    distinct?: WatchlistTweetScalarFieldEnum | WatchlistTweetScalarFieldEnum[]
  }

  /**
   * WatchlistTweet create
   */
  export type WatchlistTweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistTweet.
     */
    data: XOR<WatchlistTweetCreateInput, WatchlistTweetUncheckedCreateInput>
  }

  /**
   * WatchlistTweet createMany
   */
  export type WatchlistTweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistTweets.
     */
    data: WatchlistTweetCreateManyInput | WatchlistTweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistTweet createManyAndReturn
   */
  export type WatchlistTweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WatchlistTweets.
     */
    data: WatchlistTweetCreateManyInput | WatchlistTweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistTweet update
   */
  export type WatchlistTweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistTweet.
     */
    data: XOR<WatchlistTweetUpdateInput, WatchlistTweetUncheckedUpdateInput>
    /**
     * Choose, which WatchlistTweet to update.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet updateMany
   */
  export type WatchlistTweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistTweets.
     */
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistTweets to update
     */
    where?: WatchlistTweetWhereInput
  }

  /**
   * WatchlistTweet upsert
   */
  export type WatchlistTweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistTweet to update in case it exists.
     */
    where: WatchlistTweetWhereUniqueInput
    /**
     * In case the WatchlistTweet found by the `where` argument doesn't exist, create a new WatchlistTweet with this data.
     */
    create: XOR<WatchlistTweetCreateInput, WatchlistTweetUncheckedCreateInput>
    /**
     * In case the WatchlistTweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistTweetUpdateInput, WatchlistTweetUncheckedUpdateInput>
  }

  /**
   * WatchlistTweet delete
   */
  export type WatchlistTweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
    /**
     * Filter which WatchlistTweet to delete.
     */
    where: WatchlistTweetWhereUniqueInput
  }

  /**
   * WatchlistTweet deleteMany
   */
  export type WatchlistTweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistTweets to delete
     */
    where?: WatchlistTweetWhereInput
  }

  /**
   * WatchlistTweet without action
   */
  export type WatchlistTweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistTweet
     */
    select?: WatchlistTweetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistTweetInclude<ExtArgs> | null
  }


  /**
   * Model InteractionHistory
   */

  export type AggregateInteractionHistory = {
    _count: InteractionHistoryCountAggregateOutputType | null
    _min: InteractionHistoryMinAggregateOutputType | null
    _max: InteractionHistoryMaxAggregateOutputType | null
  }

  export type InteractionHistoryMinAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    interactionType: string | null
    tweetId: string | null
    createdAt: Date | null
  }

  export type InteractionHistoryMaxAggregateOutputType = {
    id: string | null
    watchlistUserId: string | null
    interactionType: string | null
    tweetId: string | null
    createdAt: Date | null
  }

  export type InteractionHistoryCountAggregateOutputType = {
    id: number
    watchlistUserId: number
    interactionType: number
    tweetId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type InteractionHistoryMinAggregateInputType = {
    id?: true
    watchlistUserId?: true
    interactionType?: true
    tweetId?: true
    createdAt?: true
  }

  export type InteractionHistoryMaxAggregateInputType = {
    id?: true
    watchlistUserId?: true
    interactionType?: true
    tweetId?: true
    createdAt?: true
  }

  export type InteractionHistoryCountAggregateInputType = {
    id?: true
    watchlistUserId?: true
    interactionType?: true
    tweetId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type InteractionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionHistory to aggregate.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InteractionHistories
    **/
    _count?: true | InteractionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionHistoryMaxAggregateInputType
  }

  export type GetInteractionHistoryAggregateType<T extends InteractionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInteractionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteractionHistory[P]>
      : GetScalarType<T[P], AggregateInteractionHistory[P]>
  }




  export type InteractionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionHistoryWhereInput
    orderBy?: InteractionHistoryOrderByWithAggregationInput | InteractionHistoryOrderByWithAggregationInput[]
    by: InteractionHistoryScalarFieldEnum[] | InteractionHistoryScalarFieldEnum
    having?: InteractionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionHistoryCountAggregateInputType | true
    _min?: InteractionHistoryMinAggregateInputType
    _max?: InteractionHistoryMaxAggregateInputType
  }

  export type InteractionHistoryGroupByOutputType = {
    id: string
    watchlistUserId: string
    interactionType: string
    tweetId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: InteractionHistoryCountAggregateOutputType | null
    _min: InteractionHistoryMinAggregateOutputType | null
    _max: InteractionHistoryMaxAggregateOutputType | null
  }

  type GetInteractionHistoryGroupByPayload<T extends InteractionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type InteractionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    interactionType?: boolean
    tweetId?: boolean
    metadata?: boolean
    createdAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistUserId?: boolean
    interactionType?: boolean
    tweetId?: boolean
    metadata?: boolean
    createdAt?: boolean
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionHistory"]>

  export type InteractionHistorySelectScalar = {
    id?: boolean
    watchlistUserId?: boolean
    interactionType?: boolean
    tweetId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type InteractionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }
  export type InteractionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlistUser?: boolean | WatchlistUserDefaultArgs<ExtArgs>
  }

  export type $InteractionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InteractionHistory"
    objects: {
      watchlistUser: Prisma.$WatchlistUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      watchlistUserId: string
      interactionType: string
      tweetId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["interactionHistory"]>
    composites: {}
  }

  type InteractionHistoryGetPayload<S extends boolean | null | undefined | InteractionHistoryDefaultArgs> = $Result.GetResult<Prisma.$InteractionHistoryPayload, S>

  type InteractionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InteractionHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InteractionHistoryCountAggregateInputType | true
    }

  export interface InteractionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InteractionHistory'], meta: { name: 'InteractionHistory' } }
    /**
     * Find zero or one InteractionHistory that matches the filter.
     * @param {InteractionHistoryFindUniqueArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionHistoryFindUniqueArgs>(args: SelectSubset<T, InteractionHistoryFindUniqueArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InteractionHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InteractionHistoryFindUniqueOrThrowArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InteractionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindFirstArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionHistoryFindFirstArgs>(args?: SelectSubset<T, InteractionHistoryFindFirstArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InteractionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindFirstOrThrowArgs} args - Arguments to find a InteractionHistory
     * @example
     * // Get one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InteractionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InteractionHistories
     * const interactionHistories = await prisma.interactionHistory.findMany()
     * 
     * // Get first 10 InteractionHistories
     * const interactionHistories = await prisma.interactionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionHistoryFindManyArgs>(args?: SelectSubset<T, InteractionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InteractionHistory.
     * @param {InteractionHistoryCreateArgs} args - Arguments to create a InteractionHistory.
     * @example
     * // Create one InteractionHistory
     * const InteractionHistory = await prisma.interactionHistory.create({
     *   data: {
     *     // ... data to create a InteractionHistory
     *   }
     * })
     * 
     */
    create<T extends InteractionHistoryCreateArgs>(args: SelectSubset<T, InteractionHistoryCreateArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InteractionHistories.
     * @param {InteractionHistoryCreateManyArgs} args - Arguments to create many InteractionHistories.
     * @example
     * // Create many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionHistoryCreateManyArgs>(args?: SelectSubset<T, InteractionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InteractionHistories and returns the data saved in the database.
     * @param {InteractionHistoryCreateManyAndReturnArgs} args - Arguments to create many InteractionHistories.
     * @example
     * // Create many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InteractionHistories and only return the `id`
     * const interactionHistoryWithIdOnly = await prisma.interactionHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InteractionHistory.
     * @param {InteractionHistoryDeleteArgs} args - Arguments to delete one InteractionHistory.
     * @example
     * // Delete one InteractionHistory
     * const InteractionHistory = await prisma.interactionHistory.delete({
     *   where: {
     *     // ... filter to delete one InteractionHistory
     *   }
     * })
     * 
     */
    delete<T extends InteractionHistoryDeleteArgs>(args: SelectSubset<T, InteractionHistoryDeleteArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InteractionHistory.
     * @param {InteractionHistoryUpdateArgs} args - Arguments to update one InteractionHistory.
     * @example
     * // Update one InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionHistoryUpdateArgs>(args: SelectSubset<T, InteractionHistoryUpdateArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InteractionHistories.
     * @param {InteractionHistoryDeleteManyArgs} args - Arguments to filter InteractionHistories to delete.
     * @example
     * // Delete a few InteractionHistories
     * const { count } = await prisma.interactionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionHistoryDeleteManyArgs>(args?: SelectSubset<T, InteractionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InteractionHistories
     * const interactionHistory = await prisma.interactionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionHistoryUpdateManyArgs>(args: SelectSubset<T, InteractionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InteractionHistory.
     * @param {InteractionHistoryUpsertArgs} args - Arguments to update or create a InteractionHistory.
     * @example
     * // Update or create a InteractionHistory
     * const interactionHistory = await prisma.interactionHistory.upsert({
     *   create: {
     *     // ... data to create a InteractionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InteractionHistory we want to update
     *   }
     * })
     */
    upsert<T extends InteractionHistoryUpsertArgs>(args: SelectSubset<T, InteractionHistoryUpsertArgs<ExtArgs>>): Prisma__InteractionHistoryClient<$Result.GetResult<Prisma.$InteractionHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InteractionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryCountArgs} args - Arguments to filter InteractionHistories to count.
     * @example
     * // Count the number of InteractionHistories
     * const count = await prisma.interactionHistory.count({
     *   where: {
     *     // ... the filter for the InteractionHistories we want to count
     *   }
     * })
    **/
    count<T extends InteractionHistoryCountArgs>(
      args?: Subset<T, InteractionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InteractionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionHistoryAggregateArgs>(args: Subset<T, InteractionHistoryAggregateArgs>): Prisma.PrismaPromise<GetInteractionHistoryAggregateType<T>>

    /**
     * Group by InteractionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: InteractionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InteractionHistory model
   */
  readonly fields: InteractionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InteractionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlistUser<T extends WatchlistUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistUserDefaultArgs<ExtArgs>>): Prisma__WatchlistUserClient<$Result.GetResult<Prisma.$WatchlistUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InteractionHistory model
   */ 
  interface InteractionHistoryFieldRefs {
    readonly id: FieldRef<"InteractionHistory", 'String'>
    readonly watchlistUserId: FieldRef<"InteractionHistory", 'String'>
    readonly interactionType: FieldRef<"InteractionHistory", 'String'>
    readonly tweetId: FieldRef<"InteractionHistory", 'String'>
    readonly metadata: FieldRef<"InteractionHistory", 'Json'>
    readonly createdAt: FieldRef<"InteractionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InteractionHistory findUnique
   */
  export type InteractionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory findUniqueOrThrow
   */
  export type InteractionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory findFirst
   */
  export type InteractionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionHistories.
     */
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory findFirstOrThrow
   */
  export type InteractionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistory to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionHistories.
     */
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory findMany
   */
  export type InteractionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InteractionHistories to fetch.
     */
    where?: InteractionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionHistories to fetch.
     */
    orderBy?: InteractionHistoryOrderByWithRelationInput | InteractionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InteractionHistories.
     */
    cursor?: InteractionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionHistories.
     */
    skip?: number
    distinct?: InteractionHistoryScalarFieldEnum | InteractionHistoryScalarFieldEnum[]
  }

  /**
   * InteractionHistory create
   */
  export type InteractionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a InteractionHistory.
     */
    data: XOR<InteractionHistoryCreateInput, InteractionHistoryUncheckedCreateInput>
  }

  /**
   * InteractionHistory createMany
   */
  export type InteractionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InteractionHistories.
     */
    data: InteractionHistoryCreateManyInput | InteractionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InteractionHistory createManyAndReturn
   */
  export type InteractionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InteractionHistories.
     */
    data: InteractionHistoryCreateManyInput | InteractionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteractionHistory update
   */
  export type InteractionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a InteractionHistory.
     */
    data: XOR<InteractionHistoryUpdateInput, InteractionHistoryUncheckedUpdateInput>
    /**
     * Choose, which InteractionHistory to update.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory updateMany
   */
  export type InteractionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InteractionHistories.
     */
    data: XOR<InteractionHistoryUpdateManyMutationInput, InteractionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InteractionHistories to update
     */
    where?: InteractionHistoryWhereInput
  }

  /**
   * InteractionHistory upsert
   */
  export type InteractionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the InteractionHistory to update in case it exists.
     */
    where: InteractionHistoryWhereUniqueInput
    /**
     * In case the InteractionHistory found by the `where` argument doesn't exist, create a new InteractionHistory with this data.
     */
    create: XOR<InteractionHistoryCreateInput, InteractionHistoryUncheckedCreateInput>
    /**
     * In case the InteractionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionHistoryUpdateInput, InteractionHistoryUncheckedUpdateInput>
  }

  /**
   * InteractionHistory delete
   */
  export type InteractionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
    /**
     * Filter which InteractionHistory to delete.
     */
    where: InteractionHistoryWhereUniqueInput
  }

  /**
   * InteractionHistory deleteMany
   */
  export type InteractionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionHistories to delete
     */
    where?: InteractionHistoryWhereInput
  }

  /**
   * InteractionHistory without action
   */
  export type InteractionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionHistory
     */
    select?: InteractionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PerplexityReport
   */

  export type AggregatePerplexityReport = {
    _count: PerplexityReportCountAggregateOutputType | null
    _min: PerplexityReportMinAggregateOutputType | null
    _max: PerplexityReportMaxAggregateOutputType | null
  }

  export type PerplexityReportMinAggregateOutputType = {
    id: string | null
    query: string | null
    focus: string | null
    rawAnalysis: string | null
    createdAt: Date | null
  }

  export type PerplexityReportMaxAggregateOutputType = {
    id: string | null
    query: string | null
    focus: string | null
    rawAnalysis: string | null
    createdAt: Date | null
  }

  export type PerplexityReportCountAggregateOutputType = {
    id: number
    query: number
    focus: number
    rawAnalysis: number
    trends: number
    insights: number
    contentAngles: number
    marketContext: number
    competitorActivity: number
    riskFactors: number
    createdAt: number
    _all: number
  }


  export type PerplexityReportMinAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    createdAt?: true
  }

  export type PerplexityReportMaxAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    createdAt?: true
  }

  export type PerplexityReportCountAggregateInputType = {
    id?: true
    query?: true
    focus?: true
    rawAnalysis?: true
    trends?: true
    insights?: true
    contentAngles?: true
    marketContext?: true
    competitorActivity?: true
    riskFactors?: true
    createdAt?: true
    _all?: true
  }

  export type PerplexityReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerplexityReport to aggregate.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerplexityReports
    **/
    _count?: true | PerplexityReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerplexityReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerplexityReportMaxAggregateInputType
  }

  export type GetPerplexityReportAggregateType<T extends PerplexityReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePerplexityReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerplexityReport[P]>
      : GetScalarType<T[P], AggregatePerplexityReport[P]>
  }




  export type PerplexityReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerplexityReportWhereInput
    orderBy?: PerplexityReportOrderByWithAggregationInput | PerplexityReportOrderByWithAggregationInput[]
    by: PerplexityReportScalarFieldEnum[] | PerplexityReportScalarFieldEnum
    having?: PerplexityReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerplexityReportCountAggregateInputType | true
    _min?: PerplexityReportMinAggregateInputType
    _max?: PerplexityReportMaxAggregateInputType
  }

  export type PerplexityReportGroupByOutputType = {
    id: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonValue
    insights: JsonValue
    contentAngles: JsonValue
    marketContext: JsonValue
    competitorActivity: JsonValue
    riskFactors: JsonValue
    createdAt: Date
    _count: PerplexityReportCountAggregateOutputType | null
    _min: PerplexityReportMinAggregateOutputType | null
    _max: PerplexityReportMaxAggregateOutputType | null
  }

  type GetPerplexityReportGroupByPayload<T extends PerplexityReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerplexityReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerplexityReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerplexityReportGroupByOutputType[P]>
            : GetScalarType<T[P], PerplexityReportGroupByOutputType[P]>
        }
      >
    >


  export type PerplexityReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    contentAngles?: boolean
    marketContext?: boolean
    competitorActivity?: boolean
    riskFactors?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    contentAngles?: boolean
    marketContext?: boolean
    competitorActivity?: boolean
    riskFactors?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["perplexityReport"]>

  export type PerplexityReportSelectScalar = {
    id?: boolean
    query?: boolean
    focus?: boolean
    rawAnalysis?: boolean
    trends?: boolean
    insights?: boolean
    contentAngles?: boolean
    marketContext?: boolean
    competitorActivity?: boolean
    riskFactors?: boolean
    createdAt?: boolean
  }


  export type $PerplexityReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerplexityReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      focus: string
      rawAnalysis: string
      trends: Prisma.JsonValue
      insights: Prisma.JsonValue
      contentAngles: Prisma.JsonValue
      marketContext: Prisma.JsonValue
      competitorActivity: Prisma.JsonValue
      riskFactors: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["perplexityReport"]>
    composites: {}
  }

  type PerplexityReportGetPayload<S extends boolean | null | undefined | PerplexityReportDefaultArgs> = $Result.GetResult<Prisma.$PerplexityReportPayload, S>

  type PerplexityReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerplexityReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerplexityReportCountAggregateInputType | true
    }

  export interface PerplexityReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerplexityReport'], meta: { name: 'PerplexityReport' } }
    /**
     * Find zero or one PerplexityReport that matches the filter.
     * @param {PerplexityReportFindUniqueArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerplexityReportFindUniqueArgs>(args: SelectSubset<T, PerplexityReportFindUniqueArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerplexityReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerplexityReportFindUniqueOrThrowArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerplexityReportFindUniqueOrThrowArgs>(args: SelectSubset<T, PerplexityReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerplexityReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindFirstArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerplexityReportFindFirstArgs>(args?: SelectSubset<T, PerplexityReportFindFirstArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerplexityReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindFirstOrThrowArgs} args - Arguments to find a PerplexityReport
     * @example
     * // Get one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerplexityReportFindFirstOrThrowArgs>(args?: SelectSubset<T, PerplexityReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerplexityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerplexityReports
     * const perplexityReports = await prisma.perplexityReport.findMany()
     * 
     * // Get first 10 PerplexityReports
     * const perplexityReports = await prisma.perplexityReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerplexityReportFindManyArgs>(args?: SelectSubset<T, PerplexityReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerplexityReport.
     * @param {PerplexityReportCreateArgs} args - Arguments to create a PerplexityReport.
     * @example
     * // Create one PerplexityReport
     * const PerplexityReport = await prisma.perplexityReport.create({
     *   data: {
     *     // ... data to create a PerplexityReport
     *   }
     * })
     * 
     */
    create<T extends PerplexityReportCreateArgs>(args: SelectSubset<T, PerplexityReportCreateArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerplexityReports.
     * @param {PerplexityReportCreateManyArgs} args - Arguments to create many PerplexityReports.
     * @example
     * // Create many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerplexityReportCreateManyArgs>(args?: SelectSubset<T, PerplexityReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerplexityReports and returns the data saved in the database.
     * @param {PerplexityReportCreateManyAndReturnArgs} args - Arguments to create many PerplexityReports.
     * @example
     * // Create many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerplexityReports and only return the `id`
     * const perplexityReportWithIdOnly = await prisma.perplexityReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerplexityReportCreateManyAndReturnArgs>(args?: SelectSubset<T, PerplexityReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerplexityReport.
     * @param {PerplexityReportDeleteArgs} args - Arguments to delete one PerplexityReport.
     * @example
     * // Delete one PerplexityReport
     * const PerplexityReport = await prisma.perplexityReport.delete({
     *   where: {
     *     // ... filter to delete one PerplexityReport
     *   }
     * })
     * 
     */
    delete<T extends PerplexityReportDeleteArgs>(args: SelectSubset<T, PerplexityReportDeleteArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerplexityReport.
     * @param {PerplexityReportUpdateArgs} args - Arguments to update one PerplexityReport.
     * @example
     * // Update one PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerplexityReportUpdateArgs>(args: SelectSubset<T, PerplexityReportUpdateArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerplexityReports.
     * @param {PerplexityReportDeleteManyArgs} args - Arguments to filter PerplexityReports to delete.
     * @example
     * // Delete a few PerplexityReports
     * const { count } = await prisma.perplexityReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerplexityReportDeleteManyArgs>(args?: SelectSubset<T, PerplexityReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerplexityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerplexityReports
     * const perplexityReport = await prisma.perplexityReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerplexityReportUpdateManyArgs>(args: SelectSubset<T, PerplexityReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerplexityReport.
     * @param {PerplexityReportUpsertArgs} args - Arguments to update or create a PerplexityReport.
     * @example
     * // Update or create a PerplexityReport
     * const perplexityReport = await prisma.perplexityReport.upsert({
     *   create: {
     *     // ... data to create a PerplexityReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerplexityReport we want to update
     *   }
     * })
     */
    upsert<T extends PerplexityReportUpsertArgs>(args: SelectSubset<T, PerplexityReportUpsertArgs<ExtArgs>>): Prisma__PerplexityReportClient<$Result.GetResult<Prisma.$PerplexityReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerplexityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportCountArgs} args - Arguments to filter PerplexityReports to count.
     * @example
     * // Count the number of PerplexityReports
     * const count = await prisma.perplexityReport.count({
     *   where: {
     *     // ... the filter for the PerplexityReports we want to count
     *   }
     * })
    **/
    count<T extends PerplexityReportCountArgs>(
      args?: Subset<T, PerplexityReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerplexityReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerplexityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerplexityReportAggregateArgs>(args: Subset<T, PerplexityReportAggregateArgs>): Prisma.PrismaPromise<GetPerplexityReportAggregateType<T>>

    /**
     * Group by PerplexityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerplexityReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerplexityReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerplexityReportGroupByArgs['orderBy'] }
        : { orderBy?: PerplexityReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerplexityReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerplexityReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerplexityReport model
   */
  readonly fields: PerplexityReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerplexityReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerplexityReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerplexityReport model
   */ 
  interface PerplexityReportFieldRefs {
    readonly id: FieldRef<"PerplexityReport", 'String'>
    readonly query: FieldRef<"PerplexityReport", 'String'>
    readonly focus: FieldRef<"PerplexityReport", 'String'>
    readonly rawAnalysis: FieldRef<"PerplexityReport", 'String'>
    readonly trends: FieldRef<"PerplexityReport", 'Json'>
    readonly insights: FieldRef<"PerplexityReport", 'Json'>
    readonly contentAngles: FieldRef<"PerplexityReport", 'Json'>
    readonly marketContext: FieldRef<"PerplexityReport", 'Json'>
    readonly competitorActivity: FieldRef<"PerplexityReport", 'Json'>
    readonly riskFactors: FieldRef<"PerplexityReport", 'Json'>
    readonly createdAt: FieldRef<"PerplexityReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerplexityReport findUnique
   */
  export type PerplexityReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport findUniqueOrThrow
   */
  export type PerplexityReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport findFirst
   */
  export type PerplexityReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerplexityReports.
     */
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport findFirstOrThrow
   */
  export type PerplexityReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReport to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerplexityReports.
     */
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport findMany
   */
  export type PerplexityReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter, which PerplexityReports to fetch.
     */
    where?: PerplexityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerplexityReports to fetch.
     */
    orderBy?: PerplexityReportOrderByWithRelationInput | PerplexityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerplexityReports.
     */
    cursor?: PerplexityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerplexityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerplexityReports.
     */
    skip?: number
    distinct?: PerplexityReportScalarFieldEnum | PerplexityReportScalarFieldEnum[]
  }

  /**
   * PerplexityReport create
   */
  export type PerplexityReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * The data needed to create a PerplexityReport.
     */
    data: XOR<PerplexityReportCreateInput, PerplexityReportUncheckedCreateInput>
  }

  /**
   * PerplexityReport createMany
   */
  export type PerplexityReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerplexityReports.
     */
    data: PerplexityReportCreateManyInput | PerplexityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerplexityReport createManyAndReturn
   */
  export type PerplexityReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerplexityReports.
     */
    data: PerplexityReportCreateManyInput | PerplexityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerplexityReport update
   */
  export type PerplexityReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * The data needed to update a PerplexityReport.
     */
    data: XOR<PerplexityReportUpdateInput, PerplexityReportUncheckedUpdateInput>
    /**
     * Choose, which PerplexityReport to update.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport updateMany
   */
  export type PerplexityReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerplexityReports.
     */
    data: XOR<PerplexityReportUpdateManyMutationInput, PerplexityReportUncheckedUpdateManyInput>
    /**
     * Filter which PerplexityReports to update
     */
    where?: PerplexityReportWhereInput
  }

  /**
   * PerplexityReport upsert
   */
  export type PerplexityReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * The filter to search for the PerplexityReport to update in case it exists.
     */
    where: PerplexityReportWhereUniqueInput
    /**
     * In case the PerplexityReport found by the `where` argument doesn't exist, create a new PerplexityReport with this data.
     */
    create: XOR<PerplexityReportCreateInput, PerplexityReportUncheckedCreateInput>
    /**
     * In case the PerplexityReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerplexityReportUpdateInput, PerplexityReportUncheckedUpdateInput>
  }

  /**
   * PerplexityReport delete
   */
  export type PerplexityReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
    /**
     * Filter which PerplexityReport to delete.
     */
    where: PerplexityReportWhereUniqueInput
  }

  /**
   * PerplexityReport deleteMany
   */
  export type PerplexityReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerplexityReports to delete
     */
    where?: PerplexityReportWhereInput
  }

  /**
   * PerplexityReport without action
   */
  export type PerplexityReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerplexityReport
     */
    select?: PerplexityReportSelect<ExtArgs> | null
  }


  /**
   * Model CotSession
   */

  export type AggregateCotSession = {
    _count: CotSessionCountAggregateOutputType | null
    _avg: CotSessionAvgAggregateOutputType | null
    _sum: CotSessionSumAggregateOutputType | null
    _min: CotSessionMinAggregateOutputType | null
    _max: CotSessionMaxAggregateOutputType | null
  }

  export type CotSessionAvgAggregateOutputType = {
    currentPhase: number | null
    retryCount: number | null
    totalTokens: number | null
    totalDuration: number | null
  }

  export type CotSessionSumAggregateOutputType = {
    currentPhase: number | null
    retryCount: number | null
    totalTokens: number | null
    totalDuration: number | null
  }

  export type CotSessionMinAggregateOutputType = {
    id: string | null
    expertise: string | null
    style: string | null
    platform: string | null
    status: $Enums.CotSessionStatus | null
    currentPhase: number | null
    currentStep: $Enums.CotPhaseStep | null
    lastError: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    totalTokens: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type CotSessionMaxAggregateOutputType = {
    id: string | null
    expertise: string | null
    style: string | null
    platform: string | null
    status: $Enums.CotSessionStatus | null
    currentPhase: number | null
    currentStep: $Enums.CotPhaseStep | null
    lastError: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    totalTokens: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type CotSessionCountAggregateOutputType = {
    id: number
    expertise: number
    style: number
    platform: number
    status: number
    currentPhase: number
    currentStep: number
    lastError: number
    retryCount: number
    nextRetryAt: number
    totalTokens: number
    totalDuration: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type CotSessionAvgAggregateInputType = {
    currentPhase?: true
    retryCount?: true
    totalTokens?: true
    totalDuration?: true
  }

  export type CotSessionSumAggregateInputType = {
    currentPhase?: true
    retryCount?: true
    totalTokens?: true
    totalDuration?: true
  }

  export type CotSessionMinAggregateInputType = {
    id?: true
    expertise?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type CotSessionMaxAggregateInputType = {
    id?: true
    expertise?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type CotSessionCountAggregateInputType = {
    id?: true
    expertise?: true
    style?: true
    platform?: true
    status?: true
    currentPhase?: true
    currentStep?: true
    lastError?: true
    retryCount?: true
    nextRetryAt?: true
    totalTokens?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type CotSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotSession to aggregate.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotSessions
    **/
    _count?: true | CotSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotSessionMaxAggregateInputType
  }

  export type GetCotSessionAggregateType<T extends CotSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCotSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotSession[P]>
      : GetScalarType<T[P], AggregateCotSession[P]>
  }




  export type CotSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotSessionWhereInput
    orderBy?: CotSessionOrderByWithAggregationInput | CotSessionOrderByWithAggregationInput[]
    by: CotSessionScalarFieldEnum[] | CotSessionScalarFieldEnum
    having?: CotSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotSessionCountAggregateInputType | true
    _avg?: CotSessionAvgAggregateInputType
    _sum?: CotSessionSumAggregateInputType
    _min?: CotSessionMinAggregateInputType
    _max?: CotSessionMaxAggregateInputType
  }

  export type CotSessionGroupByOutputType = {
    id: string
    expertise: string
    style: string
    platform: string
    status: $Enums.CotSessionStatus
    currentPhase: number
    currentStep: $Enums.CotPhaseStep
    lastError: string | null
    retryCount: number
    nextRetryAt: Date | null
    totalTokens: number
    totalDuration: number
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: CotSessionCountAggregateOutputType | null
    _avg: CotSessionAvgAggregateOutputType | null
    _sum: CotSessionSumAggregateOutputType | null
    _min: CotSessionMinAggregateOutputType | null
    _max: CotSessionMaxAggregateOutputType | null
  }

  type GetCotSessionGroupByPayload<T extends CotSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CotSessionGroupByOutputType[P]>
        }
      >
    >


  export type CotSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expertise?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    phases?: boolean | CotSession$phasesArgs<ExtArgs>
    drafts?: boolean | CotSession$draftsArgs<ExtArgs>
    _count?: boolean | CotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expertise?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["cotSession"]>

  export type CotSessionSelectScalar = {
    id?: boolean
    expertise?: boolean
    style?: boolean
    platform?: boolean
    status?: boolean
    currentPhase?: boolean
    currentStep?: boolean
    lastError?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    totalTokens?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type CotSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | CotSession$phasesArgs<ExtArgs>
    drafts?: boolean | CotSession$draftsArgs<ExtArgs>
    _count?: boolean | CotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CotSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CotSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotSession"
    objects: {
      phases: Prisma.$CotPhasePayload<ExtArgs>[]
      drafts: Prisma.$CotDraftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expertise: string
      style: string
      platform: string
      status: $Enums.CotSessionStatus
      currentPhase: number
      currentStep: $Enums.CotPhaseStep
      lastError: string | null
      retryCount: number
      nextRetryAt: Date | null
      totalTokens: number
      totalDuration: number
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["cotSession"]>
    composites: {}
  }

  type CotSessionGetPayload<S extends boolean | null | undefined | CotSessionDefaultArgs> = $Result.GetResult<Prisma.$CotSessionPayload, S>

  type CotSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotSessionCountAggregateInputType | true
    }

  export interface CotSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotSession'], meta: { name: 'CotSession' } }
    /**
     * Find zero or one CotSession that matches the filter.
     * @param {CotSessionFindUniqueArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotSessionFindUniqueArgs>(args: SelectSubset<T, CotSessionFindUniqueArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotSessionFindUniqueOrThrowArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CotSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindFirstArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotSessionFindFirstArgs>(args?: SelectSubset<T, CotSessionFindFirstArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindFirstOrThrowArgs} args - Arguments to find a CotSession
     * @example
     * // Get one CotSession
     * const cotSession = await prisma.cotSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CotSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotSessions
     * const cotSessions = await prisma.cotSession.findMany()
     * 
     * // Get first 10 CotSessions
     * const cotSessions = await prisma.cotSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotSessionFindManyArgs>(args?: SelectSubset<T, CotSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotSession.
     * @param {CotSessionCreateArgs} args - Arguments to create a CotSession.
     * @example
     * // Create one CotSession
     * const CotSession = await prisma.cotSession.create({
     *   data: {
     *     // ... data to create a CotSession
     *   }
     * })
     * 
     */
    create<T extends CotSessionCreateArgs>(args: SelectSubset<T, CotSessionCreateArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotSessions.
     * @param {CotSessionCreateManyArgs} args - Arguments to create many CotSessions.
     * @example
     * // Create many CotSessions
     * const cotSession = await prisma.cotSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotSessionCreateManyArgs>(args?: SelectSubset<T, CotSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotSessions and returns the data saved in the database.
     * @param {CotSessionCreateManyAndReturnArgs} args - Arguments to create many CotSessions.
     * @example
     * // Create many CotSessions
     * const cotSession = await prisma.cotSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotSessions and only return the `id`
     * const cotSessionWithIdOnly = await prisma.cotSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CotSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotSession.
     * @param {CotSessionDeleteArgs} args - Arguments to delete one CotSession.
     * @example
     * // Delete one CotSession
     * const CotSession = await prisma.cotSession.delete({
     *   where: {
     *     // ... filter to delete one CotSession
     *   }
     * })
     * 
     */
    delete<T extends CotSessionDeleteArgs>(args: SelectSubset<T, CotSessionDeleteArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotSession.
     * @param {CotSessionUpdateArgs} args - Arguments to update one CotSession.
     * @example
     * // Update one CotSession
     * const cotSession = await prisma.cotSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotSessionUpdateArgs>(args: SelectSubset<T, CotSessionUpdateArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotSessions.
     * @param {CotSessionDeleteManyArgs} args - Arguments to filter CotSessions to delete.
     * @example
     * // Delete a few CotSessions
     * const { count } = await prisma.cotSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotSessionDeleteManyArgs>(args?: SelectSubset<T, CotSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotSessions
     * const cotSession = await prisma.cotSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotSessionUpdateManyArgs>(args: SelectSubset<T, CotSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotSession.
     * @param {CotSessionUpsertArgs} args - Arguments to update or create a CotSession.
     * @example
     * // Update or create a CotSession
     * const cotSession = await prisma.cotSession.upsert({
     *   create: {
     *     // ... data to create a CotSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotSession we want to update
     *   }
     * })
     */
    upsert<T extends CotSessionUpsertArgs>(args: SelectSubset<T, CotSessionUpsertArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionCountArgs} args - Arguments to filter CotSessions to count.
     * @example
     * // Count the number of CotSessions
     * const count = await prisma.cotSession.count({
     *   where: {
     *     // ... the filter for the CotSessions we want to count
     *   }
     * })
    **/
    count<T extends CotSessionCountArgs>(
      args?: Subset<T, CotSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotSessionAggregateArgs>(args: Subset<T, CotSessionAggregateArgs>): Prisma.PrismaPromise<GetCotSessionAggregateType<T>>

    /**
     * Group by CotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotSessionGroupByArgs['orderBy'] }
        : { orderBy?: CotSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotSession model
   */
  readonly fields: CotSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phases<T extends CotSession$phasesArgs<ExtArgs> = {}>(args?: Subset<T, CotSession$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findMany"> | Null>
    drafts<T extends CotSession$draftsArgs<ExtArgs> = {}>(args?: Subset<T, CotSession$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotSession model
   */ 
  interface CotSessionFieldRefs {
    readonly id: FieldRef<"CotSession", 'String'>
    readonly expertise: FieldRef<"CotSession", 'String'>
    readonly style: FieldRef<"CotSession", 'String'>
    readonly platform: FieldRef<"CotSession", 'String'>
    readonly status: FieldRef<"CotSession", 'CotSessionStatus'>
    readonly currentPhase: FieldRef<"CotSession", 'Int'>
    readonly currentStep: FieldRef<"CotSession", 'CotPhaseStep'>
    readonly lastError: FieldRef<"CotSession", 'String'>
    readonly retryCount: FieldRef<"CotSession", 'Int'>
    readonly nextRetryAt: FieldRef<"CotSession", 'DateTime'>
    readonly totalTokens: FieldRef<"CotSession", 'Int'>
    readonly totalDuration: FieldRef<"CotSession", 'Int'>
    readonly createdAt: FieldRef<"CotSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CotSession", 'DateTime'>
    readonly completedAt: FieldRef<"CotSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotSession findUnique
   */
  export type CotSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession findUniqueOrThrow
   */
  export type CotSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession findFirst
   */
  export type CotSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotSessions.
     */
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession findFirstOrThrow
   */
  export type CotSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSession to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotSessions.
     */
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession findMany
   */
  export type CotSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter, which CotSessions to fetch.
     */
    where?: CotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotSessions to fetch.
     */
    orderBy?: CotSessionOrderByWithRelationInput | CotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotSessions.
     */
    cursor?: CotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotSessions.
     */
    skip?: number
    distinct?: CotSessionScalarFieldEnum | CotSessionScalarFieldEnum[]
  }

  /**
   * CotSession create
   */
  export type CotSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CotSession.
     */
    data: XOR<CotSessionCreateInput, CotSessionUncheckedCreateInput>
  }

  /**
   * CotSession createMany
   */
  export type CotSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotSessions.
     */
    data: CotSessionCreateManyInput | CotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotSession createManyAndReturn
   */
  export type CotSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotSessions.
     */
    data: CotSessionCreateManyInput | CotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotSession update
   */
  export type CotSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CotSession.
     */
    data: XOR<CotSessionUpdateInput, CotSessionUncheckedUpdateInput>
    /**
     * Choose, which CotSession to update.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession updateMany
   */
  export type CotSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotSessions.
     */
    data: XOR<CotSessionUpdateManyMutationInput, CotSessionUncheckedUpdateManyInput>
    /**
     * Filter which CotSessions to update
     */
    where?: CotSessionWhereInput
  }

  /**
   * CotSession upsert
   */
  export type CotSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CotSession to update in case it exists.
     */
    where: CotSessionWhereUniqueInput
    /**
     * In case the CotSession found by the `where` argument doesn't exist, create a new CotSession with this data.
     */
    create: XOR<CotSessionCreateInput, CotSessionUncheckedCreateInput>
    /**
     * In case the CotSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotSessionUpdateInput, CotSessionUncheckedUpdateInput>
  }

  /**
   * CotSession delete
   */
  export type CotSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
    /**
     * Filter which CotSession to delete.
     */
    where: CotSessionWhereUniqueInput
  }

  /**
   * CotSession deleteMany
   */
  export type CotSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotSessions to delete
     */
    where?: CotSessionWhereInput
  }

  /**
   * CotSession.phases
   */
  export type CotSession$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    where?: CotPhaseWhereInput
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    cursor?: CotPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotSession.drafts
   */
  export type CotSession$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    where?: CotDraftWhereInput
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    cursor?: CotDraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotSession without action
   */
  export type CotSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotSession
     */
    select?: CotSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotSessionInclude<ExtArgs> | null
  }


  /**
   * Model CotPhase
   */

  export type AggregateCotPhase = {
    _count: CotPhaseCountAggregateOutputType | null
    _avg: CotPhaseAvgAggregateOutputType | null
    _sum: CotPhaseSumAggregateOutputType | null
    _min: CotPhaseMinAggregateOutputType | null
    _max: CotPhaseMaxAggregateOutputType | null
  }

  export type CotPhaseAvgAggregateOutputType = {
    phaseNumber: number | null
    thinkTokens: number | null
    executeDuration: number | null
    integrateTokens: number | null
  }

  export type CotPhaseSumAggregateOutputType = {
    phaseNumber: number | null
    thinkTokens: number | null
    executeDuration: number | null
    integrateTokens: number | null
  }

  export type CotPhaseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phaseNumber: number | null
    thinkPrompt: string | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotPhaseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phaseNumber: number | null
    thinkPrompt: string | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotPhaseCountAggregateOutputType = {
    id: number
    sessionId: number
    phaseNumber: number
    thinkPrompt: number
    thinkResult: number
    thinkTokens: number
    thinkAt: number
    executeResult: number
    executeDuration: number
    executeAt: number
    integratePrompt: number
    integrateResult: number
    integrateTokens: number
    integrateAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CotPhaseAvgAggregateInputType = {
    phaseNumber?: true
    thinkTokens?: true
    executeDuration?: true
    integrateTokens?: true
  }

  export type CotPhaseSumAggregateInputType = {
    phaseNumber?: true
    thinkTokens?: true
    executeDuration?: true
    integrateTokens?: true
  }

  export type CotPhaseMinAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkTokens?: true
    thinkAt?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotPhaseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkTokens?: true
    thinkAt?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotPhaseCountAggregateInputType = {
    id?: true
    sessionId?: true
    phaseNumber?: true
    thinkPrompt?: true
    thinkResult?: true
    thinkTokens?: true
    thinkAt?: true
    executeResult?: true
    executeDuration?: true
    executeAt?: true
    integratePrompt?: true
    integrateResult?: true
    integrateTokens?: true
    integrateAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CotPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotPhase to aggregate.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotPhases
    **/
    _count?: true | CotPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotPhaseMaxAggregateInputType
  }

  export type GetCotPhaseAggregateType<T extends CotPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCotPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotPhase[P]>
      : GetScalarType<T[P], AggregateCotPhase[P]>
  }




  export type CotPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotPhaseWhereInput
    orderBy?: CotPhaseOrderByWithAggregationInput | CotPhaseOrderByWithAggregationInput[]
    by: CotPhaseScalarFieldEnum[] | CotPhaseScalarFieldEnum
    having?: CotPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotPhaseCountAggregateInputType | true
    _avg?: CotPhaseAvgAggregateInputType
    _sum?: CotPhaseSumAggregateInputType
    _min?: CotPhaseMinAggregateInputType
    _max?: CotPhaseMaxAggregateInputType
  }

  export type CotPhaseGroupByOutputType = {
    id: string
    sessionId: string
    phaseNumber: number
    thinkPrompt: string | null
    thinkResult: JsonValue | null
    thinkTokens: number | null
    thinkAt: Date | null
    executeResult: JsonValue | null
    executeDuration: number | null
    executeAt: Date | null
    integratePrompt: string | null
    integrateResult: JsonValue | null
    integrateTokens: number | null
    integrateAt: Date | null
    status: $Enums.CotPhaseStatus
    createdAt: Date
    updatedAt: Date
    _count: CotPhaseCountAggregateOutputType | null
    _avg: CotPhaseAvgAggregateOutputType | null
    _sum: CotPhaseSumAggregateOutputType | null
    _min: CotPhaseMinAggregateOutputType | null
    _max: CotPhaseMaxAggregateOutputType | null
  }

  type GetCotPhaseGroupByPayload<T extends CotPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], CotPhaseGroupByOutputType[P]>
        }
      >
    >


  export type CotPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotPhase"]>

  export type CotPhaseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    phaseNumber?: boolean
    thinkPrompt?: boolean
    thinkResult?: boolean
    thinkTokens?: boolean
    thinkAt?: boolean
    executeResult?: boolean
    executeDuration?: boolean
    executeAt?: boolean
    integratePrompt?: boolean
    integrateResult?: boolean
    integrateTokens?: boolean
    integrateAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CotPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }
  export type CotPhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }

  export type $CotPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotPhase"
    objects: {
      session: Prisma.$CotSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      phaseNumber: number
      thinkPrompt: string | null
      thinkResult: Prisma.JsonValue | null
      thinkTokens: number | null
      thinkAt: Date | null
      executeResult: Prisma.JsonValue | null
      executeDuration: number | null
      executeAt: Date | null
      integratePrompt: string | null
      integrateResult: Prisma.JsonValue | null
      integrateTokens: number | null
      integrateAt: Date | null
      status: $Enums.CotPhaseStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cotPhase"]>
    composites: {}
  }

  type CotPhaseGetPayload<S extends boolean | null | undefined | CotPhaseDefaultArgs> = $Result.GetResult<Prisma.$CotPhasePayload, S>

  type CotPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotPhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotPhaseCountAggregateInputType | true
    }

  export interface CotPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotPhase'], meta: { name: 'CotPhase' } }
    /**
     * Find zero or one CotPhase that matches the filter.
     * @param {CotPhaseFindUniqueArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotPhaseFindUniqueArgs>(args: SelectSubset<T, CotPhaseFindUniqueArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotPhase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotPhaseFindUniqueOrThrowArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CotPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindFirstArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotPhaseFindFirstArgs>(args?: SelectSubset<T, CotPhaseFindFirstArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindFirstOrThrowArgs} args - Arguments to find a CotPhase
     * @example
     * // Get one CotPhase
     * const cotPhase = await prisma.cotPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CotPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotPhases
     * const cotPhases = await prisma.cotPhase.findMany()
     * 
     * // Get first 10 CotPhases
     * const cotPhases = await prisma.cotPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotPhaseFindManyArgs>(args?: SelectSubset<T, CotPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotPhase.
     * @param {CotPhaseCreateArgs} args - Arguments to create a CotPhase.
     * @example
     * // Create one CotPhase
     * const CotPhase = await prisma.cotPhase.create({
     *   data: {
     *     // ... data to create a CotPhase
     *   }
     * })
     * 
     */
    create<T extends CotPhaseCreateArgs>(args: SelectSubset<T, CotPhaseCreateArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotPhases.
     * @param {CotPhaseCreateManyArgs} args - Arguments to create many CotPhases.
     * @example
     * // Create many CotPhases
     * const cotPhase = await prisma.cotPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotPhaseCreateManyArgs>(args?: SelectSubset<T, CotPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotPhases and returns the data saved in the database.
     * @param {CotPhaseCreateManyAndReturnArgs} args - Arguments to create many CotPhases.
     * @example
     * // Create many CotPhases
     * const cotPhase = await prisma.cotPhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotPhases and only return the `id`
     * const cotPhaseWithIdOnly = await prisma.cotPhase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotPhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CotPhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotPhase.
     * @param {CotPhaseDeleteArgs} args - Arguments to delete one CotPhase.
     * @example
     * // Delete one CotPhase
     * const CotPhase = await prisma.cotPhase.delete({
     *   where: {
     *     // ... filter to delete one CotPhase
     *   }
     * })
     * 
     */
    delete<T extends CotPhaseDeleteArgs>(args: SelectSubset<T, CotPhaseDeleteArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotPhase.
     * @param {CotPhaseUpdateArgs} args - Arguments to update one CotPhase.
     * @example
     * // Update one CotPhase
     * const cotPhase = await prisma.cotPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotPhaseUpdateArgs>(args: SelectSubset<T, CotPhaseUpdateArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotPhases.
     * @param {CotPhaseDeleteManyArgs} args - Arguments to filter CotPhases to delete.
     * @example
     * // Delete a few CotPhases
     * const { count } = await prisma.cotPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotPhaseDeleteManyArgs>(args?: SelectSubset<T, CotPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotPhases
     * const cotPhase = await prisma.cotPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotPhaseUpdateManyArgs>(args: SelectSubset<T, CotPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotPhase.
     * @param {CotPhaseUpsertArgs} args - Arguments to update or create a CotPhase.
     * @example
     * // Update or create a CotPhase
     * const cotPhase = await prisma.cotPhase.upsert({
     *   create: {
     *     // ... data to create a CotPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotPhase we want to update
     *   }
     * })
     */
    upsert<T extends CotPhaseUpsertArgs>(args: SelectSubset<T, CotPhaseUpsertArgs<ExtArgs>>): Prisma__CotPhaseClient<$Result.GetResult<Prisma.$CotPhasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseCountArgs} args - Arguments to filter CotPhases to count.
     * @example
     * // Count the number of CotPhases
     * const count = await prisma.cotPhase.count({
     *   where: {
     *     // ... the filter for the CotPhases we want to count
     *   }
     * })
    **/
    count<T extends CotPhaseCountArgs>(
      args?: Subset<T, CotPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotPhaseAggregateArgs>(args: Subset<T, CotPhaseAggregateArgs>): Prisma.PrismaPromise<GetCotPhaseAggregateType<T>>

    /**
     * Group by CotPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotPhaseGroupByArgs['orderBy'] }
        : { orderBy?: CotPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotPhase model
   */
  readonly fields: CotPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotSessionDefaultArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotPhase model
   */ 
  interface CotPhaseFieldRefs {
    readonly id: FieldRef<"CotPhase", 'String'>
    readonly sessionId: FieldRef<"CotPhase", 'String'>
    readonly phaseNumber: FieldRef<"CotPhase", 'Int'>
    readonly thinkPrompt: FieldRef<"CotPhase", 'String'>
    readonly thinkResult: FieldRef<"CotPhase", 'Json'>
    readonly thinkTokens: FieldRef<"CotPhase", 'Int'>
    readonly thinkAt: FieldRef<"CotPhase", 'DateTime'>
    readonly executeResult: FieldRef<"CotPhase", 'Json'>
    readonly executeDuration: FieldRef<"CotPhase", 'Int'>
    readonly executeAt: FieldRef<"CotPhase", 'DateTime'>
    readonly integratePrompt: FieldRef<"CotPhase", 'String'>
    readonly integrateResult: FieldRef<"CotPhase", 'Json'>
    readonly integrateTokens: FieldRef<"CotPhase", 'Int'>
    readonly integrateAt: FieldRef<"CotPhase", 'DateTime'>
    readonly status: FieldRef<"CotPhase", 'CotPhaseStatus'>
    readonly createdAt: FieldRef<"CotPhase", 'DateTime'>
    readonly updatedAt: FieldRef<"CotPhase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotPhase findUnique
   */
  export type CotPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase findUniqueOrThrow
   */
  export type CotPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase findFirst
   */
  export type CotPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotPhases.
     */
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase findFirstOrThrow
   */
  export type CotPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhase to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotPhases.
     */
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase findMany
   */
  export type CotPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter, which CotPhases to fetch.
     */
    where?: CotPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotPhases to fetch.
     */
    orderBy?: CotPhaseOrderByWithRelationInput | CotPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotPhases.
     */
    cursor?: CotPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotPhases.
     */
    skip?: number
    distinct?: CotPhaseScalarFieldEnum | CotPhaseScalarFieldEnum[]
  }

  /**
   * CotPhase create
   */
  export type CotPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CotPhase.
     */
    data: XOR<CotPhaseCreateInput, CotPhaseUncheckedCreateInput>
  }

  /**
   * CotPhase createMany
   */
  export type CotPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotPhases.
     */
    data: CotPhaseCreateManyInput | CotPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotPhase createManyAndReturn
   */
  export type CotPhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotPhases.
     */
    data: CotPhaseCreateManyInput | CotPhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotPhase update
   */
  export type CotPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CotPhase.
     */
    data: XOR<CotPhaseUpdateInput, CotPhaseUncheckedUpdateInput>
    /**
     * Choose, which CotPhase to update.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase updateMany
   */
  export type CotPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotPhases.
     */
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyInput>
    /**
     * Filter which CotPhases to update
     */
    where?: CotPhaseWhereInput
  }

  /**
   * CotPhase upsert
   */
  export type CotPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CotPhase to update in case it exists.
     */
    where: CotPhaseWhereUniqueInput
    /**
     * In case the CotPhase found by the `where` argument doesn't exist, create a new CotPhase with this data.
     */
    create: XOR<CotPhaseCreateInput, CotPhaseUncheckedCreateInput>
    /**
     * In case the CotPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotPhaseUpdateInput, CotPhaseUncheckedUpdateInput>
  }

  /**
   * CotPhase delete
   */
  export type CotPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
    /**
     * Filter which CotPhase to delete.
     */
    where: CotPhaseWhereUniqueInput
  }

  /**
   * CotPhase deleteMany
   */
  export type CotPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotPhases to delete
     */
    where?: CotPhaseWhereInput
  }

  /**
   * CotPhase without action
   */
  export type CotPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotPhase
     */
    select?: CotPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotPhaseInclude<ExtArgs> | null
  }


  /**
   * Model CotDraft
   */

  export type AggregateCotDraft = {
    _count: CotDraftCountAggregateOutputType | null
    _avg: CotDraftAvgAggregateOutputType | null
    _sum: CotDraftSumAggregateOutputType | null
    _min: CotDraftMinAggregateOutputType | null
    _max: CotDraftMaxAggregateOutputType | null
  }

  export type CotDraftAvgAggregateOutputType = {
    conceptNumber: number | null
    viralScore: number | null
  }

  export type CotDraftSumAggregateOutputType = {
    conceptNumber: number | null
    viralScore: number | null
  }

  export type CotDraftMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptNumber: number | null
    title: string | null
    hook: string | null
    angle: string | null
    format: string | null
    content: string | null
    visualGuide: string | null
    timing: string | null
    newsSource: string | null
    sourceUrl: string | null
    status: $Enums.CotDraftStatus | null
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotDraftMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conceptNumber: number | null
    title: string | null
    hook: string | null
    angle: string | null
    format: string | null
    content: string | null
    visualGuide: string | null
    timing: string | null
    newsSource: string | null
    sourceUrl: string | null
    status: $Enums.CotDraftStatus | null
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CotDraftCountAggregateOutputType = {
    id: number
    sessionId: number
    conceptNumber: number
    title: number
    hook: number
    angle: number
    format: number
    content: number
    visualGuide: number
    timing: number
    hashtags: number
    newsSource: number
    sourceUrl: number
    kpis: number
    riskAssessment: number
    optimizationTips: number
    status: number
    editedContent: number
    scheduledAt: number
    postedAt: number
    postId: number
    viralScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CotDraftAvgAggregateInputType = {
    conceptNumber?: true
    viralScore?: true
  }

  export type CotDraftSumAggregateInputType = {
    conceptNumber?: true
    viralScore?: true
  }

  export type CotDraftMinAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    newsSource?: true
    sourceUrl?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotDraftMaxAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    newsSource?: true
    sourceUrl?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CotDraftCountAggregateInputType = {
    id?: true
    sessionId?: true
    conceptNumber?: true
    title?: true
    hook?: true
    angle?: true
    format?: true
    content?: true
    visualGuide?: true
    timing?: true
    hashtags?: true
    newsSource?: true
    sourceUrl?: true
    kpis?: true
    riskAssessment?: true
    optimizationTips?: true
    status?: true
    editedContent?: true
    scheduledAt?: true
    postedAt?: true
    postId?: true
    viralScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CotDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraft to aggregate.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotDrafts
    **/
    _count?: true | CotDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotDraftMaxAggregateInputType
  }

  export type GetCotDraftAggregateType<T extends CotDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateCotDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotDraft[P]>
      : GetScalarType<T[P], AggregateCotDraft[P]>
  }




  export type CotDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftWhereInput
    orderBy?: CotDraftOrderByWithAggregationInput | CotDraftOrderByWithAggregationInput[]
    by: CotDraftScalarFieldEnum[] | CotDraftScalarFieldEnum
    having?: CotDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotDraftCountAggregateInputType | true
    _avg?: CotDraftAvgAggregateInputType
    _sum?: CotDraftSumAggregateInputType
    _min?: CotDraftMinAggregateInputType
    _max?: CotDraftMaxAggregateInputType
  }

  export type CotDraftGroupByOutputType = {
    id: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content: string | null
    visualGuide: string | null
    timing: string
    hashtags: string[]
    newsSource: string | null
    sourceUrl: string | null
    kpis: JsonValue | null
    riskAssessment: JsonValue | null
    optimizationTips: JsonValue | null
    status: $Enums.CotDraftStatus
    editedContent: string | null
    scheduledAt: Date | null
    postedAt: Date | null
    postId: string | null
    viralScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: CotDraftCountAggregateOutputType | null
    _avg: CotDraftAvgAggregateOutputType | null
    _sum: CotDraftSumAggregateOutputType | null
    _min: CotDraftMinAggregateOutputType | null
    _max: CotDraftMaxAggregateOutputType | null
  }

  type GetCotDraftGroupByPayload<T extends CotDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotDraftGroupByOutputType[P]>
            : GetScalarType<T[P], CotDraftGroupByOutputType[P]>
        }
      >
    >


  export type CotDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
    performance?: boolean | CotDraft$performanceArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraft"]>

  export type CotDraftSelectScalar = {
    id?: boolean
    sessionId?: boolean
    conceptNumber?: boolean
    title?: boolean
    hook?: boolean
    angle?: boolean
    format?: boolean
    content?: boolean
    visualGuide?: boolean
    timing?: boolean
    hashtags?: boolean
    newsSource?: boolean
    sourceUrl?: boolean
    kpis?: boolean
    riskAssessment?: boolean
    optimizationTips?: boolean
    status?: boolean
    editedContent?: boolean
    scheduledAt?: boolean
    postedAt?: boolean
    postId?: boolean
    viralScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CotDraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
    performance?: boolean | CotDraft$performanceArgs<ExtArgs>
  }
  export type CotDraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CotSessionDefaultArgs<ExtArgs>
  }

  export type $CotDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotDraft"
    objects: {
      session: Prisma.$CotSessionPayload<ExtArgs>
      performance: Prisma.$CotDraftPerformancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      conceptNumber: number
      title: string
      hook: string
      angle: string
      format: string
      content: string | null
      visualGuide: string | null
      timing: string
      hashtags: string[]
      newsSource: string | null
      sourceUrl: string | null
      kpis: Prisma.JsonValue | null
      riskAssessment: Prisma.JsonValue | null
      optimizationTips: Prisma.JsonValue | null
      status: $Enums.CotDraftStatus
      editedContent: string | null
      scheduledAt: Date | null
      postedAt: Date | null
      postId: string | null
      viralScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cotDraft"]>
    composites: {}
  }

  type CotDraftGetPayload<S extends boolean | null | undefined | CotDraftDefaultArgs> = $Result.GetResult<Prisma.$CotDraftPayload, S>

  type CotDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotDraftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotDraftCountAggregateInputType | true
    }

  export interface CotDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotDraft'], meta: { name: 'CotDraft' } }
    /**
     * Find zero or one CotDraft that matches the filter.
     * @param {CotDraftFindUniqueArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotDraftFindUniqueArgs>(args: SelectSubset<T, CotDraftFindUniqueArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotDraft that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotDraftFindUniqueOrThrowArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotDraftFindUniqueOrThrowArgs>(args: SelectSubset<T, CotDraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindFirstArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotDraftFindFirstArgs>(args?: SelectSubset<T, CotDraftFindFirstArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindFirstOrThrowArgs} args - Arguments to find a CotDraft
     * @example
     * // Get one CotDraft
     * const cotDraft = await prisma.cotDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotDraftFindFirstOrThrowArgs>(args?: SelectSubset<T, CotDraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotDrafts
     * const cotDrafts = await prisma.cotDraft.findMany()
     * 
     * // Get first 10 CotDrafts
     * const cotDrafts = await prisma.cotDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotDraftFindManyArgs>(args?: SelectSubset<T, CotDraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotDraft.
     * @param {CotDraftCreateArgs} args - Arguments to create a CotDraft.
     * @example
     * // Create one CotDraft
     * const CotDraft = await prisma.cotDraft.create({
     *   data: {
     *     // ... data to create a CotDraft
     *   }
     * })
     * 
     */
    create<T extends CotDraftCreateArgs>(args: SelectSubset<T, CotDraftCreateArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotDrafts.
     * @param {CotDraftCreateManyArgs} args - Arguments to create many CotDrafts.
     * @example
     * // Create many CotDrafts
     * const cotDraft = await prisma.cotDraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotDraftCreateManyArgs>(args?: SelectSubset<T, CotDraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotDrafts and returns the data saved in the database.
     * @param {CotDraftCreateManyAndReturnArgs} args - Arguments to create many CotDrafts.
     * @example
     * // Create many CotDrafts
     * const cotDraft = await prisma.cotDraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotDrafts and only return the `id`
     * const cotDraftWithIdOnly = await prisma.cotDraft.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotDraftCreateManyAndReturnArgs>(args?: SelectSubset<T, CotDraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotDraft.
     * @param {CotDraftDeleteArgs} args - Arguments to delete one CotDraft.
     * @example
     * // Delete one CotDraft
     * const CotDraft = await prisma.cotDraft.delete({
     *   where: {
     *     // ... filter to delete one CotDraft
     *   }
     * })
     * 
     */
    delete<T extends CotDraftDeleteArgs>(args: SelectSubset<T, CotDraftDeleteArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotDraft.
     * @param {CotDraftUpdateArgs} args - Arguments to update one CotDraft.
     * @example
     * // Update one CotDraft
     * const cotDraft = await prisma.cotDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotDraftUpdateArgs>(args: SelectSubset<T, CotDraftUpdateArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotDrafts.
     * @param {CotDraftDeleteManyArgs} args - Arguments to filter CotDrafts to delete.
     * @example
     * // Delete a few CotDrafts
     * const { count } = await prisma.cotDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotDraftDeleteManyArgs>(args?: SelectSubset<T, CotDraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotDrafts
     * const cotDraft = await prisma.cotDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotDraftUpdateManyArgs>(args: SelectSubset<T, CotDraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotDraft.
     * @param {CotDraftUpsertArgs} args - Arguments to update or create a CotDraft.
     * @example
     * // Update or create a CotDraft
     * const cotDraft = await prisma.cotDraft.upsert({
     *   create: {
     *     // ... data to create a CotDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotDraft we want to update
     *   }
     * })
     */
    upsert<T extends CotDraftUpsertArgs>(args: SelectSubset<T, CotDraftUpsertArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftCountArgs} args - Arguments to filter CotDrafts to count.
     * @example
     * // Count the number of CotDrafts
     * const count = await prisma.cotDraft.count({
     *   where: {
     *     // ... the filter for the CotDrafts we want to count
     *   }
     * })
    **/
    count<T extends CotDraftCountArgs>(
      args?: Subset<T, CotDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotDraftAggregateArgs>(args: Subset<T, CotDraftAggregateArgs>): Prisma.PrismaPromise<GetCotDraftAggregateType<T>>

    /**
     * Group by CotDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotDraftGroupByArgs['orderBy'] }
        : { orderBy?: CotDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotDraft model
   */
  readonly fields: CotDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotSessionDefaultArgs<ExtArgs>>): Prisma__CotSessionClient<$Result.GetResult<Prisma.$CotSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    performance<T extends CotDraft$performanceArgs<ExtArgs> = {}>(args?: Subset<T, CotDraft$performanceArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotDraft model
   */ 
  interface CotDraftFieldRefs {
    readonly id: FieldRef<"CotDraft", 'String'>
    readonly sessionId: FieldRef<"CotDraft", 'String'>
    readonly conceptNumber: FieldRef<"CotDraft", 'Int'>
    readonly title: FieldRef<"CotDraft", 'String'>
    readonly hook: FieldRef<"CotDraft", 'String'>
    readonly angle: FieldRef<"CotDraft", 'String'>
    readonly format: FieldRef<"CotDraft", 'String'>
    readonly content: FieldRef<"CotDraft", 'String'>
    readonly visualGuide: FieldRef<"CotDraft", 'String'>
    readonly timing: FieldRef<"CotDraft", 'String'>
    readonly hashtags: FieldRef<"CotDraft", 'String[]'>
    readonly newsSource: FieldRef<"CotDraft", 'String'>
    readonly sourceUrl: FieldRef<"CotDraft", 'String'>
    readonly kpis: FieldRef<"CotDraft", 'Json'>
    readonly riskAssessment: FieldRef<"CotDraft", 'Json'>
    readonly optimizationTips: FieldRef<"CotDraft", 'Json'>
    readonly status: FieldRef<"CotDraft", 'CotDraftStatus'>
    readonly editedContent: FieldRef<"CotDraft", 'String'>
    readonly scheduledAt: FieldRef<"CotDraft", 'DateTime'>
    readonly postedAt: FieldRef<"CotDraft", 'DateTime'>
    readonly postId: FieldRef<"CotDraft", 'String'>
    readonly viralScore: FieldRef<"CotDraft", 'Float'>
    readonly createdAt: FieldRef<"CotDraft", 'DateTime'>
    readonly updatedAt: FieldRef<"CotDraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotDraft findUnique
   */
  export type CotDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft findUniqueOrThrow
   */
  export type CotDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft findFirst
   */
  export type CotDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDrafts.
     */
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft findFirstOrThrow
   */
  export type CotDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDraft to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDrafts.
     */
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft findMany
   */
  export type CotDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter, which CotDrafts to fetch.
     */
    where?: CotDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDrafts to fetch.
     */
    orderBy?: CotDraftOrderByWithRelationInput | CotDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotDrafts.
     */
    cursor?: CotDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDrafts.
     */
    skip?: number
    distinct?: CotDraftScalarFieldEnum | CotDraftScalarFieldEnum[]
  }

  /**
   * CotDraft create
   */
  export type CotDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The data needed to create a CotDraft.
     */
    data: XOR<CotDraftCreateInput, CotDraftUncheckedCreateInput>
  }

  /**
   * CotDraft createMany
   */
  export type CotDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotDrafts.
     */
    data: CotDraftCreateManyInput | CotDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotDraft createManyAndReturn
   */
  export type CotDraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotDrafts.
     */
    data: CotDraftCreateManyInput | CotDraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraft update
   */
  export type CotDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The data needed to update a CotDraft.
     */
    data: XOR<CotDraftUpdateInput, CotDraftUncheckedUpdateInput>
    /**
     * Choose, which CotDraft to update.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft updateMany
   */
  export type CotDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotDrafts.
     */
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyInput>
    /**
     * Filter which CotDrafts to update
     */
    where?: CotDraftWhereInput
  }

  /**
   * CotDraft upsert
   */
  export type CotDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * The filter to search for the CotDraft to update in case it exists.
     */
    where: CotDraftWhereUniqueInput
    /**
     * In case the CotDraft found by the `where` argument doesn't exist, create a new CotDraft with this data.
     */
    create: XOR<CotDraftCreateInput, CotDraftUncheckedCreateInput>
    /**
     * In case the CotDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotDraftUpdateInput, CotDraftUncheckedUpdateInput>
  }

  /**
   * CotDraft delete
   */
  export type CotDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
    /**
     * Filter which CotDraft to delete.
     */
    where: CotDraftWhereUniqueInput
  }

  /**
   * CotDraft deleteMany
   */
  export type CotDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDrafts to delete
     */
    where?: CotDraftWhereInput
  }

  /**
   * CotDraft.performance
   */
  export type CotDraft$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraft without action
   */
  export type CotDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraft
     */
    select?: CotDraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftInclude<ExtArgs> | null
  }


  /**
   * Model CotDraftPerformance
   */

  export type AggregateCotDraftPerformance = {
    _count: CotDraftPerformanceCountAggregateOutputType | null
    _avg: CotDraftPerformanceAvgAggregateOutputType | null
    _sum: CotDraftPerformanceSumAggregateOutputType | null
    _min: CotDraftPerformanceMinAggregateOutputType | null
    _max: CotDraftPerformanceMaxAggregateOutputType | null
  }

  export type CotDraftPerformanceAvgAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type CotDraftPerformanceSumAggregateOutputType = {
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
  }

  export type CotDraftPerformanceMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    lastUpdateAt: Date | null
  }

  export type CotDraftPerformanceMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date | null
    lastUpdateAt: Date | null
  }

  export type CotDraftPerformanceCountAggregateOutputType = {
    id: number
    draftId: number
    likes30m: number
    retweets30m: number
    replies30m: number
    impressions30m: number
    likes1h: number
    retweets1h: number
    replies1h: number
    impressions1h: number
    likes24h: number
    retweets24h: number
    replies24h: number
    impressions24h: number
    engagementRate: number
    viralCoefficient: number
    collectedAt: number
    lastUpdateAt: number
    _all: number
  }


  export type CotDraftPerformanceAvgAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type CotDraftPerformanceSumAggregateInputType = {
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
  }

  export type CotDraftPerformanceMinAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
  }

  export type CotDraftPerformanceMaxAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
  }

  export type CotDraftPerformanceCountAggregateInputType = {
    id?: true
    draftId?: true
    likes30m?: true
    retweets30m?: true
    replies30m?: true
    impressions30m?: true
    likes1h?: true
    retweets1h?: true
    replies1h?: true
    impressions1h?: true
    likes24h?: true
    retweets24h?: true
    replies24h?: true
    impressions24h?: true
    engagementRate?: true
    viralCoefficient?: true
    collectedAt?: true
    lastUpdateAt?: true
    _all?: true
  }

  export type CotDraftPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraftPerformance to aggregate.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CotDraftPerformances
    **/
    _count?: true | CotDraftPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotDraftPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotDraftPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotDraftPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotDraftPerformanceMaxAggregateInputType
  }

  export type GetCotDraftPerformanceAggregateType<T extends CotDraftPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCotDraftPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotDraftPerformance[P]>
      : GetScalarType<T[P], AggregateCotDraftPerformance[P]>
  }




  export type CotDraftPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CotDraftPerformanceWhereInput
    orderBy?: CotDraftPerformanceOrderByWithAggregationInput | CotDraftPerformanceOrderByWithAggregationInput[]
    by: CotDraftPerformanceScalarFieldEnum[] | CotDraftPerformanceScalarFieldEnum
    having?: CotDraftPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotDraftPerformanceCountAggregateInputType | true
    _avg?: CotDraftPerformanceAvgAggregateInputType
    _sum?: CotDraftPerformanceSumAggregateInputType
    _min?: CotDraftPerformanceMinAggregateInputType
    _max?: CotDraftPerformanceMaxAggregateInputType
  }

  export type CotDraftPerformanceGroupByOutputType = {
    id: string
    draftId: string
    likes30m: number | null
    retweets30m: number | null
    replies30m: number | null
    impressions30m: number | null
    likes1h: number | null
    retweets1h: number | null
    replies1h: number | null
    impressions1h: number | null
    likes24h: number | null
    retweets24h: number | null
    replies24h: number | null
    impressions24h: number | null
    engagementRate: number | null
    viralCoefficient: number | null
    collectedAt: Date
    lastUpdateAt: Date
    _count: CotDraftPerformanceCountAggregateOutputType | null
    _avg: CotDraftPerformanceAvgAggregateOutputType | null
    _sum: CotDraftPerformanceSumAggregateOutputType | null
    _min: CotDraftPerformanceMinAggregateOutputType | null
    _max: CotDraftPerformanceMaxAggregateOutputType | null
  }

  type GetCotDraftPerformanceGroupByPayload<T extends CotDraftPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotDraftPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotDraftPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotDraftPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], CotDraftPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type CotDraftPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotDraftPerformance"]>

  export type CotDraftPerformanceSelectScalar = {
    id?: boolean
    draftId?: boolean
    likes30m?: boolean
    retweets30m?: boolean
    replies30m?: boolean
    impressions30m?: boolean
    likes1h?: boolean
    retweets1h?: boolean
    replies1h?: boolean
    impressions1h?: boolean
    likes24h?: boolean
    retweets24h?: boolean
    replies24h?: boolean
    impressions24h?: boolean
    engagementRate?: boolean
    viralCoefficient?: boolean
    collectedAt?: boolean
    lastUpdateAt?: boolean
  }

  export type CotDraftPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }
  export type CotDraftPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | CotDraftDefaultArgs<ExtArgs>
  }

  export type $CotDraftPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CotDraftPerformance"
    objects: {
      draft: Prisma.$CotDraftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      likes30m: number | null
      retweets30m: number | null
      replies30m: number | null
      impressions30m: number | null
      likes1h: number | null
      retweets1h: number | null
      replies1h: number | null
      impressions1h: number | null
      likes24h: number | null
      retweets24h: number | null
      replies24h: number | null
      impressions24h: number | null
      engagementRate: number | null
      viralCoefficient: number | null
      collectedAt: Date
      lastUpdateAt: Date
    }, ExtArgs["result"]["cotDraftPerformance"]>
    composites: {}
  }

  type CotDraftPerformanceGetPayload<S extends boolean | null | undefined | CotDraftPerformanceDefaultArgs> = $Result.GetResult<Prisma.$CotDraftPerformancePayload, S>

  type CotDraftPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CotDraftPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CotDraftPerformanceCountAggregateInputType | true
    }

  export interface CotDraftPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CotDraftPerformance'], meta: { name: 'CotDraftPerformance' } }
    /**
     * Find zero or one CotDraftPerformance that matches the filter.
     * @param {CotDraftPerformanceFindUniqueArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CotDraftPerformanceFindUniqueArgs>(args: SelectSubset<T, CotDraftPerformanceFindUniqueArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CotDraftPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CotDraftPerformanceFindUniqueOrThrowArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CotDraftPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CotDraftPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindFirstArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CotDraftPerformanceFindFirstArgs>(args?: SelectSubset<T, CotDraftPerformanceFindFirstArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CotDraftPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindFirstOrThrowArgs} args - Arguments to find a CotDraftPerformance
     * @example
     * // Get one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CotDraftPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CotDraftPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CotDraftPerformances
     * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany()
     * 
     * // Get first 10 CotDraftPerformances
     * const cotDraftPerformances = await prisma.cotDraftPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CotDraftPerformanceFindManyArgs>(args?: SelectSubset<T, CotDraftPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CotDraftPerformance.
     * @param {CotDraftPerformanceCreateArgs} args - Arguments to create a CotDraftPerformance.
     * @example
     * // Create one CotDraftPerformance
     * const CotDraftPerformance = await prisma.cotDraftPerformance.create({
     *   data: {
     *     // ... data to create a CotDraftPerformance
     *   }
     * })
     * 
     */
    create<T extends CotDraftPerformanceCreateArgs>(args: SelectSubset<T, CotDraftPerformanceCreateArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CotDraftPerformances.
     * @param {CotDraftPerformanceCreateManyArgs} args - Arguments to create many CotDraftPerformances.
     * @example
     * // Create many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CotDraftPerformanceCreateManyArgs>(args?: SelectSubset<T, CotDraftPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CotDraftPerformances and returns the data saved in the database.
     * @param {CotDraftPerformanceCreateManyAndReturnArgs} args - Arguments to create many CotDraftPerformances.
     * @example
     * // Create many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CotDraftPerformances and only return the `id`
     * const cotDraftPerformanceWithIdOnly = await prisma.cotDraftPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CotDraftPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CotDraftPerformance.
     * @param {CotDraftPerformanceDeleteArgs} args - Arguments to delete one CotDraftPerformance.
     * @example
     * // Delete one CotDraftPerformance
     * const CotDraftPerformance = await prisma.cotDraftPerformance.delete({
     *   where: {
     *     // ... filter to delete one CotDraftPerformance
     *   }
     * })
     * 
     */
    delete<T extends CotDraftPerformanceDeleteArgs>(args: SelectSubset<T, CotDraftPerformanceDeleteArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CotDraftPerformance.
     * @param {CotDraftPerformanceUpdateArgs} args - Arguments to update one CotDraftPerformance.
     * @example
     * // Update one CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CotDraftPerformanceUpdateArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CotDraftPerformances.
     * @param {CotDraftPerformanceDeleteManyArgs} args - Arguments to filter CotDraftPerformances to delete.
     * @example
     * // Delete a few CotDraftPerformances
     * const { count } = await prisma.cotDraftPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CotDraftPerformanceDeleteManyArgs>(args?: SelectSubset<T, CotDraftPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CotDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CotDraftPerformances
     * const cotDraftPerformance = await prisma.cotDraftPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CotDraftPerformanceUpdateManyArgs>(args: SelectSubset<T, CotDraftPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CotDraftPerformance.
     * @param {CotDraftPerformanceUpsertArgs} args - Arguments to update or create a CotDraftPerformance.
     * @example
     * // Update or create a CotDraftPerformance
     * const cotDraftPerformance = await prisma.cotDraftPerformance.upsert({
     *   create: {
     *     // ... data to create a CotDraftPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CotDraftPerformance we want to update
     *   }
     * })
     */
    upsert<T extends CotDraftPerformanceUpsertArgs>(args: SelectSubset<T, CotDraftPerformanceUpsertArgs<ExtArgs>>): Prisma__CotDraftPerformanceClient<$Result.GetResult<Prisma.$CotDraftPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CotDraftPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceCountArgs} args - Arguments to filter CotDraftPerformances to count.
     * @example
     * // Count the number of CotDraftPerformances
     * const count = await prisma.cotDraftPerformance.count({
     *   where: {
     *     // ... the filter for the CotDraftPerformances we want to count
     *   }
     * })
    **/
    count<T extends CotDraftPerformanceCountArgs>(
      args?: Subset<T, CotDraftPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotDraftPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CotDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotDraftPerformanceAggregateArgs>(args: Subset<T, CotDraftPerformanceAggregateArgs>): Prisma.PrismaPromise<GetCotDraftPerformanceAggregateType<T>>

    /**
     * Group by CotDraftPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotDraftPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CotDraftPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CotDraftPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: CotDraftPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CotDraftPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotDraftPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CotDraftPerformance model
   */
  readonly fields: CotDraftPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CotDraftPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CotDraftPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends CotDraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CotDraftDefaultArgs<ExtArgs>>): Prisma__CotDraftClient<$Result.GetResult<Prisma.$CotDraftPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CotDraftPerformance model
   */ 
  interface CotDraftPerformanceFieldRefs {
    readonly id: FieldRef<"CotDraftPerformance", 'String'>
    readonly draftId: FieldRef<"CotDraftPerformance", 'String'>
    readonly likes30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions30m: FieldRef<"CotDraftPerformance", 'Int'>
    readonly likes1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions1h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly likes24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly retweets24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly replies24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly impressions24h: FieldRef<"CotDraftPerformance", 'Int'>
    readonly engagementRate: FieldRef<"CotDraftPerformance", 'Float'>
    readonly viralCoefficient: FieldRef<"CotDraftPerformance", 'Float'>
    readonly collectedAt: FieldRef<"CotDraftPerformance", 'DateTime'>
    readonly lastUpdateAt: FieldRef<"CotDraftPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CotDraftPerformance findUnique
   */
  export type CotDraftPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance findUniqueOrThrow
   */
  export type CotDraftPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance findFirst
   */
  export type CotDraftPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDraftPerformances.
     */
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance findFirstOrThrow
   */
  export type CotDraftPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformance to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CotDraftPerformances.
     */
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance findMany
   */
  export type CotDraftPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which CotDraftPerformances to fetch.
     */
    where?: CotDraftPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CotDraftPerformances to fetch.
     */
    orderBy?: CotDraftPerformanceOrderByWithRelationInput | CotDraftPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CotDraftPerformances.
     */
    cursor?: CotDraftPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CotDraftPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CotDraftPerformances.
     */
    skip?: number
    distinct?: CotDraftPerformanceScalarFieldEnum | CotDraftPerformanceScalarFieldEnum[]
  }

  /**
   * CotDraftPerformance create
   */
  export type CotDraftPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a CotDraftPerformance.
     */
    data: XOR<CotDraftPerformanceCreateInput, CotDraftPerformanceUncheckedCreateInput>
  }

  /**
   * CotDraftPerformance createMany
   */
  export type CotDraftPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CotDraftPerformances.
     */
    data: CotDraftPerformanceCreateManyInput | CotDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CotDraftPerformance createManyAndReturn
   */
  export type CotDraftPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CotDraftPerformances.
     */
    data: CotDraftPerformanceCreateManyInput | CotDraftPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CotDraftPerformance update
   */
  export type CotDraftPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a CotDraftPerformance.
     */
    data: XOR<CotDraftPerformanceUpdateInput, CotDraftPerformanceUncheckedUpdateInput>
    /**
     * Choose, which CotDraftPerformance to update.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance updateMany
   */
  export type CotDraftPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CotDraftPerformances.
     */
    data: XOR<CotDraftPerformanceUpdateManyMutationInput, CotDraftPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which CotDraftPerformances to update
     */
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraftPerformance upsert
   */
  export type CotDraftPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the CotDraftPerformance to update in case it exists.
     */
    where: CotDraftPerformanceWhereUniqueInput
    /**
     * In case the CotDraftPerformance found by the `where` argument doesn't exist, create a new CotDraftPerformance with this data.
     */
    create: XOR<CotDraftPerformanceCreateInput, CotDraftPerformanceUncheckedCreateInput>
    /**
     * In case the CotDraftPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CotDraftPerformanceUpdateInput, CotDraftPerformanceUncheckedUpdateInput>
  }

  /**
   * CotDraftPerformance delete
   */
  export type CotDraftPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
    /**
     * Filter which CotDraftPerformance to delete.
     */
    where: CotDraftPerformanceWhereUniqueInput
  }

  /**
   * CotDraftPerformance deleteMany
   */
  export type CotDraftPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CotDraftPerformances to delete
     */
    where?: CotDraftPerformanceWhereInput
  }

  /**
   * CotDraftPerformance without action
   */
  export type CotDraftPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotDraftPerformance
     */
    select?: CotDraftPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CotDraftPerformanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BuzzPostScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    content: 'content',
    authorUsername: 'authorUsername',
    authorId: 'authorId',
    likesCount: 'likesCount',
    retweetsCount: 'retweetsCount',
    repliesCount: 'repliesCount',
    impressionsCount: 'impressionsCount',
    postedAt: 'postedAt',
    collectedAt: 'collectedAt',
    url: 'url',
    theme: 'theme',
    language: 'language',
    mediaUrls: 'mediaUrls',
    hashtags: 'hashtags',
    chromaId: 'chromaId',
    authorFollowers: 'authorFollowers',
    authorFollowing: 'authorFollowing',
    authorVerified: 'authorVerified'
  };

  export type BuzzPostScalarFieldEnum = (typeof BuzzPostScalarFieldEnum)[keyof typeof BuzzPostScalarFieldEnum]


  export const ScheduledPostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    scheduledTime: 'scheduledTime',
    status: 'status',
    postType: 'postType',
    refPostId: 'refPostId',
    templateType: 'templateType',
    aiGenerated: 'aiGenerated',
    aiPrompt: 'aiPrompt',
    editedContent: 'editedContent',
    postedAt: 'postedAt',
    postResult: 'postResult',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledPostScalarFieldEnum = (typeof ScheduledPostScalarFieldEnum)[keyof typeof ScheduledPostScalarFieldEnum]


  export const PostAnalyticsScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    impressions: 'impressions',
    engagements: 'engagements',
    likes: 'likes',
    retweets: 'retweets',
    replies: 'replies',
    profileClicks: 'profileClicks',
    urlClicks: 'urlClicks',
    detailExpands: 'detailExpands',
    engagementRate: 'engagementRate',
    collectedAt: 'collectedAt'
  };

  export type PostAnalyticsScalarFieldEnum = (typeof PostAnalyticsScalarFieldEnum)[keyof typeof PostAnalyticsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    twitterId: 'twitterId',
    username: 'username',
    name: 'name',
    email: 'email',
    image: 'image',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenSecret: 'tokenSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NewsSourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    rssUrl: 'rssUrl',
    category: 'category',
    language: 'language',
    isActive: 'isActive',
    lastFetched: 'lastFetched',
    createdAt: 'createdAt'
  };

  export type NewsSourceScalarFieldEnum = (typeof NewsSourceScalarFieldEnum)[keyof typeof NewsSourceScalarFieldEnum]


  export const NewsArticleScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    title: 'title',
    description: 'description',
    url: 'url',
    publishedAt: 'publishedAt',
    category: 'category',
    tags: 'tags',
    importance: 'importance',
    processed: 'processed',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type NewsArticleScalarFieldEnum = (typeof NewsArticleScalarFieldEnum)[keyof typeof NewsArticleScalarFieldEnum]


  export const NewsThreadScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    metadata: 'metadata',
    scheduledAt: 'scheduledAt',
    title: 'title',
    postedAt: 'postedAt'
  };

  export type NewsThreadScalarFieldEnum = (typeof NewsThreadScalarFieldEnum)[keyof typeof NewsThreadScalarFieldEnum]


  export const NewsThreadItemScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    articleId: 'articleId',
    order: 'order',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type NewsThreadItemScalarFieldEnum = (typeof NewsThreadItemScalarFieldEnum)[keyof typeof NewsThreadItemScalarFieldEnum]


  export const NewsAnalysisScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    summary: 'summary',
    sentiment: 'sentiment',
    keywords: 'keywords',
    topics: 'topics',
    createdAt: 'createdAt'
  };

  export type NewsAnalysisScalarFieldEnum = (typeof NewsAnalysisScalarFieldEnum)[keyof typeof NewsAnalysisScalarFieldEnum]


  export const JobQueueScalarFieldEnum: {
    id: 'id',
    type: 'type',
    payload: 'payload',
    status: 'status',
    priority: 'priority',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    runAt: 'runAt',
    completedAt: 'completedAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobQueueScalarFieldEnum = (typeof JobQueueScalarFieldEnum)[keyof typeof JobQueueScalarFieldEnum]


  export const CollectionPresetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    settings: 'settings',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionPresetScalarFieldEnum = (typeof CollectionPresetScalarFieldEnum)[keyof typeof CollectionPresetScalarFieldEnum]


  export const WatchlistUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    twitterId: 'twitterId',
    username: 'username',
    displayName: 'displayName',
    followers: 'followers',
    following: 'following',
    isActive: 'isActive',
    lastChecked: 'lastChecked',
    createdAt: 'createdAt'
  };

  export type WatchlistUserScalarFieldEnum = (typeof WatchlistUserScalarFieldEnum)[keyof typeof WatchlistUserScalarFieldEnum]


  export const WatchlistTweetScalarFieldEnum: {
    id: 'id',
    watchlistUserId: 'watchlistUserId',
    tweetId: 'tweetId',
    content: 'content',
    createdAt: 'createdAt',
    retweetCount: 'retweetCount',
    likeCount: 'likeCount',
    replyCount: 'replyCount',
    collectedAt: 'collectedAt'
  };

  export type WatchlistTweetScalarFieldEnum = (typeof WatchlistTweetScalarFieldEnum)[keyof typeof WatchlistTweetScalarFieldEnum]


  export const InteractionHistoryScalarFieldEnum: {
    id: 'id',
    watchlistUserId: 'watchlistUserId',
    interactionType: 'interactionType',
    tweetId: 'tweetId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type InteractionHistoryScalarFieldEnum = (typeof InteractionHistoryScalarFieldEnum)[keyof typeof InteractionHistoryScalarFieldEnum]


  export const PerplexityReportScalarFieldEnum: {
    id: 'id',
    query: 'query',
    focus: 'focus',
    rawAnalysis: 'rawAnalysis',
    trends: 'trends',
    insights: 'insights',
    contentAngles: 'contentAngles',
    marketContext: 'marketContext',
    competitorActivity: 'competitorActivity',
    riskFactors: 'riskFactors',
    createdAt: 'createdAt'
  };

  export type PerplexityReportScalarFieldEnum = (typeof PerplexityReportScalarFieldEnum)[keyof typeof PerplexityReportScalarFieldEnum]


  export const CotSessionScalarFieldEnum: {
    id: 'id',
    expertise: 'expertise',
    style: 'style',
    platform: 'platform',
    status: 'status',
    currentPhase: 'currentPhase',
    currentStep: 'currentStep',
    lastError: 'lastError',
    retryCount: 'retryCount',
    nextRetryAt: 'nextRetryAt',
    totalTokens: 'totalTokens',
    totalDuration: 'totalDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type CotSessionScalarFieldEnum = (typeof CotSessionScalarFieldEnum)[keyof typeof CotSessionScalarFieldEnum]


  export const CotPhaseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    phaseNumber: 'phaseNumber',
    thinkPrompt: 'thinkPrompt',
    thinkResult: 'thinkResult',
    thinkTokens: 'thinkTokens',
    thinkAt: 'thinkAt',
    executeResult: 'executeResult',
    executeDuration: 'executeDuration',
    executeAt: 'executeAt',
    integratePrompt: 'integratePrompt',
    integrateResult: 'integrateResult',
    integrateTokens: 'integrateTokens',
    integrateAt: 'integrateAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CotPhaseScalarFieldEnum = (typeof CotPhaseScalarFieldEnum)[keyof typeof CotPhaseScalarFieldEnum]


  export const CotDraftScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    conceptNumber: 'conceptNumber',
    title: 'title',
    hook: 'hook',
    angle: 'angle',
    format: 'format',
    content: 'content',
    visualGuide: 'visualGuide',
    timing: 'timing',
    hashtags: 'hashtags',
    newsSource: 'newsSource',
    sourceUrl: 'sourceUrl',
    kpis: 'kpis',
    riskAssessment: 'riskAssessment',
    optimizationTips: 'optimizationTips',
    status: 'status',
    editedContent: 'editedContent',
    scheduledAt: 'scheduledAt',
    postedAt: 'postedAt',
    postId: 'postId',
    viralScore: 'viralScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CotDraftScalarFieldEnum = (typeof CotDraftScalarFieldEnum)[keyof typeof CotDraftScalarFieldEnum]


  export const CotDraftPerformanceScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    likes30m: 'likes30m',
    retweets30m: 'retweets30m',
    replies30m: 'replies30m',
    impressions30m: 'impressions30m',
    likes1h: 'likes1h',
    retweets1h: 'retweets1h',
    replies1h: 'replies1h',
    impressions1h: 'impressions1h',
    likes24h: 'likes24h',
    retweets24h: 'retweets24h',
    replies24h: 'replies24h',
    impressions24h: 'impressions24h',
    engagementRate: 'engagementRate',
    viralCoefficient: 'viralCoefficient',
    collectedAt: 'collectedAt',
    lastUpdateAt: 'lastUpdateAt'
  };

  export type CotDraftPerformanceScalarFieldEnum = (typeof CotDraftPerformanceScalarFieldEnum)[keyof typeof CotDraftPerformanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CotSessionStatus'
   */
  export type EnumCotSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotSessionStatus'>
    


  /**
   * Reference to a field of type 'CotSessionStatus[]'
   */
  export type ListEnumCotSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotSessionStatus[]'>
    


  /**
   * Reference to a field of type 'CotPhaseStep'
   */
  export type EnumCotPhaseStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStep'>
    


  /**
   * Reference to a field of type 'CotPhaseStep[]'
   */
  export type ListEnumCotPhaseStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStep[]'>
    


  /**
   * Reference to a field of type 'CotPhaseStatus'
   */
  export type EnumCotPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStatus'>
    


  /**
   * Reference to a field of type 'CotPhaseStatus[]'
   */
  export type ListEnumCotPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotPhaseStatus[]'>
    


  /**
   * Reference to a field of type 'CotDraftStatus'
   */
  export type EnumCotDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotDraftStatus'>
    


  /**
   * Reference to a field of type 'CotDraftStatus[]'
   */
  export type ListEnumCotDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CotDraftStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BuzzPostWhereInput = {
    AND?: BuzzPostWhereInput | BuzzPostWhereInput[]
    OR?: BuzzPostWhereInput[]
    NOT?: BuzzPostWhereInput | BuzzPostWhereInput[]
    id?: StringFilter<"BuzzPost"> | string
    postId?: StringFilter<"BuzzPost"> | string
    content?: StringFilter<"BuzzPost"> | string
    authorUsername?: StringFilter<"BuzzPost"> | string
    authorId?: StringFilter<"BuzzPost"> | string
    likesCount?: IntFilter<"BuzzPost"> | number
    retweetsCount?: IntFilter<"BuzzPost"> | number
    repliesCount?: IntFilter<"BuzzPost"> | number
    impressionsCount?: IntFilter<"BuzzPost"> | number
    postedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    url?: StringFilter<"BuzzPost"> | string
    theme?: StringFilter<"BuzzPost"> | string
    language?: StringFilter<"BuzzPost"> | string
    mediaUrls?: JsonFilter<"BuzzPost">
    hashtags?: JsonFilter<"BuzzPost">
    chromaId?: StringNullableFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableFilter<"BuzzPost"> | boolean | null
    scheduledPosts?: ScheduledPostListRelationFilter
  }

  export type BuzzPostOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrderInput | SortOrder
    authorFollowers?: SortOrderInput | SortOrder
    authorFollowing?: SortOrderInput | SortOrder
    authorVerified?: SortOrderInput | SortOrder
    scheduledPosts?: ScheduledPostOrderByRelationAggregateInput
  }

  export type BuzzPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId?: string
    AND?: BuzzPostWhereInput | BuzzPostWhereInput[]
    OR?: BuzzPostWhereInput[]
    NOT?: BuzzPostWhereInput | BuzzPostWhereInput[]
    content?: StringFilter<"BuzzPost"> | string
    authorUsername?: StringFilter<"BuzzPost"> | string
    authorId?: StringFilter<"BuzzPost"> | string
    likesCount?: IntFilter<"BuzzPost"> | number
    retweetsCount?: IntFilter<"BuzzPost"> | number
    repliesCount?: IntFilter<"BuzzPost"> | number
    impressionsCount?: IntFilter<"BuzzPost"> | number
    postedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeFilter<"BuzzPost"> | Date | string
    url?: StringFilter<"BuzzPost"> | string
    theme?: StringFilter<"BuzzPost"> | string
    language?: StringFilter<"BuzzPost"> | string
    mediaUrls?: JsonFilter<"BuzzPost">
    hashtags?: JsonFilter<"BuzzPost">
    chromaId?: StringNullableFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableFilter<"BuzzPost"> | boolean | null
    scheduledPosts?: ScheduledPostListRelationFilter
  }, "id" | "postId">

  export type BuzzPostOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrderInput | SortOrder
    authorFollowers?: SortOrderInput | SortOrder
    authorFollowing?: SortOrderInput | SortOrder
    authorVerified?: SortOrderInput | SortOrder
    _count?: BuzzPostCountOrderByAggregateInput
    _avg?: BuzzPostAvgOrderByAggregateInput
    _max?: BuzzPostMaxOrderByAggregateInput
    _min?: BuzzPostMinOrderByAggregateInput
    _sum?: BuzzPostSumOrderByAggregateInput
  }

  export type BuzzPostScalarWhereWithAggregatesInput = {
    AND?: BuzzPostScalarWhereWithAggregatesInput | BuzzPostScalarWhereWithAggregatesInput[]
    OR?: BuzzPostScalarWhereWithAggregatesInput[]
    NOT?: BuzzPostScalarWhereWithAggregatesInput | BuzzPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuzzPost"> | string
    postId?: StringWithAggregatesFilter<"BuzzPost"> | string
    content?: StringWithAggregatesFilter<"BuzzPost"> | string
    authorUsername?: StringWithAggregatesFilter<"BuzzPost"> | string
    authorId?: StringWithAggregatesFilter<"BuzzPost"> | string
    likesCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    retweetsCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    repliesCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    impressionsCount?: IntWithAggregatesFilter<"BuzzPost"> | number
    postedAt?: DateTimeWithAggregatesFilter<"BuzzPost"> | Date | string
    collectedAt?: DateTimeWithAggregatesFilter<"BuzzPost"> | Date | string
    url?: StringWithAggregatesFilter<"BuzzPost"> | string
    theme?: StringWithAggregatesFilter<"BuzzPost"> | string
    language?: StringWithAggregatesFilter<"BuzzPost"> | string
    mediaUrls?: JsonWithAggregatesFilter<"BuzzPost">
    hashtags?: JsonWithAggregatesFilter<"BuzzPost">
    chromaId?: StringNullableWithAggregatesFilter<"BuzzPost"> | string | null
    authorFollowers?: IntNullableWithAggregatesFilter<"BuzzPost"> | number | null
    authorFollowing?: IntNullableWithAggregatesFilter<"BuzzPost"> | number | null
    authorVerified?: BoolNullableWithAggregatesFilter<"BuzzPost"> | boolean | null
  }

  export type ScheduledPostWhereInput = {
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    refPost?: XOR<BuzzPostNullableRelationFilter, BuzzPostWhereInput> | null
  }

  export type ScheduledPostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrderInput | SortOrder
    templateType?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refPost?: BuzzPostOrderByWithRelationInput
  }

  export type ScheduledPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    refPost?: XOR<BuzzPostNullableRelationFilter, BuzzPostWhereInput> | null
  }, "id">

  export type ScheduledPostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrderInput | SortOrder
    templateType?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledPostCountOrderByAggregateInput
    _max?: ScheduledPostMaxOrderByAggregateInput
    _min?: ScheduledPostMinOrderByAggregateInput
  }

  export type ScheduledPostScalarWhereWithAggregatesInput = {
    AND?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    OR?: ScheduledPostScalarWhereWithAggregatesInput[]
    NOT?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledPost"> | string
    content?: StringWithAggregatesFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusWithAggregatesFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeWithAggregatesFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolWithAggregatesFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableWithAggregatesFilter<"ScheduledPost">
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
  }

  export type PostAnalyticsWhereInput = {
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    id?: StringFilter<"PostAnalytics"> | string
    postId?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    engagements?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    urlClicks?: IntFilter<"PostAnalytics"> | number
    detailExpands?: IntFilter<"PostAnalytics"> | number
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    collectedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
  }

  export type PostAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    postId?: StringFilter<"PostAnalytics"> | string
    impressions?: IntFilter<"PostAnalytics"> | number
    engagements?: IntFilter<"PostAnalytics"> | number
    likes?: IntFilter<"PostAnalytics"> | number
    retweets?: IntFilter<"PostAnalytics"> | number
    replies?: IntFilter<"PostAnalytics"> | number
    profileClicks?: IntFilter<"PostAnalytics"> | number
    urlClicks?: IntFilter<"PostAnalytics"> | number
    detailExpands?: IntFilter<"PostAnalytics"> | number
    engagementRate?: FloatFilter<"PostAnalytics"> | number
    collectedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
  }, "id">

  export type PostAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
    _count?: PostAnalyticsCountOrderByAggregateInput
    _avg?: PostAnalyticsAvgOrderByAggregateInput
    _max?: PostAnalyticsMaxOrderByAggregateInput
    _min?: PostAnalyticsMinOrderByAggregateInput
    _sum?: PostAnalyticsSumOrderByAggregateInput
  }

  export type PostAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PostAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostAnalytics"> | string
    postId?: StringWithAggregatesFilter<"PostAnalytics"> | string
    impressions?: IntWithAggregatesFilter<"PostAnalytics"> | number
    engagements?: IntWithAggregatesFilter<"PostAnalytics"> | number
    likes?: IntWithAggregatesFilter<"PostAnalytics"> | number
    retweets?: IntWithAggregatesFilter<"PostAnalytics"> | number
    replies?: IntWithAggregatesFilter<"PostAnalytics"> | number
    profileClicks?: IntWithAggregatesFilter<"PostAnalytics"> | number
    urlClicks?: IntWithAggregatesFilter<"PostAnalytics"> | number
    detailExpands?: IntWithAggregatesFilter<"PostAnalytics"> | number
    engagementRate?: FloatWithAggregatesFilter<"PostAnalytics"> | number
    collectedAt?: DateTimeWithAggregatesFilter<"PostAnalytics"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    twitterId?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    accessToken?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    tokenSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    watchlistUsers?: WatchlistUserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    watchlistUsers?: WatchlistUserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    twitterId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    accessToken?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    tokenSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    watchlistUsers?: WatchlistUserListRelationFilter
  }, "id" | "twitterId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    twitterId?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    accessToken?: StringWithAggregatesFilter<"User"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    tokenSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NewsSourceWhereInput = {
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    id?: StringFilter<"NewsSource"> | string
    name?: StringFilter<"NewsSource"> | string
    url?: StringFilter<"NewsSource"> | string
    rssUrl?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    language?: StringFilter<"NewsSource"> | string
    isActive?: BoolFilter<"NewsSource"> | boolean
    lastFetched?: DateTimeNullableFilter<"NewsSource"> | Date | string | null
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    articles?: NewsArticleListRelationFilter
  }

  export type NewsSourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    articles?: NewsArticleOrderByRelationAggregateInput
  }

  export type NewsSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    name?: StringFilter<"NewsSource"> | string
    url?: StringFilter<"NewsSource"> | string
    rssUrl?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    language?: StringFilter<"NewsSource"> | string
    isActive?: BoolFilter<"NewsSource"> | boolean
    lastFetched?: DateTimeNullableFilter<"NewsSource"> | Date | string | null
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    articles?: NewsArticleListRelationFilter
  }, "id">

  export type NewsSourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NewsSourceCountOrderByAggregateInput
    _max?: NewsSourceMaxOrderByAggregateInput
    _min?: NewsSourceMinOrderByAggregateInput
  }

  export type NewsSourceScalarWhereWithAggregatesInput = {
    AND?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    OR?: NewsSourceScalarWhereWithAggregatesInput[]
    NOT?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsSource"> | string
    name?: StringWithAggregatesFilter<"NewsSource"> | string
    url?: StringWithAggregatesFilter<"NewsSource"> | string
    rssUrl?: StringWithAggregatesFilter<"NewsSource"> | string
    category?: StringWithAggregatesFilter<"NewsSource"> | string
    language?: StringWithAggregatesFilter<"NewsSource"> | string
    isActive?: BoolWithAggregatesFilter<"NewsSource"> | boolean
    lastFetched?: DateTimeNullableWithAggregatesFilter<"NewsSource"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NewsSource"> | Date | string
  }

  export type NewsArticleWhereInput = {
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    description?: StringNullableFilter<"NewsArticle"> | string | null
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
    analysis?: XOR<NewsAnalysisNullableRelationFilter, NewsAnalysisWhereInput> | null
    source?: XOR<NewsSourceRelationFilter, NewsSourceWhereInput>
    newsThreadItems?: NewsThreadItemListRelationFilter
  }

  export type NewsArticleOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    importance?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    analysis?: NewsAnalysisOrderByWithRelationInput
    source?: NewsSourceOrderByWithRelationInput
    newsThreadItems?: NewsThreadItemOrderByRelationAggregateInput
  }

  export type NewsArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    description?: StringNullableFilter<"NewsArticle"> | string | null
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
    analysis?: XOR<NewsAnalysisNullableRelationFilter, NewsAnalysisWhereInput> | null
    source?: XOR<NewsSourceRelationFilter, NewsSourceWhereInput>
    newsThreadItems?: NewsThreadItemListRelationFilter
  }, "id" | "url">

  export type NewsArticleOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    importance?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NewsArticleCountOrderByAggregateInput
    _avg?: NewsArticleAvgOrderByAggregateInput
    _max?: NewsArticleMaxOrderByAggregateInput
    _min?: NewsArticleMinOrderByAggregateInput
    _sum?: NewsArticleSumOrderByAggregateInput
  }

  export type NewsArticleScalarWhereWithAggregatesInput = {
    AND?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    OR?: NewsArticleScalarWhereWithAggregatesInput[]
    NOT?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsArticle"> | string
    sourceId?: StringWithAggregatesFilter<"NewsArticle"> | string
    title?: StringWithAggregatesFilter<"NewsArticle"> | string
    description?: StringNullableWithAggregatesFilter<"NewsArticle"> | string | null
    url?: StringWithAggregatesFilter<"NewsArticle"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    category?: StringNullableWithAggregatesFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableWithAggregatesFilter<"NewsArticle"> | number | null
    processed?: BoolWithAggregatesFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsArticle">
  }

  export type NewsThreadWhereInput = {
    AND?: NewsThreadWhereInput | NewsThreadWhereInput[]
    OR?: NewsThreadWhereInput[]
    NOT?: NewsThreadWhereInput | NewsThreadWhereInput[]
    id?: StringFilter<"NewsThread"> | string
    status?: StringFilter<"NewsThread"> | string
    createdAt?: DateTimeFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableFilter<"NewsThread">
    scheduledAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    title?: StringFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    items?: NewsThreadItemListRelationFilter
  }

  export type NewsThreadOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    title?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    items?: NewsThreadItemOrderByRelationAggregateInput
  }

  export type NewsThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsThreadWhereInput | NewsThreadWhereInput[]
    OR?: NewsThreadWhereInput[]
    NOT?: NewsThreadWhereInput | NewsThreadWhereInput[]
    status?: StringFilter<"NewsThread"> | string
    createdAt?: DateTimeFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableFilter<"NewsThread">
    scheduledAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    title?: StringFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableFilter<"NewsThread"> | Date | string | null
    items?: NewsThreadItemListRelationFilter
  }, "id">

  export type NewsThreadOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    title?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    _count?: NewsThreadCountOrderByAggregateInput
    _max?: NewsThreadMaxOrderByAggregateInput
    _min?: NewsThreadMinOrderByAggregateInput
  }

  export type NewsThreadScalarWhereWithAggregatesInput = {
    AND?: NewsThreadScalarWhereWithAggregatesInput | NewsThreadScalarWhereWithAggregatesInput[]
    OR?: NewsThreadScalarWhereWithAggregatesInput[]
    NOT?: NewsThreadScalarWhereWithAggregatesInput | NewsThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsThread"> | string
    status?: StringWithAggregatesFilter<"NewsThread"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsThread"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NewsThread">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"NewsThread"> | Date | string | null
    title?: StringWithAggregatesFilter<"NewsThread"> | string
    postedAt?: DateTimeNullableWithAggregatesFilter<"NewsThread"> | Date | string | null
  }

  export type NewsThreadItemWhereInput = {
    AND?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    OR?: NewsThreadItemWhereInput[]
    NOT?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    id?: StringFilter<"NewsThreadItem"> | string
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringFilter<"NewsThreadItem"> | string
    order?: IntFilter<"NewsThreadItem"> | number
    content?: StringNullableFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeFilter<"NewsThreadItem"> | Date | string
    thread?: XOR<NewsThreadRelationFilter, NewsThreadWhereInput>
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }

  export type NewsThreadItemOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    thread?: NewsThreadOrderByWithRelationInput
    article?: NewsArticleOrderByWithRelationInput
  }

  export type NewsThreadItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    OR?: NewsThreadItemWhereInput[]
    NOT?: NewsThreadItemWhereInput | NewsThreadItemWhereInput[]
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringFilter<"NewsThreadItem"> | string
    order?: IntFilter<"NewsThreadItem"> | number
    content?: StringNullableFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeFilter<"NewsThreadItem"> | Date | string
    thread?: XOR<NewsThreadRelationFilter, NewsThreadWhereInput>
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }, "id">

  export type NewsThreadItemOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NewsThreadItemCountOrderByAggregateInput
    _avg?: NewsThreadItemAvgOrderByAggregateInput
    _max?: NewsThreadItemMaxOrderByAggregateInput
    _min?: NewsThreadItemMinOrderByAggregateInput
    _sum?: NewsThreadItemSumOrderByAggregateInput
  }

  export type NewsThreadItemScalarWhereWithAggregatesInput = {
    AND?: NewsThreadItemScalarWhereWithAggregatesInput | NewsThreadItemScalarWhereWithAggregatesInput[]
    OR?: NewsThreadItemScalarWhereWithAggregatesInput[]
    NOT?: NewsThreadItemScalarWhereWithAggregatesInput | NewsThreadItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    threadId?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    articleId?: StringWithAggregatesFilter<"NewsThreadItem"> | string
    order?: IntWithAggregatesFilter<"NewsThreadItem"> | number
    content?: StringNullableWithAggregatesFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NewsThreadItem"> | Date | string
  }

  export type NewsAnalysisWhereInput = {
    AND?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    OR?: NewsAnalysisWhereInput[]
    NOT?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    id?: StringFilter<"NewsAnalysis"> | string
    articleId?: StringFilter<"NewsAnalysis"> | string
    summary?: StringFilter<"NewsAnalysis"> | string
    sentiment?: StringFilter<"NewsAnalysis"> | string
    keywords?: StringNullableListFilter<"NewsAnalysis">
    topics?: StringNullableListFilter<"NewsAnalysis">
    createdAt?: DateTimeFilter<"NewsAnalysis"> | Date | string
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }

  export type NewsAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    keywords?: SortOrder
    topics?: SortOrder
    createdAt?: SortOrder
    article?: NewsArticleOrderByWithRelationInput
  }

  export type NewsAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    articleId?: string
    AND?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    OR?: NewsAnalysisWhereInput[]
    NOT?: NewsAnalysisWhereInput | NewsAnalysisWhereInput[]
    summary?: StringFilter<"NewsAnalysis"> | string
    sentiment?: StringFilter<"NewsAnalysis"> | string
    keywords?: StringNullableListFilter<"NewsAnalysis">
    topics?: StringNullableListFilter<"NewsAnalysis">
    createdAt?: DateTimeFilter<"NewsAnalysis"> | Date | string
    article?: XOR<NewsArticleRelationFilter, NewsArticleWhereInput>
  }, "id" | "articleId">

  export type NewsAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    keywords?: SortOrder
    topics?: SortOrder
    createdAt?: SortOrder
    _count?: NewsAnalysisCountOrderByAggregateInput
    _max?: NewsAnalysisMaxOrderByAggregateInput
    _min?: NewsAnalysisMinOrderByAggregateInput
  }

  export type NewsAnalysisScalarWhereWithAggregatesInput = {
    AND?: NewsAnalysisScalarWhereWithAggregatesInput | NewsAnalysisScalarWhereWithAggregatesInput[]
    OR?: NewsAnalysisScalarWhereWithAggregatesInput[]
    NOT?: NewsAnalysisScalarWhereWithAggregatesInput | NewsAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    articleId?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    summary?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    sentiment?: StringWithAggregatesFilter<"NewsAnalysis"> | string
    keywords?: StringNullableListFilter<"NewsAnalysis">
    topics?: StringNullableListFilter<"NewsAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"NewsAnalysis"> | Date | string
  }

  export type JobQueueWhereInput = {
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    id?: StringFilter<"JobQueue"> | string
    type?: StringFilter<"JobQueue"> | string
    payload?: JsonFilter<"JobQueue">
    status?: StringFilter<"JobQueue"> | string
    priority?: IntFilter<"JobQueue"> | number
    attempts?: IntFilter<"JobQueue"> | number
    maxAttempts?: IntFilter<"JobQueue"> | number
    runAt?: DateTimeFilter<"JobQueue"> | Date | string
    completedAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    error?: StringNullableFilter<"JobQueue"> | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeFilter<"JobQueue"> | Date | string
  }

  export type JobQueueOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    type?: StringFilter<"JobQueue"> | string
    payload?: JsonFilter<"JobQueue">
    status?: StringFilter<"JobQueue"> | string
    priority?: IntFilter<"JobQueue"> | number
    attempts?: IntFilter<"JobQueue"> | number
    maxAttempts?: IntFilter<"JobQueue"> | number
    runAt?: DateTimeFilter<"JobQueue"> | Date | string
    completedAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    error?: StringNullableFilter<"JobQueue"> | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeFilter<"JobQueue"> | Date | string
  }, "id">

  export type JobQueueOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobQueueCountOrderByAggregateInput
    _avg?: JobQueueAvgOrderByAggregateInput
    _max?: JobQueueMaxOrderByAggregateInput
    _min?: JobQueueMinOrderByAggregateInput
    _sum?: JobQueueSumOrderByAggregateInput
  }

  export type JobQueueScalarWhereWithAggregatesInput = {
    AND?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    OR?: JobQueueScalarWhereWithAggregatesInput[]
    NOT?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobQueue"> | string
    type?: StringWithAggregatesFilter<"JobQueue"> | string
    payload?: JsonWithAggregatesFilter<"JobQueue">
    status?: StringWithAggregatesFilter<"JobQueue"> | string
    priority?: IntWithAggregatesFilter<"JobQueue"> | number
    attempts?: IntWithAggregatesFilter<"JobQueue"> | number
    maxAttempts?: IntWithAggregatesFilter<"JobQueue"> | number
    runAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"JobQueue"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"JobQueue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
  }

  export type CollectionPresetWhereInput = {
    AND?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    OR?: CollectionPresetWhereInput[]
    NOT?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    id?: StringFilter<"CollectionPreset"> | string
    name?: StringFilter<"CollectionPreset"> | string
    description?: StringNullableFilter<"CollectionPreset"> | string | null
    settings?: JsonFilter<"CollectionPreset">
    isActive?: BoolFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionPreset"> | Date | string
  }

  export type CollectionPresetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    OR?: CollectionPresetWhereInput[]
    NOT?: CollectionPresetWhereInput | CollectionPresetWhereInput[]
    name?: StringFilter<"CollectionPreset"> | string
    description?: StringNullableFilter<"CollectionPreset"> | string | null
    settings?: JsonFilter<"CollectionPreset">
    isActive?: BoolFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionPreset"> | Date | string
  }, "id">

  export type CollectionPresetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionPresetCountOrderByAggregateInput
    _max?: CollectionPresetMaxOrderByAggregateInput
    _min?: CollectionPresetMinOrderByAggregateInput
  }

  export type CollectionPresetScalarWhereWithAggregatesInput = {
    AND?: CollectionPresetScalarWhereWithAggregatesInput | CollectionPresetScalarWhereWithAggregatesInput[]
    OR?: CollectionPresetScalarWhereWithAggregatesInput[]
    NOT?: CollectionPresetScalarWhereWithAggregatesInput | CollectionPresetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionPreset"> | string
    name?: StringWithAggregatesFilter<"CollectionPreset"> | string
    description?: StringNullableWithAggregatesFilter<"CollectionPreset"> | string | null
    settings?: JsonWithAggregatesFilter<"CollectionPreset">
    isActive?: BoolWithAggregatesFilter<"CollectionPreset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CollectionPreset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionPreset"> | Date | string
  }

  export type WatchlistUserWhereInput = {
    AND?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    OR?: WatchlistUserWhereInput[]
    NOT?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    id?: StringFilter<"WatchlistUser"> | string
    userId?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    followers?: IntNullableFilter<"WatchlistUser"> | number | null
    following?: IntNullableFilter<"WatchlistUser"> | number | null
    isActive?: BoolFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchlistUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tweets?: WatchlistTweetListRelationFilter
    interactions?: InteractionHistoryListRelationFilter
  }

  export type WatchlistUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrderInput | SortOrder
    following?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tweets?: WatchlistTweetOrderByRelationAggregateInput
    interactions?: InteractionHistoryOrderByRelationAggregateInput
  }

  export type WatchlistUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_twitterId?: WatchlistUserUserIdTwitterIdCompoundUniqueInput
    AND?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    OR?: WatchlistUserWhereInput[]
    NOT?: WatchlistUserWhereInput | WatchlistUserWhereInput[]
    userId?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    followers?: IntNullableFilter<"WatchlistUser"> | number | null
    following?: IntNullableFilter<"WatchlistUser"> | number | null
    isActive?: BoolFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchlistUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tweets?: WatchlistTweetListRelationFilter
    interactions?: InteractionHistoryListRelationFilter
  }, "id" | "userId_twitterId">

  export type WatchlistUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrderInput | SortOrder
    following?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WatchlistUserCountOrderByAggregateInput
    _avg?: WatchlistUserAvgOrderByAggregateInput
    _max?: WatchlistUserMaxOrderByAggregateInput
    _min?: WatchlistUserMinOrderByAggregateInput
    _sum?: WatchlistUserSumOrderByAggregateInput
  }

  export type WatchlistUserScalarWhereWithAggregatesInput = {
    AND?: WatchlistUserScalarWhereWithAggregatesInput | WatchlistUserScalarWhereWithAggregatesInput[]
    OR?: WatchlistUserScalarWhereWithAggregatesInput[]
    NOT?: WatchlistUserScalarWhereWithAggregatesInput | WatchlistUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistUser"> | string
    userId?: StringWithAggregatesFilter<"WatchlistUser"> | string
    twitterId?: StringWithAggregatesFilter<"WatchlistUser"> | string
    username?: StringWithAggregatesFilter<"WatchlistUser"> | string
    displayName?: StringWithAggregatesFilter<"WatchlistUser"> | string
    followers?: IntNullableWithAggregatesFilter<"WatchlistUser"> | number | null
    following?: IntNullableWithAggregatesFilter<"WatchlistUser"> | number | null
    isActive?: BoolWithAggregatesFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableWithAggregatesFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WatchlistUser"> | Date | string
  }

  export type WatchlistTweetWhereInput = {
    AND?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    OR?: WatchlistTweetWhereInput[]
    NOT?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    id?: StringFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    tweetId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntFilter<"WatchlistTweet"> | number
    likeCount?: IntFilter<"WatchlistTweet"> | number
    replyCount?: IntFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }

  export type WatchlistTweetOrderByWithRelationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
    watchlistUser?: WatchlistUserOrderByWithRelationInput
  }

  export type WatchlistTweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tweetId?: string
    AND?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    OR?: WatchlistTweetWhereInput[]
    NOT?: WatchlistTweetWhereInput | WatchlistTweetWhereInput[]
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntFilter<"WatchlistTweet"> | number
    likeCount?: IntFilter<"WatchlistTweet"> | number
    replyCount?: IntFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }, "id" | "tweetId">

  export type WatchlistTweetOrderByWithAggregationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
    _count?: WatchlistTweetCountOrderByAggregateInput
    _avg?: WatchlistTweetAvgOrderByAggregateInput
    _max?: WatchlistTweetMaxOrderByAggregateInput
    _min?: WatchlistTweetMinOrderByAggregateInput
    _sum?: WatchlistTweetSumOrderByAggregateInput
  }

  export type WatchlistTweetScalarWhereWithAggregatesInput = {
    AND?: WatchlistTweetScalarWhereWithAggregatesInput | WatchlistTweetScalarWhereWithAggregatesInput[]
    OR?: WatchlistTweetScalarWhereWithAggregatesInput[]
    NOT?: WatchlistTweetScalarWhereWithAggregatesInput | WatchlistTweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    tweetId?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    content?: StringWithAggregatesFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    likeCount?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    replyCount?: IntWithAggregatesFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeWithAggregatesFilter<"WatchlistTweet"> | Date | string
  }

  export type InteractionHistoryWhereInput = {
    AND?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    OR?: InteractionHistoryWhereInput[]
    NOT?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    id?: StringFilter<"InteractionHistory"> | string
    watchlistUserId?: StringFilter<"InteractionHistory"> | string
    interactionType?: StringFilter<"InteractionHistory"> | string
    tweetId?: StringNullableFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableFilter<"InteractionHistory">
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }

  export type InteractionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    watchlistUser?: WatchlistUserOrderByWithRelationInput
  }

  export type InteractionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    OR?: InteractionHistoryWhereInput[]
    NOT?: InteractionHistoryWhereInput | InteractionHistoryWhereInput[]
    watchlistUserId?: StringFilter<"InteractionHistory"> | string
    interactionType?: StringFilter<"InteractionHistory"> | string
    tweetId?: StringNullableFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableFilter<"InteractionHistory">
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
    watchlistUser?: XOR<WatchlistUserRelationFilter, WatchlistUserWhereInput>
  }, "id">

  export type InteractionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InteractionHistoryCountOrderByAggregateInput
    _max?: InteractionHistoryMaxOrderByAggregateInput
    _min?: InteractionHistoryMinOrderByAggregateInput
  }

  export type InteractionHistoryScalarWhereWithAggregatesInput = {
    AND?: InteractionHistoryScalarWhereWithAggregatesInput | InteractionHistoryScalarWhereWithAggregatesInput[]
    OR?: InteractionHistoryScalarWhereWithAggregatesInput[]
    NOT?: InteractionHistoryScalarWhereWithAggregatesInput | InteractionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InteractionHistory"> | string
    watchlistUserId?: StringWithAggregatesFilter<"InteractionHistory"> | string
    interactionType?: StringWithAggregatesFilter<"InteractionHistory"> | string
    tweetId?: StringNullableWithAggregatesFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"InteractionHistory">
    createdAt?: DateTimeWithAggregatesFilter<"InteractionHistory"> | Date | string
  }

  export type PerplexityReportWhereInput = {
    AND?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    OR?: PerplexityReportWhereInput[]
    NOT?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    id?: StringFilter<"PerplexityReport"> | string
    query?: StringFilter<"PerplexityReport"> | string
    focus?: StringFilter<"PerplexityReport"> | string
    rawAnalysis?: StringFilter<"PerplexityReport"> | string
    trends?: JsonFilter<"PerplexityReport">
    insights?: JsonFilter<"PerplexityReport">
    contentAngles?: JsonFilter<"PerplexityReport">
    marketContext?: JsonFilter<"PerplexityReport">
    competitorActivity?: JsonFilter<"PerplexityReport">
    riskFactors?: JsonFilter<"PerplexityReport">
    createdAt?: DateTimeFilter<"PerplexityReport"> | Date | string
  }

  export type PerplexityReportOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    contentAngles?: SortOrder
    marketContext?: SortOrder
    competitorActivity?: SortOrder
    riskFactors?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    OR?: PerplexityReportWhereInput[]
    NOT?: PerplexityReportWhereInput | PerplexityReportWhereInput[]
    query?: StringFilter<"PerplexityReport"> | string
    focus?: StringFilter<"PerplexityReport"> | string
    rawAnalysis?: StringFilter<"PerplexityReport"> | string
    trends?: JsonFilter<"PerplexityReport">
    insights?: JsonFilter<"PerplexityReport">
    contentAngles?: JsonFilter<"PerplexityReport">
    marketContext?: JsonFilter<"PerplexityReport">
    competitorActivity?: JsonFilter<"PerplexityReport">
    riskFactors?: JsonFilter<"PerplexityReport">
    createdAt?: DateTimeFilter<"PerplexityReport"> | Date | string
  }, "id">

  export type PerplexityReportOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    contentAngles?: SortOrder
    marketContext?: SortOrder
    competitorActivity?: SortOrder
    riskFactors?: SortOrder
    createdAt?: SortOrder
    _count?: PerplexityReportCountOrderByAggregateInput
    _max?: PerplexityReportMaxOrderByAggregateInput
    _min?: PerplexityReportMinOrderByAggregateInput
  }

  export type PerplexityReportScalarWhereWithAggregatesInput = {
    AND?: PerplexityReportScalarWhereWithAggregatesInput | PerplexityReportScalarWhereWithAggregatesInput[]
    OR?: PerplexityReportScalarWhereWithAggregatesInput[]
    NOT?: PerplexityReportScalarWhereWithAggregatesInput | PerplexityReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerplexityReport"> | string
    query?: StringWithAggregatesFilter<"PerplexityReport"> | string
    focus?: StringWithAggregatesFilter<"PerplexityReport"> | string
    rawAnalysis?: StringWithAggregatesFilter<"PerplexityReport"> | string
    trends?: JsonWithAggregatesFilter<"PerplexityReport">
    insights?: JsonWithAggregatesFilter<"PerplexityReport">
    contentAngles?: JsonWithAggregatesFilter<"PerplexityReport">
    marketContext?: JsonWithAggregatesFilter<"PerplexityReport">
    competitorActivity?: JsonWithAggregatesFilter<"PerplexityReport">
    riskFactors?: JsonWithAggregatesFilter<"PerplexityReport">
    createdAt?: DateTimeWithAggregatesFilter<"PerplexityReport"> | Date | string
  }

  export type CotSessionWhereInput = {
    AND?: CotSessionWhereInput | CotSessionWhereInput[]
    OR?: CotSessionWhereInput[]
    NOT?: CotSessionWhereInput | CotSessionWhereInput[]
    id?: StringFilter<"CotSession"> | string
    expertise?: StringFilter<"CotSession"> | string
    style?: StringFilter<"CotSession"> | string
    platform?: StringFilter<"CotSession"> | string
    status?: EnumCotSessionStatusFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableFilter<"CotSession"> | string | null
    retryCount?: IntFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    totalTokens?: IntFilter<"CotSession"> | number
    totalDuration?: IntFilter<"CotSession"> | number
    createdAt?: DateTimeFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    phases?: CotPhaseListRelationFilter
    drafts?: CotDraftListRelationFilter
  }

  export type CotSessionOrderByWithRelationInput = {
    id?: SortOrder
    expertise?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    phases?: CotPhaseOrderByRelationAggregateInput
    drafts?: CotDraftOrderByRelationAggregateInput
  }

  export type CotSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CotSessionWhereInput | CotSessionWhereInput[]
    OR?: CotSessionWhereInput[]
    NOT?: CotSessionWhereInput | CotSessionWhereInput[]
    expertise?: StringFilter<"CotSession"> | string
    style?: StringFilter<"CotSession"> | string
    platform?: StringFilter<"CotSession"> | string
    status?: EnumCotSessionStatusFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableFilter<"CotSession"> | string | null
    retryCount?: IntFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    totalTokens?: IntFilter<"CotSession"> | number
    totalDuration?: IntFilter<"CotSession"> | number
    createdAt?: DateTimeFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"CotSession"> | Date | string | null
    phases?: CotPhaseListRelationFilter
    drafts?: CotDraftListRelationFilter
  }, "id">

  export type CotSessionOrderByWithAggregationInput = {
    id?: SortOrder
    expertise?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CotSessionCountOrderByAggregateInput
    _avg?: CotSessionAvgOrderByAggregateInput
    _max?: CotSessionMaxOrderByAggregateInput
    _min?: CotSessionMinOrderByAggregateInput
    _sum?: CotSessionSumOrderByAggregateInput
  }

  export type CotSessionScalarWhereWithAggregatesInput = {
    AND?: CotSessionScalarWhereWithAggregatesInput | CotSessionScalarWhereWithAggregatesInput[]
    OR?: CotSessionScalarWhereWithAggregatesInput[]
    NOT?: CotSessionScalarWhereWithAggregatesInput | CotSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotSession"> | string
    expertise?: StringWithAggregatesFilter<"CotSession"> | string
    style?: StringWithAggregatesFilter<"CotSession"> | string
    platform?: StringWithAggregatesFilter<"CotSession"> | string
    status?: EnumCotSessionStatusWithAggregatesFilter<"CotSession"> | $Enums.CotSessionStatus
    currentPhase?: IntWithAggregatesFilter<"CotSession"> | number
    currentStep?: EnumCotPhaseStepWithAggregatesFilter<"CotSession"> | $Enums.CotPhaseStep
    lastError?: StringNullableWithAggregatesFilter<"CotSession"> | string | null
    retryCount?: IntWithAggregatesFilter<"CotSession"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"CotSession"> | Date | string | null
    totalTokens?: IntWithAggregatesFilter<"CotSession"> | number
    totalDuration?: IntWithAggregatesFilter<"CotSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CotSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CotSession"> | Date | string | null
  }

  export type CotPhaseWhereInput = {
    AND?: CotPhaseWhereInput | CotPhaseWhereInput[]
    OR?: CotPhaseWhereInput[]
    NOT?: CotPhaseWhereInput | CotPhaseWhereInput[]
    id?: StringFilter<"CotPhase"> | string
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
  }

  export type CotPhaseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrderInput | SortOrder
    thinkResult?: SortOrderInput | SortOrder
    thinkTokens?: SortOrderInput | SortOrder
    thinkAt?: SortOrderInput | SortOrder
    executeResult?: SortOrderInput | SortOrder
    executeDuration?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    integratePrompt?: SortOrderInput | SortOrder
    integrateResult?: SortOrderInput | SortOrder
    integrateTokens?: SortOrderInput | SortOrder
    integrateAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: CotSessionOrderByWithRelationInput
  }

  export type CotPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_phaseNumber?: CotPhaseSessionIdPhaseNumberCompoundUniqueInput
    AND?: CotPhaseWhereInput | CotPhaseWhereInput[]
    OR?: CotPhaseWhereInput[]
    NOT?: CotPhaseWhereInput | CotPhaseWhereInput[]
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
  }, "id" | "sessionId_phaseNumber">

  export type CotPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrderInput | SortOrder
    thinkResult?: SortOrderInput | SortOrder
    thinkTokens?: SortOrderInput | SortOrder
    thinkAt?: SortOrderInput | SortOrder
    executeResult?: SortOrderInput | SortOrder
    executeDuration?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    integratePrompt?: SortOrderInput | SortOrder
    integrateResult?: SortOrderInput | SortOrder
    integrateTokens?: SortOrderInput | SortOrder
    integrateAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CotPhaseCountOrderByAggregateInput
    _avg?: CotPhaseAvgOrderByAggregateInput
    _max?: CotPhaseMaxOrderByAggregateInput
    _min?: CotPhaseMinOrderByAggregateInput
    _sum?: CotPhaseSumOrderByAggregateInput
  }

  export type CotPhaseScalarWhereWithAggregatesInput = {
    AND?: CotPhaseScalarWhereWithAggregatesInput | CotPhaseScalarWhereWithAggregatesInput[]
    OR?: CotPhaseScalarWhereWithAggregatesInput[]
    NOT?: CotPhaseScalarWhereWithAggregatesInput | CotPhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotPhase"> | string
    sessionId?: StringWithAggregatesFilter<"CotPhase"> | string
    phaseNumber?: IntWithAggregatesFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableWithAggregatesFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    thinkTokens?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    executeDuration?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableWithAggregatesFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableWithAggregatesFilter<"CotPhase">
    integrateTokens?: IntNullableWithAggregatesFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableWithAggregatesFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusWithAggregatesFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotPhase"> | Date | string
  }

  export type CotDraftWhereInput = {
    AND?: CotDraftWhereInput | CotDraftWhereInput[]
    OR?: CotDraftWhereInput[]
    NOT?: CotDraftWhereInput | CotDraftWhereInput[]
    id?: StringFilter<"CotDraft"> | string
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
    performance?: XOR<CotDraftPerformanceNullableRelationFilter, CotDraftPerformanceWhereInput> | null
  }

  export type CotDraftOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    visualGuide?: SortOrderInput | SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    kpis?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    optimizationTips?: SortOrderInput | SortOrder
    status?: SortOrder
    editedContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: CotSessionOrderByWithRelationInput
    performance?: CotDraftPerformanceOrderByWithRelationInput
  }

  export type CotDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_conceptNumber?: CotDraftSessionIdConceptNumberCompoundUniqueInput
    AND?: CotDraftWhereInput | CotDraftWhereInput[]
    OR?: CotDraftWhereInput[]
    NOT?: CotDraftWhereInput | CotDraftWhereInput[]
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
    session?: XOR<CotSessionRelationFilter, CotSessionWhereInput>
    performance?: XOR<CotDraftPerformanceNullableRelationFilter, CotDraftPerformanceWhereInput> | null
  }, "id" | "sessionId_conceptNumber">

  export type CotDraftOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    visualGuide?: SortOrderInput | SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    kpis?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    optimizationTips?: SortOrderInput | SortOrder
    status?: SortOrder
    editedContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    postedAt?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    viralScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CotDraftCountOrderByAggregateInput
    _avg?: CotDraftAvgOrderByAggregateInput
    _max?: CotDraftMaxOrderByAggregateInput
    _min?: CotDraftMinOrderByAggregateInput
    _sum?: CotDraftSumOrderByAggregateInput
  }

  export type CotDraftScalarWhereWithAggregatesInput = {
    AND?: CotDraftScalarWhereWithAggregatesInput | CotDraftScalarWhereWithAggregatesInput[]
    OR?: CotDraftScalarWhereWithAggregatesInput[]
    NOT?: CotDraftScalarWhereWithAggregatesInput | CotDraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotDraft"> | string
    sessionId?: StringWithAggregatesFilter<"CotDraft"> | string
    conceptNumber?: IntWithAggregatesFilter<"CotDraft"> | number
    title?: StringWithAggregatesFilter<"CotDraft"> | string
    hook?: StringWithAggregatesFilter<"CotDraft"> | string
    angle?: StringWithAggregatesFilter<"CotDraft"> | string
    format?: StringWithAggregatesFilter<"CotDraft"> | string
    content?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    timing?: StringWithAggregatesFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    kpis?: JsonNullableWithAggregatesFilter<"CotDraft">
    riskAssessment?: JsonNullableWithAggregatesFilter<"CotDraft">
    optimizationTips?: JsonNullableWithAggregatesFilter<"CotDraft">
    status?: EnumCotDraftStatusWithAggregatesFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableWithAggregatesFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableWithAggregatesFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableWithAggregatesFilter<"CotDraft"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CotDraft"> | Date | string
  }

  export type CotDraftPerformanceWhereInput = {
    AND?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    OR?: CotDraftPerformanceWhereInput[]
    NOT?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    id?: StringFilter<"CotDraftPerformance"> | string
    draftId?: StringFilter<"CotDraftPerformance"> | string
    likes30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    draft?: XOR<CotDraftRelationFilter, CotDraftWhereInput>
  }

  export type CotDraftPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
    draft?: CotDraftOrderByWithRelationInput
  }

  export type CotDraftPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId?: string
    AND?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    OR?: CotDraftPerformanceWhereInput[]
    NOT?: CotDraftPerformanceWhereInput | CotDraftPerformanceWhereInput[]
    likes30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeFilter<"CotDraftPerformance"> | Date | string
    draft?: XOR<CotDraftRelationFilter, CotDraftWhereInput>
  }, "id" | "draftId">

  export type CotDraftPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrderInput | SortOrder
    retweets30m?: SortOrderInput | SortOrder
    replies30m?: SortOrderInput | SortOrder
    impressions30m?: SortOrderInput | SortOrder
    likes1h?: SortOrderInput | SortOrder
    retweets1h?: SortOrderInput | SortOrder
    replies1h?: SortOrderInput | SortOrder
    impressions1h?: SortOrderInput | SortOrder
    likes24h?: SortOrderInput | SortOrder
    retweets24h?: SortOrderInput | SortOrder
    replies24h?: SortOrderInput | SortOrder
    impressions24h?: SortOrderInput | SortOrder
    engagementRate?: SortOrderInput | SortOrder
    viralCoefficient?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
    _count?: CotDraftPerformanceCountOrderByAggregateInput
    _avg?: CotDraftPerformanceAvgOrderByAggregateInput
    _max?: CotDraftPerformanceMaxOrderByAggregateInput
    _min?: CotDraftPerformanceMinOrderByAggregateInput
    _sum?: CotDraftPerformanceSumOrderByAggregateInput
  }

  export type CotDraftPerformanceScalarWhereWithAggregatesInput = {
    AND?: CotDraftPerformanceScalarWhereWithAggregatesInput | CotDraftPerformanceScalarWhereWithAggregatesInput[]
    OR?: CotDraftPerformanceScalarWhereWithAggregatesInput[]
    NOT?: CotDraftPerformanceScalarWhereWithAggregatesInput | CotDraftPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CotDraftPerformance"> | string
    draftId?: StringWithAggregatesFilter<"CotDraftPerformance"> | string
    likes30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions30m?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    likes1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions1h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    likes24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    retweets24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    replies24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    impressions24h?: IntNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    engagementRate?: FloatNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    viralCoefficient?: FloatNullableWithAggregatesFilter<"CotDraftPerformance"> | number | null
    collectedAt?: DateTimeWithAggregatesFilter<"CotDraftPerformance"> | Date | string
    lastUpdateAt?: DateTimeWithAggregatesFilter<"CotDraftPerformance"> | Date | string
  }

  export type BuzzPostCreateInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
    scheduledPosts?: ScheduledPostCreateNestedManyWithoutRefPostInput
  }

  export type BuzzPostUncheckedCreateInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
    scheduledPosts?: ScheduledPostUncheckedCreateNestedManyWithoutRefPostInput
  }

  export type BuzzPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduledPosts?: ScheduledPostUpdateManyWithoutRefPostNestedInput
  }

  export type BuzzPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduledPosts?: ScheduledPostUncheckedUpdateManyWithoutRefPostNestedInput
  }

  export type BuzzPostCreateManyInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ScheduledPostCreateInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    refPost?: BuzzPostCreateNestedOneWithoutScheduledPostsInput
  }

  export type ScheduledPostUncheckedCreateInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refPost?: BuzzPostUpdateOneWithoutScheduledPostsNestedInput
  }

  export type ScheduledPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostCreateManyInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    refPostId?: string | null
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    refPostId?: NullableStringFieldUpdateOperationsInput | string | null
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateInput = {
    id?: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt?: Date | string
  }

  export type PostAnalyticsUncheckedCreateInput = {
    id?: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt?: Date | string
  }

  export type PostAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateManyInput = {
    id?: string
    postId: string
    impressions: number
    engagements: number
    likes: number
    retweets: number
    replies: number
    profileClicks: number
    urlClicks: number
    detailExpands: number
    engagementRate: number
    collectedAt?: Date | string
  }

  export type PostAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    impressions?: IntFieldUpdateOperationsInput | number
    engagements?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    replies?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    urlClicks?: IntFieldUpdateOperationsInput | number
    detailExpands?: IntFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceCreateInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
    articles?: NewsArticleCreateNestedManyWithoutSourceInput
  }

  export type NewsSourceUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
    articles?: NewsArticleUncheckedCreateNestedManyWithoutSourceInput
  }

  export type NewsSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: NewsArticleUpdateManyWithoutSourceNestedInput
  }

  export type NewsSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: NewsArticleUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type NewsSourceCreateManyInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
  }

  export type NewsSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleCreateInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleCreateManyInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsThreadCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
    items?: NewsThreadItemCreateNestedManyWithoutThreadInput
  }

  export type NewsThreadUncheckedCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
    items?: NewsThreadItemUncheckedCreateNestedManyWithoutThreadInput
  }

  export type NewsThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: NewsThreadItemUpdateManyWithoutThreadNestedInput
  }

  export type NewsThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: NewsThreadItemUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type NewsThreadCreateManyInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadItemCreateInput = {
    id?: string
    order: number
    content?: string | null
    createdAt?: Date | string
    thread: NewsThreadCreateNestedOneWithoutItemsInput
    article: NewsArticleCreateNestedOneWithoutNewsThreadItemsInput
  }

  export type NewsThreadItemUncheckedCreateInput = {
    id?: string
    threadId: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: NewsThreadUpdateOneRequiredWithoutItemsNestedInput
    article?: NewsArticleUpdateOneRequiredWithoutNewsThreadItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemCreateManyInput = {
    id?: string
    threadId: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisCreateInput = {
    id?: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
    article: NewsArticleCreateNestedOneWithoutAnalysisInput
  }

  export type NewsAnalysisUncheckedCreateInput = {
    id?: string
    articleId: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: NewsArticleUpdateOneRequiredWithoutAnalysisNestedInput
  }

  export type NewsAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisCreateManyInput = {
    id?: string
    articleId: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    runAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUncheckedCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    runAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueCreateManyInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    runAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetCreateInput = {
    id?: string
    name: string
    description?: string | null
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionPresetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionPresetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserCreateInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistUsersInput
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserCreateManyInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
  }

  export type WatchlistUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetCreateInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
    watchlistUser: WatchlistUserCreateNestedOneWithoutTweetsInput
  }

  export type WatchlistTweetUncheckedCreateInput = {
    id?: string
    watchlistUserId: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUser?: WatchlistUserUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type WatchlistTweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetCreateManyInput = {
    id?: string
    watchlistUserId: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryCreateInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    watchlistUser: WatchlistUserCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionHistoryUncheckedCreateInput = {
    id?: string
    watchlistUserId: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUser?: WatchlistUserUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryCreateManyInput = {
    id?: string
    watchlistUserId: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistUserId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportCreateInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    contentAngles: JsonNullValueInput | InputJsonValue
    marketContext: JsonNullValueInput | InputJsonValue
    competitorActivity: JsonNullValueInput | InputJsonValue
    riskFactors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUncheckedCreateInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    contentAngles: JsonNullValueInput | InputJsonValue
    marketContext: JsonNullValueInput | InputJsonValue
    competitorActivity: JsonNullValueInput | InputJsonValue
    riskFactors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportCreateManyInput = {
    id?: string
    query: string
    focus: string
    rawAnalysis: string
    trends: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    contentAngles: JsonNullValueInput | InputJsonValue
    marketContext: JsonNullValueInput | InputJsonValue
    competitorActivity: JsonNullValueInput | InputJsonValue
    riskFactors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PerplexityReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerplexityReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    rawAnalysis?: StringFieldUpdateOperationsInput | string
    trends?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    contentAngles?: JsonNullValueInput | InputJsonValue
    marketContext?: JsonNullValueInput | InputJsonValue
    competitorActivity?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotSessionCreateInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseCreateNestedManyWithoutSessionInput
    drafts?: CotDraftCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseUncheckedCreateNestedManyWithoutSessionInput
    drafts?: CotDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUpdateManyWithoutSessionNestedInput
    drafts?: CotDraftUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUncheckedUpdateManyWithoutSessionNestedInput
    drafts?: CotDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionCreateManyInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CotSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CotSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CotPhaseCreateInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutPhasesInput
  }

  export type CotPhaseUncheckedCreateInput = {
    id?: string
    sessionId: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type CotPhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseCreateManyInput = {
    id?: string
    sessionId: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftCreateInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutDraftsInput
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type CotDraftUncheckedCreateInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type CotDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftCreateManyInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceCreateInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
    draft: CotDraftCreateNestedOneWithoutPerformanceInput
  }

  export type CotDraftPerformanceUncheckedCreateInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: CotDraftUpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type CotDraftPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceCreateManyInput = {
    id?: string
    draftId: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ScheduledPostListRelationFilter = {
    every?: ScheduledPostWhereInput
    some?: ScheduledPostWhereInput
    none?: ScheduledPostWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ScheduledPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuzzPostCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    mediaUrls?: SortOrder
    hashtags?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostAvgOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
  }

  export type BuzzPostMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    authorUsername?: SortOrder
    authorId?: SortOrder
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    postedAt?: SortOrder
    collectedAt?: SortOrder
    url?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    chromaId?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
    authorVerified?: SortOrder
  }

  export type BuzzPostSumOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetsCount?: SortOrder
    repliesCount?: SortOrder
    impressionsCount?: SortOrder
    authorFollowers?: SortOrder
    authorFollowing?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BuzzPostNullableRelationFilter = {
    is?: BuzzPostWhereInput | null
    isNot?: BuzzPostWhereInput | null
  }

  export type ScheduledPostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    postResult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    scheduledTime?: SortOrder
    status?: SortOrder
    postType?: SortOrder
    refPostId?: SortOrder
    templateType?: SortOrder
    aiGenerated?: SortOrder
    aiPrompt?: SortOrder
    editedContent?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PostAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsAvgOrderByAggregateInput = {
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
  }

  export type PostAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
    collectedAt?: SortOrder
  }

  export type PostAnalyticsSumOrderByAggregateInput = {
    impressions?: SortOrder
    engagements?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    replies?: SortOrder
    profileClicks?: SortOrder
    urlClicks?: SortOrder
    detailExpands?: SortOrder
    engagementRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type WatchlistUserListRelationFilter = {
    every?: WatchlistUserWhereInput
    some?: WatchlistUserWhereInput
    none?: WatchlistUserWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type NewsArticleListRelationFilter = {
    every?: NewsArticleWhereInput
    some?: NewsArticleWhereInput
    none?: NewsArticleWhereInput
  }

  export type NewsArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsSourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    rssUrl?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    lastFetched?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NewsAnalysisNullableRelationFilter = {
    is?: NewsAnalysisWhereInput | null
    isNot?: NewsAnalysisWhereInput | null
  }

  export type NewsSourceRelationFilter = {
    is?: NewsSourceWhereInput
    isNot?: NewsSourceWhereInput
  }

  export type NewsThreadItemListRelationFilter = {
    every?: NewsThreadItemWhereInput
    some?: NewsThreadItemWhereInput
    none?: NewsThreadItemWhereInput
  }

  export type NewsThreadItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsArticleCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type NewsArticleAvgOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type NewsArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    importance?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleSumOrderByAggregateInput = {
    importance?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NewsThreadCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    title?: SortOrder
    postedAt?: SortOrder
  }

  export type NewsThreadRelationFilter = {
    is?: NewsThreadWhereInput
    isNot?: NewsThreadWhereInput
  }

  export type NewsArticleRelationFilter = {
    is?: NewsArticleWhereInput
    isNot?: NewsArticleWhereInput
  }

  export type NewsThreadItemCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsThreadItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NewsThreadItemMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsThreadItemMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    articleId?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsThreadItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NewsAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    keywords?: SortOrder
    topics?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
  }

  export type JobQueueCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueAvgOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type JobQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    runAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobQueueSumOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CollectionPresetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionPresetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchlistTweetListRelationFilter = {
    every?: WatchlistTweetWhereInput
    some?: WatchlistTweetWhereInput
    none?: WatchlistTweetWhereInput
  }

  export type InteractionHistoryListRelationFilter = {
    every?: InteractionHistoryWhereInput
    some?: InteractionHistoryWhereInput
    none?: InteractionHistoryWhereInput
  }

  export type WatchlistTweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistUserUserIdTwitterIdCompoundUniqueInput = {
    userId: string
    twitterId: string
  }

  export type WatchlistUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchlistUserAvgOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
  }

  export type WatchlistUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchlistUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    twitterId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    isActive?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchlistUserSumOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
  }

  export type WatchlistUserRelationFilter = {
    is?: WatchlistUserWhereInput
    isNot?: WatchlistUserWhereInput
  }

  export type WatchlistTweetCountOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
  }

  export type WatchlistTweetAvgOrderByAggregateInput = {
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
  }

  export type WatchlistTweetMaxOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
  }

  export type WatchlistTweetMinOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    tweetId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
    collectedAt?: SortOrder
  }

  export type WatchlistTweetSumOrderByAggregateInput = {
    retweetCount?: SortOrder
    likeCount?: SortOrder
    replyCount?: SortOrder
  }

  export type InteractionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    watchlistUserId?: SortOrder
    interactionType?: SortOrder
    tweetId?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    trends?: SortOrder
    insights?: SortOrder
    contentAngles?: SortOrder
    marketContext?: SortOrder
    competitorActivity?: SortOrder
    riskFactors?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    createdAt?: SortOrder
  }

  export type PerplexityReportMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    focus?: SortOrder
    rawAnalysis?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCotSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusFilter<$PrismaModel> | $Enums.CotSessionStatus
  }

  export type EnumCotPhaseStepFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepFilter<$PrismaModel> | $Enums.CotPhaseStep
  }

  export type CotPhaseListRelationFilter = {
    every?: CotPhaseWhereInput
    some?: CotPhaseWhereInput
    none?: CotPhaseWhereInput
  }

  export type CotDraftListRelationFilter = {
    every?: CotDraftWhereInput
    some?: CotDraftWhereInput
    none?: CotDraftWhereInput
  }

  export type CotPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotDraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CotSessionCountOrderByAggregateInput = {
    id?: SortOrder
    expertise?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionAvgOrderByAggregateInput = {
    currentPhase?: SortOrder
    retryCount?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
  }

  export type CotSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expertise?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionMinOrderByAggregateInput = {
    id?: SortOrder
    expertise?: SortOrder
    style?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    currentStep?: SortOrder
    lastError?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CotSessionSumOrderByAggregateInput = {
    currentPhase?: SortOrder
    retryCount?: SortOrder
    totalTokens?: SortOrder
    totalDuration?: SortOrder
  }

  export type EnumCotSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCotSessionStatusFilter<$PrismaModel>
  }

  export type EnumCotPhaseStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStepFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStepFilter<$PrismaModel>
  }

  export type EnumCotPhaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusFilter<$PrismaModel> | $Enums.CotPhaseStatus
  }

  export type CotSessionRelationFilter = {
    is?: CotSessionWhereInput
    isNot?: CotSessionWhereInput
  }

  export type CotPhaseSessionIdPhaseNumberCompoundUniqueInput = {
    sessionId: string
    phaseNumber: number
  }

  export type CotPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkResult?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeResult?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateResult?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseAvgOrderByAggregateInput = {
    phaseNumber?: SortOrder
    thinkTokens?: SortOrder
    executeDuration?: SortOrder
    integrateTokens?: SortOrder
  }

  export type CotPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phaseNumber?: SortOrder
    thinkPrompt?: SortOrder
    thinkTokens?: SortOrder
    thinkAt?: SortOrder
    executeDuration?: SortOrder
    executeAt?: SortOrder
    integratePrompt?: SortOrder
    integrateTokens?: SortOrder
    integrateAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotPhaseSumOrderByAggregateInput = {
    phaseNumber?: SortOrder
    thinkTokens?: SortOrder
    executeDuration?: SortOrder
    integrateTokens?: SortOrder
  }

  export type EnumCotPhaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
  }

  export type EnumCotDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusFilter<$PrismaModel> | $Enums.CotDraftStatus
  }

  export type CotDraftPerformanceNullableRelationFilter = {
    is?: CotDraftPerformanceWhereInput | null
    isNot?: CotDraftPerformanceWhereInput | null
  }

  export type CotDraftSessionIdConceptNumberCompoundUniqueInput = {
    sessionId: string
    conceptNumber: number
  }

  export type CotDraftCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    hashtags?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    kpis?: SortOrder
    riskAssessment?: SortOrder
    optimizationTips?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftAvgOrderByAggregateInput = {
    conceptNumber?: SortOrder
    viralScore?: SortOrder
  }

  export type CotDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conceptNumber?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    angle?: SortOrder
    format?: SortOrder
    content?: SortOrder
    visualGuide?: SortOrder
    timing?: SortOrder
    newsSource?: SortOrder
    sourceUrl?: SortOrder
    status?: SortOrder
    editedContent?: SortOrder
    scheduledAt?: SortOrder
    postedAt?: SortOrder
    postId?: SortOrder
    viralScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CotDraftSumOrderByAggregateInput = {
    conceptNumber?: SortOrder
    viralScore?: SortOrder
  }

  export type EnumCotDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotDraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumCotDraftStatusFilter<$PrismaModel>
  }

  export type CotDraftRelationFilter = {
    is?: CotDraftWhereInput
    isNot?: CotDraftWhereInput
  }

  export type CotDraftPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceAvgOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type CotDraftPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
    collectedAt?: SortOrder
    lastUpdateAt?: SortOrder
  }

  export type CotDraftPerformanceSumOrderByAggregateInput = {
    likes30m?: SortOrder
    retweets30m?: SortOrder
    replies30m?: SortOrder
    impressions30m?: SortOrder
    likes1h?: SortOrder
    retweets1h?: SortOrder
    replies1h?: SortOrder
    impressions1h?: SortOrder
    likes24h?: SortOrder
    retweets24h?: SortOrder
    replies24h?: SortOrder
    impressions24h?: SortOrder
    engagementRate?: SortOrder
    viralCoefficient?: SortOrder
  }

  export type ScheduledPostCreateNestedManyWithoutRefPostInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
  }

  export type ScheduledPostUncheckedCreateNestedManyWithoutRefPostInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ScheduledPostUpdateManyWithoutRefPostNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    upsert?: ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput | ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    set?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    disconnect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    delete?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    update?: ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput | ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput[]
    updateMany?: ScheduledPostUpdateManyWithWhereWithoutRefPostInput | ScheduledPostUpdateManyWithWhereWithoutRefPostInput[]
    deleteMany?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
  }

  export type ScheduledPostUncheckedUpdateManyWithoutRefPostNestedInput = {
    create?: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput> | ScheduledPostCreateWithoutRefPostInput[] | ScheduledPostUncheckedCreateWithoutRefPostInput[]
    connectOrCreate?: ScheduledPostCreateOrConnectWithoutRefPostInput | ScheduledPostCreateOrConnectWithoutRefPostInput[]
    upsert?: ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput | ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput[]
    createMany?: ScheduledPostCreateManyRefPostInputEnvelope
    set?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    disconnect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    delete?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    connect?: ScheduledPostWhereUniqueInput | ScheduledPostWhereUniqueInput[]
    update?: ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput | ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput[]
    updateMany?: ScheduledPostUpdateManyWithWhereWithoutRefPostInput | ScheduledPostUpdateManyWithWhereWithoutRefPostInput[]
    deleteMany?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
  }

  export type BuzzPostCreateNestedOneWithoutScheduledPostsInput = {
    create?: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    connectOrCreate?: BuzzPostCreateOrConnectWithoutScheduledPostsInput
    connect?: BuzzPostWhereUniqueInput
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BuzzPostUpdateOneWithoutScheduledPostsNestedInput = {
    create?: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    connectOrCreate?: BuzzPostCreateOrConnectWithoutScheduledPostsInput
    upsert?: BuzzPostUpsertWithoutScheduledPostsInput
    disconnect?: BuzzPostWhereInput | boolean
    delete?: BuzzPostWhereInput | boolean
    connect?: BuzzPostWhereUniqueInput
    update?: XOR<XOR<BuzzPostUpdateToOneWithWhereWithoutScheduledPostsInput, BuzzPostUpdateWithoutScheduledPostsInput>, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WatchlistUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WatchlistUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WatchlistUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUserUpsertWithWhereUniqueWithoutUserInput | WatchlistUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    set?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    disconnect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    delete?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    update?: WatchlistUserUpdateWithWhereUniqueWithoutUserInput | WatchlistUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUserUpdateManyWithWhereWithoutUserInput | WatchlistUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WatchlistUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput> | WatchlistUserCreateWithoutUserInput[] | WatchlistUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutUserInput | WatchlistUserCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUserUpsertWithWhereUniqueWithoutUserInput | WatchlistUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistUserCreateManyUserInputEnvelope
    set?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    disconnect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    delete?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    connect?: WatchlistUserWhereUniqueInput | WatchlistUserWhereUniqueInput[]
    update?: WatchlistUserUpdateWithWhereUniqueWithoutUserInput | WatchlistUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUserUpdateManyWithWhereWithoutUserInput | WatchlistUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NewsArticleCreateNestedManyWithoutSourceInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
  }

  export type NewsArticleUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
  }

  export type NewsArticleUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    upsert?: NewsArticleUpsertWithWhereUniqueWithoutSourceInput | NewsArticleUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    set?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    disconnect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    delete?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    update?: NewsArticleUpdateWithWhereUniqueWithoutSourceInput | NewsArticleUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NewsArticleUpdateManyWithWhereWithoutSourceInput | NewsArticleUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
  }

  export type NewsArticleUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput> | NewsArticleCreateWithoutSourceInput[] | NewsArticleUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NewsArticleCreateOrConnectWithoutSourceInput | NewsArticleCreateOrConnectWithoutSourceInput[]
    upsert?: NewsArticleUpsertWithWhereUniqueWithoutSourceInput | NewsArticleUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NewsArticleCreateManySourceInputEnvelope
    set?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    disconnect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    delete?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    connect?: NewsArticleWhereUniqueInput | NewsArticleWhereUniqueInput[]
    update?: NewsArticleUpdateWithWhereUniqueWithoutSourceInput | NewsArticleUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NewsArticleUpdateManyWithWhereWithoutSourceInput | NewsArticleUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
  }

  export type NewsArticleCreatetagsInput = {
    set: string[]
  }

  export type NewsAnalysisCreateNestedOneWithoutArticleInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    connect?: NewsAnalysisWhereUniqueInput
  }

  export type NewsSourceCreateNestedOneWithoutArticlesInput = {
    create?: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: NewsSourceCreateOrConnectWithoutArticlesInput
    connect?: NewsSourceWhereUniqueInput
  }

  export type NewsThreadItemCreateNestedManyWithoutArticleInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    connect?: NewsAnalysisWhereUniqueInput
  }

  export type NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsArticleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NewsAnalysisUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    upsert?: NewsAnalysisUpsertWithoutArticleInput
    disconnect?: NewsAnalysisWhereInput | boolean
    delete?: NewsAnalysisWhereInput | boolean
    connect?: NewsAnalysisWhereUniqueInput
    update?: XOR<XOR<NewsAnalysisUpdateToOneWithWhereWithoutArticleInput, NewsAnalysisUpdateWithoutArticleInput>, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsSourceUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: NewsSourceCreateOrConnectWithoutArticlesInput
    upsert?: NewsSourceUpsertWithoutArticlesInput
    connect?: NewsSourceWhereUniqueInput
    update?: XOR<XOR<NewsSourceUpdateToOneWithWhereWithoutArticlesInput, NewsSourceUpdateWithoutArticlesInput>, NewsSourceUncheckedUpdateWithoutArticlesInput>
  }

  export type NewsThreadItemUpdateManyWithoutArticleNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput | NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput | NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutArticleInput | NewsThreadItemUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NewsAnalysisCreateOrConnectWithoutArticleInput
    upsert?: NewsAnalysisUpsertWithoutArticleInput
    disconnect?: NewsAnalysisWhereInput | boolean
    delete?: NewsAnalysisWhereInput | boolean
    connect?: NewsAnalysisWhereUniqueInput
    update?: XOR<XOR<NewsAnalysisUpdateToOneWithWhereWithoutArticleInput, NewsAnalysisUpdateWithoutArticleInput>, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput> | NewsThreadItemCreateWithoutArticleInput[] | NewsThreadItemUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutArticleInput | NewsThreadItemCreateOrConnectWithoutArticleInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput | NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: NewsThreadItemCreateManyArticleInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput | NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutArticleInput | NewsThreadItemUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadItemCreateNestedManyWithoutThreadInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsThreadItemUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
  }

  export type NewsThreadItemUpdateManyWithoutThreadNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput | NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput | NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutThreadInput | NewsThreadItemUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput> | NewsThreadItemCreateWithoutThreadInput[] | NewsThreadItemUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: NewsThreadItemCreateOrConnectWithoutThreadInput | NewsThreadItemCreateOrConnectWithoutThreadInput[]
    upsert?: NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput | NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: NewsThreadItemCreateManyThreadInputEnvelope
    set?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    disconnect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    delete?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    connect?: NewsThreadItemWhereUniqueInput | NewsThreadItemWhereUniqueInput[]
    update?: NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput | NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: NewsThreadItemUpdateManyWithWhereWithoutThreadInput | NewsThreadItemUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
  }

  export type NewsThreadCreateNestedOneWithoutItemsInput = {
    create?: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NewsThreadCreateOrConnectWithoutItemsInput
    connect?: NewsThreadWhereUniqueInput
  }

  export type NewsArticleCreateNestedOneWithoutNewsThreadItemsInput = {
    create?: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNewsThreadItemsInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type NewsThreadUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NewsThreadCreateOrConnectWithoutItemsInput
    upsert?: NewsThreadUpsertWithoutItemsInput
    connect?: NewsThreadWhereUniqueInput
    update?: XOR<XOR<NewsThreadUpdateToOneWithWhereWithoutItemsInput, NewsThreadUpdateWithoutItemsInput>, NewsThreadUncheckedUpdateWithoutItemsInput>
  }

  export type NewsArticleUpdateOneRequiredWithoutNewsThreadItemsNestedInput = {
    create?: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutNewsThreadItemsInput
    upsert?: NewsArticleUpsertWithoutNewsThreadItemsInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutNewsThreadItemsInput, NewsArticleUpdateWithoutNewsThreadItemsInput>, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
  }

  export type NewsAnalysisCreatekeywordsInput = {
    set: string[]
  }

  export type NewsAnalysisCreatetopicsInput = {
    set: string[]
  }

  export type NewsArticleCreateNestedOneWithoutAnalysisInput = {
    create?: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutAnalysisInput
    connect?: NewsArticleWhereUniqueInput
  }

  export type NewsAnalysisUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NewsAnalysisUpdatetopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NewsArticleUpdateOneRequiredWithoutAnalysisNestedInput = {
    create?: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: NewsArticleCreateOrConnectWithoutAnalysisInput
    upsert?: NewsArticleUpsertWithoutAnalysisInput
    connect?: NewsArticleWhereUniqueInput
    update?: XOR<XOR<NewsArticleUpdateToOneWithWhereWithoutAnalysisInput, NewsArticleUpdateWithoutAnalysisInput>, NewsArticleUncheckedUpdateWithoutAnalysisInput>
  }

  export type UserCreateNestedOneWithoutWatchlistUsersInput = {
    create?: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistUsersInput
    connect?: UserWhereUniqueInput
  }

  export type WatchlistTweetCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
  }

  export type InteractionHistoryCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
  }

  export type WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
  }

  export type InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWatchlistUsersNestedInput = {
    create?: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistUsersInput
    upsert?: UserUpsertWithoutWatchlistUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchlistUsersInput, UserUpdateWithoutWatchlistUsersInput>, UserUncheckedUpdateWithoutWatchlistUsersInput>
  }

  export type WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    set?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    disconnect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    delete?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    update?: WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput | WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
  }

  export type InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    set?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    disconnect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    delete?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    update?: InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput | InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
  }

  export type WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput> | WatchlistTweetCreateWithoutWatchlistUserInput[] | WatchlistTweetUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: WatchlistTweetCreateOrConnectWithoutWatchlistUserInput | WatchlistTweetCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: WatchlistTweetCreateManyWatchlistUserInputEnvelope
    set?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    disconnect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    delete?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    connect?: WatchlistTweetWhereUniqueInput | WatchlistTweetWhereUniqueInput[]
    update?: WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput | WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput | WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
  }

  export type InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput = {
    create?: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput> | InteractionHistoryCreateWithoutWatchlistUserInput[] | InteractionHistoryUncheckedCreateWithoutWatchlistUserInput[]
    connectOrCreate?: InteractionHistoryCreateOrConnectWithoutWatchlistUserInput | InteractionHistoryCreateOrConnectWithoutWatchlistUserInput[]
    upsert?: InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput[]
    createMany?: InteractionHistoryCreateManyWatchlistUserInputEnvelope
    set?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    disconnect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    delete?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    connect?: InteractionHistoryWhereUniqueInput | InteractionHistoryWhereUniqueInput[]
    update?: InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput | InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput[]
    updateMany?: InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput | InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput[]
    deleteMany?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
  }

  export type WatchlistUserCreateNestedOneWithoutTweetsInput = {
    create?: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutTweetsInput
    connect?: WatchlistUserWhereUniqueInput
  }

  export type WatchlistUserUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutTweetsInput
    upsert?: WatchlistUserUpsertWithoutTweetsInput
    connect?: WatchlistUserWhereUniqueInput
    update?: XOR<XOR<WatchlistUserUpdateToOneWithWhereWithoutTweetsInput, WatchlistUserUpdateWithoutTweetsInput>, WatchlistUserUncheckedUpdateWithoutTweetsInput>
  }

  export type WatchlistUserCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutInteractionsInput
    connect?: WatchlistUserWhereUniqueInput
  }

  export type WatchlistUserUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: WatchlistUserCreateOrConnectWithoutInteractionsInput
    upsert?: WatchlistUserUpsertWithoutInteractionsInput
    connect?: WatchlistUserWhereUniqueInput
    update?: XOR<XOR<WatchlistUserUpdateToOneWithWhereWithoutInteractionsInput, WatchlistUserUpdateWithoutInteractionsInput>, WatchlistUserUncheckedUpdateWithoutInteractionsInput>
  }

  export type CotPhaseCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
  }

  export type CotDraftCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
  }

  export type CotPhaseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
  }

  export type CotDraftUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
  }

  export type EnumCotSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotSessionStatus
  }

  export type EnumCotPhaseStepFieldUpdateOperationsInput = {
    set?: $Enums.CotPhaseStep
  }

  export type CotPhaseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    upsert?: CotPhaseUpsertWithWhereUniqueWithoutSessionInput | CotPhaseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    set?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    disconnect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    delete?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    update?: CotPhaseUpdateWithWhereUniqueWithoutSessionInput | CotPhaseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotPhaseUpdateManyWithWhereWithoutSessionInput | CotPhaseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
  }

  export type CotDraftUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    upsert?: CotDraftUpsertWithWhereUniqueWithoutSessionInput | CotDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    set?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    disconnect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    delete?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    update?: CotDraftUpdateWithWhereUniqueWithoutSessionInput | CotDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotDraftUpdateManyWithWhereWithoutSessionInput | CotDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
  }

  export type CotPhaseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput> | CotPhaseCreateWithoutSessionInput[] | CotPhaseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotPhaseCreateOrConnectWithoutSessionInput | CotPhaseCreateOrConnectWithoutSessionInput[]
    upsert?: CotPhaseUpsertWithWhereUniqueWithoutSessionInput | CotPhaseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotPhaseCreateManySessionInputEnvelope
    set?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    disconnect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    delete?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    connect?: CotPhaseWhereUniqueInput | CotPhaseWhereUniqueInput[]
    update?: CotPhaseUpdateWithWhereUniqueWithoutSessionInput | CotPhaseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotPhaseUpdateManyWithWhereWithoutSessionInput | CotPhaseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
  }

  export type CotDraftUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput> | CotDraftCreateWithoutSessionInput[] | CotDraftUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CotDraftCreateOrConnectWithoutSessionInput | CotDraftCreateOrConnectWithoutSessionInput[]
    upsert?: CotDraftUpsertWithWhereUniqueWithoutSessionInput | CotDraftUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CotDraftCreateManySessionInputEnvelope
    set?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    disconnect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    delete?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    connect?: CotDraftWhereUniqueInput | CotDraftWhereUniqueInput[]
    update?: CotDraftUpdateWithWhereUniqueWithoutSessionInput | CotDraftUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CotDraftUpdateManyWithWhereWithoutSessionInput | CotDraftUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
  }

  export type CotSessionCreateNestedOneWithoutPhasesInput = {
    create?: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutPhasesInput
    connect?: CotSessionWhereUniqueInput
  }

  export type EnumCotPhaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotPhaseStatus
  }

  export type CotSessionUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutPhasesInput
    upsert?: CotSessionUpsertWithoutPhasesInput
    connect?: CotSessionWhereUniqueInput
    update?: XOR<XOR<CotSessionUpdateToOneWithWhereWithoutPhasesInput, CotSessionUpdateWithoutPhasesInput>, CotSessionUncheckedUpdateWithoutPhasesInput>
  }

  export type CotDraftCreatehashtagsInput = {
    set: string[]
  }

  export type CotSessionCreateNestedOneWithoutDraftsInput = {
    create?: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutDraftsInput
    connect?: CotSessionWhereUniqueInput
  }

  export type CotDraftPerformanceCreateNestedOneWithoutDraftInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: CotDraftPerformanceWhereUniqueInput
  }

  export type CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    connect?: CotDraftPerformanceWhereUniqueInput
  }

  export type CotDraftUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCotDraftStatusFieldUpdateOperationsInput = {
    set?: $Enums.CotDraftStatus
  }

  export type CotSessionUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: CotSessionCreateOrConnectWithoutDraftsInput
    upsert?: CotSessionUpsertWithoutDraftsInput
    connect?: CotSessionWhereUniqueInput
    update?: XOR<XOR<CotSessionUpdateToOneWithWhereWithoutDraftsInput, CotSessionUpdateWithoutDraftsInput>, CotSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type CotDraftPerformanceUpdateOneWithoutDraftNestedInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: CotDraftPerformanceUpsertWithoutDraftInput
    disconnect?: CotDraftPerformanceWhereInput | boolean
    delete?: CotDraftPerformanceWhereInput | boolean
    connect?: CotDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, CotDraftPerformanceUpdateWithoutDraftInput>, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput = {
    create?: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    connectOrCreate?: CotDraftPerformanceCreateOrConnectWithoutDraftInput
    upsert?: CotDraftPerformanceUpsertWithoutDraftInput
    disconnect?: CotDraftPerformanceWhereInput | boolean
    delete?: CotDraftPerformanceWhereInput | boolean
    connect?: CotDraftPerformanceWhereUniqueInput
    update?: XOR<XOR<CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput, CotDraftPerformanceUpdateWithoutDraftInput>, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotDraftCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutPerformanceInput
    connect?: CotDraftWhereUniqueInput
  }

  export type CotDraftUpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CotDraftCreateOrConnectWithoutPerformanceInput
    upsert?: CotDraftUpsertWithoutPerformanceInput
    connect?: CotDraftWhereUniqueInput
    update?: XOR<XOR<CotDraftUpdateToOneWithWhereWithoutPerformanceInput, CotDraftUpdateWithoutPerformanceInput>, CotDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCotSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusFilter<$PrismaModel> | $Enums.CotSessionStatus
  }

  export type NestedEnumCotPhaseStepFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepFilter<$PrismaModel> | $Enums.CotPhaseStep
  }

  export type NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotSessionStatus | EnumCotSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotSessionStatus[] | ListEnumCotSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCotSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStep | EnumCotPhaseStepFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStep[] | ListEnumCotPhaseStepFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStepWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStepFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStepFilter<$PrismaModel>
  }

  export type NestedEnumCotPhaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusFilter<$PrismaModel> | $Enums.CotPhaseStatus
  }

  export type NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotPhaseStatus | EnumCotPhaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotPhaseStatus[] | ListEnumCotPhaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotPhaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotPhaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCotPhaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumCotDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusFilter<$PrismaModel> | $Enums.CotDraftStatus
  }

  export type NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CotDraftStatus | EnumCotDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CotDraftStatus[] | ListEnumCotDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCotDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.CotDraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCotDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumCotDraftStatusFilter<$PrismaModel>
  }

  export type ScheduledPostCreateWithoutRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUncheckedCreateWithoutRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostCreateOrConnectWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    create: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput>
  }

  export type ScheduledPostCreateManyRefPostInputEnvelope = {
    data: ScheduledPostCreateManyRefPostInput | ScheduledPostCreateManyRefPostInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledPostUpsertWithWhereUniqueWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    update: XOR<ScheduledPostUpdateWithoutRefPostInput, ScheduledPostUncheckedUpdateWithoutRefPostInput>
    create: XOR<ScheduledPostCreateWithoutRefPostInput, ScheduledPostUncheckedCreateWithoutRefPostInput>
  }

  export type ScheduledPostUpdateWithWhereUniqueWithoutRefPostInput = {
    where: ScheduledPostWhereUniqueInput
    data: XOR<ScheduledPostUpdateWithoutRefPostInput, ScheduledPostUncheckedUpdateWithoutRefPostInput>
  }

  export type ScheduledPostUpdateManyWithWhereWithoutRefPostInput = {
    where: ScheduledPostScalarWhereInput
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyWithoutRefPostInput>
  }

  export type ScheduledPostScalarWhereInput = {
    AND?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
    OR?: ScheduledPostScalarWhereInput[]
    NOT?: ScheduledPostScalarWhereInput | ScheduledPostScalarWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    content?: StringFilter<"ScheduledPost"> | string
    scheduledTime?: DateTimeFilter<"ScheduledPost"> | Date | string
    status?: EnumPostStatusFilter<"ScheduledPost"> | $Enums.PostStatus
    postType?: EnumPostTypeFilter<"ScheduledPost"> | $Enums.PostType
    refPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    templateType?: StringNullableFilter<"ScheduledPost"> | string | null
    aiGenerated?: BoolFilter<"ScheduledPost"> | boolean
    aiPrompt?: StringNullableFilter<"ScheduledPost"> | string | null
    editedContent?: StringNullableFilter<"ScheduledPost"> | string | null
    postedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    postResult?: JsonNullableFilter<"ScheduledPost">
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
  }

  export type BuzzPostCreateWithoutScheduledPostsInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostUncheckedCreateWithoutScheduledPostsInput = {
    id?: string
    postId: string
    content: string
    authorUsername: string
    authorId: string
    likesCount: number
    retweetsCount: number
    repliesCount: number
    impressionsCount: number
    postedAt: Date | string
    collectedAt?: Date | string
    url: string
    theme: string
    language: string
    mediaUrls: JsonNullValueInput | InputJsonValue
    hashtags: JsonNullValueInput | InputJsonValue
    chromaId?: string | null
    authorFollowers?: number | null
    authorFollowing?: number | null
    authorVerified?: boolean | null
  }

  export type BuzzPostCreateOrConnectWithoutScheduledPostsInput = {
    where: BuzzPostWhereUniqueInput
    create: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
  }

  export type BuzzPostUpsertWithoutScheduledPostsInput = {
    update: XOR<BuzzPostUpdateWithoutScheduledPostsInput, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
    create: XOR<BuzzPostCreateWithoutScheduledPostsInput, BuzzPostUncheckedCreateWithoutScheduledPostsInput>
    where?: BuzzPostWhereInput
  }

  export type BuzzPostUpdateToOneWithWhereWithoutScheduledPostsInput = {
    where?: BuzzPostWhereInput
    data: XOR<BuzzPostUpdateWithoutScheduledPostsInput, BuzzPostUncheckedUpdateWithoutScheduledPostsInput>
  }

  export type BuzzPostUpdateWithoutScheduledPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BuzzPostUncheckedUpdateWithoutScheduledPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetsCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    impressionsCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    mediaUrls?: JsonNullValueInput | InputJsonValue
    hashtags?: JsonNullValueInput | InputJsonValue
    chromaId?: NullableStringFieldUpdateOperationsInput | string | null
    authorFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    authorFollowing?: NullableIntFieldUpdateOperationsInput | number | null
    authorVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WatchlistUserCreateWithoutUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
    interactions?: InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUserCreateManyUserInputEnvelope = {
    data: WatchlistUserCreateManyUserInput | WatchlistUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type WatchlistUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    update: XOR<WatchlistUserUpdateWithoutUserInput, WatchlistUserUncheckedUpdateWithoutUserInput>
    create: XOR<WatchlistUserCreateWithoutUserInput, WatchlistUserUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchlistUserWhereUniqueInput
    data: XOR<WatchlistUserUpdateWithoutUserInput, WatchlistUserUncheckedUpdateWithoutUserInput>
  }

  export type WatchlistUserUpdateManyWithWhereWithoutUserInput = {
    where: WatchlistUserScalarWhereInput
    data: XOR<WatchlistUserUpdateManyMutationInput, WatchlistUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WatchlistUserScalarWhereInput = {
    AND?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
    OR?: WatchlistUserScalarWhereInput[]
    NOT?: WatchlistUserScalarWhereInput | WatchlistUserScalarWhereInput[]
    id?: StringFilter<"WatchlistUser"> | string
    userId?: StringFilter<"WatchlistUser"> | string
    twitterId?: StringFilter<"WatchlistUser"> | string
    username?: StringFilter<"WatchlistUser"> | string
    displayName?: StringFilter<"WatchlistUser"> | string
    followers?: IntNullableFilter<"WatchlistUser"> | number | null
    following?: IntNullableFilter<"WatchlistUser"> | number | null
    isActive?: BoolFilter<"WatchlistUser"> | boolean
    lastChecked?: DateTimeNullableFilter<"WatchlistUser"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchlistUser"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlistUsers?: WatchlistUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlistUsers?: WatchlistUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUsers?: WatchlistUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlistUsers?: WatchlistUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NewsArticleCreateWithoutSourceInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutSourceInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput>
  }

  export type NewsArticleCreateManySourceInputEnvelope = {
    data: NewsArticleCreateManySourceInput | NewsArticleCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type NewsArticleUpsertWithWhereUniqueWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    update: XOR<NewsArticleUpdateWithoutSourceInput, NewsArticleUncheckedUpdateWithoutSourceInput>
    create: XOR<NewsArticleCreateWithoutSourceInput, NewsArticleUncheckedCreateWithoutSourceInput>
  }

  export type NewsArticleUpdateWithWhereUniqueWithoutSourceInput = {
    where: NewsArticleWhereUniqueInput
    data: XOR<NewsArticleUpdateWithoutSourceInput, NewsArticleUncheckedUpdateWithoutSourceInput>
  }

  export type NewsArticleUpdateManyWithWhereWithoutSourceInput = {
    where: NewsArticleScalarWhereInput
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyWithoutSourceInput>
  }

  export type NewsArticleScalarWhereInput = {
    AND?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
    OR?: NewsArticleScalarWhereInput[]
    NOT?: NewsArticleScalarWhereInput | NewsArticleScalarWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    sourceId?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    description?: StringNullableFilter<"NewsArticle"> | string | null
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    category?: StringNullableFilter<"NewsArticle"> | string | null
    tags?: StringNullableListFilter<"NewsArticle">
    importance?: FloatNullableFilter<"NewsArticle"> | number | null
    processed?: BoolFilter<"NewsArticle"> | boolean
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
    metadata?: JsonNullableFilter<"NewsArticle">
  }

  export type NewsAnalysisCreateWithoutArticleInput = {
    id?: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisUncheckedCreateWithoutArticleInput = {
    id?: string
    summary: string
    sentiment: string
    keywords?: NewsAnalysisCreatekeywordsInput | string[]
    topics?: NewsAnalysisCreatetopicsInput | string[]
    createdAt?: Date | string
  }

  export type NewsAnalysisCreateOrConnectWithoutArticleInput = {
    where: NewsAnalysisWhereUniqueInput
    create: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
  }

  export type NewsSourceCreateWithoutArticlesInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
  }

  export type NewsSourceUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    url: string
    rssUrl: string
    category: string
    language?: string
    isActive?: boolean
    lastFetched?: Date | string | null
    createdAt?: Date | string
  }

  export type NewsSourceCreateOrConnectWithoutArticlesInput = {
    where: NewsSourceWhereUniqueInput
    create: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
  }

  export type NewsThreadItemCreateWithoutArticleInput = {
    id?: string
    order: number
    content?: string | null
    createdAt?: Date | string
    thread: NewsThreadCreateNestedOneWithoutItemsInput
  }

  export type NewsThreadItemUncheckedCreateWithoutArticleInput = {
    id?: string
    threadId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemCreateOrConnectWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    create: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput>
  }

  export type NewsThreadItemCreateManyArticleInputEnvelope = {
    data: NewsThreadItemCreateManyArticleInput | NewsThreadItemCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type NewsAnalysisUpsertWithoutArticleInput = {
    update: XOR<NewsAnalysisUpdateWithoutArticleInput, NewsAnalysisUncheckedUpdateWithoutArticleInput>
    create: XOR<NewsAnalysisCreateWithoutArticleInput, NewsAnalysisUncheckedCreateWithoutArticleInput>
    where?: NewsAnalysisWhereInput
  }

  export type NewsAnalysisUpdateToOneWithWhereWithoutArticleInput = {
    where?: NewsAnalysisWhereInput
    data: XOR<NewsAnalysisUpdateWithoutArticleInput, NewsAnalysisUncheckedUpdateWithoutArticleInput>
  }

  export type NewsAnalysisUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsAnalysisUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    keywords?: NewsAnalysisUpdatekeywordsInput | string[]
    topics?: NewsAnalysisUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUpsertWithoutArticlesInput = {
    update: XOR<NewsSourceUpdateWithoutArticlesInput, NewsSourceUncheckedUpdateWithoutArticlesInput>
    create: XOR<NewsSourceCreateWithoutArticlesInput, NewsSourceUncheckedCreateWithoutArticlesInput>
    where?: NewsSourceWhereInput
  }

  export type NewsSourceUpdateToOneWithWhereWithoutArticlesInput = {
    where?: NewsSourceWhereInput
    data: XOR<NewsSourceUpdateWithoutArticlesInput, NewsSourceUncheckedUpdateWithoutArticlesInput>
  }

  export type NewsSourceUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    rssUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUpsertWithWhereUniqueWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    update: XOR<NewsThreadItemUpdateWithoutArticleInput, NewsThreadItemUncheckedUpdateWithoutArticleInput>
    create: XOR<NewsThreadItemCreateWithoutArticleInput, NewsThreadItemUncheckedCreateWithoutArticleInput>
  }

  export type NewsThreadItemUpdateWithWhereUniqueWithoutArticleInput = {
    where: NewsThreadItemWhereUniqueInput
    data: XOR<NewsThreadItemUpdateWithoutArticleInput, NewsThreadItemUncheckedUpdateWithoutArticleInput>
  }

  export type NewsThreadItemUpdateManyWithWhereWithoutArticleInput = {
    where: NewsThreadItemScalarWhereInput
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyWithoutArticleInput>
  }

  export type NewsThreadItemScalarWhereInput = {
    AND?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
    OR?: NewsThreadItemScalarWhereInput[]
    NOT?: NewsThreadItemScalarWhereInput | NewsThreadItemScalarWhereInput[]
    id?: StringFilter<"NewsThreadItem"> | string
    threadId?: StringFilter<"NewsThreadItem"> | string
    articleId?: StringFilter<"NewsThreadItem"> | string
    order?: IntFilter<"NewsThreadItem"> | number
    content?: StringNullableFilter<"NewsThreadItem"> | string | null
    createdAt?: DateTimeFilter<"NewsThreadItem"> | Date | string
  }

  export type NewsThreadItemCreateWithoutThreadInput = {
    id?: string
    order: number
    content?: string | null
    createdAt?: Date | string
    article: NewsArticleCreateNestedOneWithoutNewsThreadItemsInput
  }

  export type NewsThreadItemUncheckedCreateWithoutThreadInput = {
    id?: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemCreateOrConnectWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    create: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput>
  }

  export type NewsThreadItemCreateManyThreadInputEnvelope = {
    data: NewsThreadItemCreateManyThreadInput | NewsThreadItemCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type NewsThreadItemUpsertWithWhereUniqueWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    update: XOR<NewsThreadItemUpdateWithoutThreadInput, NewsThreadItemUncheckedUpdateWithoutThreadInput>
    create: XOR<NewsThreadItemCreateWithoutThreadInput, NewsThreadItemUncheckedCreateWithoutThreadInput>
  }

  export type NewsThreadItemUpdateWithWhereUniqueWithoutThreadInput = {
    where: NewsThreadItemWhereUniqueInput
    data: XOR<NewsThreadItemUpdateWithoutThreadInput, NewsThreadItemUncheckedUpdateWithoutThreadInput>
  }

  export type NewsThreadItemUpdateManyWithWhereWithoutThreadInput = {
    where: NewsThreadItemScalarWhereInput
    data: XOR<NewsThreadItemUpdateManyMutationInput, NewsThreadItemUncheckedUpdateManyWithoutThreadInput>
  }

  export type NewsThreadCreateWithoutItemsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadUncheckedCreateWithoutItemsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    title: string
    postedAt?: Date | string | null
  }

  export type NewsThreadCreateOrConnectWithoutItemsInput = {
    where: NewsThreadWhereUniqueInput
    create: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
  }

  export type NewsArticleCreateWithoutNewsThreadItemsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisCreateNestedOneWithoutArticleInput
    source: NewsSourceCreateNestedOneWithoutArticlesInput
  }

  export type NewsArticleUncheckedCreateWithoutNewsThreadItemsInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedCreateNestedOneWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutNewsThreadItemsInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
  }

  export type NewsThreadUpsertWithoutItemsInput = {
    update: XOR<NewsThreadUpdateWithoutItemsInput, NewsThreadUncheckedUpdateWithoutItemsInput>
    create: XOR<NewsThreadCreateWithoutItemsInput, NewsThreadUncheckedCreateWithoutItemsInput>
    where?: NewsThreadWhereInput
  }

  export type NewsThreadUpdateToOneWithWhereWithoutItemsInput = {
    where?: NewsThreadWhereInput
    data: XOR<NewsThreadUpdateWithoutItemsInput, NewsThreadUncheckedUpdateWithoutItemsInput>
  }

  export type NewsThreadUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsThreadUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsArticleUpsertWithoutNewsThreadItemsInput = {
    update: XOR<NewsArticleUpdateWithoutNewsThreadItemsInput, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
    create: XOR<NewsArticleCreateWithoutNewsThreadItemsInput, NewsArticleUncheckedCreateWithoutNewsThreadItemsInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutNewsThreadItemsInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutNewsThreadItemsInput, NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput>
  }

  export type NewsArticleUpdateWithoutNewsThreadItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutNewsThreadItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type NewsArticleCreateWithoutAnalysisInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source: NewsSourceCreateNestedOneWithoutArticlesInput
    newsThreadItems?: NewsThreadItemCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleUncheckedCreateWithoutAnalysisInput = {
    id?: string
    sourceId: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    newsThreadItems?: NewsThreadItemUncheckedCreateNestedManyWithoutArticleInput
  }

  export type NewsArticleCreateOrConnectWithoutAnalysisInput = {
    where: NewsArticleWhereUniqueInput
    create: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
  }

  export type NewsArticleUpsertWithoutAnalysisInput = {
    update: XOR<NewsArticleUpdateWithoutAnalysisInput, NewsArticleUncheckedUpdateWithoutAnalysisInput>
    create: XOR<NewsArticleCreateWithoutAnalysisInput, NewsArticleUncheckedCreateWithoutAnalysisInput>
    where?: NewsArticleWhereInput
  }

  export type NewsArticleUpdateToOneWithWhereWithoutAnalysisInput = {
    where?: NewsArticleWhereInput
    data: XOR<NewsArticleUpdateWithoutAnalysisInput, NewsArticleUncheckedUpdateWithoutAnalysisInput>
  }

  export type NewsArticleUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source?: NewsSourceUpdateOneRequiredWithoutArticlesNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserCreateWithoutWatchlistUsersInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchlistUsersInput = {
    id?: string
    twitterId: string
    username: string
    name?: string | null
    email?: string | null
    image?: string | null
    accessToken: string
    refreshToken?: string | null
    tokenSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchlistUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
  }

  export type WatchlistTweetCreateWithoutWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetUncheckedCreateWithoutWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type WatchlistTweetCreateOrConnectWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    create: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetCreateManyWatchlistUserInputEnvelope = {
    data: WatchlistTweetCreateManyWatchlistUserInput | WatchlistTweetCreateManyWatchlistUserInput[]
    skipDuplicates?: boolean
  }

  export type InteractionHistoryCreateWithoutWatchlistUserInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryUncheckedCreateWithoutWatchlistUserInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InteractionHistoryCreateOrConnectWithoutWatchlistUserInput = {
    where: InteractionHistoryWhereUniqueInput
    create: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput>
  }

  export type InteractionHistoryCreateManyWatchlistUserInputEnvelope = {
    data: InteractionHistoryCreateManyWatchlistUserInput | InteractionHistoryCreateManyWatchlistUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWatchlistUsersInput = {
    update: XOR<UserUpdateWithoutWatchlistUsersInput, UserUncheckedUpdateWithoutWatchlistUsersInput>
    create: XOR<UserCreateWithoutWatchlistUsersInput, UserUncheckedCreateWithoutWatchlistUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchlistUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchlistUsersInput, UserUncheckedUpdateWithoutWatchlistUsersInput>
  }

  export type UserUpdateWithoutWatchlistUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchlistUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WatchlistTweetUpsertWithWhereUniqueWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    update: XOR<WatchlistTweetUpdateWithoutWatchlistUserInput, WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput>
    create: XOR<WatchlistTweetCreateWithoutWatchlistUserInput, WatchlistTweetUncheckedCreateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetUpdateWithWhereUniqueWithoutWatchlistUserInput = {
    where: WatchlistTweetWhereUniqueInput
    data: XOR<WatchlistTweetUpdateWithoutWatchlistUserInput, WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput>
  }

  export type WatchlistTweetUpdateManyWithWhereWithoutWatchlistUserInput = {
    where: WatchlistTweetScalarWhereInput
    data: XOR<WatchlistTweetUpdateManyMutationInput, WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserInput>
  }

  export type WatchlistTweetScalarWhereInput = {
    AND?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
    OR?: WatchlistTweetScalarWhereInput[]
    NOT?: WatchlistTweetScalarWhereInput | WatchlistTweetScalarWhereInput[]
    id?: StringFilter<"WatchlistTweet"> | string
    watchlistUserId?: StringFilter<"WatchlistTweet"> | string
    tweetId?: StringFilter<"WatchlistTweet"> | string
    content?: StringFilter<"WatchlistTweet"> | string
    createdAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
    retweetCount?: IntFilter<"WatchlistTweet"> | number
    likeCount?: IntFilter<"WatchlistTweet"> | number
    replyCount?: IntFilter<"WatchlistTweet"> | number
    collectedAt?: DateTimeFilter<"WatchlistTweet"> | Date | string
  }

  export type InteractionHistoryUpsertWithWhereUniqueWithoutWatchlistUserInput = {
    where: InteractionHistoryWhereUniqueInput
    update: XOR<InteractionHistoryUpdateWithoutWatchlistUserInput, InteractionHistoryUncheckedUpdateWithoutWatchlistUserInput>
    create: XOR<InteractionHistoryCreateWithoutWatchlistUserInput, InteractionHistoryUncheckedCreateWithoutWatchlistUserInput>
  }

  export type InteractionHistoryUpdateWithWhereUniqueWithoutWatchlistUserInput = {
    where: InteractionHistoryWhereUniqueInput
    data: XOR<InteractionHistoryUpdateWithoutWatchlistUserInput, InteractionHistoryUncheckedUpdateWithoutWatchlistUserInput>
  }

  export type InteractionHistoryUpdateManyWithWhereWithoutWatchlistUserInput = {
    where: InteractionHistoryScalarWhereInput
    data: XOR<InteractionHistoryUpdateManyMutationInput, InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserInput>
  }

  export type InteractionHistoryScalarWhereInput = {
    AND?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
    OR?: InteractionHistoryScalarWhereInput[]
    NOT?: InteractionHistoryScalarWhereInput | InteractionHistoryScalarWhereInput[]
    id?: StringFilter<"InteractionHistory"> | string
    watchlistUserId?: StringFilter<"InteractionHistory"> | string
    interactionType?: StringFilter<"InteractionHistory"> | string
    tweetId?: StringNullableFilter<"InteractionHistory"> | string | null
    metadata?: JsonNullableFilter<"InteractionHistory">
    createdAt?: DateTimeFilter<"InteractionHistory"> | Date | string
  }

  export type WatchlistUserCreateWithoutTweetsInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistUsersInput
    interactions?: InteractionHistoryCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutTweetsInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    interactions?: InteractionHistoryUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutTweetsInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
  }

  export type WatchlistUserUpsertWithoutTweetsInput = {
    update: XOR<WatchlistUserUpdateWithoutTweetsInput, WatchlistUserUncheckedUpdateWithoutTweetsInput>
    create: XOR<WatchlistUserCreateWithoutTweetsInput, WatchlistUserUncheckedCreateWithoutTweetsInput>
    where?: WatchlistUserWhereInput
  }

  export type WatchlistUserUpdateToOneWithWhereWithoutTweetsInput = {
    where?: WatchlistUserWhereInput
    data: XOR<WatchlistUserUpdateWithoutTweetsInput, WatchlistUserUncheckedUpdateWithoutTweetsInput>
  }

  export type WatchlistUserUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
    interactions?: InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserCreateWithoutInteractionsInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistUsersInput
    tweets?: WatchlistTweetCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserUncheckedCreateWithoutInteractionsInput = {
    id?: string
    userId: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    tweets?: WatchlistTweetUncheckedCreateNestedManyWithoutWatchlistUserInput
  }

  export type WatchlistUserCreateOrConnectWithoutInteractionsInput = {
    where: WatchlistUserWhereUniqueInput
    create: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
  }

  export type WatchlistUserUpsertWithoutInteractionsInput = {
    update: XOR<WatchlistUserUpdateWithoutInteractionsInput, WatchlistUserUncheckedUpdateWithoutInteractionsInput>
    create: XOR<WatchlistUserCreateWithoutInteractionsInput, WatchlistUserUncheckedCreateWithoutInteractionsInput>
    where?: WatchlistUserWhereInput
  }

  export type WatchlistUserUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: WatchlistUserWhereInput
    data: XOR<WatchlistUserUpdateWithoutInteractionsInput, WatchlistUserUncheckedUpdateWithoutInteractionsInput>
  }

  export type WatchlistUserUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistUsersNestedInput
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type CotPhaseCreateWithoutSessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUncheckedCreateWithoutSessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseCreateOrConnectWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    create: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput>
  }

  export type CotPhaseCreateManySessionInputEnvelope = {
    data: CotPhaseCreateManySessionInput | CotPhaseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CotDraftCreateWithoutSessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceCreateNestedOneWithoutDraftInput
  }

  export type CotDraftUncheckedCreateWithoutSessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performance?: CotDraftPerformanceUncheckedCreateNestedOneWithoutDraftInput
  }

  export type CotDraftCreateOrConnectWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput>
  }

  export type CotDraftCreateManySessionInputEnvelope = {
    data: CotDraftCreateManySessionInput | CotDraftCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CotPhaseUpsertWithWhereUniqueWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    update: XOR<CotPhaseUpdateWithoutSessionInput, CotPhaseUncheckedUpdateWithoutSessionInput>
    create: XOR<CotPhaseCreateWithoutSessionInput, CotPhaseUncheckedCreateWithoutSessionInput>
  }

  export type CotPhaseUpdateWithWhereUniqueWithoutSessionInput = {
    where: CotPhaseWhereUniqueInput
    data: XOR<CotPhaseUpdateWithoutSessionInput, CotPhaseUncheckedUpdateWithoutSessionInput>
  }

  export type CotPhaseUpdateManyWithWhereWithoutSessionInput = {
    where: CotPhaseScalarWhereInput
    data: XOR<CotPhaseUpdateManyMutationInput, CotPhaseUncheckedUpdateManyWithoutSessionInput>
  }

  export type CotPhaseScalarWhereInput = {
    AND?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
    OR?: CotPhaseScalarWhereInput[]
    NOT?: CotPhaseScalarWhereInput | CotPhaseScalarWhereInput[]
    id?: StringFilter<"CotPhase"> | string
    sessionId?: StringFilter<"CotPhase"> | string
    phaseNumber?: IntFilter<"CotPhase"> | number
    thinkPrompt?: StringNullableFilter<"CotPhase"> | string | null
    thinkResult?: JsonNullableFilter<"CotPhase">
    thinkTokens?: IntNullableFilter<"CotPhase"> | number | null
    thinkAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    executeResult?: JsonNullableFilter<"CotPhase">
    executeDuration?: IntNullableFilter<"CotPhase"> | number | null
    executeAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    integratePrompt?: StringNullableFilter<"CotPhase"> | string | null
    integrateResult?: JsonNullableFilter<"CotPhase">
    integrateTokens?: IntNullableFilter<"CotPhase"> | number | null
    integrateAt?: DateTimeNullableFilter<"CotPhase"> | Date | string | null
    status?: EnumCotPhaseStatusFilter<"CotPhase"> | $Enums.CotPhaseStatus
    createdAt?: DateTimeFilter<"CotPhase"> | Date | string
    updatedAt?: DateTimeFilter<"CotPhase"> | Date | string
  }

  export type CotDraftUpsertWithWhereUniqueWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    update: XOR<CotDraftUpdateWithoutSessionInput, CotDraftUncheckedUpdateWithoutSessionInput>
    create: XOR<CotDraftCreateWithoutSessionInput, CotDraftUncheckedCreateWithoutSessionInput>
  }

  export type CotDraftUpdateWithWhereUniqueWithoutSessionInput = {
    where: CotDraftWhereUniqueInput
    data: XOR<CotDraftUpdateWithoutSessionInput, CotDraftUncheckedUpdateWithoutSessionInput>
  }

  export type CotDraftUpdateManyWithWhereWithoutSessionInput = {
    where: CotDraftScalarWhereInput
    data: XOR<CotDraftUpdateManyMutationInput, CotDraftUncheckedUpdateManyWithoutSessionInput>
  }

  export type CotDraftScalarWhereInput = {
    AND?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
    OR?: CotDraftScalarWhereInput[]
    NOT?: CotDraftScalarWhereInput | CotDraftScalarWhereInput[]
    id?: StringFilter<"CotDraft"> | string
    sessionId?: StringFilter<"CotDraft"> | string
    conceptNumber?: IntFilter<"CotDraft"> | number
    title?: StringFilter<"CotDraft"> | string
    hook?: StringFilter<"CotDraft"> | string
    angle?: StringFilter<"CotDraft"> | string
    format?: StringFilter<"CotDraft"> | string
    content?: StringNullableFilter<"CotDraft"> | string | null
    visualGuide?: StringNullableFilter<"CotDraft"> | string | null
    timing?: StringFilter<"CotDraft"> | string
    hashtags?: StringNullableListFilter<"CotDraft">
    newsSource?: StringNullableFilter<"CotDraft"> | string | null
    sourceUrl?: StringNullableFilter<"CotDraft"> | string | null
    kpis?: JsonNullableFilter<"CotDraft">
    riskAssessment?: JsonNullableFilter<"CotDraft">
    optimizationTips?: JsonNullableFilter<"CotDraft">
    status?: EnumCotDraftStatusFilter<"CotDraft"> | $Enums.CotDraftStatus
    editedContent?: StringNullableFilter<"CotDraft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postedAt?: DateTimeNullableFilter<"CotDraft"> | Date | string | null
    postId?: StringNullableFilter<"CotDraft"> | string | null
    viralScore?: FloatNullableFilter<"CotDraft"> | number | null
    createdAt?: DateTimeFilter<"CotDraft"> | Date | string
    updatedAt?: DateTimeFilter<"CotDraft"> | Date | string
  }

  export type CotSessionCreateWithoutPhasesInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    drafts?: CotDraftCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateWithoutPhasesInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    drafts?: CotDraftUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionCreateOrConnectWithoutPhasesInput = {
    where: CotSessionWhereUniqueInput
    create: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
  }

  export type CotSessionUpsertWithoutPhasesInput = {
    update: XOR<CotSessionUpdateWithoutPhasesInput, CotSessionUncheckedUpdateWithoutPhasesInput>
    create: XOR<CotSessionCreateWithoutPhasesInput, CotSessionUncheckedCreateWithoutPhasesInput>
    where?: CotSessionWhereInput
  }

  export type CotSessionUpdateToOneWithWhereWithoutPhasesInput = {
    where?: CotSessionWhereInput
    data: XOR<CotSessionUpdateWithoutPhasesInput, CotSessionUncheckedUpdateWithoutPhasesInput>
  }

  export type CotSessionUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drafts?: CotDraftUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drafts?: CotDraftUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionCreateWithoutDraftsInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseCreateNestedManyWithoutSessionInput
  }

  export type CotSessionUncheckedCreateWithoutDraftsInput = {
    id?: string
    expertise: string
    style: string
    platform: string
    status?: $Enums.CotSessionStatus
    currentPhase?: number
    currentStep?: $Enums.CotPhaseStep
    lastError?: string | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    totalTokens?: number
    totalDuration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    phases?: CotPhaseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CotSessionCreateOrConnectWithoutDraftsInput = {
    where: CotSessionWhereUniqueInput
    create: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
  }

  export type CotDraftPerformanceCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceUncheckedCreateWithoutDraftInput = {
    id?: string
    likes30m?: number | null
    retweets30m?: number | null
    replies30m?: number | null
    impressions30m?: number | null
    likes1h?: number | null
    retweets1h?: number | null
    replies1h?: number | null
    impressions1h?: number | null
    likes24h?: number | null
    retweets24h?: number | null
    replies24h?: number | null
    impressions24h?: number | null
    engagementRate?: number | null
    viralCoefficient?: number | null
    collectedAt?: Date | string
    lastUpdateAt?: Date | string
  }

  export type CotDraftPerformanceCreateOrConnectWithoutDraftInput = {
    where: CotDraftPerformanceWhereUniqueInput
    create: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
  }

  export type CotSessionUpsertWithoutDraftsInput = {
    update: XOR<CotSessionUpdateWithoutDraftsInput, CotSessionUncheckedUpdateWithoutDraftsInput>
    create: XOR<CotSessionCreateWithoutDraftsInput, CotSessionUncheckedCreateWithoutDraftsInput>
    where?: CotSessionWhereInput
  }

  export type CotSessionUpdateToOneWithWhereWithoutDraftsInput = {
    where?: CotSessionWhereInput
    data: XOR<CotSessionUpdateWithoutDraftsInput, CotSessionUncheckedUpdateWithoutDraftsInput>
  }

  export type CotSessionUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUpdateManyWithoutSessionNestedInput
  }

  export type CotSessionUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    style?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    status?: EnumCotSessionStatusFieldUpdateOperationsInput | $Enums.CotSessionStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    currentStep?: EnumCotPhaseStepFieldUpdateOperationsInput | $Enums.CotPhaseStep
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phases?: CotPhaseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CotDraftPerformanceUpsertWithoutDraftInput = {
    update: XOR<CotDraftPerformanceUpdateWithoutDraftInput, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
    create: XOR<CotDraftPerformanceCreateWithoutDraftInput, CotDraftPerformanceUncheckedCreateWithoutDraftInput>
    where?: CotDraftPerformanceWhereInput
  }

  export type CotDraftPerformanceUpdateToOneWithWhereWithoutDraftInput = {
    where?: CotDraftPerformanceWhereInput
    data: XOR<CotDraftPerformanceUpdateWithoutDraftInput, CotDraftPerformanceUncheckedUpdateWithoutDraftInput>
  }

  export type CotDraftPerformanceUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftPerformanceUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes30m?: NullableIntFieldUpdateOperationsInput | number | null
    retweets30m?: NullableIntFieldUpdateOperationsInput | number | null
    replies30m?: NullableIntFieldUpdateOperationsInput | number | null
    impressions30m?: NullableIntFieldUpdateOperationsInput | number | null
    likes1h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets1h?: NullableIntFieldUpdateOperationsInput | number | null
    replies1h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions1h?: NullableIntFieldUpdateOperationsInput | number | null
    likes24h?: NullableIntFieldUpdateOperationsInput | number | null
    retweets24h?: NullableIntFieldUpdateOperationsInput | number | null
    replies24h?: NullableIntFieldUpdateOperationsInput | number | null
    impressions24h?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    viralCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftCreateWithoutPerformanceInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: CotSessionCreateNestedOneWithoutDraftsInput
  }

  export type CotDraftUncheckedCreateWithoutPerformanceInput = {
    id?: string
    sessionId: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftCreateOrConnectWithoutPerformanceInput = {
    where: CotDraftWhereUniqueInput
    create: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
  }

  export type CotDraftUpsertWithoutPerformanceInput = {
    update: XOR<CotDraftUpdateWithoutPerformanceInput, CotDraftUncheckedUpdateWithoutPerformanceInput>
    create: XOR<CotDraftCreateWithoutPerformanceInput, CotDraftUncheckedCreateWithoutPerformanceInput>
    where?: CotDraftWhereInput
  }

  export type CotDraftUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: CotDraftWhereInput
    data: XOR<CotDraftUpdateWithoutPerformanceInput, CotDraftUncheckedUpdateWithoutPerformanceInput>
  }

  export type CotDraftUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CotSessionUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostCreateManyRefPostInput = {
    id?: string
    content: string
    scheduledTime: Date | string
    status?: $Enums.PostStatus
    postType: $Enums.PostType
    templateType?: string | null
    aiGenerated?: boolean
    aiPrompt?: string | null
    editedContent?: string | null
    postedAt?: Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPostUpdateWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostUncheckedUpdateManyWithoutRefPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    templateType?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type WatchlistUserCreateManyUserInput = {
    id?: string
    twitterId: string
    username: string
    displayName: string
    followers?: number | null
    following?: number | null
    isActive?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserNestedInput
    interactions?: InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserNestedInput
  }

  export type WatchlistUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    twitterId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    following?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleCreateManySourceInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    publishedAt: Date | string
    category?: string | null
    tags?: NewsArticleCreatetagsInput | string[]
    importance?: number | null
    processed?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsArticleUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NewsAnalysisUncheckedUpdateOneWithoutArticleNestedInput
    newsThreadItems?: NewsThreadItemUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type NewsArticleUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NewsArticleUpdatetagsInput | string[]
    importance?: NullableFloatFieldUpdateOperationsInput | number | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsThreadItemCreateManyArticleInput = {
    id?: string
    threadId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: NewsThreadUpdateOneRequiredWithoutItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemCreateManyThreadInput = {
    id?: string
    articleId: string
    order: number
    content?: string | null
    createdAt?: Date | string
  }

  export type NewsThreadItemUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: NewsArticleUpdateOneRequiredWithoutNewsThreadItemsNestedInput
  }

  export type NewsThreadItemUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsThreadItemUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetCreateManyWatchlistUserInput = {
    id?: string
    tweetId: string
    content: string
    createdAt: Date | string
    retweetCount: number
    likeCount: number
    replyCount: number
    collectedAt?: Date | string
  }

  export type InteractionHistoryCreateManyWatchlistUserInput = {
    id?: string
    interactionType: string
    tweetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WatchlistTweetUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetUncheckedUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistTweetUncheckedUpdateManyWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retweetCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionHistoryUncheckedUpdateManyWithoutWatchlistUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseCreateManySessionInput = {
    id?: string
    phaseNumber: number
    thinkPrompt?: string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: number | null
    thinkAt?: Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: number | null
    executeAt?: Date | string | null
    integratePrompt?: string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: number | null
    integrateAt?: Date | string | null
    status?: $Enums.CotPhaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotDraftCreateManySessionInput = {
    id?: string
    conceptNumber: number
    title: string
    hook: string
    angle: string
    format: string
    content?: string | null
    visualGuide?: string | null
    timing: string
    hashtags?: CotDraftCreatehashtagsInput | string[]
    newsSource?: string | null
    sourceUrl?: string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CotDraftStatus
    editedContent?: string | null
    scheduledAt?: Date | string | null
    postedAt?: Date | string | null
    postId?: string | null
    viralScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CotPhaseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotPhaseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseNumber?: IntFieldUpdateOperationsInput | number
    thinkPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    thinkResult?: NullableJsonNullValueInput | InputJsonValue
    thinkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    thinkAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executeResult?: NullableJsonNullValueInput | InputJsonValue
    executeDuration?: NullableIntFieldUpdateOperationsInput | number | null
    executeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integratePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    integrateResult?: NullableJsonNullValueInput | InputJsonValue
    integrateTokens?: NullableIntFieldUpdateOperationsInput | number | null
    integrateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCotPhaseStatusFieldUpdateOperationsInput | $Enums.CotPhaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CotDraftUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performance?: CotDraftPerformanceUncheckedUpdateOneWithoutDraftNestedInput
  }

  export type CotDraftUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    angle?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visualGuide?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: StringFieldUpdateOperationsInput | string
    hashtags?: CotDraftUpdatehashtagsInput | string[]
    newsSource?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kpis?: NullableJsonNullValueInput | InputJsonValue
    riskAssessment?: NullableJsonNullValueInput | InputJsonValue
    optimizationTips?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCotDraftStatusFieldUpdateOperationsInput | $Enums.CotDraftStatus
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    viralScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BuzzPostCountOutputTypeDefaultArgs instead
     */
    export type BuzzPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuzzPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsSourceCountOutputTypeDefaultArgs instead
     */
    export type NewsSourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsSourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsArticleCountOutputTypeDefaultArgs instead
     */
    export type NewsArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsThreadCountOutputTypeDefaultArgs instead
     */
    export type NewsThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistUserCountOutputTypeDefaultArgs instead
     */
    export type WatchlistUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotSessionCountOutputTypeDefaultArgs instead
     */
    export type CotSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuzzPostDefaultArgs instead
     */
    export type BuzzPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuzzPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledPostDefaultArgs instead
     */
    export type ScheduledPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostAnalyticsDefaultArgs instead
     */
    export type PostAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsSourceDefaultArgs instead
     */
    export type NewsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsArticleDefaultArgs instead
     */
    export type NewsArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsThreadDefaultArgs instead
     */
    export type NewsThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsThreadItemDefaultArgs instead
     */
    export type NewsThreadItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsThreadItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsAnalysisDefaultArgs instead
     */
    export type NewsAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobQueueDefaultArgs instead
     */
    export type JobQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollectionPresetDefaultArgs instead
     */
    export type CollectionPresetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionPresetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistUserDefaultArgs instead
     */
    export type WatchlistUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistTweetDefaultArgs instead
     */
    export type WatchlistTweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistTweetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InteractionHistoryDefaultArgs instead
     */
    export type InteractionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InteractionHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerplexityReportDefaultArgs instead
     */
    export type PerplexityReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerplexityReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotSessionDefaultArgs instead
     */
    export type CotSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotPhaseDefaultArgs instead
     */
    export type CotPhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotPhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotDraftDefaultArgs instead
     */
    export type CotDraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotDraftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotDraftPerformanceDefaultArgs instead
     */
    export type CotDraftPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotDraftPerformanceDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}